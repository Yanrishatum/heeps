<!-- This file can be parsed by haxe.rtti.XmlParser -->
<haxe>
	<abstract path="Any" params="" file="E:\HaxeToolkit\haxe\std/Any.hx">
		<from><icast field="__cast"><c path="__cast.T"/></icast></from>
		<this><d/></this>
		<to><icast field="__promote"><c path="__promote.T"/></icast></to>
		<haxe_doc>`Any` is a type that is compatible with any other in both ways.

	This means that a value of any type can be assigned to `Any`, and
	vice-versa, a value of `Any` type can be assigned to any other type.

	It's a more type-safe alternative to `Dynamic`, because it doesn't
	support field access or operators and it's bound to monomorphs. So,
	to work with the actual value, it needs to be explicitly promoted
	to another type.</haxe_doc>
		<impl><class path="_Any.Any_Impl_" params="" file="E:\HaxeToolkit\haxe\std/Any.hx" private="1" module="Any"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="Array" params="T" file="E:\HaxeToolkit\haxe\std/Array.hx" extern="1">
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The length of `this` Array.</haxe_doc>
		</length>
		<concat public="1" set="method">
			<f a="a">
				<c path="Array"><c path="Array.T"/></c>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Returns a new Array by appending the elements of `a` to the elements of
		`this` Array.

		This operation does not modify `this` Array.

		If `a` is the empty Array `[]`, a copy of `this` Array is returned.

		The length of the returned Array is equal to the sum of `this.length`
		and `a.length`.

		If `a` is `null`, the result is unspecified.</haxe_doc>
		</concat>
		<join public="1" set="method">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string representation of `this` Array, with `sep` separating
		each element.

		The result of this operation is equal to `Std.string(this[0]) + sep +
		Std.string(this[1]) + sep + ... + sep + Std.string(this[this.length-1])`

		If `this` is the empty Array `[]`, the result is the empty String `""`.
		If `this` has exactly one element, the result is equal to a call to
		`Std.string(this[0])`.

		If `sep` is null, the result is unspecified.</haxe_doc>
		</join>
		<pop public="1" set="method">
			<f a=""><x path="Null"><c path="Array.T"/></x></f>
			<haxe_doc>Removes the last element of `this` Array and returns it.

		This operation modifies `this` Array in place.

		If `this` has at least one element, `this.length` will decrease by 1.

		If `this` is the empty Array `[]`, null is returned and the length
		remains 0.</haxe_doc>
		</pop>
		<push public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Adds the element `x` at the end of `this` Array and returns the new
		length of `this` Array.

		This operation modifies `this` Array in place.

		`this.length` increases by 1.</haxe_doc>
		</push>
		<reverse public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[Reverse the order of elements of `this` Array.

		This operation modifies `this` Array in place.

		If `this.length < 2`, `this` remains unchanged.]]></haxe_doc>
		</reverse>
		<shift public="1" set="method">
			<f a=""><x path="Null"><c path="Array.T"/></x></f>
			<haxe_doc>Removes the first element of `this` Array and returns it.

		This operation modifies `this` Array in place.

		If `this` has at least one element, `this`.length and the index of each
		remaining element is decreased by 1.

		If `this` is the empty Array `[]`, `null` is returned and the length
		remains 0.</haxe_doc>
		</shift>
		<slice public="1" set="method">
			<f a="pos:?end">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Creates a shallow copy of the range of `this` Array, starting at and
		including `pos`, up to but not including `end`.

		This operation does not modify `this` Array.

		The elements are not copied and retain their identity.

		If `end` is omitted or exceeds `this.length`, it defaults to the end of
		`this` Array.

		If `pos` or `end` are negative, their offsets are calculated from the
		end of `this` Array by `this.length + pos` and `this.length + end`
		respectively. If this yields a negative value, 0 is used instead.

		If `pos` exceeds `this.length` or if `end` is less than or equals
		`pos`, the result is `[]`.</haxe_doc>
		</slice>
		<sort public="1" set="method">
			<f a="f">
				<f a=":">
					<c path="Array.T"/>
					<c path="Array.T"/>
					<x path="Int"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[Sorts `this` Array according to the comparison function `f`, where
		`f(x,y)` returns 0 if x == y, a positive Int if x > y and a
		negative Int if x < y.

		This operation modifies `this` Array in place.

		The sort operation is not guaranteed to be stable, which means that the
		order of equal elements may not be retained. For a stable Array sorting
		algorithm, `haxe.ds.ArraySort.sort()` can be used instead.

		If `f` is null, the result is unspecified.]]></haxe_doc>
		</sort>
		<splice public="1" set="method">
			<f a="pos:len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc><![CDATA[Removes `len` elements from `this` Array, starting at and including
		`pos`, an returns them.

		This operation modifies `this` Array in place.

		If `len` is < 0 or `pos` exceeds `this`.length, an empty Array [] is
		returned and `this` Array is unchanged.

		If `pos` is negative, its value is calculated from the end	of `this`
		Array by `this.length + pos`. If this yields a negative value, 0 is
		used instead.

		If the sum of the resulting values for `len` and `pos` exceed
		`this.length`, this operation will affect the elements from `pos` to the
		end of `this` Array.

		The length of the returned Array is equal to the new length of `this`
		Array subtracted from the original length of `this` Array. In other
		words, each element of the original `this` Array either remains in
		`this` Array or becomes an element of the returned Array.]]></haxe_doc>
		</splice>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representation of `this` Array.

		The result will include the individual elements' String representations
		separated by comma. The enclosing [ ] may be missing on some platforms,
		use `Std.string()` to get a String representation that is consistent
		across platforms.</haxe_doc>
		</toString>
		<unshift public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds the element `x` at the start of `this` Array.

		This operation modifies `this` Array in place.

		`this.length` and the index of each Array element increases by 1.</haxe_doc>
		</unshift>
		<insert public="1" set="method">
			<f a="pos:x">
				<x path="Int"/>
				<c path="Array.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Inserts the element `x` at the position `pos`.

		This operation modifies `this` Array in place.

		The offset is calculated like so:

		- If `pos` exceeds `this.length`, the offset is `this.length`.
		- If `pos` is negative, the offset is calculated from the end of `this`
		  Array, i.e. `this.length + pos`. If this yields a negative value, the
		  offset is 0.
		- Otherwise, the offset is `pos`.

		If the resulting offset does not exceed `this.length`, all elements from
		and including that offset to the end of `this` Array are moved one index
		ahead.</haxe_doc>
		</insert>
		<remove public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes the first occurrence of `x` in `this` Array.

		This operation modifies `this` Array in place.

		If `x` is found by checking standard equality, it is removed from `this`
		Array and all following elements are reindexed accordingly. The function
		then returns true.

		If `x` is not found, `this` Array is not changed and the function
		returns false.</haxe_doc>
		</remove>
		<indexOf public="1" set="method">
			<f a="x:?fromIndex">
				<c path="Array.T"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns position of the first occurrence of `x` in `this` Array, searching front to back.

		If `x` is found by checking standard equality, the function returns its index.

		If `x` is not found, the function returns -1.

		If `fromIndex` is specified, it will be used as the starting index to search from,
		otherwise search starts with zero index. If it is negative, it will be taken as the
		offset from the end of `this` Array to compute the starting index. If given or computed
		starting index is less than 0, the whole array will be searched, if it is greater than
		or equal to the length of `this` Array, the function returns -1.</haxe_doc>
		</indexOf>
		<lastIndexOf public="1" set="method">
			<f a="x:?fromIndex">
				<c path="Array.T"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns position of the last occurrence of `x` in `this` Array, searching back to front.

		If `x` is found by checking standard equality, the function returns its index.

		If `x` is not found, the function returns -1.

		If `fromIndex` is specified, it will be used as the starting index to search from,
		otherwise search starts with the last element index. If it is negative, it will be
		taken as the offset from the end of `this` Array to compute the starting index. If
		given or computed starting index is greater than or equal to the length of `this` Array,
		the whole array will be searched, if it is less than 0, the function returns -1.</haxe_doc>
		</lastIndexOf>
		<copy public="1" set="method">
			<f a=""><c path="Array"><c path="Array.T"/></c></f>
			<haxe_doc>Returns a shallow copy of `this` Array.

		The elements are not copied and retain their identity, so
		`a[i] == a.copy()[i]` is true for any valid `i`. However,
		`a == a.copy()` is always false.</haxe_doc>
		</copy>
		<iterator public="1" set="method">
			<f a=""><t path="Iterator"><c path="Array.T"/></t></f>
			<haxe_doc>Returns an iterator of the Array values.</haxe_doc>
		</iterator>
		<map public="1" params="S" get="inline" set="null" line="277">
			<f a="f">
				<f a="">
					<c path="Array.T"/>
					<c path="map.S"/>
				</f>
				<c path="Array"><c path="map.S"/></c>
			</f>
			<meta><m n=":runtime"/></meta>
			<haxe_doc>Creates a new Array by applying function `f` to all elements of `this`.

		The order of elements is preserved.

		If `f` is null, the result is unspecified.</haxe_doc>
		</map>
		<filter public="1" get="inline" set="null" line="295">
			<f a="f">
				<f a="">
					<c path="Array.T"/>
					<x path="Bool"/>
				</f>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<meta><m n=":runtime"/></meta>
			<haxe_doc>Returns an Array containing those elements of `this` for which `f`
		returned true.

		The individual elements are not duplicated and retain their identity.

		If `f` is null, the result is unspecified.</haxe_doc>
		</filter>
		<resize public="1" set="method">
			<f a="len">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Set the length of the Array.

		If `len` is shorter than the array's current size, the last
		`length - len` elements will be removed. If `len` is longer, the Array
		will be extended, with new elements set to a target-specific default
		value:

		- always null on dynamic targets
		- 0, 0.0 or false for Int, Float and Bool respectively on static targets
		- null for other types on static targets</haxe_doc>
		</resize>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Array.</haxe_doc>
		</new>
		<haxe_doc>An Array is a storage for values. You can access it using indexes or
	with its API.

	@see https://haxe.org/manual/std-Array.html
	@see https://haxe.org/manual/lf-array-comprehension.html</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="Class" params="T" file="E:\HaxeToolkit\haxe\std/Class.hx">
		<this><x path="Class"><c path="Class.T"/></x></this>
		<haxe_doc>An abstract type that represents a Class.

	See `Type` for the Haxe Reflection API.

	@see https://haxe.org/manual/types-class-instance.html</haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<class path="Date" params="" file="E:\HaxeToolkit\haxe\std/Date.hx" extern="1">
		<now public="1" set="method" static="1">
			<f a=""><c path="Date"/></f>
			<haxe_doc>Returns a Date representing the current local time.</haxe_doc>
		</now>
		<fromTime public="1" set="method" static="1">
			<f a="t">
				<x path="Float"/>
				<c path="Date"/>
			</f>
			<haxe_doc>Creates a Date from the timestamp (in milliseconds) `t`.</haxe_doc>
		</fromTime>
		<fromString public="1" set="method" static="1">
			<f a="s">
				<c path="String"/>
				<c path="Date"/>
			</f>
			<haxe_doc>Creates a Date from the formatted string `s`. The following formats are
		accepted by the function:

		- `"YYYY-MM-DD hh:mm:ss"`
		- `"YYYY-MM-DD"`
		- `"hh:mm:ss"`

		The first two formats expressed a date in local time. The third is a time
		relative to the UTC epoch.</haxe_doc>
		</fromString>
		<getTime public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the timestamp (in milliseconds) of `this` date.
		On cpp and neko, this function only has a second resolution, so the
		result will always be a multiple of `1000.0`, e.g. `1454698271000.0`.
		To obtain the current timestamp with better precision on cpp and neko,
		see the `Sys.time` API.

		For measuring time differences with millisecond accuracy on
		all platforms, see `haxe.Timer.stamp`.</haxe_doc>
		</getTime>
		<getHours public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the hours of `this` Date (0-23 range) in the local timezone.</haxe_doc>
		</getHours>
		<getMinutes public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the minutes of `this` Date (0-59 range) in the local timezone.</haxe_doc>
		</getMinutes>
		<getSeconds public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the seconds of `this` Date (0-59 range) in the local timezone.</haxe_doc>
		</getSeconds>
		<getFullYear public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the full year of `this` Date (4 digits) in the local timezone.</haxe_doc>
		</getFullYear>
		<getMonth public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the month of `this` Date (0-11 range) in the local timezone.
		Note that the month number is zero-based.</haxe_doc>
		</getMonth>
		<getDate public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the day of `this` Date (1-31 range) in the local timezone.</haxe_doc>
		</getDate>
		<getDay public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the day of the week of `this` Date (0-6 range, where `0` is Sunday)
		in the local timezone.</haxe_doc>
		</getDay>
		<getUTCHours public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the hours of `this` Date (0-23 range) in UTC.</haxe_doc>
		</getUTCHours>
		<getUTCMinutes public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the minutes of `this` Date (0-59 range) in UTC.</haxe_doc>
		</getUTCMinutes>
		<getUTCSeconds public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the seconds of `this` Date (0-59 range) in UTC.</haxe_doc>
		</getUTCSeconds>
		<getUTCFullYear public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the full year of `this` Date (4 digits) in UTC.</haxe_doc>
		</getUTCFullYear>
		<getUTCMonth public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the month of `this` Date (0-11 range) in UTC.
		Note that the month number is zero-based.</haxe_doc>
		</getUTCMonth>
		<getUTCDate public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the day of `this` Date (1-31 range) in UTC.</haxe_doc>
		</getUTCDate>
		<getUTCDay public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the day of the week of `this` Date (0-6 range, where `0` is Sunday)
		in UTC.</haxe_doc>
		</getUTCDay>
		<getTimezoneOffset public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the time zone difference of `this` Date in the current locale
		to UTC, in minutes.

		Assuming the function is executed on a machine in a UTC+2 timezone,
		`Date.now().getTimezoneOffset()` will return `-120`.</haxe_doc>
		</getTimezoneOffset>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representation of `this` Date in the local timezone
		using the standard format `YYYY-MM-DD HH:MM:SS`. See `DateTools.format` for
		other formatting rules.</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a="year:month:day:hour:min:sec">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new date object from the given arguments.

		The behaviour of a Date instance is only consistent across platforms if
		the the arguments describe a valid date.

		- month: 0 to 11 (note that this is zero-based)
		- day: 1 to 31
		- hour: 0 to 23
		- min: 0 to 59
		- sec: 0 to 59</haxe_doc>
		</new>
		<haxe_doc>The Date class provides a basic structure for date and time related
	information. Date instances can be created by

	- `new Date()` for a specific date,
	- `Date.now()` to obtain information about the current time,
	- `Date.fromTime()` with a given timestamp or
	- `Date.fromString()` by parsing from a String.

	There are some extra functions available in the `DateTools` class.

	In the context of Haxe dates, a timestamp is defined as the number of
	milliseconds elapsed since 1st January 1970 UTC.

	## Supported range

	Due to platform limitations, only dates in the range 1970 through 2038 are
	supported consistently. Some targets may support dates outside this range,
	depending on the OS at runtime. The `Date.fromTime` method will not work with
	timestamps outside the range on any target.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="EReg" params="" file="E:\HaxeToolkit\haxe\std/EReg.hx">
		<match public="1" set="method" line="58">
			<f a="s">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `this` regular expression matches String `s`.

		This method modifies the internal state.

		If `s` is `null`, the result is unspecified.</haxe_doc>
		</match>
		<matched public="1" set="method" line="73">
			<f a="n">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the matched sub-group `n` of `this` EReg.

		This method should only be called after `this.match` or
		`this.matchSub`, and then operates on the String of that operation.

		The index `n` corresponds to the n-th set of parentheses in the pattern
		of `this` EReg. If no such sub-group exists, the result is unspecified.

		If `n` equals 0, the whole matched substring is returned.</haxe_doc>
		</matched>
		<matchedPos public="1" set="method" line="118">
			<f a=""><a>
	<pos><x path="Int"/></pos>
	<len><x path="Int"/></len>
</a></f>
			<haxe_doc>Returns the position and length of the last matched substring, within
		the String which was last used as argument to `this.match` or
		`this.matchSub`.

		If the most recent call to `this.match` or `this.matchSub` did not
		match anything, the result is unspecified.

		If the global g modifier was in place for the matching, the position and
		length of the leftmost substring is returned.</haxe_doc>
		</matchedPos>
		<matchSub public="1" set="method" line="133">
			<f a="s:pos:?len" v="::-1">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ len : -1 }</e></m></meta>
			<haxe_doc>Tells if `this` regular expression matches a substring of String `s`.

		This function expects `pos` and `len` to describe a valid substring of
		`s`, or else the result is unspecified. To get more robust behavior,
		`this.match(s.substr(pos,len))` can be used instead.

		This method modifies the internal state.

		If `s` is null, the result is unspecified.</haxe_doc>
		</matchSub>
		<replace public="1" set="method" line="173">
			<f a="s:by">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Replaces the first substring of `s` which `this` EReg matches with `by`.

		If `this` EReg does not match any substring, the result is `s`.

		By default, this method replaces only the first matched substring. If
		the global g modifier is in place, all matched substrings are replaced.

		If `by` contains `$1` to `$9`, the digit corresponds to number of a
		matched sub-group and its value is used instead. If no such sub-group
		exists, the replacement is unspecified. The string `$$` becomes `$`.

		If `s` or `by` are null, the result is unspecified.</haxe_doc>
		</replace>
		<map public="1" set="method" line="191">
			<f a="s:f">
				<c path="String"/>
				<f a="">
					<c path="EReg"/>
					<c path="String"/>
				</f>
				<c path="String"/>
			</f>
			<haxe_doc>Calls the function `f` for the substring of `s` which `this` EReg matches
		and replaces that substring with the result of `f` call.

		The `f` function takes `this` EReg object as its first argument and should
		return a replacement string for the substring matched.

		If `this` EReg does not match any substring, the result is `s`.

		By default, this method replaces only the first matched substring. If
		the global g modifier is in place, all matched substrings are replaced.

		If `s` or `f` are null, the result is unspecified.</haxe_doc>
		</map>
		<new public="1" set="method" line="47">
			<f a="r:opt">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new regular expression with pattern `r` and modifiers `opt`.

		This is equivalent to the shorthand syntax `~/r/opt`

		If `r` or `opt` are null, the result is unspecified.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[The EReg class represents regular expressions.

	While basic usage and patterns consistently work across platforms, some more
	complex operations may yield different results. This is a necessary trade-
	off to retain a certain level of performance.

	EReg instances can be created by calling the constructor, or with the
	special syntax `~/pattern/modifier`

	EReg instances maintain an internal state, which is affected by several of
	its methods.

	A detailed explanation of the supported operations is available at
	<https://haxe.org/manual/std-regex.html>]]></haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<abstract path="Enum" params="T" file="E:\HaxeToolkit\haxe\std/Enum.hx">
		<this><x path="Enum"><c path="Enum.T"/></x></this>
		<haxe_doc>An abstract type that represents an Enum type.

	The corresponding enum instance type is `EnumValue`.

	See `Type` for the Haxe Reflection API.

	@see https://haxe.org/manual/types-enum-instance.html</haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="EnumValue" params="" file="E:\HaxeToolkit\haxe\std/EnumValue.hx">
		<this><x path="EnumValue"/></this>
		<haxe_doc>An abstract type that represents any enum value.
	See `Type` for the Haxe Reflection API.

	@see https://haxe.org/manual/types-enum-instance.html</haxe_doc>
		<meta><m n=":coreType"/></meta>
		<impl><class path="_EnumValue.EnumValue_Impl_" params="" file="E:\HaxeToolkit\haxe\std/EnumValue.hx" private="1" module="EnumValue"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="Lambda" params="" file="E:\HaxeToolkit\haxe\std/Lambda.hx">
		<array public="1" params="A" set="method" line="45" static="1">
			<f a="it">
				<t path="Iterable"><c path="array.A"/></t>
				<c path="Array"><c path="array.A"/></c>
			</f>
			<haxe_doc>Creates an Array from Iterable `it`.

		If `it` is an Array, this function returns a copy of it.</haxe_doc>
		</array>
		<count public="1" params="A" set="method" line="195" static="1">
			<f a="it:?pred">
				<t path="Iterable"><c path="count.A"/></t>
				<f a="item">
					<c path="count.A"/>
					<x path="Bool"/>
				</f>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the number of elements in `it` for which `pred` is true, or the
		total number of elements in `it` if `pred` is null.

		This function traverses all elements.</haxe_doc>
		</count>
		<indexOf public="1" params="T" set="method" line="221" static="1">
			<f a="it:v">
				<t path="Iterable"><c path="indexOf.T"/></t>
				<c path="indexOf.T"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the index of the first element `v` within Iterable `it`.

		This function uses operator `==` to check for equality.

		If `v` does not exist in `it`, the result is -1.</haxe_doc>
		</indexOf>
		<haxe_doc>The `Lambda` class is a collection of methods to support functional
	programming. It is ideally used with `using Lambda` and then acts as an
	extension to Iterable types.

	On static platforms, working with the Iterable structure might be slower
	than performing the operations directly on known types, such as Array and
	List.

	If the first argument to any of the methods is null, the result is
	unspecified.

	@see https://haxe.org/manual/std-Lambda.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<typedef path="List" params="T" file="E:\HaxeToolkit\haxe\std/List.hx"><c path="haxe.ds.List"><c path="List.T"/></c></typedef>
	<typedef path="Map" params="K:V" file="E:\HaxeToolkit\haxe\std/Map.hx"><x path="haxe.ds.Map">
	<c path="Map.K"/>
	<c path="Map.V"/>
</x></typedef>
	<typedef path="IMap" params="K:V" file="E:\HaxeToolkit\haxe\std/Map.hx" module="Map">
		<c path="haxe.IMap">
			<c path="IMap.K"/>
			<c path="IMap.V"/>
		</c>
		<meta>
			<m n=":dox"><e>hide</e></m>
			<m n=":deprecated"/>
		</meta>
	</typedef>
	<class path="Math" params="" file="E:\HaxeToolkit\haxe\std/Math.hx" extern="1">
		<PI public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>Represents the ratio of the circumference of a circle to its diameter,
		specified by the constant, Ï€. `PI` is approximately 3.141592653589793.</haxe_doc>
		</PI>
		<NEGATIVE_INFINITY public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special `Float` constant which denotes negative infinity.

		For example, this is the result of -1.0 / 0.0.

		Operations with `NEGATIVE_INFINITY` as an operand may result in
		`NEGATIVE_INFINITY`, `POSITIVE_INFINITY` or `NaN`.

		If this constant is converted to an `Int`, e.g. through `Std.int()`, the
		result is unspecified.</haxe_doc>
		</NEGATIVE_INFINITY>
		<POSITIVE_INFINITY public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special `Float` constant which denotes positive infinity.

		For example, this is the result of 1.0 / 0.0.

		Operations with `POSITIVE_INFINITY` as an operand may result in
		`NEGATIVE_INFINITY`, `POSITIVE_INFINITY` or `NaN`.

		If this constant is converted to an `Int`, e.g. through `Std.int()`, the
		result is unspecified.</haxe_doc>
		</POSITIVE_INFINITY>
		<NaN public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special `Float` constant which denotes an invalid number.

		NaN stands for "Not a Number". It occurs when a mathematically incorrect
		operation is executed, such as taking the square root of a negative
		number: Math.sqrt(-1).

		All further operations with `NaN` as an operand will result in `NaN`.

		If this constant is converted to an `Int`, e.g. through `Std.int()`, the
		result is unspecified.

		In order to test if a value is `NaN`, you should use `Math.isNaN()` function.</haxe_doc>
		</NaN>
		<abs public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the absolute value of `v`.

		If `v` is positive or 0, the result is unchanged. Otherwise the result
		is -`v`.

		If `v` is `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`, the result is
		`POSITIVE_INFINITY`.

		If `v` is `NaN`, the result is `NaN`.</haxe_doc>
		</abs>
		<min public="1" set="method" static="1">
			<f a="a:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the smaller of values `a` and `b`.

		If `a` or `b` are `NaN`, the result is `NaN`.
		If `a` or `b` are `NEGATIVE_INFINITY`, the result is `NEGATIVE_INFINITY`.
		If `a` and `b` are `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.</haxe_doc>
		</min>
		<max public="1" set="method" static="1">
			<f a="a:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the greater of values `a` and `b`.

		If `a` or `b` are `NaN`, the result is `NaN`.
		If `a` or `b` are `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		If `a` and `b` are `NEGATIVE_INFINITY`, the result is `NEGATIVE_INFINITY`.</haxe_doc>
		</max>
		<sin public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric sine of the specified angle `v`, in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</sin>
		<cos public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric cosine of the specified angle `v`, in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</cos>
		<tan public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric tangent of the specified angle `v`, in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</tan>
		<asin public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc of the specified angle `v`, in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</asin>
		<acos public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc cosine of the specified angle `v`,
		in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</acos>
		<atan public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc tangent of the specified angle `v`,
		in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</atan>
		<atan2 public="1" set="method" static="1">
			<f a="y:x">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc tangent whose tangent is the quotient of
		two specified numbers, in radians.

		If parameter `x` or `y`  is `NaN`, `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`,
		the result is `NaN`.</haxe_doc>
		</atan2>
		<exp public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns Euler's number, raised to the power of `v`.

		exp(1.0) is approximately 2.718281828459.

		If `v` is `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		If `v` is `NEGATIVE_INFINITY`, the result is `0.0`.
		If `v` is `NaN`, the result is `NaN`.</haxe_doc>
		</exp>
		<log public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the natural logarithm of `v`.

		This is the mathematical inverse operation of exp,
		i.e. `log(exp(v)) == v` always holds.

		If `v` is negative (including `NEGATIVE_INFINITY`) or `NaN`, the result
		is `NaN`.
		If `v` is `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		If `v` is `0.0`, the result is `NEGATIVE_INFINITY`.</haxe_doc>
		</log>
		<pow public="1" set="method" static="1">
			<f a="v:exp">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns a specified base `v` raised to the specified power `exp`.</haxe_doc>
		</pow>
		<sqrt public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the square root of `v`.

		If `v` is negative (including `NEGATIVE_INFINITY`) or `NaN`, the result
		is `NaN`.
		If `v` is `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		If `v` is `0.0`, the result is `0.0`.</haxe_doc>
		</sqrt>
		<round public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Rounds `v` to the nearest integer value.

		Ties are rounded up, so that `0.5` becomes `1` and `-0.5` becomes `0`.

		If `v` is outside of the signed `Int32` range, or is `NaN`, `NEGATIVE_INFINITY`
		or `POSITIVE_INFINITY`, the result is unspecified.</haxe_doc>
		</round>
		<floor public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the largest integer value that is not greater than `v`.

		If `v` is outside of the signed `Int32` range, or is `NaN`, `NEGATIVE_INFINITY`
		or `POSITIVE_INFINITY`, the result is unspecified.</haxe_doc>
		</floor>
		<ceil public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the smallest integer value that is not less than `v`.

		If `v` is outside of the signed `Int32` range, or is `NaN`, `NEGATIVE_INFINITY`
		or `POSITIVE_INFINITY`, the result is unspecified.</haxe_doc>
		</ceil>
		<random public="1" set="method" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns a pseudo-random number which is greater than or equal to 0.0,
		and less than 1.0.</haxe_doc>
		</random>
		<ffloor public="1" get="inline" set="null" line="263" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></ffloor>
		<fceil public="1" get="inline" set="null" line="267" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></fceil>
		<fround public="1" get="inline" set="null" line="271" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></fround>
		<isFinite public="1" set="method" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `f` is a finite number.

		If `f` is `POSITIVE_INFINITY`, `NEGATIVE_INFINITY` or `NaN`, the result
		is `false`, otherwise the result is `true`.</haxe_doc>
		</isFinite>
		<isNaN public="1" set="method" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `f` is not a valid number.

		If `f` is `NaN`, the result is `true`, otherwise the result is `false`.
		In particular, both `POSITIVE_INFINITY` and `NEGATIVE_INFINITY` are
		not considered `NaN`.</haxe_doc>
		</isNaN>
		<haxe_doc>This class defines mathematical functions and constants.

	@see https://haxe.org/manual/std-math.html</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="Reflect" params="" file="E:\HaxeToolkit\haxe\std/Reflect.hx" extern="1">
		<hasField public="1" set="method" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if structure `o` has a field named `field`.

		This is only guaranteed to work for anonymous structures. Refer to
		`Type.getInstanceFields` for a function supporting class instances.

		If `o` or `field` are null, the result is unspecified.</haxe_doc>
		</hasField>
		<field public="1" set="method" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>Returns the value of the field named `field` on object `o`.

		If `o` is not an object or has no field named `field`, the result is
		null.

		If the field is defined as a property, its accessors are ignored. Refer
		to `Reflect.getProperty` for a function supporting property accessors.

		If `field` is null, the result is unspecified.

		(As3) If used on a property field, the getter will be invoked. It is
		not possible to obtain the value directly.</haxe_doc>
		</field>
		<setField public="1" set="method" static="1">
			<f a="o:field:value">
				<d/>
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the field named `field` of object `o` to value `value`.

		If `o` has no field named `field`, this function is only guaranteed to
		work for anonymous structures.

		If `o` or `field` are null, the result is unspecified.

		(As3) If used on a property field, the setter will be invoked. It is
		not possible to set the value directly.</haxe_doc>
		</setField>
		<getProperty public="1" set="method" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>Returns the value of the field named `field` on object `o`, taking
		property getter functions into account.

		If the field is not a property, this function behaves like
		`Reflect.field`, but might be slower.

		If `o` or `field` are null, the result is unspecified.</haxe_doc>
		</getProperty>
		<setProperty public="1" set="method" static="1">
			<f a="o:field:value">
				<d/>
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the field named `field` of object `o` to value `value`, taking
		property setter functions into account.

		If the field is not a property, this function behaves like
		`Reflect.setField`, but might be slower.

		If `field` is null, the result is unspecified.</haxe_doc>
		</setProperty>
		<callMethod public="1" set="method" static="1">
			<f a="o:func:args">
				<d/>
				<x path="haxe.Function"/>
				<c path="Array"><d/></c>
				<d/>
			</f>
			<haxe_doc>Call a method `func` with the given arguments `args`.

		The object `o` is ignored in most cases. It serves as the `this`-context in the following
		situations:

		* (neko) Allows switching the context to `o` in all cases.
		* (macro) Same as neko for Haxe 3. No context switching in Haxe 4.
		* (js, lua) Require the `o` argument if `func` does not, but should have a context.
			This can occur by accessing a function field natively, e.g. through `Reflect.field`
			or by using `(object : Dynamic).field`. However, if `func` has a context, `o` is
			ignored like on other targets.</haxe_doc>
		</callMethod>
		<fields public="1" set="method" static="1">
			<f a="o">
				<d/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns the fields of structure `o`.

		This method is only guaranteed to work on anonymous structures. Refer to
		`Type.getInstanceFields` for a function supporting class instances.

		If `o` is null, the result is unspecified.</haxe_doc>
		</fields>
		<isFunction public="1" set="method" static="1">
			<f a="f">
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns true if `f` is a function, false otherwise.

		If `f` is null, the result is false.</haxe_doc>
		</isFunction>
		<compare public="1" params="T" set="method" static="1">
			<f a="a:b">
				<c path="compare.T"/>
				<c path="compare.T"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Compares `a` and `b`.

		If `a` is less than `b`, the result is negative. If `b` is less than
		`a`, the result is positive. If `a` and `b` are equal, the result is 0.

		This function is only defined if `a` and `b` are of the same type.

		If that type is a function, the result is unspecified and
		`Reflect.compareMethods` should be used instead.

		For all other types, the result is 0 if `a` and `b` are equal. If they
		are not equal, the result depends on the type and is negative if:

		- Numeric types: a is less than b
		- String: a is lexicographically less than b
		- Other: unspecified

		If `a` and `b` are null, the result is 0. If only one of them is null,
		the result is unspecified.</haxe_doc>
		</compare>
		<compareMethods public="1" set="method" static="1">
			<f a="f1:f2">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Compares the functions `f1` and `f2`.

		If `f1` or `f2` are null, the result is false.
		If `f1` or `f2` are not functions, the result is unspecified.

		Otherwise the result is true if `f1` and the `f2` are physically equal,
		false otherwise.

		If `f1` or `f2` are member method closures, the result is true if they
		are closures of the same method on the same object value, false otherwise.</haxe_doc>
		</compareMethods>
		<isObject public="1" set="method" static="1">
			<f a="v">
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[Tells if `v` is an object.

		The result is true if `v` is one of the following:

		- class instance
		- structure
		- `Class<T>`
		- `Enum<T>`

		Otherwise, including if `v` is null, the result is false.]]></haxe_doc>
		</isObject>
		<isEnumValue public="1" set="method" static="1">
			<f a="v">
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `v` is an enum value.

		The result is true if `v` is of type EnumValue, i.e. an enum
		constructor.

		Otherwise, including if `v` is null, the result is false.</haxe_doc>
		</isEnumValue>
		<deleteField public="1" set="method" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes the field named `field` from structure `o`.

		This method is only guaranteed to work on anonymous structures.

		If `o` or `field` are null, the result is unspecified.</haxe_doc>
		</deleteField>
		<copy public="1" params="T" set="method" static="1">
			<f a="o">
				<x path="Null"><c path="copy.T"/></x>
				<x path="Null"><c path="copy.T"/></x>
			</f>
			<haxe_doc>Copies the fields of structure `o`.

		This is only guaranteed to work on anonymous structures.

		If `o` is null, the result is `null`.</haxe_doc>
		</copy>
		<makeVarArgs public="1" set="method" static="1">
			<f a="f">
				<f a="">
					<c path="Array"><d/></c>
					<d/>
				</f>
				<d/>
			</f>
			<haxe_doc>Transform a function taking an array of arguments into a function that can
		be called with any number of arguments.</haxe_doc>
			<overloads><makeVarArgs public="1" set="method">
	<f a="f">
		<f a="">
			<c path="Array"><d/></c>
			<x path="Void"/>
		</f>
		<d/>
	</f>
	<haxe_doc>Transform a function taking an array of arguments into a function that can
		be called with any number of arguments.</haxe_doc>
</makeVarArgs></overloads>
		</makeVarArgs>
		<haxe_doc>The Reflect API is a way to manipulate values dynamically through an
	abstract interface in an untyped manner. Use with care.

	@see https://haxe.org/manual/std-reflection.html</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="Std" params="" file="E:\HaxeToolkit\haxe\std/Std.hx" extern="1">
		<is public="1" set="method" static="1">
			<f a="v:t">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if a value `v` is of the type `t`. Returns `false` if `v` or `t` are null.

		If `t` is a class or interface with `@:generic` meta, the result is `false`.</haxe_doc>
		</is>
		<downcast public="1" params="T:S" set="method" static="1">
			<f a="value:c">
				<c path="downcast.T"/>
				<x path="Class"><c path="downcast.S"/></x>
				<c path="downcast.S"/>
			</f>
			<haxe_doc>Checks if object `value` is an instance of class or interface `c`.

		Compiles only if the type specified by `c` can be assigned to the type
		of `value`.

		This method checks if a downcast is possible. That is, if the runtime
		type of `value` is assignable to the type specified by `c`, `value` is
		returned. Otherwise null is returned.

		This method is not guaranteed to work with core types such as `String`,
		`Array` and `Date`.

		If `value` is null, the result is null. If `c` is null, the result is
		unspecified.</haxe_doc>
		</downcast>
		<instance public="1" params="T:S" set="method" static="1">
			<f a="value:c">
				<c path="instance.T"/>
				<x path="Class"><c path="instance.S"/></x>
				<c path="instance.S"/>
			</f>
			<meta><m n=":deprecated"><e>"Std.instance() is deprecated. Use Std.downcast() instead."</e></m></meta>
		</instance>
		<string public="1" set="method" static="1">
			<f a="s">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>Converts any value to a String.

		If `s` is of `String`, `Int`, `Float` or `Bool`, its value is returned.

		If `s` is an instance of a class and that class or one of its parent classes has
		a `toString` method, that method is called. If no such method is present, the result
		is unspecified.

		If `s` is an enum constructor without argument, the constructor's name is returned. If
		arguments exists, the constructor's name followed by the String representations of
		the arguments is returned.

		If `s` is a structure, the field names along with their values are returned. The field order
		and the operator separating field names and values are unspecified.

		If s is null, "null" is returned.</haxe_doc>
		</string>
		<int public="1" set="method" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Converts a `Float` to an `Int`, rounded towards 0.

		If `x` is outside of the signed Int32 range, or is `NaN`, `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`, the result is unspecified.</haxe_doc>
		</int>
		<parseInt public="1" set="method" static="1">
			<f a="x">
				<c path="String"/>
				<x path="Null"><x path="Int"/></x>
			</f>
			<haxe_doc>Converts a `String` to an `Int`.

		Leading whitespaces are ignored.

		If `x` starts with 0x or 0X, hexadecimal notation is recognized where the following digits may
		contain 0-9 and A-F.

		Otherwise `x` is read as decimal number with 0-9 being allowed characters. `x` may also start with
		a - to denote a negative value.

		In decimal mode, parsing continues until an invalid character is detected, in which case the
		result up to that point is returned. For hexadecimal notation, the effect of invalid characters
		is unspecified.

		Leading 0s that are not part of the 0x/0X hexadecimal notation are ignored, which means octal
		notation is not supported.

		If `x` is null, the result is unspecified.
		If `x` cannot be parsed as integer, the result is `null`.</haxe_doc>
		</parseInt>
		<parseFloat public="1" set="method" static="1">
			<f a="x">
				<c path="String"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Converts a `String` to a `Float`.

		The parsing rules for `parseInt` apply here as well, with the exception of invalid input
		resulting in a `NaN` value instead of null.

		Additionally, decimal notation may contain a single `.` to denote the start of the fractions.</haxe_doc>
		</parseFloat>
		<random public="1" set="method" static="1">
			<f a="x">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc><![CDATA[Return a random integer between 0 included and `x` excluded.

		If `x <= 1`, the result is always 0.]]></haxe_doc>
		</random>
		<haxe_doc>The Std class provides standard methods for manipulating basic types.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="Void" params="" file="E:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<this><x path="Void"/></this>
		<haxe_doc>The standard `Void` type. Only `null` values can be of the type `Void`.

	@see https://haxe.org/manual/types-void.html</haxe_doc>
		<meta><m n=":coreType"/></meta>
	</abstract>
	<abstract path="Float" params="" file="E:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<this><x path="Float"/></this>
		<haxe_doc><![CDATA[The standard `Float` type, this is a double-precision IEEE 64bit float.

	On static targets, `null` cannot be assigned to Float. If this is necessary,
	`Null<Float>` can be used instead.

	`Std.int` converts a `Float` to an `Int`, rounded towards 0.
	`Std.parseFloat` converts a `String` to a `Float`.

	@see https://haxe.org/manual/types-basic-types.html
	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Int" params="" file="E:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<this><x path="Int"/></this>
		<to><icast><x path="Float"/></icast></to>
		<haxe_doc><![CDATA[The standard `Int` type. Its precision depends on the platform.

	On static targets, `null` cannot be assigned to `Int`. If this is necessary,
	`Null<Int>` can be used instead.

	`Std.int` converts a `Float` to an `Int`, rounded towards 0.
	`Std.parseInt` converts a `String` to an `Int`.

	@see https://haxe.org/manual/types-basic-types.html
	@see https://haxe.org/manual/std-math-integer-math.html
	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Null" params="T" file="E:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<from><icast><c path="Null.T"/></icast></from>
		<this><x path="Null"><c path="Null.T"/></x></this>
		<to><icast><c path="Null.T"/></icast></to>
		<haxe_doc><![CDATA[`Null<T>` is a wrapper that can be used to make the basic types `Int`,
	`Float` and `Bool` nullable on static targets.

	If null safety is enabled, only types wrapped in `Null<T>` are nullable.

	Otherwise, it has no effect on non-basic-types, but it can be useful as a way to document
	that `null` is an acceptable value for a method argument, return value or variable.

	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":forward"/>
			<m n=":coreType"/>
		</meta>
	</abstract>
	<abstract path="Bool" params="" file="E:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<this><x path="Bool"/></this>
		<haxe_doc><![CDATA[The standard Boolean type, which can either be `true` or `false`.

	On static targets, `null` cannot be assigned to `Bool`. If this is necessary,
	`Null<Bool>` can be used instead.

	@see https://haxe.org/manual/types-bool.html
	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Dynamic" params="T" file="E:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<this><x path="Dynamic"><c path="Dynamic.T"/></x></this>
		<haxe_doc>`Dynamic` is a special type which is compatible with all other types.

	Use of `Dynamic` should be minimized as it prevents several compiler
	checks and optimizations. See `Any` type for a safer alternative for
	representing values of any type.

	@see https://haxe.org/manual/types-dynamic.html</haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<typedef path="Iterator" params="T" file="E:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<a>
			<next set="method">
				<f a=""><c path="Iterator.T"/></f>
				<haxe_doc>Returns the current item of the `Iterator` and advances to the next one.

		This method is not required to check `hasNext()` first. A call to this
		method while `hasNext()` is `false` yields unspecified behavior.

		On the other hand, iterators should not require a call to `hasNext()`
		before the first call to `next()` if an element is available.</haxe_doc>
			</next>
			<hasNext set="method">
				<f a=""><x path="Bool"/></f>
				<haxe_doc>Returns `false` if the iteration is complete, `true` otherwise.

		Usually iteration is considered to be complete if all elements of the
		underlying data structure were handled through calls to `next()`. However,
		in custom iterators any logic may be used to determine the completion
		state.</haxe_doc>
			</hasNext>
		</a>
		<haxe_doc>An `Iterator` is a structure that permits iteration over elements of type `T`.

	Any class with matching `hasNext()` and `next()` fields is considered an `Iterator`
	and can then be used e.g. in `for`-loops. This makes it easy to implement
	custom iterators.

	@see https://haxe.org/manual/lf-iterators.html</haxe_doc>
	</typedef>
	<typedef path="Iterable" params="T" file="E:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<a><iterator set="method"><f a=""><t path="Iterator"><c path="Iterable.T"/></t></f></iterator></a>
		<haxe_doc>An `Iterable` is a data structure which has an `iterator()` method.
	See `Lambda` for generic functions on iterable structures.

	@see https://haxe.org/manual/lf-iterators.html</haxe_doc>
	</typedef>
	<typedef path="KeyValueIterator" params="K:V" file="E:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<t path="Iterator"><a>
	<value><c path="KeyValueIterator.V"/></value>
	<key><c path="KeyValueIterator.K"/></key>
</a></t>
		<haxe_doc>A `KeyValueIterator` is an `Iterator` that has a key and a value.</haxe_doc>
	</typedef>
	<typedef path="KeyValueIterable" params="K:V" file="E:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<a><keyValueIterator set="method"><f a=""><t path="KeyValueIterator">
	<c path="KeyValueIterable.K"/>
	<c path="KeyValueIterable.V"/>
</t></f></keyValueIterator></a>
		<haxe_doc>A `KeyValueIterable` is a data structure which has a `keyValueIterator()`
	method to iterate over key-value-pairs.</haxe_doc>
	</typedef>
	<class path="ArrayAccess" params="T" file="E:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes" extern="1" interface="1"><haxe_doc>`ArrayAccess` is used to indicate a class that can be accessed using brackets.
	The type parameter represents the type of the elements stored.

	This interface should be used for externs only. Haxe does not support custom
	array access on classes. However, array access can be implemented for
	abstract types.

	@see https://haxe.org/manual/types-abstract-array-access.html</haxe_doc></class>
	<class path="String" params="" file="E:\HaxeToolkit\haxe\std/String.hx" extern="1">
		<fromCharCode public="1" set="method" static="1">
			<f a="code">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the String corresponding to the character code `code`.

		If `code` is negative or has another invalid value, the result is
		unspecified.</haxe_doc>
		</fromCharCode>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The number of characters in `this` String.</haxe_doc>
		</length>
		<toUpperCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String where all characters of `this` String are upper case.</haxe_doc>
		</toUpperCase>
		<toLowerCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String where all characters of `this` String are lower case.</haxe_doc>
		</toLowerCase>
		<charAt public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the character at position `index` of `this` String.

		If `index` is negative or exceeds `this.length`, the empty String `""`
		is returned.</haxe_doc>
		</charAt>
		<charCodeAt public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<x path="Null"><x path="Int"/></x>
			</f>
			<haxe_doc>Returns the character code at position `index` of `this` String.

		If `index` is negative or exceeds `this.length`, `null` is returned.

		To obtain the character code of a single character, `"x".code` can be
		used instead to inline the character code at compile time. Note that
		this only works on String literals of length 1.</haxe_doc>
		</charCodeAt>
		<indexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the position of the leftmost occurrence of `str` within `this`
		String.

		If `startIndex` is given, the search is performed within the substring
		of `this` String starting from `startIndex` (if `startIndex` is posivite
		or 0) or `max(this.length + startIndex, 0)` (if `startIndex` is negative).

		If `startIndex` exceeds `this.length`, -1 is returned.

		Otherwise the search is performed within `this` String. In either case,
		the returned position is relative to the beginning of `this` String.

		If `str` cannot be found, -1 is returned.</haxe_doc>
		</indexOf>
		<lastIndexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the position of the rightmost occurrence of `str` within `this`
		String.

		If `startIndex` is given, the search is performed within the substring
		of `this` String from 0 to `startIndex + str.length`. Otherwise the search
		is performed within `this` String. In either case, the returned position
		is relative to the beginning of `this` String.

		If `str` cannot be found, -1 is returned.</haxe_doc>
		</lastIndexOf>
		<split public="1" set="method">
			<f a="delimiter">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Splits `this` String at each occurrence of `delimiter`.

		If `this` String is the empty String `""`, the result is not consistent
		across targets and may either be `[]` (on Js, Cpp) or `[""]`.

		If `delimiter` is the empty String `""`, `this` String is split into an
		Array of `this.length` elements, where the elements correspond to the
		characters of `this` String.

		If `delimiter` is not found within `this` String, the result is an Array
		with one element, which equals `this` String.

		If `delimiter` is null, the result is unspecified.

		Otherwise, `this` String is split into parts at each occurrence of
		`delimiter`. If `this` String starts (or ends) with `delimiter`, the
		result `Array` contains a leading (or trailing) empty String `""` element.
		Two subsequent delimiters also result in an empty String `""` element.</haxe_doc>
		</split>
		<substr public="1" set="method">
			<f a="pos:?len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns `len` characters of `this` String, starting at position `pos`.

		If `len` is omitted, all characters from position `pos` to the end of
		`this` String are included.

		If `pos` is negative, its value is calculated from the end of `this`
		String by `this.length + pos`. If this yields a negative value, 0 is
		used instead.

		If the calculated position + `len` exceeds `this.length`, the characters
		from that position to the end of `this` String are returned.

		If `len` is negative, the result is unspecified.</haxe_doc>
		</substr>
		<substring public="1" set="method">
			<f a="startIndex:?endIndex">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the part of `this` String from `startIndex` to but not including `endIndex`.

		If `startIndex` or `endIndex` are negative, 0 is used instead.

		If `startIndex` exceeds `endIndex`, they are swapped.

		If the (possibly swapped) `endIndex` is omitted or exceeds
		`this.length`, `this.length` is used instead.

		If the (possibly swapped) `startIndex` exceeds `this.length`, the empty
		String `""` is returned.</haxe_doc>
		</substring>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the String itself.</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a="string">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a copy from a given String.</haxe_doc>
		</new>
		<haxe_doc>The basic String class.

	A Haxe String is immutable, it is not possible to modify individual
	characters. No method of this class changes the state of `this` String.

	Strings can be constructed using the String literal syntax `"string value"`.

	String can be concatenated by using the `+` operator. If an operand is not a
	String, it is passed through `Std.string()` first.

	@see https://haxe.org/manual/std-String.html</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="StringBuf" params="" file="E:\HaxeToolkit\haxe\std/StringBuf.hx">
		<b><c path="String"/></b>
		<length public="1" get="null" set="null">
			<x path="Int"/>
			<haxe_doc>The length of `this` StringBuf in characters.</haxe_doc>
		</length>
		<new public="1" get="inline" set="null" line="47">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new StringBuf instance.

		This may involve initialization of the internal buffer.</haxe_doc>
		</new>
		<haxe_doc>A String buffer is an efficient way to build a big string by appending small
	elements together.

	Its cross-platform implementation uses String concatenation internally, but
	StringBuf may be optimized for different targets.

	Unlike String, an instance of StringBuf is not immutable in the sense that
	it can be passed as argument to functions which modify it by appending more
	values. However, the internal buffer cannot be modified.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="StringTools" params="" file="E:\HaxeToolkit\haxe\std/StringTools.hx">
		<htmlEscape public="1" set="method" line="158" static="1">
			<f a="s:?quotes">
				<c path="String"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<haxe_doc><![CDATA[Escapes HTML special characters of the string `s`.

		The following replacements are made:

		- `&` becomes `&amp`;
		- `<` becomes `&lt`;
		- `>` becomes `&gt`;

		If `quotes` is true, the following characters are also replaced:

		- `"` becomes `&quot`;
		- `'` becomes `&#039`;]]></haxe_doc>
		</htmlEscape>
		<startsWith public="1" set="method" line="222" static="1">
			<f a="s:start">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if the string `s` starts with the string `start`.

		If `start` is `null`, the result is unspecified.

		If `start` is the empty String `""`, the result is true.</haxe_doc>
		</startsWith>
		<endsWith public="1" set="method" line="252" static="1">
			<f a="s:end">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if the string `s` ends with the string `end`.

		If `end` is `null`, the result is unspecified.

		If `end` is the empty String `""`, the result is true.</haxe_doc>
		</endsWith>
		<isSpace public="1" set="method" line="288" static="1">
			<f a="s:pos">
				<c path="String"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if the character in the string `s` at position `pos` is a space.

		A character is considered to be a space character if its character code
		is 9,10,11,12,13 or 32.

		If `s` is the empty String `""`, or if pos is not a valid position within
		`s`, the result is false.</haxe_doc>
		</isSpace>
		<ltrim public="1" set="method" line="306" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes leading space characters of `s`.

		This function internally calls `isSpace()` to decide which characters to
		remove.

		If `s` is the empty String `""` or consists only of space characters, the
		result is the empty String `""`.</haxe_doc>
		</ltrim>
		<rtrim public="1" set="method" line="331" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes trailing space characters of `s`.

		This function internally calls `isSpace()` to decide which characters to
		remove.

		If `s` is the empty String `""` or consists only of space characters, the
		result is the empty String `""`.</haxe_doc>
		</rtrim>
		<trim public="1" set="method" line="353" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes leading and trailing space characters of `s`.

		This is a convenience function for `ltrim(rtrim(s))`.</haxe_doc>
		</trim>
		<lpad public="1" set="method" line="375" static="1">
			<f a="s:c:l">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Concatenates `c` to `s` until `s.length` is at least `l`.

		If `c` is the empty String `""` or if `l` does not exceed `s.length`,
		`s` is returned unchanged.

		If `c.length` is 1, the resulting String length is exactly `l`.

		Otherwise the length may exceed `l`.

		If `c` is null, the result is unspecified.</haxe_doc>
		</lpad>
		<hex public="1" set="method" line="444" static="1">
			<f a="n:?digits">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Encodes `n` into a hexadecimal representation.

		If `digits` is specified, the resulting String is padded with "0" until
		its `length` equals `digits`.</haxe_doc>
		</hex>
		<haxe_doc>This class provides advanced methods on Strings. It is ideally used with
	`using StringTools` and then acts as an [extension](https://haxe.org/manual/lf-static-extension.html)
	to the `String` class.

	If the first argument to any of the methods is null, the result is
	unspecified.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="Sys" params="" file="E:\HaxeToolkit\haxe\std/Sys.hx" extern="1">
		<print public="1" set="method" static="1">
			<f a="v">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>Prints any value to the standard output.</haxe_doc>
		</print>
		<println public="1" set="method" static="1">
			<f a="v">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>Prints any value to the standard output, followed by a newline.
		On Windows, this function outputs a CRLF newline.
		LF newlines are printed on all other platforms.</haxe_doc>
		</println>
		<args public="1" set="method" static="1">
			<f a=""><c path="Array"><c path="String"/></c></f>
			<haxe_doc>Returns all the arguments that were passed in the command line.
		This does not include the interpreter or the name of the program file.

		(java)(eval) On Windows, non-ASCII Unicode arguments will not work correctly.

		(cs) Non-ASCII Unicode arguments will not work correctly.</haxe_doc>
		</args>
		<getEnv public="1" set="method" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the value of the given environment variable, or `null` if it
		doesn't exist.</haxe_doc>
		</getEnv>
		<putEnv public="1" set="method" static="1">
			<f a="s:v">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the value of the given environment variable.

		(java) This functionality is not available on Java; calling this function will throw.</haxe_doc>
		</putEnv>
		<environment public="1" set="method" static="1">
			<f a=""><t path="Map">
	<c path="String"/>
	<c path="String"/>
</t></f>
			<haxe_doc>Returns all environment variables.</haxe_doc>
		</environment>
		<sleep public="1" set="method" static="1">
			<f a="seconds">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Suspends execution for the given length of time (in seconds).</haxe_doc>
		</sleep>
		<setTimeLocale public="1" set="method" static="1">
			<f a="loc">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Changes the current time locale, which will affect `DateTools.format` date formating.
		Returns `true` if the locale was successfully changed.</haxe_doc>
		</setTimeLocale>
		<getCwd public="1" set="method" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>Gets the current working directory (usually the one in which the program was started).</haxe_doc>
		</getCwd>
		<setCwd public="1" set="method" static="1">
			<f a="s">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Changes the current working directory.

		(java) This functionality is not available on Java; calling this function will throw.</haxe_doc>
		</setCwd>
		<systemName public="1" set="method" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the type of the current system. Possible values are:
		 - `"Windows"`
		 - `"Linux"`
		 - `"BSD"`
		 - `"Mac"`</haxe_doc>
		</systemName>
		<command public="1" set="method" static="1">
			<f a="cmd:?args">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
				<x path="Int"/>
			</f>
			<haxe_doc>Runs the given command. The command output will be printed to the same output as the current process.
		The current process will block until the command terminates.
		The return value is the exit code of the command (usually `0` indicates no error).

		Command arguments can be passed in two ways:

		 1. Using `args` to pass command arguments. Each argument will be automatically quoted and shell meta-characters will be escaped if needed.
		`cmd` should be an executable name that can be located in the `PATH` environment variable, or a full path to an executable.

		 2. When `args` is not given or is `null`, command arguments can be appended to `cmd`. No automatic quoting/escaping will be performed. `cmd` should be formatted exactly as it would be when typed at the command line.
		It can run executables, as well as shell commands that are not executables (e.g. on Windows: `dir`, `cd`, `echo` etc).

		Use the `sys.io.Process` API for more complex tasks, such as background processes, or providing input to the command.</haxe_doc>
		</command>
		<exit public="1" set="method" static="1">
			<f a="code">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Exits the current process with the given exit code.

		(macro)(eval) Being invoked in a macro or eval context (e.g. with `-x` or `--run`) immediately terminates
		the compilation process, which also prevents the execution of any `--next` sections of compilation arguments.</haxe_doc>
		</exit>
		<time public="1" set="method" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Gives the most precise timestamp value available (in seconds).</haxe_doc>
		</time>
		<cpuTime public="1" set="method" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Gives the most precise timestamp value available (in seconds),
		but only accounts for the actual time spent running on the CPU for the current thread/process.</haxe_doc>
		</cpuTime>
		<executablePath public="1" set="method" static="1">
			<f a=""><c path="String"/></f>
			<meta><m n=":deprecated"><e>"Use programPath instead"</e></m></meta>
			<haxe_doc>Returns the path to the current executable that we are running.</haxe_doc>
		</executablePath>
		<programPath public="1" set="method" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the absolute path to the current program file that we are running.
		Concretely, for an executable binary, it returns the path to the binary.
		For a script (e.g. a PHP file), it returns the path to the script.</haxe_doc>
		</programPath>
		<getChar public="1" set="method" static="1">
			<f a="echo">
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Reads a single input character from the standard input and returns it.
		Setting `echo` to `true` will also display the character on the output.</haxe_doc>
		</getChar>
		<stdin public="1" set="method" static="1">
			<f a=""><c path="haxe.io.Input"/></f>
			<haxe_doc>Returns the standard input of the process, from which user input can be read.
		Usually it will block until the user sends a full input line.
		See `getChar` for an alternative.</haxe_doc>
		</stdin>
		<stdout public="1" set="method" static="1">
			<f a=""><c path="haxe.io.Output"/></f>
			<haxe_doc>Returns the standard output of the process, to which program output can be written.</haxe_doc>
		</stdout>
		<stderr public="1" set="method" static="1">
			<f a=""><c path="haxe.io.Output"/></f>
			<haxe_doc>Returns the standard error of the process, to which program errors can be written.</haxe_doc>
		</stderr>
		<haxe_doc>This class provides access to various base functions of system platforms.
	Look in the `sys` package for more system APIs.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":require"><e>sys</e></m>
		</meta>
	</class>
	<class path="Type" params="" file="E:\HaxeToolkit\haxe\std/Type.hx" extern="1">
		<getClass public="1" params="T" set="method" static="1">
			<f a="o">
				<c path="getClass.T"/>
				<x path="Class"><c path="getClass.T"/></x>
			</f>
			<haxe_doc>Returns the class of `o`, if `o` is a class instance.

		If `o` is null or of a different type, null is returned.

		In general, type parameter information cannot be obtained at runtime.</haxe_doc>
		</getClass>
		<getEnum public="1" set="method" static="1">
			<f a="o">
				<x path="EnumValue"/>
				<x path="Enum"><d/></x>
			</f>
			<haxe_doc><![CDATA[Returns the enum of enum instance `o`.

		An enum instance is the result of using an enum constructor. Given an
		`enum Color { Red; }`, `getEnum(Red)` returns `Enum<Color>`.

		If `o` is null, null is returned.

		In general, type parameter information cannot be obtained at runtime.]]></haxe_doc>
		</getEnum>
		<getSuperClass public="1" set="method" static="1">
			<f a="c">
				<x path="Class"><d/></x>
				<x path="Class"><d/></x>
			</f>
			<haxe_doc>Returns the super-class of class `c`.

		If `c` has no super class, null is returned.

		If `c` is null, the result is unspecified.

		In general, type parameter information cannot be obtained at runtime.</haxe_doc>
		</getSuperClass>
		<getClassName public="1" set="method" static="1">
			<f a="c">
				<x path="Class"><d/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the name of class `c`, including its path.

		If `c` is inside a package, the package structure is returned dot-
		separated, with another dot separating the class name:
		`pack1.pack2.(...).packN.ClassName`
		If `c` is a sub-type of a Haxe module, that module is not part of the
		package structure.

		If `c` has no package, the class name is returned.

		If `c` is null, the result is unspecified.

		The class name does not include any type parameters.</haxe_doc>
		</getClassName>
		<getEnumName public="1" set="method" static="1">
			<f a="e">
				<x path="Enum"><d/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the name of enum `e`, including its path.

		If `e` is inside a package, the package structure is returned dot-
		separated, with another dot separating the enum name:
		`pack1.pack2.(...).packN.EnumName`
		If `e` is a sub-type of a Haxe module, that module is not part of the
		package structure.

		If `e` has no package, the enum name is returned.

		If `e` is null, the result is unspecified.

		The enum name does not include any type parameters.</haxe_doc>
		</getEnumName>
		<resolveClass public="1" set="method" static="1">
			<f a="name">
				<c path="String"/>
				<x path="Class"><d/></x>
			</f>
			<haxe_doc>Resolves a class by name.

		If `name` is the path of an existing class, that class is returned.

		Otherwise null is returned.

		If `name` is null or the path to a different type, the result is
		unspecified.

		The class name must not include any type parameters.</haxe_doc>
		</resolveClass>
		<resolveEnum public="1" set="method" static="1">
			<f a="name">
				<c path="String"/>
				<x path="Enum"><d/></x>
			</f>
			<haxe_doc>Resolves an enum by name.

		If `name` is the path of an existing enum, that enum is returned.

		Otherwise null is returned.

		If `name` is null the result is unspecified.

		If `name` is the path to a different type, null is returned.

		The enum name must not include any type parameters.</haxe_doc>
		</resolveEnum>
		<createInstance public="1" params="T" set="method" static="1">
			<f a="cl:args">
				<x path="Class"><c path="createInstance.T"/></x>
				<c path="Array"><d/></c>
				<c path="createInstance.T"/>
			</f>
			<haxe_doc>Creates an instance of class `cl`, using `args` as arguments to the
		class constructor.

		This function guarantees that the class constructor is called.

		Default values of constructors arguments are not guaranteed to be
		taken into account.

		If `cl` or `args` are null, or if the number of elements in `args` does
		not match the expected number of constructor arguments, or if any
		argument has an invalid type,  or if `cl` has no own constructor, the
		result is unspecified.

		In particular, default values of constructor arguments are not
		guaranteed to be taken into account.</haxe_doc>
		</createInstance>
		<createEmptyInstance public="1" params="T" set="method" static="1">
			<f a="cl">
				<x path="Class"><c path="createEmptyInstance.T"/></x>
				<c path="createEmptyInstance.T"/>
			</f>
			<haxe_doc>Creates an instance of class `cl`.

		This function guarantees that the class constructor is not called.

		If `cl` is null, the result is unspecified.</haxe_doc>
		</createEmptyInstance>
		<createEnum public="1" params="T" set="method" static="1">
			<f a="e:constr:?params">
				<x path="Enum"><c path="createEnum.T"/></x>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createEnum.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor `constr` with
		arguments `params`.

		If `e` or `constr` is null, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createEnum>
		<createEnumIndex public="1" params="T" set="method" static="1">
			<f a="e:index:?params">
				<x path="Enum"><c path="createEnumIndex.T"/></x>
				<x path="Int"/>
				<c path="Array"><d/></c>
				<c path="createEnumIndex.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor number
		`index` with arguments `params`.

		The constructor indices are preserved from Haxe syntax, so the first
		declared is index 0, the next index 1 etc.

		If `e` or `constr` is null, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createEnumIndex>
		<getInstanceFields public="1" set="method" static="1">
			<f a="c">
				<x path="Class"><d/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of the instance fields of class `c`, including
		inherited fields.

		This only includes fields which are known at compile-time. In
		particular, using `getInstanceFields(getClass(obj))` will not include
		any fields which were added to `obj` at runtime.

		The order of the fields in the returned Array is unspecified.

		If `c` is null, the result is unspecified.

		(As3) This method only returns instance fields that are public.</haxe_doc>
		</getInstanceFields>
		<getClassFields public="1" set="method" static="1">
			<f a="c">
				<x path="Class"><d/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of static fields of class `c`.

		This does not include static fields of parent classes.

		The order of the fields in the returned Array is unspecified.

		If `c` is null, the result is unspecified.

		(As3) This method only returns class fields that are public.</haxe_doc>
		</getClassFields>
		<getEnumConstructs public="1" set="method" static="1">
			<f a="e">
				<x path="Enum"><d/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of the names of all constructors of enum `e`.

		The order of the constructor names in the returned Array is preserved
		from the original syntax.

		If `e` is null, the result is unspecified.</haxe_doc>
		</getEnumConstructs>
		<typeof public="1" set="method" static="1">
			<f a="v">
				<d/>
				<e path="ValueType"/>
			</f>
			<haxe_doc>Returns the runtime type of value `v`.

		The result corresponds to the type `v` has at runtime, which may vary
		per platform. Assumptions regarding this should be minimized to avoid
		surprises.</haxe_doc>
		</typeof>
		<enumEq public="1" params="T" set="method" static="1">
			<f a="a:b">
				<c path="enumEq.T"/>
				<c path="enumEq.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Recursively compares two enum instances `a` and `b` by value.

		Unlike `a == b`, this function performs a deep equality check on the
		arguments of the constructors, if exists.

		If `a` or `b` are null, the result is unspecified.</haxe_doc>
		</enumEq>
		<enumConstructor public="1" set="method" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the constructor name of enum instance `e`.

		The result String does not contain any constructor arguments.

		If `e` is null, the result is unspecified.</haxe_doc>
		</enumConstructor>
		<enumParameters public="1" set="method" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>Returns a list of the constructor arguments of enum instance `e`.

		If `e` has no arguments, the result is [].

		Otherwise the result are the values that were used as arguments to `e`,
		in the order of their declaration.

		If `e` is null, the result is unspecified.</haxe_doc>
		</enumParameters>
		<enumIndex public="1" set="method" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the index of enum instance `e`.

		This corresponds to the original syntactic position of `e`. The index of
		the first declared constructor is 0, the next one is 1 etc.

		If `e` is null, the result is unspecified.</haxe_doc>
		</enumIndex>
		<allEnums public="1" params="T" set="method" static="1">
			<f a="e">
				<x path="Enum"><c path="allEnums.T"/></x>
				<c path="Array"><c path="allEnums.T"/></c>
			</f>
			<haxe_doc>Returns a list of all constructors of enum `e` that require no
		arguments.

		This may return the empty Array `[]` if all constructors of `e` require
		arguments.

		Otherwise an instance of `e` constructed through each of its non-
		argument constructors is returned, in the order of the constructor
		declaration.

		If `e` is null, the result is unspecified.</haxe_doc>
		</allEnums>
		<haxe_doc>The Haxe Reflection API allows retrieval of type information at runtime.

	This class complements the more lightweight Reflect class, with a focus on
	class and enum instances.

	@see https://haxe.org/manual/types.html
	@see https://haxe.org/manual/std-reflection.html</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="ValueType" params="" file="E:\HaxeToolkit\haxe\std/Type.hx" module="Type">
		<TNull/>
		<TInt/>
		<TFloat/>
		<TBool/>
		<TObject/>
		<TFunction/>
		<TClass a="c"><x path="Class"><d/></x></TClass>
		<TEnum a="e"><x path="Enum"><d/></x></TEnum>
		<TUnknown/>
		<haxe_doc>The different possible runtime types of a value.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<abstract path="UInt" params="" file="E:\HaxeToolkit\haxe\std/UInt.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="Int"/></icast>
			<icast field="toFloat"><x path="Float"/></icast>
		</to>
		<haxe_doc>The unsigned `Int` type is only defined for Flash and C#.
	Simulate it for other platforms.

	@see https://haxe.org/manual/types-basic-types.html</haxe_doc>
		<impl><class path="_UInt.UInt_Impl_" params="" file="E:\HaxeToolkit\haxe\std/UInt.hx" private="1" module="UInt"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="XmlType" params="" file="E:\HaxeToolkit\haxe\std/Xml.hx" module="Xml">
		<this><x path="Int"/></this>
		<haxe_doc>Xml node types.

	@see https://haxe.org/manual/std-Xml.html</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="_Xml.XmlType_Impl_" params="" file="E:\HaxeToolkit\haxe\std/Xml.hx" private="1" module="Xml">
	<toString public="1" set="method" line="64" static="1">
		<f a="this">
			<x path="Int"/>
			<c path="String"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toString>
	<meta>
		<m n=":keep"/>
		<m n=":directlyUsed"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="_Xml.XmlType_Impl_" params="" file="E:\HaxeToolkit\haxe\std/Xml.hx" private="1" module="Xml">
		<toString public="1" set="method" line="64" static="1">
			<f a="this">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toString>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="Xml" params="" file="E:\HaxeToolkit\haxe\std/Xml.hx">
		<Element public="1" set="null" expr="XmlType.Element" line="86" static="1">
			<x path="XmlType"/>
			<meta><m n=":value"><e>XmlType.Element</e></m></meta>
			<haxe_doc>XML element type.</haxe_doc>
		</Element>
		<PCData public="1" set="null" expr="XmlType.PCData" line="91" static="1">
			<x path="XmlType"/>
			<meta><m n=":value"><e>XmlType.PCData</e></m></meta>
			<haxe_doc>XML parsed character data type.</haxe_doc>
		</PCData>
		<CData public="1" set="null" expr="XmlType.CData" line="96" static="1">
			<x path="XmlType"/>
			<meta><m n=":value"><e>XmlType.CData</e></m></meta>
			<haxe_doc>XML character data type.</haxe_doc>
		</CData>
		<Comment public="1" set="null" expr="XmlType.Comment" line="101" static="1">
			<x path="XmlType"/>
			<meta><m n=":value"><e>XmlType.Comment</e></m></meta>
			<haxe_doc>XML comment type.</haxe_doc>
		</Comment>
		<DocType public="1" set="null" expr="XmlType.DocType" line="106" static="1">
			<x path="XmlType"/>
			<meta><m n=":value"><e>XmlType.DocType</e></m></meta>
			<haxe_doc>XML doctype element type.</haxe_doc>
		</DocType>
		<ProcessingInstruction public="1" set="null" expr="XmlType.ProcessingInstruction" line="111" static="1">
			<x path="XmlType"/>
			<meta><m n=":value"><e>XmlType.ProcessingInstruction</e></m></meta>
			<haxe_doc>XML processing instruction type.</haxe_doc>
		</ProcessingInstruction>
		<Document public="1" set="null" expr="XmlType.Document" line="116" static="1">
			<x path="XmlType"/>
			<meta><m n=":value"><e>XmlType.Document</e></m></meta>
			<haxe_doc>XML document type.</haxe_doc>
		</Document>
		<parse public="1" set="method" line="121" static="1">
			<f a="str">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Parses the String into an Xml document.</haxe_doc>
		</parse>
		<createElement public="1" set="method" line="182" static="1">
			<f a="name">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createElement>
		<createPCData public="1" set="method" line="191" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createPCData>
		<createCData public="1" set="method" line="200" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createCData>
		<createComment public="1" set="method" line="209" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createComment>
		<createDocType public="1" set="method" line="218" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createDocType>
		<createProcessingInstruction public="1" set="method" line="227" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createProcessingInstruction>
		<createDocument public="1" set="method" line="236" static="1">
			<f a=""><c path="Xml"/></f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createDocument>
		<nodeType public="1" set="null">
			<x path="XmlType"/>
			<haxe_doc>Returns the type of the Xml Node. This should be used before
		accessing other functions since some might raise an exception
		if the node type is not correct.</haxe_doc>
		</nodeType>
		<nodeName public="1" get="null" set="null">
			<c path="String"/>
			<meta><m n=":isVar"/></meta>
			<haxe_doc>Returns the node name of an Element.</haxe_doc>
		</nodeName>
		<nodeValue public="1" get="null" set="null">
			<c path="String"/>
			<meta><m n=":isVar"/></meta>
			<haxe_doc>Returns the node value. Only works if the Xml node is not an Element or a Document.</haxe_doc>
		</nodeValue>
		<parent public="1" set="null">
			<c path="Xml"/>
			<haxe_doc>Returns the parent object in the Xml hierarchy.
		The parent can be `null`, an Element or a Document.</haxe_doc>
		</parent>
		<children><c path="Array"><c path="Xml"/></c></children>
		<attributeMap><t path="Map">
	<c path="String"/>
	<c path="String"/>
</t></attributeMap>
		<get public="1" set="method" line="244">
			<f a="att">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Get the given attribute of an Element node. Returns `null` if not found.
		Attributes are case-sensitive.</haxe_doc>
		</get>
		<set public="1" set="method" line="255">
			<f a="att:value">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Set the given attribute value for an Element node.
		Attributes are case-sensitive.</haxe_doc>
		</set>
		<exists public="1" set="method" line="277">
			<f a="att">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if the Element node has a given attribute.
		Attributes are case-sensitive.</haxe_doc>
		</exists>
		<attributes public="1" set="method" line="287">
			<f a=""><t path="Iterator"><c path="String"/></t></f>
			<haxe_doc>Returns an `Iterator` on all the attribute names.</haxe_doc>
		</attributes>
		<iterator public="1" get="inline" set="null" line="298">
			<f a=""><t path="Iterator"><c path="Xml"/></t></f>
			<haxe_doc>Returns an iterator of all child nodes.
		Only works if the current node is an Element or a Document.</haxe_doc>
		</iterator>
		<elements public="1" set="method" line="307">
			<f a=""><t path="Iterator"><c path="Xml"/></t></f>
			<haxe_doc>Returns an iterator of all child nodes which are Elements.
		Only works if the current node is an Element or a Document.</haxe_doc>
		</elements>
		<elementsNamed public="1" set="method" line="317">
			<f a="name">
				<c path="String"/>
				<t path="Iterator"><c path="Xml"/></t>
			</f>
			<haxe_doc>Returns an iterator of all child nodes which are Elements with the given nodeName.
		Only works if the current node is an Element or a Document.</haxe_doc>
		</elementsNamed>
		<firstElement public="1" set="method" line="337">
			<f a=""><c path="Xml"/></f>
			<haxe_doc>Returns the first child node which is an Element.</haxe_doc>
		</firstElement>
		<addChild public="1" set="method" line="353">
			<f a="x">
				<c path="Xml"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds a child node to the Document or Element.
		A child node can only be inside one given parent node, which is indicated by the `parent` property.
		If the child is already inside this Document or Element, it will be moved to the last position among the Document or Element's children.
		If the child node was previously inside a different node, it will be moved to this Document or Element.</haxe_doc>
		</addChild>
		<removeChild public="1" set="method" line="366">
			<f a="x">
				<c path="Xml"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes a child from the Document or Element.
		Returns true if the child was successfuly removed.</haxe_doc>
		</removeChild>
		<insertChild public="1" set="method" line="381">
			<f a="x:pos">
				<c path="Xml"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Inserts a child at the given position among the other childs.
		A child node can only be inside one given parent node, which is indicated by the [parent] property.
		If the child is already inside this Document or Element, it will be moved to the new position among the Document or Element's children.
		If the child node was previously inside a different node, it will be moved to this Document or Element.</haxe_doc>
		</insertChild>
		<toString public="1" get="inline" set="null" line="393">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String representation of the Xml node.</haxe_doc>
		</toString>
		<new set="method" line="397"><f a="nodeType">
	<x path="XmlType"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Cross-platform Xml API.

	@see https://haxe.org/manual/std-Xml.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="ch2.AnimationFrame" params="" file="./ch2/Animation.hx" module="ch2.Animation">
		<tile public="1">
			<x path="Null"><c path="h2d.Tile"/></x>
			<haxe_doc>An `h2d.Tile` this frame should display. Can be null to show nothing.</haxe_doc>
		</tile>
		<duration public="1">
			<x path="Float"/>
			<haxe_doc>Frame display duration in seconds.</haxe_doc>
		</duration>
		<isKey public="1">
			<x path="Bool"/>
			<haxe_doc>Is this frame a keyframe? (default: true)
		Keyframes are not skipped when Animation accumulated more than one frame between updates.</haxe_doc>
		</isKey>
		<color public="1">
			<x path="Null"><c path="h3d.Vector"/></x>
			<haxe_doc>Override color multiplier for this frame.</haxe_doc>
		</color>
		<alpha public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>Alpha value for this frame. Shortcut to `color.a`, and will create it as [1, 1, 1, alpha] if it's null.</haxe_doc>
		</alpha>
		<eventEnter public="1">
			<c path="String"/>
			<haxe_doc>Specifies event, triggered when this frame is activated.</haxe_doc>
		</eventEnter>
		<eventExit public="1">
			<c path="String"/>
			<haxe_doc>Specifies event, triggered when this frame is deactivated.
		If animation is paused during exit trigger, this frame will remain active.</haxe_doc>
		</eventExit>
		<get_alpha get="inline" set="null" line="59"><f a=""><x path="Float"/></f></get_alpha>
		<set_alpha get="inline" set="null" line="63"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_alpha>
		<new public="1" set="method" line="53">
			<f a="tile:duration:?isKey" v="::true">
				<x path="Null"><c path="h2d.Tile"/></x>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ isKey : true }</e></m></meta>
			<haxe_doc>Create a new Animation Frame with specified tile (or null), duration and keyframe flag.</haxe_doc>
		</new>
		<haxe_doc>Single Animation Frame. Can be reused multiple times in Animation.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h2d.Object" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h2d/Object.hx">
		<nullDrawable static="1"><c path="h2d.Drawable"/></nullDrawable>
		<children><c path="Array"><c path="h2d.Object"/></c></children>
		<parentContainer><c path="h2d.Object"/></parentContainer>
		<parent public="1" set="null">
			<c path="h2d.Object"/>
			<haxe_doc>The parent object in the scene tree.</haxe_doc>
		</parent>
		<numChildren public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>How many immediate children this object has.</haxe_doc>
		</numChildren>
		<name public="1">
			<c path="String"/>
			<haxe_doc>The name of the object, can be used to retrieve an object within a tree by using `getObjectByName` (default null)</haxe_doc>
		</name>
		<x public="1" set="accessor">
			<x path="Float"/>
			<haxe_doc>The x position (in pixels) of the object relative to its parent.</haxe_doc>
		</x>
		<y public="1" set="accessor">
			<x path="Float"/>
			<haxe_doc>The y position (in pixels) of the object relative to its parent.</haxe_doc>
		</y>
		<scaleX public="1" set="accessor">
			<x path="Float"/>
			<haxe_doc>The amount of horizontal scaling of this object (default 1.0)</haxe_doc>
		</scaleX>
		<scaleY public="1" set="accessor">
			<x path="Float"/>
			<haxe_doc>The amount of vertical scaling of this object (default 1.0)</haxe_doc>
		</scaleY>
		<rotation public="1" set="accessor">
			<x path="Float"/>
			<haxe_doc>The rotation angle of this object, in radians.</haxe_doc>
		</rotation>
		<visible public="1" set="accessor">
			<x path="Bool"/>
			<haxe_doc>Is the object and its children are displayed on screen (default true).</haxe_doc>
		</visible>
		<alpha public="1" expr="1.">
			<x path="Float"/>
			<meta><m n=":value"><e>1.</e></m></meta>
			<haxe_doc>The amount of transparency of the Object (default 1.0)</haxe_doc>
		</alpha>
		<filter public="1" set="accessor">
			<c path="h2d.filter.Filter"/>
			<haxe_doc>The post process filter for this object.
		When set, `alpha` value affects both filter and object transparency (use `Drawable.color.a` to set transparency only for the object).</haxe_doc>
		</filter>
		<blendMode public="1">
			<e path="h2d.BlendMode"/>
			<haxe_doc>The blendMode of the object (default Alpha).
		If there is no filter active, only apply to the current object (not inherited by children)
		If there is a filter active, tells how the filter is blended with background.</haxe_doc>
		</blendMode>
		<matA><x path="Float"/></matA>
		<matB><x path="Float"/></matB>
		<matC><x path="Float"/></matC>
		<matD><x path="Float"/></matD>
		<absX><x path="Float"/></absX>
		<absY><x path="Float"/></absY>
		<posChanged><x path="Bool"/></posChanged>
		<allocated><x path="Bool"/></allocated>
		<lastFrame><x path="Int"/></lastFrame>
		<getBounds public="1" set="method" line="116">
			<f a="?relativeTo:?out">
				<c path="h2d.Object"/>
				<c path="h2d.col.Bounds"/>
				<c path="h2d.col.Bounds"/>
			</f>
			<haxe_doc>Return the bounds of the object for its whole content, recursively.
		If relativeTo is null, it will return the bounds in the absolute coordinates.
		If not, it will return the bounds relative to the specified object coordinates.
		You can pass an already allocated bounds or getBounds will allocate one for you and return it.</haxe_doc>
		</getBounds>
		<getSize public="1" set="method" line="136">
			<f a="?out">
				<c path="h2d.col.Bounds"/>
				<c path="h2d.col.Bounds"/>
			</f>
			<haxe_doc>Similar to getBounds(parent), but instead of the full content, it will return
		the size based on the alignement of the object. For instance for a text, getBounds will return
		the full glyphs size whereas getSize() will ignore the pixels under the baseline.</haxe_doc>
		</getSize>
		<getAbsPos public="1" set="method" line="153">
			<f a=""><c path="h2d.col.Matrix"/></f>
			<haxe_doc>Returns the updated absolute position matrix.</haxe_doc>
		</getAbsPos>
		<find public="1" params="T" set="method" line="168">
			<f a="f">
				<f a="">
					<c path="h2d.Object"/>
					<x path="Null"><c path="find.T"/></x>
				</f>
				<x path="Null"><c path="find.T"/></x>
			</f>
			<haxe_doc>Find a single object in the tree by calling `f` on each and returning the first not-null value returned, or null if not found.</haxe_doc>
		</find>
		<findAll public="1" params="T" set="method" line="182">
			<f a="f:?arr">
				<f a="">
					<c path="h2d.Object"/>
					<x path="Null"><c path="findAll.T"/></x>
				</f>
				<c path="Array"><c path="findAll.T"/></c>
				<c path="Array"><c path="findAll.T"/></c>
			</f>
			<haxe_doc>Find several objects in the tree by calling `f` on each and returning all the not-null values returned.</haxe_doc>
		</findAll>
		<set_filter set="method" line="192"><f a="f">
	<c path="h2d.filter.Filter"/>
	<c path="h2d.filter.Filter"/>
</f></set_filter>
		<getBoundsRec set="method" line="199"><f a="relativeTo:out:forSize">
	<c path="h2d.Object"/>
	<c path="h2d.col.Bounds"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></getBoundsRec>
		<addBounds set="method" line="232"><f a="relativeTo:out:dx:dy:width:height">
	<c path="h2d.Object"/>
	<c path="h2d.col.Bounds"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></addBounds>
		<getObjectsCount public="1" set="method" line="287">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Return the total number of children, recursively.</haxe_doc>
		</getObjectsCount>
		<localToGlobal public="1" set="method" line="297">
			<f a="?pt">
				<c path="h2d.col.Point"/>
				<c path="h2d.col.Point"/>
			</f>
			<haxe_doc>Convert a local position (or [0,0] if pt is null) relative to the object origin into an absolute screen position, applying all the inherited transforms.</haxe_doc>
		</localToGlobal>
		<globalToLocal public="1" set="method" line="310">
			<f a="pt">
				<c path="h2d.col.Point"/>
				<c path="h2d.col.Point"/>
			</f>
			<haxe_doc>Convert an absolute screen position into a local position relative to the object origin, applying all the inherited transforms.</haxe_doc>
		</globalToLocal>
		<getScene public="1" set="method" line="322"><f a=""><c path="h2d.Scene"/></f></getScene>
		<set_visible set="method" line="328"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_visible>
		<addChild public="1" set="method" line="339">
			<f a="s">
				<c path="h2d.Object"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Add a child object at the end of the children list.</haxe_doc>
		</addChild>
		<addChildAt public="1" set="method" line="346">
			<f a="s:pos">
				<c path="h2d.Object"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Insert a child object at the specified position of the children list.</haxe_doc>
		</addChildAt>
		<onContentChanged get="inline" set="null" line="380"><f a=""><x path="Void"/></f></onContentChanged>
		<onHierarchyMoved set="method" line="385"><f a="parentChanged">
	<x path="Bool"/>
	<x path="Void"/>
</f></onHierarchyMoved>
		<onAdd set="method" line="391"><f a=""><x path="Void"/></f></onAdd>
		<onRemove set="method" line="400"><f a=""><x path="Void"/></f></onRemove>
		<getMatrix set="method" line="408"><f a="m">
	<c path="h2d.col.Matrix"/>
	<x path="Void"/>
</f></getMatrix>
		<removeChild public="1" set="method" line="420">
			<f a="s">
				<c path="h2d.Object"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Remove the given object from our immediate children list if it's part of it.</haxe_doc>
		</removeChild>
		<setParentContainer set="method" line="433"><f a="c">
	<c path="h2d.Object"/>
	<x path="Void"/>
</f></setParentContainer>
		<removeChildren public="1" set="method" line="442">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Remove all children from our immediate children list</haxe_doc>
		</removeChildren>
		<remove public="1" get="inline" set="null" line="451">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Same as parent.removeChild(this), but does nothing if parent is null.
		In order to capture add/removal from scene, you can override onAdd/onRemove/onHierarchyMoved</haxe_doc>
		</remove>
		<drawTo public="1" set="method" line="458">
			<f a="t">
				<c path="h3d.mat.Texture"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Draw the object and all its children into the given Texture</haxe_doc>
		</drawTo>
		<drawToTextures public="1" set="method" line="472">
			<f a="texs:outputs">
				<c path="Array"><c path="h3d.mat.Texture"/></c>
				<c path="Array"><e path="hxsl.Output"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>Draw the object and all its children into the given Textures</haxe_doc>
		</drawToTextures>
		<draw set="method" line="483"><f a="ctx">
	<c path="h2d.RenderContext"/>
	<x path="Void"/>
</f></draw>
		<sync set="method" line="486"><f a="ctx">
	<c path="h2d.RenderContext"/>
	<x path="Void"/>
</f></sync>
		<syncPos set="method" line="513"><f a=""><x path="Void"/></f></syncPos>
		<calcAbsPos set="method" line="523"><f a=""><x path="Void"/></f></calcAbsPos>
		<emitTile set="method" line="567"><f a="ctx:tile">
	<c path="h2d.RenderContext"/>
	<c path="h2d.Tile"/>
	<x path="Void"/>
</f></emitTile>
		<clipBounds set="method" line="640">
			<f a="ctx:bounds">
				<c path="h2d.RenderContext"/>
				<c path="h2d.col.Bounds"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Clip a local bounds with our global viewport</haxe_doc>
		</clipBounds>
		<drawFilters set="method" line="702"><f a="ctx">
	<c path="h2d.RenderContext"/>
	<x path="Void"/>
</f></drawFilters>
		<drawFiltered set="method" line="788"><f a="ctx:tile">
	<c path="h2d.RenderContext"/>
	<c path="h2d.Tile"/>
	<x path="Void"/>
</f></drawFiltered>
		<drawRec set="method" line="802"><f a="ctx">
	<c path="h2d.RenderContext"/>
	<x path="Void"/>
</f></drawRec>
		<set_x get="inline" set="null" line="830"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_x>
		<set_y get="inline" set="null" line="835"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_y>
		<set_scaleX get="inline" set="null" line="840"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_scaleX>
		<set_scaleY get="inline" set="null" line="845"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_scaleY>
		<set_rotation get="inline" set="null" line="850"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_rotation>
		<move public="1" set="method" line="858">
			<f a="dx:dy">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Move the object by the specied amount along its current direction (rotation angle).</haxe_doc>
		</move>
		<setPosition public="1" get="inline" set="null" line="866">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Set the position of the object relative to its parent.</haxe_doc>
		</setPosition>
		<rotate public="1" get="inline" set="null" line="874">
			<f a="v">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Rotate the object by the given angle (in radians)</haxe_doc>
		</rotate>
		<scale public="1" get="inline" set="null" line="881">
			<f a="v">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Scale uniformly the object by the given factor.</haxe_doc>
		</scale>
		<setScale public="1" get="inline" set="null" line="889">
			<f a="v">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Set the uniform scale for the object.</haxe_doc>
		</setScale>
		<getChildAt public="1" get="inline" set="null" line="897">
			<f a="n">
				<x path="Int"/>
				<c path="h2d.Object"/>
			</f>
			<haxe_doc>Return the `n`th element among our immediate children list, or null if there is no.</haxe_doc>
		</getChildAt>
		<getChildIndex public="1" set="method" line="904">
			<f a="o">
				<c path="h2d.Object"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Return the index of the object `o` within our immediate children list, or `-1` if it is not part of our children list.</haxe_doc>
		</getChildIndex>
		<getObjectByName public="1" set="method" line="914">
			<f a="name">
				<c path="String"/>
				<c path="h2d.Object"/>
			</f>
			<haxe_doc>Search for an object recursively by name, return null if not found.</haxe_doc>
		</getObjectByName>
		<get_numChildren get="inline" set="null" line="924"><f a=""><x path="Int"/></f></get_numChildren>
		<iterator public="1" get="inline" set="null" line="931">
			<f a=""><c path="hxd.impl.ArrayIterator_h2d_Object"/></f>
			<haxe_doc>Return an iterator over this object immediate children</haxe_doc>
		</iterator>
		<toString set="method" line="935"><f a=""><c path="String"/></f></toString>
		<contentChanged set="method" line="945">
			<f a="s">
				<c path="h2d.Object"/>
				<x path="Void"/>
			</f>
			<haxe_doc>This is called by our children if we have defined their parentContainer when they get resized</haxe_doc>
		</contentChanged>
		<constraintSize set="method" line="952">
			<f a="maxWidth:maxHeight">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>This can be called by a parent container to constraint the size of its children.
		Negative value mean that constraint is to be disable.</haxe_doc>
		</constraintSize>
		<new public="1" set="method" line="99">
			<f a="?parent">
				<c path="h2d.Object"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Create a new empty object, and adds it to the parent object if not null.</haxe_doc>
		</new>
		<haxe_doc>h2d.Object is the base 2D class that all scene tree elements inherit from.
	It can be used to create a virtual container that does not display anything but can contain other objects
	so the various transforms are inherited to its children.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>h2d.Tools</e></m>
		</meta>
	</class>
	<class path="h2d.Drawable" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h2d/Drawable.hx">
		<extends path="h2d.Object"/>
		<color public="1">
			<c path="h3d.Vector"/>
			<haxe_doc>The color multiplier for the object. Can be used to adjust individually each of the four channels R,G,B,A (default [1,1,1,1])</haxe_doc>
		</color>
		<smooth public="1">
			<x path="Null"><x path="Bool"/></x>
			<haxe_doc>By enabling smoothing, scaling the object up or down will use hardware bilinear filtering resulting in less crisp aspect.
		By default smooth is null and then Scene.defaultSmooth value is used.</haxe_doc>
		</smooth>
		<tileWrap public="1" set="accessor">
			<x path="Bool"/>
			<haxe_doc>By enabling tile wrapping, you can have tiles which size exceed the texture size and will repeat instead of displaying clamped pixels.</haxe_doc>
		</tileWrap>
		<colorKey public="1" set="accessor">
			<x path="Null"><x path="Int"/></x>
			<haxe_doc>Setting a colorKey color value will discard all pixels that have this exact color in the tile.</haxe_doc>
		</colorKey>
		<colorMatrix public="1" get="accessor" set="accessor">
			<x path="Null"><c path="h3d.Matrix"/></x>
			<haxe_doc>Setting a colorMatrix will apply a color transformation. See also `adjustColor`.</haxe_doc>
		</colorMatrix>
		<colorAdd public="1" get="accessor" set="accessor">
			<x path="Null"><c path="h3d.Vector"/></x>
			<haxe_doc>Setting colorAdd will add the amount of color of each channel R,G,B,A to the object pixels.</haxe_doc>
		</colorAdd>
		<shaders><c path="hxsl.ShaderList"/></shaders>
		<set_tileWrap set="method" line="47"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_tileWrap>
		<get_colorAdd set="method" line="51"><f a=""><x path="Null"><c path="h3d.Vector"/></x></f></get_colorAdd>
		<set_colorAdd set="method" line="56"><f a="c">
	<c path="h3d.Vector"/>
	<c path="h3d.Vector"/>
</f></set_colorAdd>
		<drawFiltered set="method" line="72" override="1"><f a="ctx:tile">
	<c path="h2d.RenderContext"/>
	<c path="h2d.Tile"/>
	<x path="Void"/>
</f></drawFiltered>
		<set_colorKey set="method" line="79"><f a="v">
	<x path="Null"><x path="Int"/></x>
	<x path="Null"><x path="Int"/></x>
</f></set_colorKey>
		<adjustColor public="1" set="method" line="96">
			<f a="?col">
				<t path="h3d.ColorAdjust"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Set the `colorMatrix` value by specifying which effects to apply. Calling adjustColor() reset the colorMatrix to `null`</haxe_doc>
		</adjustColor>
		<get_colorMatrix set="method" line="110"><f a=""><x path="Null"><c path="h3d.Matrix"/></x></f></get_colorMatrix>
		<set_colorMatrix set="method" line="115"><f a="m">
	<c path="h3d.Matrix"/>
	<c path="h3d.Matrix"/>
</f></set_colorMatrix>
		<getDebugShaderCode public="1" set="method" line="134">
			<f a="?toHxsl" v="true">
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ toHxsl : true }</e></m></meta>
			<haxe_doc>Return the built shader code, can be used for debugging shader assembly</haxe_doc>
		</getDebugShaderCode>
		<getShader public="1" params="T" set="method" line="150">
			<f a="stype">
				<x path="Class"><c path="getShader.T"/></x>
				<c path="getShader.T"/>
			</f>
			<haxe_doc>Return the first shader of the given shader class among the object shaders</haxe_doc>
		</getShader>
		<getShaders public="1" get="inline" set="null" line="162">
			<f a=""><c path="hxsl._ShaderList.ShaderIterator"/></f>
			<haxe_doc>Return all object shaders</haxe_doc>
		</getShaders>
		<addShader public="1" params="T" set="method" line="169">
			<f a="s">
				<c path="addShader.T"/>
				<c path="addShader.T"/>
			</f>
			<haxe_doc>Add a shader to the object shaders</haxe_doc>
		</addShader>
		<removeShader public="1" set="method" line="178">
			<f a="s">
				<c path="hxsl.Shader"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Remove a shader from the object shaders, returns true if found or false if it was not part of our shaders.</haxe_doc>
		</removeShader>
		<emitTile set="method" line="194" override="1"><f a="ctx:tile">
	<c path="h2d.RenderContext"/>
	<c path="h2d.Tile"/>
	<x path="Void"/>
</f></emitTile>
		<new set="method" line="42"><f a="parent">
	<c path="h2d.Object"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>h2d.Drawable is the base class for all 2D objects that will draw something on screen.
	Unlike Object base class, all properties of Drawable only apply to the current object and are not inherited by its children.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="ch2.Animation" params="" file="./ch2/Animation.hx">
		<extends path="h2d.Drawable"/>
		<fromFixedFramerate public="1" set="method" line="82" static="1">
			<f a="tiles:fps">
				<c path="Array"><c path="h2d.Tile"/></c>
				<x path="Float"/>
				<c path="Array"><c path="ch2.AnimationFrame"/></c>
			</f>
			<haxe_doc>Create an array of frames with fixed framerate. Will produce same playback result as h2d.Anim.</haxe_doc>
		</fromFixedFramerate>
		<fromDurationList public="1" set="method" line="94" static="1">
			<f a="tiles:durations">
				<c path="Array"><c path="h2d.Tile"/></c>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><c path="ch2.AnimationFrame"/></c>
			</f>
			<haxe_doc>Create an array from list of tiles and their durations. Both arrays should be the same length.</haxe_doc>
		</fromDurationList>
		<getDuration public="1" set="method" line="106" static="1">
			<f a="frames">
				<c path="Array"><c path="ch2.AnimationFrame"/></c>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns total duration of animation frames.</haxe_doc>
		</getDuration>
		<frames public="1" set="null">
			<c path="Array"><c path="ch2.AnimationFrame"/></c>
			<haxe_doc>The current animation, as a list of AnimationFrame instances to display.</haxe_doc>
		</frames>
		<currentFrame public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<haxe_doc>The current frame the animation is currently playing. Always in `[0,frames.length]` range</haxe_doc>
		</currentFrame>
		<pause public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>Setting pause will pause the animation, preventing any automatic change to currentFrame.</haxe_doc>
		</pause>
		<loop public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>Disabling loop will stop the animation at the last frame (default : true)</haxe_doc>
		</loop>
		<speed public="1" expr="1.">
			<x path="Float"/>
			<meta><m n=":value"><e>1.</e></m></meta>
			<haxe_doc>Playback speed multiplier for animation (default : 1)</haxe_doc>
		</speed>
		<curFrame><x path="Int"/></curFrame>
		<elapsedTime><x path="Float"/></elapsedTime>
		<playWhenHidden public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>Enables playback of animation even when `visible = false`. (default: false)
		Does not check for nested visibility.</haxe_doc>
		</playWhenHidden>
		<width public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>Total width of the animation. Accounts for all frames.</haxe_doc>
		</width>
		<height public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>Total height of the animation. Accounts for all frames.</haxe_doc>
		</height>
		<duration public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>Duration of current animation. Affected by `speed` variable, for duration of frame use static `getDuration` function.</haxe_doc>
		</duration>
		<play public="1" set="method" line="175">
			<f a="frames:?atFrame" v=":0">
				<c path="Array"><c path="ch2.AnimationFrame"/></c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ atFrame : 0 }</e></m></meta>
			<haxe_doc>Change the currently playing animation and unset the pause if it was set.</haxe_doc>
		</play>
		<palyAt public="1" set="method" line="184">
			<f a="?frame" v="0">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ frame : 0 }</e></m></meta>
			<haxe_doc>Starts animation playback at specified frame.</haxe_doc>
		</palyAt>
		<onAnimEnd public="1" set="dynamic" line="194">
			<f a=""><x path="Void"/></f>
			<haxe_doc>onAnimEnd is automatically called each time the animation will reach past the last frame.
		If loop is true, it is called everytime the animation loops.
		If loop is false, it is called once when the animation reachs `currentFrame == frames.length`</haxe_doc>
		</onAnimEnd>
		<onEvent public="1" set="dynamic" line="201">
			<f a="name">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Triggers when frame contains `event` string</haxe_doc>
		</onEvent>
		<getFrame public="1" get="inline" set="null" line="208">
			<f a=""><c path="ch2.AnimationFrame"/></f>
			<haxe_doc>Returns current AnimationFrame being played.</haxe_doc>
		</getFrame>
		<getTile public="1" set="method" line="215">
			<f a=""><c path="h2d.Tile"/></f>
			<haxe_doc>Returns current h2d.Tile being played.</haxe_doc>
		</getTile>
		<get_currentFrame get="inline" set="null" line="220"><f a=""><x path="Int"/></f></get_currentFrame>
		<set_currentFrame set="method" line="224"><f a="frame">
	<x path="Int"/>
	<x path="Int"/>
</f></set_currentFrame>
		<get_width get="inline" set="null" line="231"><f a=""><x path="Int"/></f></get_width>
		<get_height get="inline" set="null" line="237"><f a=""><x path="Int"/></f></get_height>
		<get_duration get="inline" set="null" line="243"><f a=""><x path="Float"/></f></get_duration>
		<getBoundsRec set="method" line="247" override="1"><f a="relativeTo:out:forSize">
	<c path="h2d.Object"/>
	<c path="h2d.col.Bounds"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></getBoundsRec>
		<sync set="method" line="253" override="1"><f a="ctx">
	<c path="h2d.RenderContext"/>
	<x path="Void"/>
</f></sync>
		<_onAnimEnd set="method" line="322"><f a=""><x path="Void"/></f></_onAnimEnd>
		<draw set="method" line="327" override="1"><f a="ctx">
	<c path="h2d.RenderContext"/>
	<x path="Void"/>
</f></draw>
		<new public="1" set="method" line="165">
			<f a="?frames:?parent">
				<c path="Array"><c path="ch2.AnimationFrame"/></c>
				<c path="h2d.Object"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Create a new animation with the specified frames and parent object</haxe_doc>
		</new>
		<haxe_doc>ch2.Animation is used to display a parametrized sequence of bitmap tiles on the screen.
	This is more powerful version than h2d.Anim, but requires more setup.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="ch2.AnimationExt" params="" file="./ch2/AnimationExt.hx">
		<extends path="ch2.Animation"/>
		<animations public="1" expr="new Map()">
			<t path="Map">
				<c path="String"/>
				<c path="ch2.AnimationDescriptor"/>
			</t>
			<meta><m n=":value"><e>new Map()</e></m></meta>
			<haxe_doc>List of named animation between which AnimationExt can switch.</haxe_doc>
		</animations>
		<current><c path="ch2.AnimationDescriptor"/></current>
		<currentAnimation public="1" set="null">
			<c path="String"/>
			<haxe_doc>Current animation name.</haxe_doc>
		</currentAnimation>
		<commands expr="new List()">
			<t path="List"><e path="ch2.AnimationCommand"/></t>
			<meta><m n=":value"><e>new List()</e></m></meta>
		</commands>
		<wait expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</wait>
		<addCommand public="1" set="method" line="30">
			<f a="cmd">
				<e path="ch2.AnimationCommand"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds new command to the end of command buffer.</haxe_doc>
		</addCommand>
		<resetCommands public="1" set="method" line="38">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Clears command buffer.</haxe_doc>
		</resetCommands>
		<playAnim public="1" set="method" line="47">
			<f a="name:?atFrame">
				<c path="String"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Plays animation with specified name, and optionally at specific frame.</haxe_doc>
		</playAnim>
		<durationOf public="1" set="method" line="64">
			<f a="anim">
				<c path="String"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns duration of specified animation. Uses either animation descriptor speed, or current Animation speed value.</haxe_doc>
		</durationOf>
		<sync set="method" line="74" override="1"><f a="ctx">
	<c path="h2d.RenderContext"/>
	<x path="Void"/>
</f></sync>
		<_onAnimEnd set="method" line="86" override="1"><f a=""><x path="Void"/></f></_onAnimEnd>
		<nextCommand set="method" line="101"><f a=""><x path="Void"/></f></nextCommand>
		<executeCommand set="method" line="110"><f a="cmd">
	<e path="ch2.AnimationCommand"/>
	<x path="Bool"/>
</f></executeCommand>
		<new public="1" set="method" line="10"><f a="?frames:?parent">
	<c path="Array"><c path="ch2.AnimationFrame"/></c>
	<c path="h2d.Object"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Extended version of Animation with named animation storage and primitive command buffer.
  Command buffer triggers next command either when delay timeout runs out or animation reaches it's end.</haxe_doc>
	</class>
	<class path="ch2.AnimationDescriptor" params="" file="./ch2/AnimationExt.hx" module="ch2.AnimationExt">
		<frames public="1">
			<c path="Array"><c path="ch2.AnimationFrame"/></c>
			<haxe_doc>List of frames used in animation.</haxe_doc>
		</frames>
		<loop public="1">
			<x path="Bool"/>
			<haxe_doc>Should this animation loop?</haxe_doc>
		</loop>
		<speed public="1">
			<x path="Null"><x path="Float"/></x>
			<haxe_doc>If not null, will set Animation.speed value to this value.
    Note: Does not reset to old value when switches to another animation.</haxe_doc>
		</speed>
		<next public="1">
			<c path="String"/>
			<haxe_doc>If present, will switch to specified animation name when this animation end.
    In that case, it will not trigger next command from buffer.</haxe_doc>
		</next>
		<nextFrame public="1" expr="null">
			<x path="Null"><x path="Int"/></x>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>Optional frame at which next animation should start.</haxe_doc>
		</nextFrame>
		<new public="1" set="method" line="185">
			<f a="frames">
				<c path="Array"><c path="ch2.AnimationFrame"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates new animation descriptor with specified frames.</haxe_doc>
		</new>
		<haxe_doc>An animation descriptor used for AnimationExt.
  Describes general information about animation.</haxe_doc>
	</class>
	<enum path="ch2.AnimationCommand" params="" file="./ch2/AnimationExt.hx" module="ch2.AnimationExt">
		<Delay a="time">
			<x path="Float"/>
			<haxe_doc>Delays execution of next command by specified time in seconds.</haxe_doc>
		</Delay>
		<SwitchTo a="name:frame">
			<c path="String"/>
			<x path="Null"><x path="Int"/></x>
			<haxe_doc>Switches to an animation with specified name and plays it at specified frame.
    If frame value is `null` - animation frame will not reset when switching to same animation.
    Executes next command immediately if animation not found.</haxe_doc>
		</SwitchTo>
		<Jump a="frame">
			<x path="Int"/>
			<haxe_doc>Jumps to specified frame in current animation.</haxe_doc>
		</Jump>
		<Pause><haxe_doc>Pauses playback.
    Executes next command immediately.</haxe_doc></Pause>
		<Reset><haxe_doc>Resets animation. Equivalent to Jump(0).</haxe_doc></Reset>
		<SetLoop a="loop">
			<x path="Bool"/>
			<haxe_doc>Sets animation looping flag.
    Executes next command immediately.</haxe_doc>
		</SetLoop>
		<SetSpeed a="speed">
			<x path="Float"/>
			<haxe_doc>Sets animation speed value.
    Executes next command immediately.</haxe_doc>
		</SetSpeed>
		<Event a="name">
			<c path="String"/>
			<haxe_doc>Calls `onEvent` with specified event name.
    Executes next command immediately.</haxe_doc>
		</Event>
		<Chain a="commands">
			<c path="Array"><e path="ch2.AnimationCommand"/></c>
			<haxe_doc>Executes a chain of command ignoring if it should trigger next command or delay it.
    Delay command does not have an effect on Chain execution, but sets the animation delay.
    Executes next command immediately if animation is paused.</haxe_doc>
		</Chain>
		<haxe_doc>Type of animation command for AnimationExt command buffer.</haxe_doc>
	</enum>
	<class path="h2d.TileGroup" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h2d/TileGroup.hx">
		<extends path="h2d.Drawable"/>
		<content><c path="h2d.TileLayerContent"/></content>
		<curColor><c path="h3d.Vector"/></curColor>
		<tile public="1"><c path="h2d.Tile"/></tile>
		<rangeMin public="1"><x path="Int"/></rangeMin>
		<rangeMax public="1"><x path="Int"/></rangeMax>
		<getBoundsRec set="method" line="404" override="1"><f a="relativeTo:out:forSize">
	<c path="h2d.Object"/>
	<c path="h2d.col.Bounds"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></getBoundsRec>
		<clear public="1" set="method" line="409"><f a=""><x path="Void"/></f></clear>
		<invalidate public="1" set="method" line="417">
			<f a=""><x path="Void"/></f>
			<haxe_doc>If you want to add tiles after the GPU memory has been allocated (when the tilegroup with sync/displayed),
		make sure to call invalidate() first to force a refresh of your data.</haxe_doc>
		</invalidate>
		<count public="1" set="method" line="424">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the number of tiles added to the group</haxe_doc>
		</count>
		<onRemove set="method" line="428" override="1"><f a=""><x path="Void"/></f></onRemove>
		<setDefaultColor public="1" set="method" line="433">
			<f a="rgb:?alpha" v=":1.0">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ alpha : 1.0 }</e></m></meta>
		</setDefaultColor>
		<add public="1" get="inline" set="null" line="440"><f a="x:y:t">
	<x path="Float"/>
	<x path="Float"/>
	<c path="h2d.Tile"/>
	<x path="Void"/>
</f></add>
		<addColor public="1" get="inline" set="null" line="444"><f a="x:y:r:g:b:a:t">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="h2d.Tile"/>
	<x path="Void"/>
</f></addColor>
		<addAlpha public="1" get="inline" set="null" line="448"><f a="x:y:a:t">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="h2d.Tile"/>
	<x path="Void"/>
</f></addAlpha>
		<addTransform public="1" get="inline" set="null" line="452"><f a="x:y:sx:sy:r:t">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="h2d.Tile"/>
	<x path="Void"/>
</f></addTransform>
		<draw set="method" line="456" override="1"><f a="ctx">
	<c path="h2d.RenderContext"/>
	<x path="Void"/>
</f></draw>
		<sync set="method" line="461" override="1"><f a="ctx">
	<c path="h2d.RenderContext"/>
	<x path="Void"/>
</f></sync>
		<drawWith set="method" line="470">
			<f a="ctx:obj">
				<c path="h2d.RenderContext"/>
				<c path="h2d.Drawable"/>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>h2d</e></m></meta>
		</drawWith>
		<new public="1" set="method" line="396"><f a="t:?parent">
	<c path="h2d.Tile"/>
	<c path="h2d.Object"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="ch2.ScaleGridExt" params="" file="./ch2/ScaleGridExt.hx">
		<extends path="h2d.TileGroup"/>
		<borderTop public="1" set="accessor">
			<x path="Int"/>
			<haxe_doc>Height of the top border.</haxe_doc>
		</borderTop>
		<borderBottom public="1" set="accessor">
			<x path="Int"/>
			<haxe_doc>Height of the bottom border.</haxe_doc>
		</borderBottom>
		<borderLeft public="1" set="accessor">
			<x path="Int"/>
			<haxe_doc>Width of the left border.</haxe_doc>
		</borderLeft>
		<borderRight public="1" set="accessor">
			<x path="Int"/>
			<haxe_doc>Height of the right border.</haxe_doc>
		</borderRight>
		<width public="1" set="accessor">
			<x path="Int"/>
			<haxe_doc>Width of the ScaleGrid.</haxe_doc>
		</width>
		<height public="1" set="accessor">
			<x path="Int"/>
			<haxe_doc>Height of the ScaleGrid.</haxe_doc>
		</height>
		<tileBorders public="1" set="accessor">
			<x path="Bool"/>
			<haxe_doc>If true, borders will be tiled instead of stretched.</haxe_doc>
		</tileBorders>
		<tileCenter public="1" set="accessor">
			<x path="Bool"/>
			<haxe_doc>If true, central part will be tiled instead of stretched.</haxe_doc>
		</tileCenter>
		<setSize public="1" set="method" line="55"><f a="w:h">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setSize>
		<set_tileBorders set="method" line="61"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_tileBorders>
		<set_tileCenter set="method" line="67"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_tileCenter>
		<set_width set="method" line="73"><f a="w">
	<x path="Int"/>
	<x path="Int"/>
</f></set_width>
		<set_height set="method" line="79"><f a="h">
	<x path="Int"/>
	<x path="Int"/>
</f></set_height>
		<set_borderTop set="method" line="85"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></set_borderTop>
		<set_borderBottom set="method" line="91"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></set_borderBottom>
		<set_borderLeft set="method" line="97"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></set_borderLeft>
		<set_borderRight set="method" line="103"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></set_borderRight>
		<getBoundsRec set="method" line="109" override="1"><f a="relativeTo:out:forSize">
	<c path="h2d.Object"/>
	<c path="h2d.col.Bounds"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></getBoundsRec>
		<updateContent set="method" line="114"><f a=""><x path="Void"/></f></updateContent>
		<sync set="method" line="225" override="1"><f a="ctx">
	<c path="h2d.RenderContext"/>
	<x path="Void"/>
</f></sync>
		<new public="1" set="method" line="45"><f a="tile:borderT:borderB:borderL:borderR:?parent">
	<c path="h2d.Tile"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="h2d.Object"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Extended ScaleGrid: Allows for tiling of center and borders have individual sizes.</haxe_doc>
	</class>
	<class path="h2d.SpriteBatch" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h2d/SpriteBatch.hx">
		<extends path="h2d.Drawable"/>
		<tile public="1"><c path="h2d.Tile"/></tile>
		<hasRotationScale public="1"><x path="Bool"/></hasRotationScale>
		<hasUpdate public="1"><x path="Bool"/></hasUpdate>
		<first><c path="h2d.BatchElement"/></first>
		<last><c path="h2d.BatchElement"/></last>
		<tmpBuf><x path="hxd.FloatBuffer"/></tmpBuf>
		<buffer><c path="h3d.Buffer"/></buffer>
		<bufferVertices><x path="Int"/></bufferVertices>
		<add public="1" set="method" line="105">
			<f a="e:?before" v=":false">
				<c path="h2d.BatchElement"/>
				<x path="Bool"/>
				<c path="h2d.BatchElement"/>
			</f>
			<meta><m n=":value"><e>{ before : false }</e></m></meta>
		</add>
		<clear public="1" set="method" line="124"><f a=""><x path="Void"/></f></clear>
		<alloc public="1" set="method" line="129"><f a="t">
	<c path="h2d.Tile"/>
	<c path="h2d.BatchElement"/>
</f></alloc>
		<delete set="method" line="134">
			<f a="e">
				<c path="h2d.BatchElement"/>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>h2d.BatchElement</e></m></meta>
		</delete>
		<sync set="method" line="148" override="1"><f a="ctx">
	<c path="h2d.RenderContext"/>
	<x path="Void"/>
</f></sync>
		<getBoundsRec set="method" line="161" override="1"><f a="relativeTo:out:forSize">
	<c path="h2d.Object"/>
	<c path="h2d.col.Bounds"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></getBoundsRec>
		<flush set="method" line="196"><f a=""><x path="Void"/></f></flush>
		<draw set="method" line="305" override="1"><f a="ctx">
	<c path="h2d.RenderContext"/>
	<x path="Void"/>
</f></draw>
		<drawWith set="method" line="310">
			<f a="ctx:obj">
				<c path="h2d.RenderContext"/>
				<c path="h2d.Drawable"/>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>h2d</e></m></meta>
		</drawWith>
		<isEmpty public="1" get="inline" set="null" line="316"><f a=""><x path="Bool"/></f></isEmpty>
		<getElements public="1" get="inline" set="null" line="320"><f a=""><c path="h2d._SpriteBatch.ElementsIterator"/></f></getElements>
		<onRemove set="method" line="324" override="1"><f a=""><x path="Void"/></f></onRemove>
		<new public="1" set="method" line="100"><f a="t:?parent">
	<c path="h2d.Tile"/>
	<c path="h2d.Object"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="ch2.SpriteBatchExt" params="" file="./ch2/SpriteBatchExt.hx">
		<extends path="h2d.SpriteBatch"/>
		<noTexture static="1">
			<c path="h3d.mat.Texture"/>
			<meta><m n=":allow"><e>ch2.TileGroupExt</e></m></meta>
		</noTexture>
		<textureShader><c path="ch3.shader.MultiTexture"/></textureShader>
		<textureIndex><c path="Array"><c path="ch2.TextureRef"/></c></textureIndex>
		<add public="1" set="method" line="37" override="1">
			<f a="e:?before" v=":false">
				<c path="h2d.BatchElement"/>
				<x path="Bool"/>
				<c path="h2d.BatchElement"/>
			</f>
			<meta><m n=":value"><e>{ before : false }</e></m></meta>
		</add>
		<clear public="1" set="method" line="72" override="1"><f a=""><x path="Void"/></f></clear>
		<delete set="method" line="86" override="1"><f a="e">
	<c path="h2d.BatchElement"/>
	<x path="Void"/>
</f></delete>
		<repopulate set="method" line="107"><f a=""><x path="Void"/></f></repopulate>
		<flush set="method" line="135" override="1"><f a=""><x path="Void"/></f></flush>
		<new public="1" set="method" line="21"><f a="?parent">
	<c path="h2d.Object"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Experimental SpriteBatch with support of up to 8 different textures.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>h2d.Tile</e></m>
		</meta>
	</class>
	<class path="ch2.TextureRef" params="" file="./ch2/SpriteBatchExt.hx" module="ch2.SpriteBatchExt">
		<texture public="1"><c path="h3d.mat.Texture"/></texture>
		<tile public="1"><c path="h2d.Tile"/></tile>
		<refCount public="1"><x path="Int"/></refCount>
		<new public="1" set="method" line="248">
			<f a="texture:tile:refCount">
				<c path="h3d.mat.Texture"/>
				<c path="h2d.Tile"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":compilerGenerated"/></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="hxd.impl._Serializable.NoSerializeSupport" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/impl/Serializable.hx" private="1" module="hxd.impl.Serializable" interface="1"/>
	<class path="h3d.prim.Primitive" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/prim/Primitive.hx">
		<implements path="hxd.impl._Serializable.NoSerializeSupport"/>
		<buffer public="1">
			<c path="h3d.Buffer"/>
			<haxe_doc>The primitive vertex buffer, holding its vertexes data.</haxe_doc>
		</buffer>
		<indexes public="1">
			<c path="h3d.Indexes"/>
			<haxe_doc>The primitive indexes buffer, holding its triangles indices.</haxe_doc>
		</indexes>
		<refCount public="1" set="null" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>Current amount of references to this Primitive.  
		Use `incref` and `decref` methods to affect this value. If it reaches 0, it will be atuomatically disposed.</haxe_doc>
		</refCount>
		<triCount public="1" set="method" line="28">
			<f a=""><x path="Int"/></f>
			<haxe_doc>The number of triangles the primitive has.</haxe_doc>
		</triCount>
		<vertexCount public="1" set="method" line="35">
			<f a=""><x path="Int"/></f>
			<haxe_doc>The number of vertexes the primitive has.</haxe_doc>
		</vertexCount>
		<getCollider public="1" set="method" line="42">
			<f a=""><c path="h3d.col.Collider"/></f>
			<haxe_doc>Return a local collider for the primitive</haxe_doc>
		</getCollider>
		<getBounds public="1" set="method" line="50">
			<f a=""><c path="h3d.col.Bounds"/></f>
			<haxe_doc>Return the bounds for the primitive</haxe_doc>
		</getBounds>
		<incref public="1" set="method" line="58">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Increase reference count of the Primitive.</haxe_doc>
		</incref>
		<decref public="1" set="method" line="67">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Decrease reference count of the Primitive.  
		If recount reaches zero, Primitive is automatically disposed when last referencing mesh is removed from scene.</haxe_doc>
		</decref>
		<alloc public="1" set="method" line="79">
			<f a="engine">
				<c path="h3d.Engine"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Allocate the primitive on GPU. Used for internal usage.</haxe_doc>
		</alloc>
		<selectMaterial public="1" set="method" line="86">
			<f a="material">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Select the specified sub material before drawin. Used for internal usage.</haxe_doc>
		</selectMaterial>
		<buildNormalsDisplay public="1" set="method" line="89">
			<f a=""><c path="h3d.prim.Primitive"/></f>
			<meta><m n=":noCompletion"/></meta>
		</buildNormalsDisplay>
		<render public="1" set="method" line="97">
			<f a="engine">
				<c path="h3d.Engine"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Render the primitive. Used for internal usage.</haxe_doc>
		</render>
		<dispose public="1" set="method" line="111">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Dispose the primitive, freeing the GPU memory it uses.</haxe_doc>
		</dispose>
		<toString public="1" set="method" line="125">
			<f a=""><x path="Null"><c path="String"/></x></f>
			<haxe_doc>Return the primitive type.</haxe_doc>
		</toString>
		<new public="1" set="method" line="7">
			<f a=""><x path="Void"/></f>
			<meta><m n=":compilerGenerated"/></meta>
		</new>
		<haxe_doc>h3d.prim.Primitive is the base class for all 3D primitives.
	You can't create an instance of it and need to use one of its subclasses.</haxe_doc>
	</class>
	<class path="ch2._TileGroupExt.TileLayerContentExt" params="" file="./ch2/TileGroupExt.hx" private="1" module="ch2.TileGroupExt">
		<extends path="h3d.prim.Primitive"/>
		<tmp><x path="hxd.FloatBuffer"/></tmp>
		<xMin public="1"><x path="Float"/></xMin>
		<yMin public="1"><x path="Float"/></yMin>
		<xMax public="1"><x path="Float"/></xMax>
		<yMax public="1"><x path="Float"/></yMax>
		<clear public="1" set="method" line="26"><f a=""><x path="Void"/></f></clear>
		<isEmpty public="1" set="method" line="36"><f a=""><x path="Bool"/></f></isEmpty>
		<triCount public="1" set="method" line="40" override="1"><f a=""><x path="Int"/></f></triCount>
		<addColor public="1" get="inline" set="null" line="44"><f a="x:y:color:t:index">
	<x path="Float"/>
	<x path="Float"/>
	<c path="h3d.Vector"/>
	<c path="h2d.Tile"/>
	<x path="Int"/>
	<x path="Void"/>
</f></addColor>
		<add public="1" set="method" line="48"><f a="x:y:r:g:b:a:t:index">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="h2d.Tile"/>
	<x path="Int"/>
	<x path="Void"/>
</f></add>
		<addTransform public="1" set="method" line="89"><f a="x:y:sx:sy:r:c:t:index">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="h3d.Vector"/>
	<c path="h2d.Tile"/>
	<x path="Int"/>
	<x path="Void"/>
</f></addTransform>
		<addPoint public="1" set="method" line="155"><f a="x:y:color">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></addPoint>
		<insertColor get="inline" set="null" line="167"><f a="c:index">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></insertColor>
		<rectColor public="1" get="inline" set="null" line="175">
			<f a="x:y:w:h:color:?index" v=":::::0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ index : 0 }</e></m></meta>
		</rectColor>
		<rectGradient public="1" get="inline" set="null" line="205">
			<f a="x:y:w:h:ctl:ctr:cbl:cbr:?index" v="::::::::0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ index : 0 }</e></m></meta>
		</rectGradient>
		<fillArc public="1" get="inline" set="null" line="235"><f a="x:y:ray:c:start:end">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></fillArc>
		<fillCircle public="1" get="inline" set="null" line="269"><f a="x:y:radius:c">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></fillCircle>
		<circle public="1" get="inline" set="null" line="301"><f a="x:y:ray:size:c">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></circle>
		<arc public="1" get="inline" set="null" line="330"><f a="x:y:ray:size:start:end:c">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></arc>
		<alloc public="1" set="method" line="374" override="1"><f a="engine">
	<c path="h3d.Engine"/>
	<x path="Void"/>
</f></alloc>
		<flush public="1" get="inline" set="null" line="380"><f a=""><x path="Void"/></f></flush>
		<doRender public="1" set="method" line="384"><f a="engine:min:len">
	<c path="h3d.Engine"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></doRender>
		<new public="1" set="method" line="22"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>h2d.Tile</e></m>
		</meta>
	</class>
	<class path="ch2.TileGroupExt" params="" file="./ch2/TileGroupExt.hx">
		<extends path="h2d.Drawable"/>
		<content><c path="ch2._TileGroupExt.TileLayerContentExt"/></content>
		<curColor><c path="h3d.Vector"/></curColor>
		<rangeMin public="1"><x path="Int"/></rangeMin>
		<rangeMax public="1"><x path="Int"/></rangeMax>
		<textureShader><c path="ch3.shader.MultiTexture"/></textureShader>
		<textureIndex><c path="Array"><c path="h3d.mat.Texture"/></c></textureIndex>
		<getBoundsRec set="method" line="422" override="1"><f a="relativeTo:out:forSize">
	<c path="h2d.Object"/>
	<c path="h2d.col.Bounds"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></getBoundsRec>
		<clear public="1" set="method" line="427"><f a=""><x path="Void"/></f></clear>
		<invalidate public="1" set="method" line="443">
			<f a=""><x path="Void"/></f>
			<haxe_doc>If you want to add tiles after the GPU memory has been allocated (when the tilegroup with sync/displayed),
		make sure to call invalidate() first to force a refresh of your data.</haxe_doc>
		</invalidate>
		<count public="1" set="method" line="450">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the number of tiles added to the group</haxe_doc>
		</count>
		<onRemove set="method" line="454" override="1"><f a=""><x path="Void"/></f></onRemove>
		<setDefaultColor public="1" set="method" line="459">
			<f a="rgb:?alpha" v=":1.0">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ alpha : 1.0 }</e></m></meta>
		</setDefaultColor>
		<add public="1" get="inline" set="null" line="466"><f a="x:y:t">
	<x path="Float"/>
	<x path="Float"/>
	<c path="h2d.Tile"/>
	<x path="Void"/>
</f></add>
		<addColor public="1" get="inline" set="null" line="470"><f a="x:y:r:g:b:a:t">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="h2d.Tile"/>
	<x path="Void"/>
</f></addColor>
		<addAlpha public="1" get="inline" set="null" line="474"><f a="x:y:a:t">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="h2d.Tile"/>
	<x path="Void"/>
</f></addAlpha>
		<addTransform public="1" get="inline" set="null" line="478"><f a="x:y:sx:sy:r:t">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="h2d.Tile"/>
	<x path="Void"/>
</f></addTransform>
		<addRef set="method" line="482"><f a="t">
	<c path="h2d.Tile"/>
	<x path="Int"/>
</f></addRef>
		<draw set="method" line="512" override="1"><f a="ctx">
	<c path="h2d.RenderContext"/>
	<x path="Void"/>
</f></draw>
		<sync set="method" line="517" override="1"><f a="ctx">
	<c path="h2d.RenderContext"/>
	<x path="Void"/>
</f></sync>
		<drawWith set="method" line="526">
			<f a="ctx:obj">
				<c path="h2d.RenderContext"/>
				<c path="h2d.Drawable"/>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>h2d</e></m></meta>
		</drawWith>
		<new public="1" set="method" line="403"><f a="?parent">
	<c path="h2d.Object"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="ch2.Tilemap" params="" file="./ch2/Tilemap.hx">
		<extends path="h2d.Drawable"/>
		<width public="1" set="null"><x path="Int"/></width>
		<height public="1" set="null"><x path="Int"/></height>
		<tileWidth public="1" set="null"><x path="Int"/></tileWidth>
		<tileHeight public="1" set="null"><x path="Int"/></tileHeight>
		<batches><c path="Array"><c path="ch2.TilesetDisplay"/></c></batches>
		<tiles><c path="Array"><x path="Int"/></c></tiles>
		<tileCount><x path="Int"/></tileCount>
		<tilesets><c path="Array"><c path="ch2.Tileset"/></c></tilesets>
		<add public="1" set="method" line="39"><f a="x:y:gid">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></add>
		<getBoundsRec set="method" line="62" override="1"><f a="relativeTo:out:forSize">
	<c path="h2d.Object"/>
	<c path="h2d.col.Bounds"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></getBoundsRec>
		<sync set="method" line="68" override="1"><f a="ctx">
	<c path="h2d.RenderContext"/>
	<x path="Void"/>
</f></sync>
		<draw set="method" line="74" override="1"><f a="ctx">
	<c path="h2d.RenderContext"/>
	<x path="Void"/>
</f></draw>
		<new public="1" set="method" line="23"><f a="width:height:tileWidth:tileHeight:tilesets:?parent">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><c path="ch2.Tileset"/></c>
	<c path="h2d.Object"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="ch2.TilesetDisplay" params="" file="./ch2/Tilemap.hx" module="ch2.Tilemap">
		<tset><c path="ch2.Tileset"/></tset>
		<tile public="1"><c path="h2d.Tile"/></tile>
		<tmpBuf><x path="hxd.FloatBuffer"/></tmpBuf>
		<buffer><c path="h3d.Buffer"/></buffer>
		<bufferVertices><x path="Int"/></bufferVertices>
		<tileIndex><c path="Array"><x path="Int"/></c></tileIndex>
		<tileIds><c path="Array"><x path="Int"/></c></tileIds>
		<tileX><c path="Array"><x path="Float"/></c></tileX>
		<tileY><c path="Array"><x path="Float"/></c></tileY>
		<dirty><x path="Bool"/></dirty>
		<remove public="1" set="method" line="106"><f a="index">
	<x path="Int"/>
	<x path="Void"/>
</f></remove>
		<set public="1" set="method" line="116"><f a="index:tile:x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></set>
		<sync public="1" set="method" line="134"><f a=""><x path="Void"/></f></sync>
		<flush set="method" line="139"><f a=""><x path="Void"/></f></flush>
		<render public="1" set="method" line="197"><f a="ctx:obj">
	<c path="h2d.RenderContext"/>
	<c path="h2d.Drawable"/>
	<x path="Void"/>
</f></render>
		<dispose public="1" set="method" line="204"><f a=""><x path="Void"/></f></dispose>
		<new public="1" set="method" line="97"><f a="tileset">
	<c path="ch2.Tileset"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>h2d.Tile</e></m>
		</meta>
	</class>
	<class path="ch2.Tileset" params="" file="./ch2/Tilemap.hx" module="ch2.Tilemap">
		<firstId public="1"><x path="Int"/></firstId>
		<source public="1"><c path="h2d.Tile"/></source>
		<tiles public="1"><c path="Array"><c path="h2d.Tile"/></c></tiles>
		<new public="1" set="method" line="221">
			<f a="source:firstId:tileWidth:tileHeight:?spacing:?margin:?dx:?dy" v="::::0:0:0:0">
				<c path="h2d.Tile"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ dy : 0, dx : 0, margin : 0, spacing : 0 }</e></m></meta>
		</new>
	</class>
	<class path="ch2.tiled.TilemapLayer" params="" file="./ch2/tiled/TilemapLayer.hx">
		<extends path="ch2.TileGroupExt"/>
		<map><c path="cherry.res.TiledMapData"/></map>
		<layer><c path="format.tmx.TmxTileLayer"/></layer>
		<gidAt public="1" set="method" line="50"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></gidAt>
		<addTile public="1" set="method" line="55"><f a="tx:ty:ox:oy:tile">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="format.tmx.TmxTile"/>
	<x path="Void"/>
</f></addTile>
		<new public="1" set="method" line="15"><f a="map:layer:?parent">
	<c path="cherry.res.TiledMapData"/>
	<c path="format.tmx.TmxTileLayer"/>
	<c path="h2d.Object"/>
	<x path="Void"/>
</f></new>
	</class>
	<enum path="ch3.prim.PlaneFront" params="" file="./ch3/prim/PlanePrim.hx" module="ch3.prim.PlanePrim">
		<X/>
		<Y/>
		<Z/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="ch3.prim.PlanePrim" params="" file="./ch3/prim/PlanePrim.hx">
		<extends path="h3d.prim.Primitive"/>
		<width public="1" set="null"><x path="Float"/></width>
		<height public="1" set="null"><x path="Float"/></height>
		<ox public="1" set="null"><x path="Float"/></ox>
		<oy public="1" set="null"><x path="Float"/></oy>
		<u0 public="1" set="null"><x path="Float"/></u0>
		<u1 public="1" set="null"><x path="Float"/></u1>
		<v0 public="1" set="null"><x path="Float"/></v0>
		<v1 public="1" set="null"><x path="Float"/></v1>
		<front public="1" set="null"><e path="ch3.prim.PlaneFront"/></front>
		<buf><x path="hxd.FloatBuffer"/></buf>
		<bounds><c path="h3d.col.Bounds"/></bounds>
		<setOrigin public="1" set="method" line="45"><f a="ox:oy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setOrigin>
		<setSize public="1" set="method" line="55"><f a="width:height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setSize>
		<setUV public="1" set="method" line="65"><f a="u0:v0:u1:v1">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setUV>
		<setSizeUV public="1" set="method" line="77"><f a="width:height:u0:v0:u1:v1">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setSizeUV>
		<set public="1" set="method" line="91"><f a="width:height:u0:v0:u1:v1:ox:oy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></set>
		<setFront public="1" set="method" line="104"><f a="front">
	<e path="ch3.prim.PlaneFront"/>
	<x path="Void"/>
</f></setFront>
		<invalidate set="method" line="110"><f a=""><x path="Void"/></f></invalidate>
		<triCount public="1" set="method" line="140" override="1"><f a=""><x path="Int"/></f></triCount>
		<vertexCount public="1" set="method" line="145" override="1"><f a=""><x path="Int"/></f></vertexCount>
		<alloc public="1" set="method" line="150" override="1"><f a="engine">
	<c path="h3d.Engine"/>
	<x path="Void"/>
</f></alloc>
		<refill set="method" line="157"><f a=""><x path="Void"/></f></refill>
		<render public="1" set="method" line="212" override="1"><f a="engine">
	<c path="h3d.Engine"/>
	<x path="Void"/>
</f></render>
		<getBounds public="1" set="method" line="217" override="1"><f a=""><c path="h3d.col.Bounds"/></f></getBounds>
		<new public="1" set="method" line="31">
			<f a="w:h:?ox:?oy:?u0:?v0:?u1:?v1:?front" v="::0:0:0:0:1:1:Z">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<e path="ch3.prim.PlaneFront"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ front : Z, v1 : 1, u1 : 1, v0 : 0, u0 : 0, oy : 0, ox : 0 }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.Matrix" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/Matrix.hx">
		<tmp expr="new Matrix()" line="15" static="1">
			<c path="h3d.Matrix"/>
			<meta><m n=":value"><e>new Matrix()</e></m></meta>
		</tmp>
		<lumR get="inline" set="null" expr="0.212671" line="572" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.212671</e></m></meta>
		</lumR>
		<lumG get="inline" set="null" expr="0.71516" line="573" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.71516</e></m></meta>
		</lumG>
		<lumB get="inline" set="null" expr="0.072169" line="574" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.072169</e></m></meta>
		</lumB>
		<SQ13 get="inline" set="null" expr="0.57735026918962576450914878050196" line="576" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.57735026918962576450914878050196</e></m></meta>
		</SQ13>
		<I public="1" set="method" line="737" static="1"><f a=""><c path="h3d.Matrix"/></f></I>
		<L public="1" set="method" line="743" static="1"><f a="a">
	<c path="Array"><x path="Float"/></c>
	<c path="h3d.Matrix"/>
</f></L>
		<T public="1" set="method" line="749" static="1">
			<f a="?x:?y:?z" v="0.:0.:0.">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="h3d.Matrix"/>
			</f>
			<meta><m n=":value"><e>{ z : 0., y : 0., x : 0. }</e></m></meta>
		</T>
		<R public="1" set="method" line="755" static="1"><f a="x:y:z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="h3d.Matrix"/>
</f></R>
		<S public="1" set="method" line="761" static="1">
			<f a="?x:?y:?z" v="1.:1.:1.0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="h3d.Matrix"/>
			</f>
			<meta><m n=":value"><e>{ z : 1.0, y : 1., x : 1. }</e></m></meta>
		</S>
		<lookAtX public="1" set="method" line="770" static="1">
			<f a="dir:?up:?m">
				<c path="h3d.Vector"/>
				<c path="h3d.Vector"/>
				<c path="h3d.Matrix"/>
				<x path="Null"><c path="h3d.Matrix"/></x>
			</f>
			<haxe_doc>Build a rotation Matrix so the X axis will look at the given direction, and the Z axis will be the Up vector ([0,0,1] by default)</haxe_doc>
		</lookAtX>
		<_11 public="1"><x path="Float"/></_11>
		<_12 public="1"><x path="Float"/></_12>
		<_13 public="1"><x path="Float"/></_13>
		<_14 public="1"><x path="Float"/></_14>
		<_21 public="1"><x path="Float"/></_21>
		<_22 public="1"><x path="Float"/></_22>
		<_23 public="1"><x path="Float"/></_23>
		<_24 public="1"><x path="Float"/></_24>
		<_31 public="1"><x path="Float"/></_31>
		<_32 public="1"><x path="Float"/></_32>
		<_33 public="1"><x path="Float"/></_33>
		<_34 public="1"><x path="Float"/></_34>
		<_41 public="1"><x path="Float"/></_41>
		<_42 public="1"><x path="Float"/></_42>
		<_43 public="1"><x path="Float"/></_43>
		<_44 public="1"><x path="Float"/></_44>
		<tx public="1" get="accessor" set="accessor"><x path="Float"/></tx>
		<ty public="1" get="accessor" set="accessor"><x path="Float"/></ty>
		<tz public="1" get="accessor" set="accessor"><x path="Float"/></tz>
		<get_tx get="inline" set="null" line="41"><f a=""><x path="Float"/></f></get_tx>
		<get_ty get="inline" set="null" line="42"><f a=""><x path="Float"/></f></get_ty>
		<get_tz get="inline" set="null" line="43"><f a=""><x path="Float"/></f></get_tz>
		<set_tx get="inline" set="null" line="44"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_tx>
		<set_ty get="inline" set="null" line="45"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_ty>
		<set_tz get="inline" set="null" line="46"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_tz>
		<equal public="1" set="method" line="48"><f a="other">
	<c path="h3d.Matrix"/>
	<x path="Bool"/>
</f></equal>
		<zero public="1" set="method" line="55"><f a=""><x path="Void"/></f></zero>
		<identity public="1" set="method" line="62"><f a=""><x path="Void"/></f></identity>
		<initRotationX public="1" set="method" line="69"><f a="a">
	<x path="Float"/>
	<x path="Void"/>
</f></initRotationX>
		<initRotationY public="1" set="method" line="78"><f a="a">
	<x path="Float"/>
	<x path="Void"/>
</f></initRotationY>
		<initRotationZ public="1" set="method" line="87"><f a="a">
	<x path="Float"/>
	<x path="Void"/>
</f></initRotationZ>
		<initTranslation public="1" set="method" line="96">
			<f a="?x:?y:?z" v="0.:0.:0.">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ z : 0., y : 0., x : 0. }</e></m></meta>
		</initTranslation>
		<initScale public="1" set="method" line="103">
			<f a="?x:?y:?z" v="1.:1.:1.">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ z : 1., y : 1., x : 1. }</e></m></meta>
		</initScale>
		<initRotationAxis public="1" set="method" line="110"><f a="axis:angle">
	<c path="h3d.Vector"/>
	<x path="Float"/>
	<x path="Void"/>
</f></initRotationAxis>
		<initRotation public="1" set="method" line="135"><f a="x:y:z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></initRotation>
		<translate public="1" set="method" line="162">
			<f a="?x:?y:?z" v="0.:0.:0.">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ z : 0., y : 0., x : 0. }</e></m></meta>
		</translate>
		<scale public="1" set="method" line="177">
			<f a="?x:?y:?z" v="1.:1.:1.">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ z : 1., y : 1., x : 1. }</e></m></meta>
		</scale>
		<rotate public="1" set="method" line="192"><f a="x:y:z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></rotate>
		<rotateAxis public="1" set="method" line="198"><f a="axis:angle">
	<c path="h3d.Vector"/>
	<x path="Float"/>
	<x path="Void"/>
</f></rotateAxis>
		<getPosition public="1" get="inline" set="null" line="204"><f a="?v">
	<c path="h3d.Vector"/>
	<x path="Null"><c path="h3d.Vector"/></x>
</f></getPosition>
		<setPosition public="1" get="inline" set="null" line="210"><f a="v">
	<c path="h3d.Vector"/>
	<x path="Void"/>
</f></setPosition>
		<prependTranslation public="1" set="method" line="217">
			<f a="?x:?y:?z" v="0.:0.:0.">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ z : 0., y : 0., x : 0. }</e></m></meta>
		</prependTranslation>
		<getScale public="1" get="inline" set="null" line="228"><f a="?v">
	<c path="h3d.Vector"/>
	<x path="Null"><c path="h3d.Vector"/></x>
</f></getScale>
		<prependRotation public="1" set="method" line="242"><f a="x:y:z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></prependRotation>
		<prependRotationAxis public="1" set="method" line="248"><f a="axis:angle">
	<c path="h3d.Vector"/>
	<x path="Float"/>
	<x path="Void"/>
</f></prependRotationAxis>
		<prependScale public="1" set="method" line="254">
			<f a="?sx:?sy:?sz" v="1.:1.:1.">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ sz : 1., sy : 1., sx : 1. }</e></m></meta>
		</prependScale>
		<multiply3x4 public="1" set="method" line="261">
			<f a="a:b">
				<c path="h3d.Matrix"/>
				<c path="h3d.Matrix"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noDebug"/></meta>
		</multiply3x4>
		<multiply3x4inline public="1" get="inline" set="null" line="265"><f a="a:b">
	<c path="h3d.Matrix"/>
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></multiply3x4inline>
		<multiply public="1" set="method" line="296"><f a="a:b">
	<c path="h3d.Matrix"/>
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></multiply>
		<multiplyValue public="1" set="method" line="327"><f a="v">
	<x path="Float"/>
	<x path="Void"/>
</f></multiplyValue>
		<invert public="1" get="inline" set="null" line="346"><f a=""><x path="Void"/></f></invert>
		<getDeterminant public="1" get="inline" set="null" line="350"><f a=""><x path="Float"/></f></getDeterminant>
		<inverse3x4 public="1" set="method" line="354"><f a="m">
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></inverse3x4>
		<initInverse public="1" set="method" line="388"><f a="m">
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></initInverse>
		<initInverse3x3 public="1" set="method" line="437"><f a="m">
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></initInverse3x3>
		<front public="1" get="inline" set="null" line="477"><f a=""><c path="h3d.Vector"/></f></front>
		<right public="1" get="inline" set="null" line="483"><f a=""><c path="h3d.Vector"/></f></right>
		<up public="1" get="inline" set="null" line="489"><f a=""><c path="h3d.Vector"/></f></up>
		<transpose public="1" set="method" line="495"><f a=""><x path="Void"/></f></transpose>
		<clone public="1" set="method" line="505"><f a=""><c path="h3d.Matrix"/></f></clone>
		<load public="1" set="method" line="514"><f a="m">
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></load>
		<loadValues public="1" set="method" line="521"><f a="a">
	<c path="Array"><x path="Float"/></c>
	<x path="Void"/>
</f></loadValues>
		<getFloats public="1" set="method" line="528"><f a=""><c path="Array"><x path="Float"/></c></f></getFloats>
		<getEulerAngles public="1" set="method" line="535">
			<f a=""><c path="h3d.Vector"/></f>
			<haxe_doc>Extracts Euler rotation angles from rotation matrix</haxe_doc>
		</getEulerAngles>
		<toString public="1" set="method" line="561"><f a=""><c path="String"/></f></toString>
		<colorHue public="1" set="method" line="577"><f a="hue">
	<x path="Float"/>
	<x path="Void"/>
</f></colorHue>
		<colorSaturate public="1" set="method" line="603"><f a="sat">
	<x path="Float"/>
	<x path="Void"/>
</f></colorSaturate>
		<colorContrast public="1" set="method" line="625"><f a="contrast">
	<x path="Float"/>
	<x path="Void"/>
</f></colorContrast>
		<colorLightness public="1" set="method" line="643"><f a="lightness">
	<x path="Float"/>
	<x path="Void"/>
</f></colorLightness>
		<colorGain public="1" set="method" line="649"><f a="color:alpha">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></colorGain>
		<colorBits public="1" set="method" line="667"><f a="bits:blend">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></colorBits>
		<colorAdd public="1" get="inline" set="null" line="715"><f a="c">
	<x path="Int"/>
	<x path="Void"/>
</f></colorAdd>
		<colorSet public="1" get="inline" set="null" line="721">
			<f a="c:?alpha" v=":1.">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ alpha : 1. }</e></m></meta>
		</colorSet>
		<adjustColor public="1" set="method" line="727"><f a="col">
	<t path="h3d.ColorAdjust"/>
	<x path="Void"/>
</f></adjustColor>
		<new public="1" set="method" line="38"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="h3d.Vector" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/Vector.hx">
		<fromColor public="1" get="inline" set="null" line="256" static="1">
			<f a="c:?scale" v=":1.0">
				<x path="Int"/>
				<x path="Float"/>
				<c path="h3d.Vector"/>
			</f>
			<meta><m n=":value"><e>{ scale : 1.0 }</e></m></meta>
		</fromColor>
		<fromArray public="1" get="inline" set="null" line="261" static="1"><f a="a">
	<c path="Array"><x path="Float"/></c>
	<c path="h3d.Vector"/>
</f></fromArray>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<z public="1"><x path="Float"/></z>
		<w public="1"><x path="Float"/></w>
		<distance public="1" get="inline" set="null" line="22"><f a="v">
	<c path="h3d.Vector"/>
	<x path="Float"/>
</f></distance>
		<distanceSq public="1" get="inline" set="null" line="26"><f a="v">
	<c path="h3d.Vector"/>
	<x path="Float"/>
</f></distanceSq>
		<sub public="1" get="inline" set="null" line="33"><f a="v">
	<c path="h3d.Vector"/>
	<c path="h3d.Vector"/>
</f></sub>
		<add public="1" get="inline" set="null" line="37"><f a="v">
	<c path="h3d.Vector"/>
	<c path="h3d.Vector"/>
</f></add>
		<cross public="1" get="inline" set="null" line="42"><f a="v">
	<c path="h3d.Vector"/>
	<c path="h3d.Vector"/>
</f></cross>
		<reflect public="1" get="inline" set="null" line="46"><f a="n">
	<c path="h3d.Vector"/>
	<c path="h3d.Vector"/>
</f></reflect>
		<dot3 public="1" get="inline" set="null" line="51"><f a="v">
	<c path="h3d.Vector"/>
	<x path="Float"/>
</f></dot3>
		<dot4 public="1" get="inline" set="null" line="55"><f a="v">
	<c path="h3d.Vector"/>
	<x path="Float"/>
</f></dot4>
		<lengthSq public="1" get="inline" set="null" line="59"><f a=""><x path="Float"/></f></lengthSq>
		<length public="1" get="inline" set="null" line="63"><f a=""><x path="Float"/></f></length>
		<normalize public="1" set="method" line="67"><f a=""><x path="Void"/></f></normalize>
		<normalizeFast public="1" get="inline" set="null" line="75"><f a=""><x path="Void"/></f></normalizeFast>
		<getNormalized public="1" get="inline" set="null" line="82"><f a=""><c path="h3d.Vector"/></f></getNormalized>
		<set public="1" get="inline" set="null" line="88">
			<f a="?x:?y:?z:?w" v="0.:0.:0.:1.">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ w : 1., z : 0., y : 0., x : 0. }</e></m></meta>
		</set>
		<load public="1" get="inline" set="null" line="95"><f a="v">
	<c path="h3d.Vector"/>
	<x path="Void"/>
</f></load>
		<scale3 public="1" get="inline" set="null" line="102"><f a="f">
	<x path="Float"/>
	<x path="Void"/>
</f></scale3>
		<project public="1" get="inline" set="null" line="108"><f a="m">
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></project>
		<lerp public="1" get="inline" set="null" line="119"><f a="v1:v2:k">
	<c path="h3d.Vector"/>
	<c path="h3d.Vector"/>
	<x path="Float"/>
	<x path="Void"/>
</f></lerp>
		<transform3x4 public="1" get="inline" set="null" line="130"><f a="m">
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></transform3x4>
		<transform3x3 public="1" get="inline" set="null" line="139"><f a="m">
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></transform3x3>
		<transform public="1" get="inline" set="null" line="148"><f a="m">
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></transform>
		<clone public="1" get="inline" set="null" line="159"><f a=""><c path="h3d.Vector"/></f></clone>
		<toPoint public="1" get="inline" set="null" line="163"><f a=""><c path="h3d.col.Point"/></f></toPoint>
		<toString public="1" set="method" line="167"><f a=""><c path="String"/></f></toString>
		<r public="1" get="accessor" set="accessor"><x path="Float"/></r>
		<g public="1" get="accessor" set="accessor"><x path="Float"/></g>
		<b public="1" get="accessor" set="accessor"><x path="Float"/></b>
		<a public="1" get="accessor" set="accessor"><x path="Float"/></a>
		<get_r get="inline" set="null" line="178"><f a=""><x path="Float"/></f></get_r>
		<get_g get="inline" set="null" line="179"><f a=""><x path="Float"/></f></get_g>
		<get_b get="inline" set="null" line="180"><f a=""><x path="Float"/></f></get_b>
		<get_a get="inline" set="null" line="181"><f a=""><x path="Float"/></f></get_a>
		<set_r get="inline" set="null" line="182"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_r>
		<set_g get="inline" set="null" line="183"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_g>
		<set_b get="inline" set="null" line="184"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_b>
		<set_a get="inline" set="null" line="185"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_a>
		<setColor public="1" get="inline" set="null" line="187"><f a="c">
	<x path="Int"/>
	<x path="Void"/>
</f></setColor>
		<makeColor public="1" set="method" line="194">
			<f a="hue:?saturation:?brightness" v=":1.:0.5">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ brightness : 0.5, saturation : 1. }</e></m></meta>
		</makeColor>
		<toColor public="1" get="inline" set="null" line="230"><f a=""><x path="Int"/></f></toColor>
		<toColorHSL public="1" set="method" line="234"><f a=""><c path="h3d.Vector"/></f></toColorHSL>
		<new public="1" get="inline" set="null" line="15">
			<f a="?x:?y:?z:?w" v="0.:0.:0.:1.">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ w : 1., z : 0., y : 0., x : 0. }</e></m></meta>
		</new>
		<haxe_doc>A 4 floats vector. Everytime a Vector is returned, it means a copy is created.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="h3d.scene.Object" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/scene/Object.hx">
		<implements path="hxd.impl._Serializable.NoSerializeSupport"/>
		<ROT2RAD get="inline" set="null" expr="-0.017453292519943295769236907684886" line="35" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>-0.017453292519943295769236907684886</e></m></meta>
		</ROT2RAD>
		<tmpMat expr="new h3d.Matrix()" line="803" static="1">
			<c path="h3d.Matrix"/>
			<meta><m n=":value"><e>new h3d.Matrix()</e></m></meta>
			<haxe_doc>Set the position, scale and rotation of the object relative to its parent based on the specified transform matrix.</haxe_doc>
		</tmpMat>
		<tmpVec expr="new h3d.Vector()" line="804" static="1">
			<c path="h3d.Vector"/>
			<meta><m n=":value"><e>new h3d.Vector()</e></m></meta>
		</tmpVec>
		<flags>
			<x path="h3d.scene.ObjectFlags"/>
			<meta><m n=":s"/></meta>
		</flags>
		<children><c path="Array"><c path="h3d.scene.Object"/></c></children>
		<parent public="1" set="null">
			<c path="h3d.scene.Object"/>
			<haxe_doc>The parent object in the scene tree.</haxe_doc>
		</parent>
		<numChildren public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>How many immediate children this object has.</haxe_doc>
		</numChildren>
		<name public="1">
			<x path="Null"><c path="String"/></x>
			<meta><m n=":s"/></meta>
			<haxe_doc>The name of the object, can be used to retrieve an object within a tree by using `getObjectByName` (default null)</haxe_doc>
		</name>
		<x public="1" set="accessor">
			<x path="Float"/>
			<meta><m n=":s"/></meta>
			<haxe_doc>The x position of the object relative to its parent.</haxe_doc>
		</x>
		<y public="1" set="accessor">
			<x path="Float"/>
			<meta><m n=":s"/></meta>
			<haxe_doc>The y position of the object relative to its parent.</haxe_doc>
		</y>
		<z public="1" set="accessor">
			<x path="Float"/>
			<meta><m n=":s"/></meta>
			<haxe_doc>The z position of the object relative to its parent.</haxe_doc>
		</z>
		<scaleX public="1" set="accessor">
			<x path="Float"/>
			<meta><m n=":s"/></meta>
			<haxe_doc>The amount of scaling along the X axis of this object (default 1.0)</haxe_doc>
		</scaleX>
		<scaleY public="1" set="accessor">
			<x path="Float"/>
			<meta><m n=":s"/></meta>
			<haxe_doc>The amount of scaling along the Y axis of this object (default 1.0)</haxe_doc>
		</scaleY>
		<scaleZ public="1" set="accessor">
			<x path="Float"/>
			<meta><m n=":s"/></meta>
			<haxe_doc>The amount of scaling along the Z axis of this object (default 1.0)</haxe_doc>
		</scaleZ>
		<visible public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>Is the object and its children are displayed on screen (default true).</haxe_doc>
		</visible>
		<allocated get="accessor" set="accessor"><x path="Bool"/></allocated>
		<follow public="1" set="accessor">
			<c path="h3d.scene.Object"/>
			<meta><m n=":s"/></meta>
			<haxe_doc>Follow a given object or joint as if it was our parent. Ignore defaultTransform when set.</haxe_doc>
		</follow>
		<followPositionOnly public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>When follow is set, only follow the position and ignore both scale and rotation.</haxe_doc>
		</followPositionOnly>
		<defaultTransform public="1" set="accessor">
			<c path="h3d.Matrix"/>
			<haxe_doc>This is an additional optional transformation that is performed before other local transformations.
		It is used by the animation system.</haxe_doc>
		</defaultTransform>
		<currentAnimation public="1" set="null">
			<c path="h3d.anim.Animation"/>
			<meta><m n=":s"/></meta>
		</currentAnimation>
		<culled public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>Inform that the object is not to be displayed and his animation doesn't have to be sync. Unlike visible, this doesn't apply to children unless inheritCulled is set to true.</haxe_doc>
		</culled>
		<alwaysSync public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>When an object is not visible or culled, its animation does not get synchronized unless you set alwaysSync=true</haxe_doc>
		</alwaysSync>
		<inheritCulled public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>When enabled, the culled flag and culling collider is inherited by children objects.</haxe_doc>
		</inheritCulled>
		<ignoreBounds public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>When enabled, the object bounds are ignored when using getBounds()</haxe_doc>
		</ignoreBounds>
		<ignoreCollide public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>When enabled, the object is ignored when using getCollider()</haxe_doc>
		</ignoreCollide>
		<allowSerialize public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>When enabled, the object can be serialized (default : true)</haxe_doc>
		</allowSerialize>
		<ignoreParentTransform public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>When enabled, the object will not follow its parent transform</haxe_doc>
		</ignoreParentTransform>
		<lightCameraCenter public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>When selecting the lights to apply to this object, we will use the camera target as reference
		instead of the object absolute position. This is useful for very large objects so they can get good lighting.</haxe_doc>
		</lightCameraCenter>
		<cullingCollider public="1" set="accessor">
			<c path="h3d.col.Collider"/>
			<haxe_doc>When set, collider shape will be used for automatic frustum culling.
		If `inheritCulled` is true, collider will be inherited to children unless they have their own collider set.</haxe_doc>
		</cullingCollider>
		<set_cullingCollider set="method" line="156"><f a="c">
	<c path="h3d.col.Collider"/>
	<c path="h3d.col.Collider"/>
</f></set_cullingCollider>
		<cullingColliderInherited get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>Indicates that current cullingCollider is currently inherited from a parent object</haxe_doc>
		</cullingColliderInherited>
		<absPos><c path="h3d.Matrix"/></absPos>
		<invPos><c path="h3d.Matrix"/></invPos>
		<qRot><c path="h3d.Quat"/></qRot>
		<posChanged get="accessor" set="accessor"><x path="Bool"/></posChanged>
		<lastFrame><x path="Int"/></lastFrame>
		<get_visible get="inline" set="null" line="189"><f a=""><x path="Bool"/></f></get_visible>
		<get_allocated get="inline" set="null" line="190"><f a=""><x path="Bool"/></f></get_allocated>
		<get_posChanged get="inline" set="null" line="191"><f a=""><x path="Bool"/></f></get_posChanged>
		<get_culled get="inline" set="null" line="192"><f a=""><x path="Bool"/></f></get_culled>
		<get_followPositionOnly get="inline" set="null" line="193"><f a=""><x path="Bool"/></f></get_followPositionOnly>
		<get_lightCameraCenter get="inline" set="null" line="194"><f a=""><x path="Bool"/></f></get_lightCameraCenter>
		<get_alwaysSync get="inline" set="null" line="195"><f a=""><x path="Bool"/></f></get_alwaysSync>
		<get_inheritCulled get="inline" set="null" line="196"><f a=""><x path="Bool"/></f></get_inheritCulled>
		<get_ignoreBounds get="inline" set="null" line="197"><f a=""><x path="Bool"/></f></get_ignoreBounds>
		<get_ignoreCollide get="inline" set="null" line="198"><f a=""><x path="Bool"/></f></get_ignoreCollide>
		<get_allowSerialize get="inline" set="null" line="199"><f a=""><x path="Bool"/></f></get_allowSerialize>
		<get_ignoreParentTransform get="inline" set="null" line="200"><f a=""><x path="Bool"/></f></get_ignoreParentTransform>
		<get_cullingColliderInherited get="inline" set="null" line="201"><f a=""><x path="Bool"/></f></get_cullingColliderInherited>
		<set_posChanged get="inline" set="null" line="202"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_posChanged>
		<set_culled get="inline" set="null" line="203"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_culled>
		<set_visible get="inline" set="null" line="204"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_visible>
		<set_allocated get="inline" set="null" line="205"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_allocated>
		<set_followPositionOnly get="inline" set="null" line="206"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_followPositionOnly>
		<set_lightCameraCenter get="inline" set="null" line="207"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_lightCameraCenter>
		<set_alwaysSync get="inline" set="null" line="208"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_alwaysSync>
		<set_ignoreBounds get="inline" set="null" line="209"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_ignoreBounds>
		<set_inheritCulled get="inline" set="null" line="210"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_inheritCulled>
		<set_ignoreCollide get="inline" set="null" line="211"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_ignoreCollide>
		<set_allowSerialize get="inline" set="null" line="212"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_allowSerialize>
		<set_ignoreParentTransform get="inline" set="null" line="213"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_ignoreParentTransform>
		<set_cullingColliderInherited get="inline" set="null" line="214"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_cullingColliderInherited>
		<playAnimation public="1" set="method" line="219">
			<f a="a">
				<c path="h3d.anim.Animation"/>
				<c path="h3d.anim.Animation"/>
			</f>
			<haxe_doc>Create an animation instance bound to the object, set it as currentAnimation and play it.</haxe_doc>
		</playAnimation>
		<switchToAnimation public="1" set="method" line="226">
			<f a="a">
				<c path="h3d.anim.Animation"/>
				<c path="h3d.anim.Animation"/>
			</f>
			<haxe_doc>Change the current animation. This animation should be an instance that was previously created by playAnimation.</haxe_doc>
		</switchToAnimation>
		<stopAnimation public="1" set="method" line="233">
			<f a="?recursive" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ recursive : false }</e></m></meta>
			<haxe_doc>Stop the current animation. If recursive is set to true, all children will also stop their animation</haxe_doc>
		</stopAnimation>
		<applyAnimationTransform public="1" set="method" line="248">
			<f a="?recursive" v="true">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ recursive : true }</e></m></meta>
			<haxe_doc>When an object is loaded, its position scale and rotation will always be set to the default values (0 for position/rotation and 1 for scale).
		If it's part of a group/scene or if it's animated, then its position/rotation/scale will be stored into the defaultTransform matrix.
		Calling this function will reset the defaultTransform to null and instead initialize x/y/z/rotation/scale properties.
		This will not change the actual position of the object but allows you to move the object more freely on your own.
		Do not use on an object that is currently being animated, since it will set again defaultTransform and apply twice the transformation.</haxe_doc>
		</applyAnimationTransform>
		<getObjectsCount public="1" set="method" line="268">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Return the total number of children, recursively.</haxe_doc>
		</getObjectsCount>
		<getMaterialByName public="1" set="method" line="278">
			<f a="name">
				<c path="String"/>
				<c path="h3d.mat.Material"/>
			</f>
			<haxe_doc>Search for a material recursively by name, return it or null if not found.</haxe_doc>
		</getMaterialByName>
		<find public="1" params="T" set="method" line="289">
			<f a="f">
				<f a="">
					<c path="h3d.scene.Object"/>
					<x path="Null"><c path="find.T"/></x>
				</f>
				<x path="Null"><c path="find.T"/></x>
			</f>
			<haxe_doc>Find a single object in the tree by calling `f` on each and returning the first not-null value returned, or null if not found.</haxe_doc>
		</find>
		<findAll public="1" params="T" set="method" line="303">
			<f a="f:?arr">
				<f a="">
					<c path="h3d.scene.Object"/>
					<x path="Null"><c path="findAll.T"/></x>
				</f>
				<c path="Array"><c path="findAll.T"/></c>
				<c path="Array"><c path="findAll.T"/></c>
			</f>
			<haxe_doc>Find several objects in the tree by calling `f` on each and returning all the not-null values returned.</haxe_doc>
		</findAll>
		<getMaterials public="1" set="method" line="316">
			<f a="?a">
				<c path="Array"><c path="h3d.mat.Material"/></c>
				<x path="Null"><c path="Array"><c path="h3d.mat.Material"/></c></x>
			</f>
			<haxe_doc>Return all materials in the tree.</haxe_doc>
		</getMaterials>
		<localToGlobal public="1" set="method" line="326">
			<f a="?pt">
				<c path="h3d.Vector"/>
				<x path="Null"><c path="h3d.Vector"/></x>
			</f>
			<haxe_doc>Convert a local position (or [0,0] if pt is null) relative to the object origin into an absolute global position, applying all the inherited transforms.</haxe_doc>
		</localToGlobal>
		<globalToLocal public="1" set="method" line="336">
			<f a="pt">
				<c path="h3d.Vector"/>
				<c path="h3d.Vector"/>
			</f>
			<haxe_doc>Convert an absolute global position into a local position relative to the object origin, applying all the inherited transforms.</haxe_doc>
		</globalToLocal>
		<getInvPos public="1" set="method" line="344">
			<f a=""><c path="h3d.Matrix"/></f>
			<haxe_doc>Returns the updated inverse position matrix. Please note that this is not a copy and should not be modified.</haxe_doc>
		</getInvPos>
		<getBounds final="1" public="1" set="method" line="358">
			<f a="?b">
				<c path="h3d.col.Bounds"/>
				<c path="h3d.col.Bounds"/>
			</f>
			<meta><m n=":final"/></meta>
			<haxe_doc>Return the bounds of this object and all its children, in absolute global coordinates.</haxe_doc>
		</getBounds>
		<getBoundsRec set="method" line="366"><f a="b">
	<c path="h3d.col.Bounds"/>
	<c path="h3d.col.Bounds"/>
</f></getBoundsRec>
		<getMeshes public="1" set="method" line="381">
			<f a="?out">
				<c path="Array"><c path="h3d.scene.Mesh"/></c>
				<x path="Null"><c path="Array"><c path="h3d.scene.Mesh"/></c></x>
			</f>
			<haxe_doc>Return all meshes part of this tree</haxe_doc>
		</getMeshes>
		<getMeshByName public="1" set="method" line="393">
			<f a="name">
				<c path="String"/>
				<c path="h3d.scene.Mesh"/>
			</f>
			<haxe_doc>Search for an mesh recursively by name, return null if not found.</haxe_doc>
		</getMeshByName>
		<getObjectByName public="1" set="method" line="400">
			<f a="name">
				<c path="String"/>
				<c path="h3d.scene.Object"/>
			</f>
			<haxe_doc>Search for an object recursively by name, return null if not found.</haxe_doc>
		</getObjectByName>
		<clone public="1" set="method" line="413">
			<f a="?o">
				<c path="h3d.scene.Object"/>
				<c path="h3d.scene.Object"/>
			</f>
			<haxe_doc>Make a copy of the object and all its children.</haxe_doc>
		</clone>
		<addChild public="1" set="method" line="442">
			<f a="o">
				<c path="h3d.scene.Object"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Add a child object at the end of the children list.</haxe_doc>
		</addChild>
		<addChildAt public="1" set="method" line="449">
			<f a="o:pos">
				<c path="h3d.scene.Object"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Insert a child object at the specified position of the children list.</haxe_doc>
		</addChildAt>
		<iterVisibleMeshes public="1" set="method" line="481">
			<f a="callb">
				<f a="">
					<c path="h3d.scene.Mesh"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>Iterate on all mesh that are currently visible and not culled in the tree. Call `callb` for each mesh found.</haxe_doc>
		</iterVisibleMeshes>
		<onParentChanged set="method" line="492"><f a=""><x path="Void"/></f></onParentChanged>
		<onAdd set="method" line="498"><f a=""><x path="Void"/></f></onAdd>
		<onRemove set="method" line="505"><f a=""><x path="Void"/></f></onRemove>
		<removeChild public="1" set="method" line="514">
			<f a="o">
				<c path="h3d.scene.Object"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Remove the given object from our immediate children list if it's part of it.</haxe_doc>
		</removeChild>
		<removeChildren public="1" set="method" line="525">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Remove all children from our immediate children list</haxe_doc>
		</removeChildren>
		<remove public="1" get="inline" set="null" line="534">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Same as parent.removeChild(this), but does nothing if parent is null.
		In order to capture add/removal from scene, you can override onAdd/onRemove/onParentChanged</haxe_doc>
		</remove>
		<getScene public="1" set="method" line="541">
			<f a=""><c path="h3d.scene.Scene"/></f>
			<haxe_doc>Return the Scene this object is part of, or null if not added to a Scene.</haxe_doc>
		</getScene>
		<getAbsPos public="1" set="method" line="550">
			<f a=""><c path="h3d.Matrix"/></f>
			<haxe_doc>Returns the updated absolute position matrix. Please note that this is not a copy so it should not be modified.</haxe_doc>
		</getAbsPos>
		<isMesh public="1" get="inline" set="null" line="558">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Tell if the object is a Mesh.</haxe_doc>
		</isMesh>
		<toMesh public="1" set="method" line="565">
			<f a=""><c path="h3d.scene.Mesh"/></f>
			<haxe_doc>If the object is a Mesh, return the corresponding Mesh. If not, throw an exception.</haxe_doc>
		</toMesh>
		<getCollider final="1" public="1" set="method" line="576">
			<f a=""><c path="h3d.col.Collider"/></f>
			<meta><m n=":final"/></meta>
			<haxe_doc>Build and return the global absolute recursive collider for the object.
		Returns null if no collider was found or if ignoreCollide was set to true.</haxe_doc>
		</getCollider>
		<getGlobalCollider public="1" set="method" line="603">
			<f a=""><c path="h3d.col.Collider"/></f>
			<haxe_doc>Same as getLocalCollider, but returns an absolute collider instead of a local one.</haxe_doc>
		</getGlobalCollider>
		<getLocalCollider public="1" set="method" line="614">
			<f a=""><c path="h3d.col.Collider"/></f>
			<haxe_doc>Build and returns the local relative not-recursive collider for the object, or null if this object does not have a collider.
		Does not check for ignoreCollide.</haxe_doc>
		</getLocalCollider>
		<draw set="method" line="618"><f a="ctx">
	<c path="h3d.scene.RenderContext"/>
	<x path="Void"/>
</f></draw>
		<set_follow set="method" line="621"><f a="v">
	<c path="h3d.scene.Object"/>
	<c path="h3d.scene.Object"/>
</f></set_follow>
		<calcAbsPos set="method" line="626"><f a=""><x path="Void"/></f></calcAbsPos>
		<sync set="method" line="659"><f a="ctx">
	<c path="h3d.scene.RenderContext"/>
	<x path="Void"/>
</f></sync>
		<syncRec set="method" line="662"><f a="ctx">
	<c path="h3d.scene.RenderContext"/>
	<x path="Void"/>
</f></syncRec>
		<syncPos set="method" line="714"><f a=""><x path="Void"/></f></syncPos>
		<emit set="method" line="724"><f a="ctx">
	<c path="h3d.scene.RenderContext"/>
	<x path="Void"/>
</f></emit>
		<emitRec set="method" line="727"><f a="ctx">
	<c path="h3d.scene.RenderContext"/>
	<x path="Void"/>
</f></emitRec>
		<set_x get="inline" set="null" line="748"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_x>
		<set_y get="inline" set="null" line="754"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_y>
		<set_z get="inline" set="null" line="760"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_z>
		<set_scaleX get="inline" set="null" line="766"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_scaleX>
		<set_scaleY get="inline" set="null" line="772"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_scaleY>
		<set_scaleZ get="inline" set="null" line="778"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_scaleZ>
		<set_defaultTransform get="inline" set="null" line="784"><f a="v">
	<c path="h3d.Matrix"/>
	<c path="h3d.Matrix"/>
</f></set_defaultTransform>
		<setPosition public="1" get="inline" set="null" line="793">
			<f a="x:y:z">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Set the position of the object relative to its parent.</haxe_doc>
		</setPosition>
		<setTransform public="1" set="method" line="805"><f a="mat">
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></setTransform>
		<rotate public="1" set="method" line="822">
			<f a="rx:ry:rz">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Rotate around the current rotation axis by the specified angles (in radian).</haxe_doc>
		</rotate>
		<setRotation public="1" set="method" line="832">
			<f a="rx:ry:rz">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Set the rotation using the specified angles (in radian).</haxe_doc>
		</setRotation>
		<setRotationAxis public="1" set="method" line="840">
			<f a="ax:ay:az:angle">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Set the rotation using the specified axis and angle of rotation around it (in radian).</haxe_doc>
		</setRotationAxis>
		<setDirection public="1" set="method" line="848">
			<f a="v">
				<c path="h3d.Vector"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Set the rotation using the specified look at direction</haxe_doc>
		</setDirection>
		<getDirection public="1" set="method" line="856">
			<f a=""><c path="h3d.Vector"/></f>
			<haxe_doc>Return the direction in which the object rotation is currently oriented to</haxe_doc>
		</getDirection>
		<getRotationQuat public="1" set="method" line="864">
			<f a=""><c path="h3d.Quat"/></f>
			<haxe_doc>Return the quaternion representing the current object rotation.
		Dot not modify as it's not a copy.</haxe_doc>
		</getRotationQuat>
		<setRotationQuat public="1" set="method" line="872">
			<f a="q">
				<c path="h3d.Quat"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Set the quaternion representing the current object rotation.
		Dot not modify the value afterwards as no copy is made.</haxe_doc>
		</setRotationQuat>
		<scale public="1" get="inline" set="null" line="880">
			<f a="v">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Scale uniformly the object by the given factor.</haxe_doc>
		</scale>
		<setScale public="1" get="inline" set="null" line="890">
			<f a="v">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Set the uniform scale for the object.</haxe_doc>
		</setScale>
		<toString public="1" set="method" line="900">
			<f a=""><c path="String"/></f>
			<haxe_doc>Return both class name and object name if any.</haxe_doc>
		</toString>
		<getChildAt public="1" get="inline" set="null" line="907">
			<f a="n">
				<x path="Int"/>
				<c path="h3d.scene.Object"/>
			</f>
			<haxe_doc>Return the `n`th element among our immediate children list, or null if there is no.</haxe_doc>
		</getChildAt>
		<getChildIndex public="1" set="method" line="914">
			<f a="o">
				<c path="h3d.scene.Object"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Return the index of the object `o` within our immediate children list, or `-1` if it is not part of our children list.</haxe_doc>
		</getChildIndex>
		<get_numChildren get="inline" set="null" line="921"><f a=""><x path="Int"/></f></get_numChildren>
		<iterator public="1" get="inline" set="null" line="928">
			<f a=""><c path="hxd.impl.ArrayIterator_h3d_scene_Object"/></f>
			<haxe_doc>Return an iterator over this object immediate children</haxe_doc>
		</iterator>
		<new public="1" set="method" line="176">
			<f a="?parent">
				<c path="h3d.scene.Object"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Create a new empty object, and adds it to the parent object if not null.</haxe_doc>
		</new>
		<haxe_doc>h3d.scene.Object is the base 3D class that all scene tree elements inherit from.
	It can be used to create a virtual container that does not display anything but can contain other objects
	so the various transforms are inherited to its children.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="ch3.scene.Axes" params="" file="./ch3/scene/Axes.hx">
		<extends path="h3d.scene.Object"/>
		<new public="1" set="method" line="8"><f a="?parent">
	<c path="h3d.scene.Object"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="h3d.scene.Mesh" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/scene/Mesh.hx">
		<extends path="h3d.scene.Object"/>
		<primitive public="1" set="accessor">
			<c path="h3d.prim.Primitive"/>
			<haxe_doc>The primitive of the mesh: the list of vertexes and indices necessary to display the mesh.</haxe_doc>
		</primitive>
		<material public="1">
			<c path="h3d.mat.Material"/>
			<haxe_doc>The material of the mesh: the properties used to display it (texture, color, shaders, etc.)</haxe_doc>
		</material>
		<getMeshMaterials public="1" set="method" line="36">
			<f a=""><c path="Array"><c path="h3d.mat.Material"/></c></f>
			<haxe_doc>Return all materials for the current object.</haxe_doc>
		</getMeshMaterials>
		<getBoundsRec set="method" line="40" override="1"><f a="b">
	<c path="h3d.col.Bounds"/>
	<c path="h3d.col.Bounds"/>
</f></getBoundsRec>
		<clone public="1" set="method" line="50" override="1"><f a="?o">
	<c path="h3d.scene.Object"/>
	<c path="h3d.scene.Object"/>
</f></clone>
		<getLocalCollider public="1" set="method" line="58" override="1"><f a=""><c path="h3d.col.Collider"/></f></getLocalCollider>
		<draw set="method" line="62" override="1"><f a="ctx">
	<c path="h3d.scene.RenderContext"/>
	<x path="Void"/>
</f></draw>
		<emit set="method" line="66" override="1"><f a="ctx">
	<c path="h3d.scene.RenderContext"/>
	<x path="Void"/>
</f></emit>
		<getMaterialByName public="1" set="method" line="70" override="1"><f a="name">
	<c path="String"/>
	<c path="h3d.mat.Material"/>
</f></getMaterialByName>
		<getMaterials public="1" set="method" line="76" override="1"><f a="?a">
	<c path="Array"><c path="h3d.mat.Material"/></c>
	<x path="Null"><c path="Array"><c path="h3d.mat.Material"/></c></x>
</f></getMaterials>
		<onAdd set="method" line="95" override="1"><f a=""><x path="Void"/></f></onAdd>
		<onRemove set="method" line="101" override="1"><f a=""><x path="Void"/></f></onRemove>
		<set_primitive set="method" line="107"><f a="prim">
	<c path="h3d.prim.Primitive"/>
	<c path="h3d.prim.Primitive"/>
</f></set_primitive>
		<new public="1" set="method" line="23">
			<f a="primitive:?material:?parent">
				<c path="h3d.prim.Primitive"/>
				<c path="h3d.mat.Material"/>
				<c path="h3d.scene.Object"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new mesh with given primitive, material and parent object.
		If material is not specified, a new default material is created for the current renderer.</haxe_doc>
		</new>
		<haxe_doc>h3d.scene.Mesh is the base class for all 3D objects displayed on screen.
	Unlike Object base class, all properties of Mesh only apply to the current object and are not inherited by its children.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="ch3.scene.S2DPlane" params="" file="./ch3/scene/S2DPlane.hx">
		<extends path="h3d.scene.Mesh"/>
		<root public="1"><c path="ch3.scene.S2DPlaneRoot"/></root>
		<immediateMode public="1"><x path="Bool"/></immediateMode>
		<_dirty><x path="Bool"/></_dirty>
		<_bounds><c path="h2d.col.Bounds"/></_bounds>
		<_autoresize><x path="Bool"/></_autoresize>
		<_texture><c path="h3d.mat.Texture"/></_texture>
		<_ppu><x path="Float"/></_ppu>
		<_plane><c path="ch3.scene._S2DPlane.DrawPrim"/></_plane>
		<filter public="1" get="accessor" set="accessor"><e path="h3d.mat.Filter"/></filter>
		<ppu public="1" get="accessor" set="accessor"><x path="Float"/></ppu>
		<get_ppu get="inline" set="null" line="27"><f a=""><x path="Float"/></f></get_ppu>
		<set_ppu get="inline" set="null" line="28"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_ppu>
		<get_filter get="inline" set="null" line="36"><f a=""><e path="h3d.mat.Filter"/></f></get_filter>
		<set_filter get="inline" set="null" line="37"><f a="v">
	<e path="h3d.mat.Filter"/>
	<e path="h3d.mat.Filter"/>
</f></set_filter>
		<invalidate public="1" get="inline" set="null" line="57"><f a=""><x path="Void"/></f></invalidate>
		<sync set="method" line="59" override="1"><f a="ctx">
	<c path="h3d.scene.RenderContext"/>
	<x path="Void"/>
</f></sync>
		<onRemove public="1" set="method" line="83" override="1"><f a=""><x path="Void"/></f></onRemove>
		<new public="1" set="method" line="43">
			<f a="parent:?immediateMode:?textureWidth:?textureHeight:?ppu:?autoresize" v=":false:512:512:1:false">
				<c path="h3d.scene.Object"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ autoresize : false, ppu : 1, textureHeight : 512, textureWidth : 512, immediateMode : false }</e></m></meta>
		</new>
	</class>
	<class path="ch3.scene.S2DPlaneRoot" params="" file="./ch3/scene/S2DPlane.hx" module="ch3.scene.S2DPlane">
		<extends path="h2d.Object"/>
		<plane><c path="ch3.scene.S2DPlane"/></plane>
		<contentChanged set="method" line="109" override="1"><f a="s">
	<c path="h2d.Object"/>
	<x path="Void"/>
</f></contentChanged>
		<drawRec set="method" line="114" override="1"><f a="ctx">
	<c path="h2d.RenderContext"/>
	<x path="Void"/>
</f></drawRec>
		<new set="method" line="102"><f a="plane">
	<c path="ch3.scene.S2DPlane"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>ch3.scene.S2DPlane</e></m>
			<m n=":allow"><e>ch3.scene.S2DPlane</e></m>
		</meta>
	</class>
	<class path="ch3.scene._S2DPlane.DrawPrim" params="" file="./ch3/scene/S2DPlane.hx" private="1" module="ch3.scene.S2DPlane">
		<extends path="h3d.prim.Primitive"/>
		<_b><c path="h3d.col.Bounds"/></_b>
		<_w><x path="Float"/></_w>
		<_h><x path="Float"/></_h>
		<_tx><x path="Int"/></_tx>
		<_ty><x path="Int"/></_ty>
		<_buf><x path="hxd.FloatBuffer"/></_buf>
		<ppu public="1"><x path="Float"/></ppu>
		<invalid public="1"><x path="Bool"/></invalid>
		<resize public="1" set="method" line="140"><f a="w:h:tx:ty">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></resize>
		<triCount public="1" set="method" line="163" override="1"><f a=""><x path="Int"/></f></triCount>
		<vertexCount public="1" set="method" line="167" override="1"><f a=""><x path="Int"/></f></vertexCount>
		<alloc public="1" set="method" line="171" override="1"><f a="engine">
	<c path="h3d.Engine"/>
	<x path="Void"/>
</f></alloc>
		<refill get="inline" set="null" line="179"><f a=""><x path="Void"/></f></refill>
		<render public="1" set="method" line="230" override="1"><f a="engine">
	<c path="h3d.Engine"/>
	<x path="Void"/>
</f></render>
		<getBounds public="1" set="method" line="235" override="1"><f a=""><c path="h3d.col.Bounds"/></f></getBounds>
		<new public="1" set="method" line="134"><f a="w:h:tx:ty:ppu">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="ch3.scene.TileSprite" params="" file="./ch3/scene/TileSprite.hx">
		<extends path="h3d.scene.Mesh"/>
		<faceCamera public="1">
			<x path="Bool"/>
			<haxe_doc>If true, will follow camera orientation to always appear facing X coordinate at camera. (default: true)</haxe_doc>
		</faceCamera>
		<faceZAxis public="1">
			<x path="Bool"/>
			<haxe_doc>If true, will track camera on Z axis, otherwise only X and Y coordinates will be adjusted, and sprite will look forward at all times. (default: true)</haxe_doc>
		</faceZAxis>
		<tile public="1" set="accessor">
			<c path="h2d.Tile"/>
			<haxe_doc>Currently displayed `h2d.Tile`.</haxe_doc>
		</tile>
		<ppu><x path="Float"/></ppu>
		<pixelsPerUnit public="1" set="accessor">
			<x path="Float"/>
			<haxe_doc>Pixels per unit value. Affects the sprite size in 3D space. (default: 1)</haxe_doc>
		</pixelsPerUnit>
		<plane><c path="ch3.prim.PlanePrim"/></plane>
		<set_tile set="method" line="52"><f a="t">
	<c path="h2d.Tile"/>
	<c path="h2d.Tile"/>
</f></set_tile>
		<set_pixelsPerUnit set="method" line="66"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_pixelsPerUnit>
		<syncRec set="method" line="73" override="1"><f a="ctx">
	<c path="h3d.scene.RenderContext"/>
	<x path="Void"/>
</f></syncRec>
		<new public="1" set="method" line="38">
			<f a="tile:?ppu:?faceCamera:?parent" v=":1:true:">
				<c path="h2d.Tile"/>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="h3d.scene.Object"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ faceCamera : true, ppu : 1 }</e></m></meta>
		</new>
		<haxe_doc>A classic 2D sprite that can follow camera orientation to always face it.
  Sprite front is X forward.</haxe_doc>
		<meta><m n=":access"><e>h2d.Tile</e></m></meta>
	</class>
	<class path="hxsl.Shader" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Shader.hx">
		<priority public="1" set="null" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</priority>
		<shader><c path="hxsl.SharedShader"/></shader>
		<instance><c path="hxsl.ShaderInstance"/></instance>
		<constBits><x path="Int"/></constBits>
		<constModified><x path="Bool"/></constModified>
		<initialize set="method" line="17"><f a=""><x path="Void"/></f></initialize>
		<setPriority public="1" set="method" line="40">
			<f a="v">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Shader priority should only be changed *before* the shader is added to a material.</haxe_doc>
		</setPriority>
		<getParamValue public="1" set="method" line="44"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="49"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<updateConstants public="1" set="method" line="54"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<updateConstantsFinal set="method" line="58"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstantsFinal>
		<clone public="1" set="method" line="100"><f a=""><c path="hxsl.Shader"/></f></clone>
		<toString public="1" set="method" line="104"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="13"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="ch3.shader.MultiTexture" params="" file="./ch3/shader/MultiTexture.hx">
		<extends path="hxsl.Shader"/>
		<SRC expr="&quot;HXSLF2NoMy5zaGFkZXIuTXVsdGlUZXh0dXJlDQEFaWR4SW4NAQECDHRleHR1cmVJbmRleAMBAQABAAADDGNhbGN1bGF0ZWRVVgUKBAAABAx0ZXh0dXJlQ29sb3IFDAQAAAUIdGV4SW5kZXgDAwAABgh0ZXh0dXJlMQoCAAAHCHRleHR1cmUyCgIAAAgIdGV4dHVyZTMKAgAACQh0ZXh0dXJlNAoCAAAKCHRleHR1cmU1CgIAAAsIdGV4dHVyZTYKAgAADAh0ZXh0dXJlNwoCAAANCF9faW5pdF9fDgYAAA4IZnJhZ21lbnQOBgAAAgINAAAFAQYEAgUDAgIDAwABDgAABQMIDwJ0MAUMBAAAAgQFDAAIEAVpbmRleAEEAAAJAyUOAQIFAwEACwYFAhABAQIBAAAAAQIGBAIEBQwJAyEOAgIGCgIDBQoFDAUMCwYFAhABAQICAAAAAQIGBAIEBQwJAyEOAgIHCgIDBQoFDAUMCwYFAhABAQIDAAAAAQIGBAIEBQwJAyEOAgIICgIDBQoFDAUMCwYFAhABAQIEAAAAAQIGBAIEBQwJAyEOAgIJCgIDBQoFDAUMCwYFAhABAQIFAAAAAQIGBAIEBQwJAyEOAgIKCgIDBQoFDAUMCwYFAhABAQIGAAAAAQIGBAIEBQwJAyEOAgILCgIDBQoFDAUMCwYFAhABAQIHAAAAAQIGBAIEBQwJAyEOAgIMCgIDBQoFDAUMBgQCBAUMAg8FDAUMAAAAAAAAAAA&quot;" line="11" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"HXSLF2NoMy5zaGFkZXIuTXVsdGlUZXh0dXJlDQEFaWR4SW4NAQECDHRleHR1cmVJbmRleAMBAQABAAADDGNhbGN1bGF0ZWRVVgUKBAAABAx0ZXh0dXJlQ29sb3IFDAQAAAUIdGV4SW5kZXgDAwAABgh0ZXh0dXJlMQoCAAAHCHRleHR1cmUyCgIAAAgIdGV4dHVyZTMKAgAACQh0ZXh0dXJlNAoCAAAKCHRleHR1cmU1CgIAAAsIdGV4dHVyZTYKAgAADAh0ZXh0dXJlNwoCAAANCF9faW5pdF9fDgYAAA4IZnJhZ21lbnQOBgAAAgINAAAFAQYEAgUDAgIDAwABDgAABQMIDwJ0MAUMBAAAAgQFDAAIEAVpbmRleAEEAAAJAyUOAQIFAwEACwYFAhABAQIBAAAAAQIGBAIEBQwJAyEOAgIGCgIDBQoFDAUMCwYFAhABAQICAAAAAQIGBAIEBQwJAyEOAgIHCgIDBQoFDAUMCwYFAhABAQIDAAAAAQIGBAIEBQwJAyEOAgIICgIDBQoFDAUMCwYFAhABAQIEAAAAAQIGBAIEBQwJAyEOAgIJCgIDBQoFDAUMCwYFAhABAQIFAAAAAQIGBAIEBQwJAyEOAgIKCgIDBQoFDAUMCwYFAhABAQIGAAAAAQIGBAIEBQwJAyEOAgILCgIDBQoFDAUMCwYFAhABAQIHAAAAAQIGBAIEBQwJAyEOAgIMCgIDBQoFDAUMBgQCBAUMAg8FDAUMAAAAAAAAAAA"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<texture1 public="1" get="accessor" set="accessor"><t path="hxsl.Sampler2D"/></texture1>
		<texture1__>
			<t path="hxsl.Sampler2D"/>
			<meta><m n=":noCompletion"/></meta>
		</texture1__>
		<get_texture1 get="inline" set="null" line="11">
			<f a=""><t path="hxsl.Sampler2D"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_texture1>
		<set_texture1 get="inline" set="null" line="11">
			<f a="_v">
				<t path="hxsl.Sampler2D"/>
				<t path="hxsl.Sampler2D"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_texture1>
		<texture2 public="1" get="accessor" set="accessor"><t path="hxsl.Sampler2D"/></texture2>
		<texture2__>
			<t path="hxsl.Sampler2D"/>
			<meta><m n=":noCompletion"/></meta>
		</texture2__>
		<get_texture2 get="inline" set="null" line="11">
			<f a=""><t path="hxsl.Sampler2D"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_texture2>
		<set_texture2 get="inline" set="null" line="11">
			<f a="_v">
				<t path="hxsl.Sampler2D"/>
				<t path="hxsl.Sampler2D"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_texture2>
		<texture3 public="1" get="accessor" set="accessor"><t path="hxsl.Sampler2D"/></texture3>
		<texture3__>
			<t path="hxsl.Sampler2D"/>
			<meta><m n=":noCompletion"/></meta>
		</texture3__>
		<get_texture3 get="inline" set="null" line="11">
			<f a=""><t path="hxsl.Sampler2D"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_texture3>
		<set_texture3 get="inline" set="null" line="11">
			<f a="_v">
				<t path="hxsl.Sampler2D"/>
				<t path="hxsl.Sampler2D"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_texture3>
		<texture4 public="1" get="accessor" set="accessor"><t path="hxsl.Sampler2D"/></texture4>
		<texture4__>
			<t path="hxsl.Sampler2D"/>
			<meta><m n=":noCompletion"/></meta>
		</texture4__>
		<get_texture4 get="inline" set="null" line="11">
			<f a=""><t path="hxsl.Sampler2D"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_texture4>
		<set_texture4 get="inline" set="null" line="11">
			<f a="_v">
				<t path="hxsl.Sampler2D"/>
				<t path="hxsl.Sampler2D"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_texture4>
		<texture5 public="1" get="accessor" set="accessor"><t path="hxsl.Sampler2D"/></texture5>
		<texture5__>
			<t path="hxsl.Sampler2D"/>
			<meta><m n=":noCompletion"/></meta>
		</texture5__>
		<get_texture5 get="inline" set="null" line="11">
			<f a=""><t path="hxsl.Sampler2D"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_texture5>
		<set_texture5 get="inline" set="null" line="11">
			<f a="_v">
				<t path="hxsl.Sampler2D"/>
				<t path="hxsl.Sampler2D"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_texture5>
		<texture6 public="1" get="accessor" set="accessor"><t path="hxsl.Sampler2D"/></texture6>
		<texture6__>
			<t path="hxsl.Sampler2D"/>
			<meta><m n=":noCompletion"/></meta>
		</texture6__>
		<get_texture6 get="inline" set="null" line="11">
			<f a=""><t path="hxsl.Sampler2D"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_texture6>
		<set_texture6 get="inline" set="null" line="11">
			<f a="_v">
				<t path="hxsl.Sampler2D"/>
				<t path="hxsl.Sampler2D"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_texture6>
		<texture7 public="1" get="accessor" set="accessor"><t path="hxsl.Sampler2D"/></texture7>
		<texture7__>
			<t path="hxsl.Sampler2D"/>
			<meta><m n=":noCompletion"/></meta>
		</texture7__>
		<get_texture7 get="inline" set="null" line="11">
			<f a=""><t path="hxsl.Sampler2D"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_texture7>
		<set_texture7 get="inline" set="null" line="11">
			<f a="_v">
				<t path="hxsl.Sampler2D"/>
				<t path="hxsl.Sampler2D"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_texture7>
		<updateConstants public="1" set="method" line="11" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="11" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="11" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="11" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="8"><f a=""><x path="Void"/></f></new>
		<haxe_doc>An s2d shader that allows binding up to 7 additional textures.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":src"><e>{
	@input var idxIn:{ var textureIndex : Float};
	var calculatedUV:Vec2;
	var textureColor:Vec4;
	@var var texIndex:Float;
	@param var texture1:Sampler2D;
	@param var texture2:Sampler2D;
	@param var texture3:Sampler2D;
	@param var texture4:Sampler2D;
	@param var texture5:Sampler2D;
	@param var texture6:Sampler2D;
	@param var texture7:Sampler2D;
	function __init__() {
		texIndex = idxIn.textureIndex;
	};
	function fragment() {
		var t0 = textureColor;
		var index = int(texIndex);
		if (index == 1) textureColor = texture1.get(calculatedUV) else if (index == 2) textureColor = texture2.get(calculatedUV) else if (index == 3) textureColor = texture3.get(calculatedUV) else if (index == 4) textureColor = texture4.get(calculatedUV) else if (index == 5) textureColor = texture5.get(calculatedUV) else if (index == 6) textureColor = texture6.get(calculatedUV) else if (index == 7) textureColor = texture7.get(calculatedUV) else textureColor = t0;
	};
}</e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="ch3.shader.PaletteShader" params="" file="./ch3/shader/PaletteShader.hx">
		<extends path="hxsl.Shader"/>
		<SRC expr="&quot;HXSLGGNoMy5zaGFkZXIuUGFsZXR0ZVNoYWRlcggBDFBBTEVUVEVfU0laRQECAAEAAAAAAAILVEVTVF9BUFBST1gCAgABAAAAAAADClRFU1RfQUxQSEECAgABAAAAAAAEB1NSQ19DT0wPBQwBAgAABQdEU1RfQ09MDwUMAQIAAAYMdGV4dHVyZUNvbG9yBQwEAAAHBnRlc3RlcQ4GAAAICGZyYWdtZW50DgYAAAIDBwIJAWEFDAQAAAoBYgUMBAAAAgUBCwICAgUBCwIDAgUBDQYOBg4GDgYOBg4GDgYOBggGAwoCCQUMAAADAQO7vdfZ33zbPQMDCgIKBQwAAAMCBgoGAAoCCQUMAAADAQO7vdfZ33zbPQMDCgIKBQwAAAMCAgYIBgMKAgkFDAQAAwEDu73X2d982z0DAwoCCgUMBAADAgIGCgYACgIJBQwEAAMBA7u919nffNs9AwMKAgoFDAQAAwICBggGAwoCCQUMCAADAQO7vdfZ33zbPQMDCgIKBQwIAAMCAgYKBgAKAgkFDAgAAwEDu73X2d982z0DAwoCCgUMCAADAgIGCAYDCgIJBQwMAAMBA7u919nffNs9AwMKAgoFDAwAAwICBgoGAAoCCQUMDAADAQO7vdfZ33zbPQMDCgIKBQwMAAMCAgAABQENBg4GDgYOBg4GDgYIBgMKAgkFDAAAAwEDu73X2d982z0DAwoCCgUMAAADAgYKBgAKAgkFDAAAAwEDu73X2d982z0DAwoCCgUMAAADAgIGCAYDCgIJBQwEAAMBA7u919nffNs9AwMKAgoFDAQAAwICBgoGAAoCCQUMBAADAQO7vdfZ33zbPQMDCgIKBQwEAAMCAgYIBgMKAgkFDAgAAwEDu73X2d982z0DAwoCCgUMCAADAgIGCgYACgIJBQwIAAMBA7u919nffNs9AwMKAgoFDAgAAwICAAAAAAUBCwIDAgUBDQYOBg4GDgYFCgIJBQwAAAMKAgoFDAAAAwIGBQoCCQUMBAADCgIKBQwEAAMCAgYFCgIJBQwIAAMKAgoFDAgAAwICBgUKAgkFDAwAAwoCCgUMDAADAgIAAAUBDQYOBg4GBQoCCQUMAAADCgIKBQwAAAMCBgUKAgkFDAQAAwoCCgUMBAADAgIGBQoCCQUMCAADCgIKBQwIAAMCAgAAAAAAAAEIAAAFAggLAnRjBQwEAAACBgUMAA4MAWkBBAAABhUBAgAAAAABAgEBDwEAAAUBCwkCBw4CAgsFDBECBA8FDAECDAEFDAIFAgsCAwIGBAIGBQwRAgUPBQwBAgwBBQwFDAYECgIGBQySAAULChECBQ8FDAECDAEFDJIABQsFCwAQAAAAAAAAAA&quot;" line="7" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"HXSLGGNoMy5zaGFkZXIuUGFsZXR0ZVNoYWRlcggBDFBBTEVUVEVfU0laRQECAAEAAAAAAAILVEVTVF9BUFBST1gCAgABAAAAAAADClRFU1RfQUxQSEECAgABAAAAAAAEB1NSQ19DT0wPBQwBAgAABQdEU1RfQ09MDwUMAQIAAAYMdGV4dHVyZUNvbG9yBQwEAAAHBnRlc3RlcQ4GAAAICGZyYWdtZW50DgYAAAIDBwIJAWEFDAQAAAoBYgUMBAAAAgUBCwICAgUBCwIDAgUBDQYOBg4GDgYOBg4GDgYOBggGAwoCCQUMAAADAQO7vdfZ33zbPQMDCgIKBQwAAAMCBgoGAAoCCQUMAAADAQO7vdfZ33zbPQMDCgIKBQwAAAMCAgYIBgMKAgkFDAQAAwEDu73X2d982z0DAwoCCgUMBAADAgIGCgYACgIJBQwEAAMBA7u919nffNs9AwMKAgoFDAQAAwICBggGAwoCCQUMCAADAQO7vdfZ33zbPQMDCgIKBQwIAAMCAgYKBgAKAgkFDAgAAwEDu73X2d982z0DAwoCCgUMCAADAgIGCAYDCgIJBQwMAAMBA7u919nffNs9AwMKAgoFDAwAAwICBgoGAAoCCQUMDAADAQO7vdfZ33zbPQMDCgIKBQwMAAMCAgAABQENBg4GDgYOBg4GDgYIBgMKAgkFDAAAAwEDu73X2d982z0DAwoCCgUMAAADAgYKBgAKAgkFDAAAAwEDu73X2d982z0DAwoCCgUMAAADAgIGCAYDCgIJBQwEAAMBA7u919nffNs9AwMKAgoFDAQAAwICBgoGAAoCCQUMBAADAQO7vdfZ33zbPQMDCgIKBQwEAAMCAgYIBgMKAgkFDAgAAwEDu73X2d982z0DAwoCCgUMCAADAgIGCgYACgIJBQwIAAMBA7u919nffNs9AwMKAgoFDAgAAwICAAAAAAUBCwIDAgUBDQYOBg4GDgYFCgIJBQwAAAMKAgoFDAAAAwIGBQoCCQUMBAADCgIKBQwEAAMCAgYFCgIJBQwIAAMKAgoFDAgAAwICBgUKAgkFDAwAAwoCCgUMDAADAgIAAAUBDQYOBg4GBQoCCQUMAAADCgIKBQwAAAMCBgUKAgkFDAQAAwoCCgUMBAADAgIGBQoCCQUMCAADCgIKBQwIAAMCAgAAAAAAAAEIAAAFAggLAnRjBQwEAAACBgUMAA4MAWkBBAAABhUBAgAAAAABAgEBDwEAAAUBCwkCBw4CAgsFDBECBA8FDAECDAEFDAIFAgsCAwIGBAIGBQwRAgUPBQwBAgwBBQwFDAYECgIGBQySAAULChECBQ8FDAECDAEFDJIABQsFCwAQAAAAAAAAAA"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<setPalette public="1" set="method" line="56"><f a="pal">
	<t path="Map">
		<x path="Int"/>
		<x path="Int"/>
	</t>
	<x path="Void"/>
</f></setPalette>
		<PALETTE_SIZE public="1" get="accessor" set="accessor"><x path="Int"/></PALETTE_SIZE>
		<PALETTE_SIZE__ expr="0">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":noCompletion"/>
			</meta>
		</PALETTE_SIZE__>
		<get_PALETTE_SIZE get="inline" set="null" line="7">
			<f a=""><x path="Int"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_PALETTE_SIZE>
		<set_PALETTE_SIZE get="inline" set="null" line="7">
			<f a="_v">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_PALETTE_SIZE>
		<TEST_APPROX public="1" get="accessor" set="accessor"><x path="Bool"/></TEST_APPROX>
		<TEST_APPROX__ expr="false">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n=":noCompletion"/>
			</meta>
		</TEST_APPROX__>
		<get_TEST_APPROX get="inline" set="null" line="7">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_TEST_APPROX>
		<set_TEST_APPROX get="inline" set="null" line="7">
			<f a="_v">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_TEST_APPROX>
		<TEST_ALPHA public="1" get="accessor" set="accessor"><x path="Bool"/></TEST_ALPHA>
		<TEST_ALPHA__ expr="false">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n=":noCompletion"/>
			</meta>
		</TEST_ALPHA__>
		<get_TEST_ALPHA get="inline" set="null" line="7">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_TEST_ALPHA>
		<set_TEST_ALPHA get="inline" set="null" line="7">
			<f a="_v">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_TEST_ALPHA>
		<SRC_COL public="1" get="accessor" set="accessor"><c path="Array"><t path="hxsl.Vec"/></c></SRC_COL>
		<SRC_COL__ expr="new Array()">
			<c path="Array"><t path="hxsl.Vec"/></c>
			<meta>
				<m n=":value"><e>new Array()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</SRC_COL__>
		<get_SRC_COL get="inline" set="null" line="7">
			<f a=""><c path="Array"><t path="hxsl.Vec"/></c></f>
			<meta><m n=":noCompletion"/></meta>
		</get_SRC_COL>
		<set_SRC_COL get="inline" set="null" line="7">
			<f a="_v">
				<c path="Array"><t path="hxsl.Vec"/></c>
				<c path="Array"><t path="hxsl.Vec"/></c>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_SRC_COL>
		<DST_COL public="1" get="accessor" set="accessor"><c path="Array"><t path="hxsl.Vec"/></c></DST_COL>
		<DST_COL__ expr="new Array()">
			<c path="Array"><t path="hxsl.Vec"/></c>
			<meta>
				<m n=":value"><e>new Array()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</DST_COL__>
		<get_DST_COL get="inline" set="null" line="7">
			<f a=""><c path="Array"><t path="hxsl.Vec"/></c></f>
			<meta><m n=":noCompletion"/></meta>
		</get_DST_COL>
		<set_DST_COL get="inline" set="null" line="7">
			<f a="_v">
				<c path="Array"><t path="hxsl.Vec"/></c>
				<c path="Array"><t path="hxsl.Vec"/></c>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_DST_COL>
		<updateConstants public="1" set="method" line="7" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="7" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="7" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="7" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="51"><f a="pal">
	<t path="Map">
		<x path="Int"/>
		<x path="Int"/>
	</t>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":src"><e><![CDATA[{
	@const @param var PALETTE_SIZE:Int;
	@const var TEST_APPROX:Bool = false;
	@const var TEST_ALPHA:Bool = false;
	@param var SRC_COL:Array<Vec4,PALETTE_SIZE>;
	@param var DST_COL:Array<Vec4,PALETTE_SIZE>;
	var textureColor:Vec4;
	function testeq(a:Vec4, b:Vec4):Bool {
		if (TEST_APPROX) {
			if (TEST_ALPHA) {
				return a.r - 1e-10 >= b.r && a.r + 1e-10 <= b.r && a.g - 1e-10 >= b.g && a.g + 1e-10 <= b.g && a.b - 1e-10 >= b.b && a.b + 1e-10 <= b.b && a.a - 1e-10 >= b.a && a.a + 1e-10 <= b.a;
			} else {
				return a.r - 1e-10 >= b.r && a.r + 1e-10 <= b.r && a.g - 1e-10 >= b.g && a.g + 1e-10 <= b.g && a.b - 1e-10 >= b.b && a.b + 1e-10 <= b.b;
			};
		} else {
			if (TEST_ALPHA) {
				return a.r == b.r && a.g == b.g && a.b == b.b && a.a == b.a;
			} else {
				return a.r == b.r && a.g == b.g && a.b == b.b;
			};
		};
	};
	function fragment() {
		var tc = textureColor;
		for (i  in  0 ... PALETTE_SIZE) {
			if (testeq(tc, SRC_COL[i])) {
				if (TEST_ALPHA) textureColor = DST_COL[i] else textureColor.rgb = DST_COL[i].rgb;
				break;
			};
		};
	};
}]]></e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="cherry.Ease" params="" file="./cherry/Ease.hx">
		<sineIn public="1" set="method" line="12" static="1">
			<f a="t">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Sine in.</haxe_doc>
		</sineIn>
		<sineOut public="1" set="method" line="18" static="1">
			<f a="t">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Sine out.</haxe_doc>
		</sineOut>
		<sineInOut public="1" set="method" line="24" static="1">
			<f a="t">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Sine in and out.</haxe_doc>
		</sineInOut>
		<quadIn public="1" set="method" line="30" static="1">
			<f a="t">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Quadratic in.</haxe_doc>
		</quadIn>
		<quadOut public="1" set="method" line="36" static="1">
			<f a="t">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Quadratic out.</haxe_doc>
		</quadOut>
		<quadInOut public="1" set="method" line="42" static="1">
			<f a="t">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Quadratic in and out.</haxe_doc>
		</quadInOut>
		<cubeIn public="1" set="method" line="48" static="1">
			<f a="t">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Cubic in.</haxe_doc>
		</cubeIn>
		<cubeOut public="1" set="method" line="54" static="1">
			<f a="t">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Cubic out.</haxe_doc>
		</cubeOut>
		<cubeInOut public="1" set="method" line="60" static="1">
			<f a="t">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Cubic in and out.</haxe_doc>
		</cubeInOut>
		<quartIn public="1" set="method" line="66" static="1">
			<f a="t">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Quart in.</haxe_doc>
		</quartIn>
		<quartOut public="1" set="method" line="72" static="1">
			<f a="t">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Quart out.</haxe_doc>
		</quartOut>
		<quartInOut public="1" set="method" line="78" static="1">
			<f a="t">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Quart in and out.</haxe_doc>
		</quartInOut>
		<quintIn public="1" set="method" line="84" static="1">
			<f a="t">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Quint in.</haxe_doc>
		</quintIn>
		<quintOut public="1" set="method" line="90" static="1">
			<f a="t">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Quint out.</haxe_doc>
		</quintOut>
		<quintInOut public="1" set="method" line="96" static="1">
			<f a="t">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Quint in and out.</haxe_doc>
		</quintInOut>
		<expoIn public="1" set="method" line="102" static="1">
			<f a="t">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Exponential in.</haxe_doc>
		</expoIn>
		<expoOut public="1" set="method" line="108" static="1">
			<f a="t">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Exponential out.</haxe_doc>
		</expoOut>
		<expoInOut public="1" set="method" line="114" static="1">
			<f a="t">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Exponential in and out.</haxe_doc>
		</expoInOut>
		<circIn public="1" set="method" line="120" static="1">
			<f a="t">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Circle in.</haxe_doc>
		</circIn>
		<circOut public="1" set="method" line="126" static="1">
			<f a="t">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Circle out.</haxe_doc>
		</circOut>
		<circInOut public="1" set="method" line="132" static="1">
			<f a="t">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Circle in and out.</haxe_doc>
		</circInOut>
		<backIn public="1" set="method" line="138" static="1">
			<f a="t">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Back in.</haxe_doc>
		</backIn>
		<backOut public="1" set="method" line="144" static="1">
			<f a="t">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Back out.</haxe_doc>
		</backOut>
		<backInOut public="1" set="method" line="150" static="1">
			<f a="t">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Back in and out.</haxe_doc>
		</backInOut>
		<bounceIn public="1" set="method" line="161" static="1">
			<f a="t">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Bounce in.</haxe_doc>
		</bounceIn>
		<bounceOut public="1" set="method" line="171" static="1">
			<f a="t">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Bounce out.</haxe_doc>
		</bounceOut>
		<bounceInOut public="1" set="method" line="180" static="1">
			<f a="t">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Bounce in and out.</haxe_doc>
		</bounceInOut>
		<PI get="accessor" set="null" static="1"><x path="Float"/></PI>
		<PI2 get="accessor" set="null" static="1"><x path="Float"/></PI2>
		<EL get="accessor" set="null" static="1"><x path="Float"/></EL>
		<B1 get="inline" set="null" expr="1 / 2.75" line="201" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1 / 2.75</e></m></meta>
		</B1>
		<B2 get="inline" set="null" expr="2 / 2.75" line="202" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>2 / 2.75</e></m></meta>
		</B2>
		<B3 get="inline" set="null" expr="1.5 / 2.75" line="203" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1.5 / 2.75</e></m></meta>
		</B3>
		<B4 get="inline" set="null" expr="2.5 / 2.75" line="204" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>2.5 / 2.75</e></m></meta>
		</B4>
		<B5 get="inline" set="null" expr="2.25 / 2.75" line="205" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>2.25 / 2.75</e></m></meta>
		</B5>
		<B6 get="inline" set="null" expr="2.625 / 2.75" line="206" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>2.625 / 2.75</e></m></meta>
		</B6>
		<get_PI get="inline" set="null" line="207" static="1"><f a=""><x path="Float"/></f></get_PI>
		<get_PI2 get="inline" set="null" line="208" static="1"><f a=""><x path="Float"/></f></get_PI2>
		<get_EL get="inline" set="null" line="209" static="1"><f a=""><x path="Float"/></f></get_EL>
		<haxe_doc>* Static class with useful easer functions that can be used by Tweens.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="cherry.EaseElastic" params="" file="./cherry/Ease.hx" module="cherry.Ease"/>
	<class path="cherry.EaseBack" params="" file="./cherry/Ease.hx" module="cherry.Ease">
		<cache expr="new Array()" line="269" static="1">
			<c path="Array"><c path="cherry.EaseBack"/></c>
			<meta><m n=":value"><e>new Array()</e></m></meta>
		</cache>
		<get public="1" set="method" line="270" static="1">
			<f a="?magnitude" v="1.70158">
				<x path="Float"/>
				<c path="cherry.EaseBack"/>
			</f>
			<meta><m n=":value"><e>{ magnitude : 1.70158 }</e></m></meta>
		</get>
		<magnitude final="1"><x path="Float"/></magnitude>
		<magnitude2 final="1"><x path="Float"/></magnitude2>
		<easeIn set="method" line="291">
			<f a="t">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Back in.</haxe_doc>
		</easeIn>
		<easeOut set="method" line="297">
			<f a="t">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Back out.</haxe_doc>
		</easeOut>
		<easeInOut set="method" line="303">
			<f a="t">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Back in and out.</haxe_doc>
		</easeInOut>
		<new set="method" line="284"><f a="magnitude">
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="cherry.Music" params="" file="./cherry/Music.hx">
		<current public="1" set="null" static="1"><c path="hxd.res.Sound"/></current>
		<channelGroup public="1" static="1"><c path="hxd.snd.ChannelGroup"/></channelGroup>
		<channel static="1"><c path="hxd.snd.Channel"/></channel>
		<FADE_TIME public="1" expr="0.4" line="12" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.4</e></m></meta>
		</FADE_TIME>
		<play public="1" set="method" line="14" static="1">
			<f a="res:?fade" v=":true">
				<c path="hxd.res.Sound"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ fade : true }</e></m></meta>
		</play>
		<transit public="1" set="method" line="32" static="1">
			<f a="res:jingle:?fadeCurrent:?fadeNew" v="::true:false">
				<c path="hxd.res.Sound"/>
				<c path="hxd.res.Sound"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ fadeNew : false, fadeCurrent : true }</e></m></meta>
		</transit>
		<jingle public="1" set="method" line="65" static="1">
			<f a="jingle:?fade" v=":true">
				<c path="hxd.res.Sound"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ fade : true }</e></m></meta>
		</jingle>
		<stop public="1" set="method" line="88" static="1">
			<f a="?fade" v="true">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ fade : true }</e></m></meta>
		</stop>
	</class>
	<class path="cherry.fmt.atl.AtlasData" params="" file="./cherry/fmt/atl/Data.hx" module="cherry.fmt.atl.Data">
		<texturePath public="1"><c path="String"/></texturePath>
		<texture public="1"><c path="h2d.Tile"/></texture>
		<anims public="1"><t path="Map">
	<c path="String"/>
	<c path="cherry.fmt.atl.AtlasAnim"/>
</t></anims>
		<names public="1"><t path="Map">
	<c path="String"/>
	<c path="cherry.fmt.atl.AtlasSprite"/>
</t></names>
		<sprites public="1"><c path="Array"><c path="cherry.fmt.atl.AtlasSprite"/></c></sprites>
		<get public="1" get="inline" set="null" line="23"><f a="name">
	<c path="String"/>
	<c path="cherry.fmt.atl.AtlasSprite"/>
</f></get>
		<getAnim public="1" get="inline" set="null" line="24"><f a="name">
	<c path="String"/>
	<c path="cherry.fmt.atl.AtlasAnim"/>
</f></getAnim>
		<getFrame public="1" get="inline" set="null" line="25"><f a="anim:index">
	<c path="String"/>
	<x path="Int"/>
	<c path="cherry.fmt.atl.AtlasSprite"/>
</f></getFrame>
		<getTile public="1" get="inline" set="null" line="27"><f a="name">
	<c path="String"/>
	<c path="h2d.Tile"/>
</f></getTile>
		<getAnimTiles public="1" get="inline" set="null" line="28"><f a="name">
	<c path="String"/>
	<c path="Array"><c path="h2d.Tile"/></c>
</f></getAnimTiles>
		<getAnimTile public="1" get="inline" set="null" line="29"><f a="anim:index">
	<c path="String"/>
	<x path="Int"/>
	<c path="h2d.Tile"/>
</f></getAnimTile>
		<addSprite public="1" set="method" line="32">
			<f a="s:?index" v=":-1">
				<c path="cherry.fmt.atl.AtlasSprite"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ index : -1 }</e></m>
				<m n=":noCompletion"/>
			</meta>
		</addSprite>
		<removeSprite public="1" set="method" line="58">
			<f a="s">
				<c path="cherry.fmt.atl.AtlasSprite"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</removeSprite>
		<renameSprite public="1" set="method" line="77">
			<f a="s:newId">
				<c path="cherry.fmt.atl.AtlasSprite"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</renameSprite>
		<renameAnim public="1" set="method" line="108">
			<f a="anim:newId">
				<c path="cherry.fmt.atl.AtlasAnim"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</renameAnim>
		<moveSprite public="1" set="method" line="129">
			<f a="s:newIndex">
				<c path="cherry.fmt.atl.AtlasSprite"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</moveSprite>
		<save public="1" set="method" line="152"><f a=""><a>
	<ver><x path="Int"/></ver>
	<texture><c path="String"/></texture>
	<sprites><c path="Array"><a>
	<y><x path="Int"/></y>
	<x><x path="Int"/></x>
	<width><x path="Int"/></width>
	<index><x path="Int"/></index>
	<id><c path="String"/></id>
	<height><x path="Int"/></height>
	<dy><x path="Float"/></dy>
	<dx><x path="Float"/></dx>
	<delay><x path="Float"/></delay>
</a></c></sprites>
	<anims><c path="Array"><a>
	<sprites><c path="Array"><x path="Int"/></c></sprites>
	<id><c path="String"/></id>
</a></c></anims>
</a></f></save>
		<load public="1" set="method" line="165"><f a="data">
	<d/>
	<x path="Void"/>
</f></load>
		<loadV0 get="inline" set="null" line="173"><f a="data:v">
	<d/>
	<x path="Int"/>
	<x path="Void"/>
</f></loadV0>
		<new public="1" set="method" line="17"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="cherry.fmt.atl.AtlasAnim" params="" file="./cherry/fmt/atl/Data.hx" module="cherry.fmt.atl.Data">
		<id public="1"><c path="String"/></id>
		<sprites public="1"><c path="Array"><c path="cherry.fmt.atl.AtlasSprite"/></c></sprites>
		<tiles public="1"><c path="Array"><c path="h2d.Tile"/></c></tiles>
		<length public="1" get="accessor" set="null"><x path="Int"/></length>
		<get_length get="inline" set="null" line="195"><f a=""><x path="Int"/></f></get_length>
		<makeFrames public="1" set="method" line="204"><f a=""><c path="Array"><c path="ch2.AnimationFrame"/></c></f></makeFrames>
		<makeAnimation public="1" set="method" line="208"><f a="?parent">
	<c path="h2d.Object"/>
	<c path="ch2.Animation"/>
</f></makeAnimation>
		<makeAnim public="1" set="method" line="212"><f a="speed:?parent">
	<x path="Float"/>
	<c path="h2d.Object"/>
	<c path="h2d.Anim"/>
</f></makeAnim>
		<syncTiles public="1" set="method" line="216">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</syncTiles>
		<new public="1" set="method" line="197"><f a="id:sprites">
	<c path="String"/>
	<c path="Array"><c path="cherry.fmt.atl.AtlasSprite"/></c>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="cherry.fmt.atl.AtlasSprite" params="" file="./cherry/fmt/atl/Data.hx" module="cherry.fmt.atl.Data">
		<load public="1" set="method" line="243" static="1"><f a="data:ver">
	<d/>
	<x path="Int"/>
	<c path="cherry.fmt.atl.AtlasSprite"/>
</f></load>
		<id public="1"><c path="String"/></id>
		<index public="1"><x path="Int"/></index>
		<x public="1"><x path="Int"/></x>
		<y public="1"><x path="Int"/></y>
		<width public="1"><x path="Int"/></width>
		<height public="1"><x path="Int"/></height>
		<originX public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</originX>
		<originY public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</originY>
		<delay public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</delay>
		<tile public="1"><c path="h2d.Tile"/></tile>
		<fid public="1" get="accessor" set="null"><c path="String"/></fid>
		<get_fid get="inline" set="null" line="241"><f a=""><c path="String"/></f></get_fid>
		<toFrame public="1" set="method" line="263">
			<f a="?isKey" v="true">
				<x path="Bool"/>
				<c path="ch2.AnimationFrame"/>
			</f>
			<meta><m n=":value"><e>{ isKey : true }</e></m></meta>
		</toFrame>
		<save public="1" set="method" line="267"><f a=""><a>
	<y><x path="Int"/></y>
	<x><x path="Int"/></x>
	<width><x path="Int"/></width>
	<index><x path="Int"/></index>
	<id><c path="String"/></id>
	<height><x path="Int"/></height>
	<dy><x path="Float"/></dy>
	<dx><x path="Float"/></dx>
	<delay><x path="Float"/></delay>
</a></f></save>
		<new public="1" set="method" line="258"><f a="id">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.fs.Convert" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fs/Convert.hx">
		<converts expr="new Map&lt;String,Array&lt;Convert&gt;&gt;()" line="58" static="1">
			<x path="haxe.ds.Map">
				<c path="String"/>
				<c path="Array"><c path="hxd.fs.Convert"/></c>
			</x>
			<meta><m n=":value"><e><![CDATA[new Map<String,Array<Convert>>()]]></e></m></meta>
		</converts>
		<register public="1" set="method" line="59" static="1"><f a="c">
	<c path="hxd.fs.Convert"/>
	<x path="Int"/>
</f></register>
		<sourceExts public="1" set="null"><c path="Array"><c path="String"/></c></sourceExts>
		<destExt public="1" set="null"><c path="String"/></destExt>
		<version public="1" set="null">
			<x path="Int"/>
			<haxe_doc>Major version of the Convert.
		When incremented, all files processed by this Convert would be rebuilt.</haxe_doc>
		</version>
		<params public="1"><d/></params>
		<srcPath public="1"><c path="String"/></srcPath>
		<dstPath public="1"><c path="String"/></dstPath>
		<originalFilename public="1"><c path="String"/></originalFilename>
		<srcBytes public="1"><c path="haxe.io.Bytes"/></srcBytes>
		<convert public="1" set="method" line="27"><f a=""><x path="Void"/></f></convert>
		<hasParam set="method" line="31"><f a="name">
	<c path="String"/>
	<x path="Bool"/>
</f></hasParam>
		<getParam set="method" line="36"><f a="name">
	<c path="String"/>
	<c path="String"/>
</f></getParam>
		<save set="method" line="42"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></save>
		<command set="method" line="46"><f a="cmd:args">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
	<x path="Void"/>
</f></command>
		<new public="1" set="method" line="21"><f a="sourceExts:destExt">
	<a><split set="null"><f a="">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
</f></split></a>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":keep"/>
			<m n=":keepSub"/>
		</meta>
	</class>
	<class path="cherry.fs.GifConvert" params="" file="./cherry/fs/Convert.hx" module="cherry.fs.Convert">
		<extends path="hxd.fs.Convert"/>
		<convert public="1" set="method" line="14" override="1"><f a=""><x path="Void"/></f></convert>
		<new public="1" set="method" line="9"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="cherry.fs.ManifestFileInfo" params="" file="./cherry/fs/ManifestBuilder.hx" module="cherry.fs.ManifestBuilder"><a>
	<path><c path="String"/></path>
	<original><c path="String"/></original>
</a></typedef>
	<class path="cherry.fs.ManifestBuilder" params="" file="./cherry/fs/ManifestBuilder.hx">
		<initManifest public="1" set="method" static="1"><f a="?basePath:?options:?storeManifest">
	<d/>
	<d/>
	<d/>
	<d/>
</f></initManifest>
		<generate public="1" set="method" static="1"><f a="?basePath:?options:?storeManifest">
	<d/>
	<d/>
	<d/>
	<d/>
</f></generate>
		<create public="1" set="method" static="1"><f a="?basePath:?options:?storeManifest">
	<d/>
	<d/>
	<d/>
	<d/>
</f></create>
	</class>
	<typedef path="cherry.fs.ManifestOptions" params="" file="./cherry/fs/ManifestBuilder.hx" module="cherry.fs.ManifestBuilder"><a><format>
	<x path="Null"><e path="cherry.fs.ManifestFormat"/></x>
	<meta><m n=":optional"/></meta>
</format></a></typedef>
	<enum path="cherry.fs.ManifestFormat" params="" file="./cherry/fs/ManifestBuilder.hx" module="cherry.fs.ManifestBuilder">
		<KeyValue/>
		<List/>
		<Serialized/>
		<Json/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="hxd.fs.FileEntry" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fs/FileEntry.hx">
		<name public="1" set="null"><c path="String"/></name>
		<path public="1" get="accessor" set="null"><c path="String"/></path>
		<directory public="1" get="accessor" set="null"><c path="String"/></directory>
		<extension public="1" get="accessor" set="null"><c path="String"/></extension>
		<size public="1" get="accessor" set="null"><x path="Int"/></size>
		<isDirectory public="1" get="accessor" set="null"><x path="Bool"/></isDirectory>
		<isAvailable public="1" get="accessor" set="null"><x path="Bool"/></isAvailable>
		<getSign public="1" set="method" line="14"><f a=""><x path="Int"/></f></getSign>
		<getBytes public="1" set="method" line="16"><f a=""><c path="haxe.io.Bytes"/></f></getBytes>
		<getText public="1" set="method" line="18"><f a=""><c path="String"/></f></getText>
		<open public="1" set="method" line="20"><f a=""><x path="Void"/></f></open>
		<skip public="1" set="method" line="21"><f a="nbytes">
	<x path="Int"/>
	<x path="Void"/>
</f></skip>
		<readByte public="1" set="method" line="22"><f a=""><x path="Int"/></f></readByte>
		<read public="1" set="method" line="23"><f a="out:pos:size">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></read>
		<close public="1" set="method" line="24"><f a=""><x path="Void"/></f></close>
		<load public="1" set="method" line="26"><f a="?onReady">
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></load>
		<loadBitmap public="1" set="method" line="27"><f a="onLoaded">
	<f a="">
		<x path="hxd.fs.LoadedBitmap"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></loadBitmap>
		<watch public="1" set="method" line="28"><f a="onChanged">
	<x path="Null"><f a=""><x path="Void"/></f></x>
	<x path="Void"/>
</f></watch>
		<exists public="1" set="method" line="29"><f a="name">
	<c path="String"/>
	<x path="Bool"/>
</f></exists>
		<get public="1" set="method" line="30"><f a="name">
	<c path="String"/>
	<c path="hxd.fs.FileEntry"/>
</f></get>
		<iterator public="1" set="method" line="32"><f a=""><c path="hxd.impl.ArrayIterator_hxd_fs_FileEntry"/></f></iterator>
		<get_isAvailable set="method" line="34"><f a=""><x path="Bool"/></f></get_isAvailable>
		<get_isDirectory set="method" line="35"><f a=""><x path="Bool"/></f></get_isDirectory>
		<get_size set="method" line="36"><f a=""><x path="Int"/></f></get_size>
		<get_path set="method" line="37"><f a=""><c path="String"/></f></get_path>
		<get_directory set="method" line="39"><f a=""><c path="String"/></f></get_directory>
		<get_extension set="method" line="45"><f a=""><c path="String"/></f></get_extension>
	</class>
	<class path="cherry.fs.ManifestEntry" params="" file="./cherry/fs/ManifestFileSystem.hx" module="cherry.fs.ManifestFileSystem">
		<extends path="hxd.fs.FileEntry"/>
		<fs><c path="cherry.fs.ManifestFileSystem"/></fs>
		<relPath><c path="String"/></relPath>
		<isDir><x path="Bool"/></isDir>
		<contents><c path="Array"><c path="cherry.fs.ManifestEntry"/></c></contents>
		<file><c path="String"/></file>
		<originalFile><c path="String"/></originalFile>
		<fio><c path="sys.io.FileInput"/></fio>
		<getSign public="1" set="method" line="46" override="1"><f a=""><x path="Int"/></f></getSign>
		<getBytes public="1" set="method" line="59" override="1"><f a=""><c path="haxe.io.Bytes"/></f></getBytes>
		<open public="1" set="method" line="68" override="1"><f a=""><x path="Void"/></f></open>
		<skip public="1" set="method" line="80" override="1"><f a="nbytes">
	<x path="Int"/>
	<x path="Void"/>
</f></skip>
		<readByte public="1" set="method" line="90" override="1"><f a=""><x path="Int"/></f></readByte>
		<read public="1" set="method" line="99" override="1"><f a="out:pos:size">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></read>
		<close public="1" set="method" line="109" override="1"><f a=""><x path="Void"/></f></close>
		<fancyLoad public="1" set="method" line="122"><f a="onReady:onProgress">
	<f a=""><x path="Void"/></f>
	<f a="cur:max">
		<x path="Int"/>
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></fancyLoad>
		<load public="1" set="method" line="141" override="1"><f a="?onReady">
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></load>
		<loadBitmap public="1" set="method" line="167" override="1"><f a="onLoaded">
	<f a="">
		<x path="hxd.fs.LoadedBitmap"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></loadBitmap>
		<exists public="1" set="method" line="183" override="1"><f a="name">
	<c path="String"/>
	<x path="Bool"/>
</f></exists>
		<get public="1" set="method" line="188" override="1"><f a="name">
	<c path="String"/>
	<c path="hxd.fs.FileEntry"/>
</f></get>
		<_exists set="method" line="193"><f a="name">
	<c path="String"/>
	<x path="Bool"/>
</f></_exists>
		<_get set="method" line="202"><f a="name">
	<c path="String"/>
	<c path="cherry.fs.ManifestEntry"/>
</f></_get>
		<iterator public="1" set="method" line="211" override="1"><f a=""><c path="hxd.impl.ArrayIterator_hxd_fs_FileEntry"/></f></iterator>
		<get_isDirectory set="method" line="225" override="1"><f a=""><x path="Bool"/></f></get_isDirectory>
		<get_path set="method" line="230" override="1"><f a=""><c path="String"/></f></get_path>
		<get_size set="method" line="235" override="1"><f a=""><x path="Int"/></f></get_size>
		<dispose set="method" line="244"><f a=""><x path="Void"/></f></dispose>
		<new public="1" set="method" line="32"><f a="fs:name:relPath:file:?originalFile">
	<c path="cherry.fs.ManifestFileSystem"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>cherry.fs.ManifestFileSystem</e></m>
		</meta>
	</class>
	<class path="hxd.fs.FileSystem" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fs/FileSystem.hx" interface="1">
		<getRoot public="1" set="method"><f a=""><c path="hxd.fs.FileEntry"/></f></getRoot>
		<get public="1" set="method"><f a="path">
	<c path="String"/>
	<c path="hxd.fs.FileEntry"/>
</f></get>
		<exists public="1" set="method"><f a="path">
	<c path="String"/>
	<x path="Bool"/>
</f></exists>
		<dispose public="1" set="method"><f a=""><x path="Void"/></f></dispose>
		<dir public="1" set="method"><f a="path">
	<c path="String"/>
	<c path="Array"><c path="hxd.fs.FileEntry"/></c>
</f></dir>
	</class>
	<class path="cherry.fs.ManifestFileSystem" params="" file="./cherry/fs/ManifestFileSystem.hx">
		<implements path="hxd.fs.FileSystem"/>
		<baseDir><c path="String"/></baseDir>
		<manifest public="1"><t path="Map">
	<c path="String"/>
	<c path="cherry.fs.ManifestEntry"/>
</t></manifest>
		<root><c path="cherry.fs.ManifestEntry"/></root>
		<getRoot public="1" set="method" line="338"><f a=""><c path="hxd.fs.FileEntry"/></f></getRoot>
		<splitPath set="method" line="343"><f a="path">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
</f></splitPath>
		<find set="method" line="348"><f a="path">
	<c path="String"/>
	<c path="cherry.fs.ManifestEntry"/>
</f></find>
		<exists public="1" set="method" line="359"><f a="path">
	<c path="String"/>
	<x path="Bool"/>
</f></exists>
		<get public="1" set="method" line="363"><f a="path">
	<c path="String"/>
	<c path="cherry.fs.ManifestEntry"/>
</f></get>
		<dispose public="1" set="method" line="370"><f a=""><x path="Void"/></f></dispose>
		<dir public="1" set="method" line="375"><f a="path">
	<c path="String"/>
	<c path="Array"><c path="hxd.fs.FileEntry"/></c>
</f></dir>
		<new public="1" set="method" line="267"><f a="dir:_manifest">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="cherry.macro.ClassExtensionTools" params="" file="./cherry/macro/ClassExtensionTools.hx"/>
	<class path="cherry.macro.Extensions" params="" file="./cherry/macro/Extensions.hx"/>
	<class path="cherry.macro.Helper" params="" file="./cherry/macro/Helper.hx"/>
	<class path="cherry.plugins.generic.shaders.CheckerShader" params="" file="./cherry/plugins/generic/shaders/CheckerShader.hx">
		<extends path="hxsl.Shader"/>
		<SRC expr="&quot;HXSLLGNoZXJyeS5wbHVnaW5zLmdlbmVyaWMuc2hhZGVycy5DaGVja2VyU2hhZGVyBgELY2hlY2tlclNpemUDAgAAAgpibGFja0NvbG9yBQwCAAADCndoaXRlQ29sb3IFDAIAAAQKcGl4ZWxDb2xvcgUMBAAABQxjYWxjdWxhdGVkVVYFCgMAAAYIZnJhZ21lbnQOBgAAAQEGAAAFBAgHBHR2ZWMFCgQAAAYCAgUFCgIBAwUKAAgIBWJsYWNrAgQAAAYJBAYTCgIHBQoAAAMBAwAAAAAAAABAAwMDAQMAAAAAAADwPwMCAAsGCQQGEwoCBwUKBAADAQMAAAAAAAAAQAMDAwEDAAAAAAAA8D8DAgYEAggCBwICCAICAgAACwIIAgUCBgQKAgQFDJIABQsKAgIFDJIABQsFCwaBCgIEBQwMAAMKAgIFDAwAAwMABQIGBAoCBAUMkgAFCwoCAwUMkgAFCwULBoEKAgQFDAwAAwoCAwUMDAADAwAAAA&quot;" line="5" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"HXSLLGNoZXJyeS5wbHVnaW5zLmdlbmVyaWMuc2hhZGVycy5DaGVja2VyU2hhZGVyBgELY2hlY2tlclNpemUDAgAAAgpibGFja0NvbG9yBQwCAAADCndoaXRlQ29sb3IFDAIAAAQKcGl4ZWxDb2xvcgUMBAAABQxjYWxjdWxhdGVkVVYFCgMAAAYIZnJhZ21lbnQOBgAAAQEGAAAFBAgHBHR2ZWMFCgQAAAYCAgUFCgIBAwUKAAgIBWJsYWNrAgQAAAYJBAYTCgIHBQoAAAMBAwAAAAAAAABAAwMDAQMAAAAAAADwPwMCAAsGCQQGEwoCBwUKBAADAQMAAAAAAAAAQAMDAwEDAAAAAAAA8D8DAgYEAggCBwICCAICAgAACwIIAgUCBgQKAgQFDJIABQsKAgIFDJIABQsFCwaBCgIEBQwMAAMKAgIFDAwAAwMABQIGBAoCBAUMkgAFCwoCAwUMkgAFCwULBoEKAgQFDAwAAwoCAwUMDAADAwAAAA"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<checkerSize public="1" get="accessor" set="accessor"><x path="Float"/></checkerSize>
		<checkerSize__ expr="8">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>8</e></m>
				<m n=":noCompletion"/>
			</meta>
		</checkerSize__>
		<get_checkerSize get="inline" set="null" line="5">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_checkerSize>
		<set_checkerSize get="inline" set="null" line="5">
			<f a="_v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_checkerSize>
		<blackColor public="1" get="accessor" set="accessor"><t path="hxsl.Vec"/></blackColor>
		<blackColor__ expr="new hxsl.Types.Vec()">
			<t path="hxsl.Vec"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Vec()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</blackColor__>
		<get_blackColor get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Vec"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_blackColor>
		<set_blackColor get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Vec"/>
				<t path="hxsl.Vec"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_blackColor>
		<whiteColor public="1" get="accessor" set="accessor"><t path="hxsl.Vec"/></whiteColor>
		<whiteColor__ expr="new hxsl.Types.Vec()">
			<t path="hxsl.Vec"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Vec()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</whiteColor__>
		<get_whiteColor get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Vec"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_whiteColor>
		<set_whiteColor get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Vec"/>
				<t path="hxsl.Vec"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_whiteColor>
		<updateConstants public="1" set="method" line="5" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="5" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="28"><f a="?white:?black">
	<c path="h3d.Vector"/>
	<c path="h3d.Vector"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":src"><e><![CDATA[{
	@param var checkerSize:Float = 8;
	@param var blackColor:Vec4;
	@param var whiteColor:Vec4;
	var pixelColor:Vec4;
	@var var calculatedUV:Vec2;
	function fragment() {
		var tvec = calculatedUV / checkerSize;
		var black = (tvec.x % 2) < 1;
		if ((tvec.y % 2) < 1) black = !black;
		if (black) {
			pixelColor.rgb = blackColor.rgb;
			pixelColor.a *= blackColor.a;
		} else {
			pixelColor.rgb = whiteColor.rgb;
			pixelColor.a *= whiteColor.a;
		};
	};
}]]></e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="cherry.plugins.generic.shaders.OutlineShader" params="" file="./cherry/plugins/generic/shaders/OutlineShader.hx">
		<extends path="hxsl.Shader"/>
		<SRC expr="&quot;HXSLLGNoZXJyeS5wbHVnaW5zLmdlbmVyaWMuc2hhZGVycy5PdXRsaW5lU2hhZGVyDAEEdGltZQMAAAACDG91dGxpbmVDb2xvcgUMAgAAAwtjaGVja2VyU2l6ZQMCAAAEBXNwZWVkAwIAAAUKYmxhY2tDb2xvcgUMAgAABgp3aGl0ZUNvbG9yBQwCAAAHB2FuaW1hdGUCAgABAAAAAAAICGFic29sdXRlAgIAAQAAAAAACQpwaXhlbENvbG9yBQwEAAAKEGFic29sdXRlUG9zaXRpb24FDAQAAAsOc3ByaXRlUG9zaXRpb24FDAQAAAwIZnJhZ21lbnQOBgAAAQEMAAAFAQsGDgYOBgUKAgkFDAAAAwoCAgUMAAADAgYFCgIJBQwEAAMKAgIFDAQAAwICBgUKAgkFDAgAAwoCAgUMCAADAgIFAggNBHR2ZWMFCgQAAAYCBAYDBAsCCAIKAgoFDBEABQoKAgsFDBEABQoFCgUKBAsCBwIGAQIBAwIEAwMBAwAAAAAAAAAAAwMDBQoFCgkDKA4CAgMDAgMDBQoFCgALBgkEBhMEBgAKAg0FCgAAAwoCDQUKBAADAwMBAwAAAAAAAABAAwMDAQMAAAAAAADwPwMCBQIGBAoCCQUMkgAFCwoCBQUMkgAFCwULBoEKAgkFDAwAAwoCBQUMDAADAwAFAgYECgIJBQySAAULCgIGBQySAAULBQsGgQoCCQUMDAADCgIGBQwMAAMDAAAAAAAA&quot;" line="5" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"HXSLLGNoZXJyeS5wbHVnaW5zLmdlbmVyaWMuc2hhZGVycy5PdXRsaW5lU2hhZGVyDAEEdGltZQMAAAACDG91dGxpbmVDb2xvcgUMAgAAAwtjaGVja2VyU2l6ZQMCAAAEBXNwZWVkAwIAAAUKYmxhY2tDb2xvcgUMAgAABgp3aGl0ZUNvbG9yBQwCAAAHB2FuaW1hdGUCAgABAAAAAAAICGFic29sdXRlAgIAAQAAAAAACQpwaXhlbENvbG9yBQwEAAAKEGFic29sdXRlUG9zaXRpb24FDAQAAAsOc3ByaXRlUG9zaXRpb24FDAQAAAwIZnJhZ21lbnQOBgAAAQEMAAAFAQsGDgYOBgUKAgkFDAAAAwoCAgUMAAADAgYFCgIJBQwEAAMKAgIFDAQAAwICBgUKAgkFDAgAAwoCAgUMCAADAgIFAggNBHR2ZWMFCgQAAAYCBAYDBAsCCAIKAgoFDBEABQoKAgsFDBEABQoFCgUKBAsCBwIGAQIBAwIEAwMBAwAAAAAAAAAAAwMDBQoFCgkDKA4CAgMDAgMDBQoFCgALBgkEBhMEBgAKAg0FCgAAAwoCDQUKBAADAwMBAwAAAAAAAABAAwMDAQMAAAAAAADwPwMCBQIGBAoCCQUMkgAFCwoCBQUMkgAFCwULBoEKAgkFDAwAAwoCBQUMDAADAwAFAgYECgIJBQySAAULCgIGBQySAAULBQsGgQoCCQUMDAADCgIGBQwMAAMDAAAAAAAA"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<outlineColor public="1" get="accessor" set="accessor"><t path="hxsl.Vec"/></outlineColor>
		<outlineColor__ expr="new hxsl.Types.Vec()">
			<t path="hxsl.Vec"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Vec()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</outlineColor__>
		<get_outlineColor get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Vec"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_outlineColor>
		<set_outlineColor get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Vec"/>
				<t path="hxsl.Vec"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_outlineColor>
		<checkerSize public="1" get="accessor" set="accessor"><x path="Float"/></checkerSize>
		<checkerSize__ expr="6">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>6</e></m>
				<m n=":noCompletion"/>
			</meta>
		</checkerSize__>
		<get_checkerSize get="inline" set="null" line="5">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_checkerSize>
		<set_checkerSize get="inline" set="null" line="5">
			<f a="_v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_checkerSize>
		<speed public="1" get="accessor" set="accessor"><x path="Float"/></speed>
		<speed__ expr="5">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>5</e></m>
				<m n=":noCompletion"/>
			</meta>
		</speed__>
		<get_speed get="inline" set="null" line="5">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_speed>
		<set_speed get="inline" set="null" line="5">
			<f a="_v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_speed>
		<blackColor public="1" get="accessor" set="accessor"><t path="hxsl.Vec"/></blackColor>
		<blackColor__ expr="new hxsl.Types.Vec()">
			<t path="hxsl.Vec"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Vec()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</blackColor__>
		<get_blackColor get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Vec"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_blackColor>
		<set_blackColor get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Vec"/>
				<t path="hxsl.Vec"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_blackColor>
		<whiteColor public="1" get="accessor" set="accessor"><t path="hxsl.Vec"/></whiteColor>
		<whiteColor__ expr="new hxsl.Types.Vec()">
			<t path="hxsl.Vec"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Vec()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</whiteColor__>
		<get_whiteColor get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Vec"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_whiteColor>
		<set_whiteColor get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Vec"/>
				<t path="hxsl.Vec"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_whiteColor>
		<animate public="1" get="accessor" set="accessor"><x path="Bool"/></animate>
		<animate__ expr="true">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>true</e></m>
				<m n=":noCompletion"/>
			</meta>
		</animate__>
		<get_animate get="inline" set="null" line="5">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_animate>
		<set_animate get="inline" set="null" line="5">
			<f a="_v">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_animate>
		<absolute public="1" get="accessor" set="accessor"><x path="Bool"/></absolute>
		<absolute__ expr="false">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n=":noCompletion"/>
			</meta>
		</absolute__>
		<get_absolute get="inline" set="null" line="5">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_absolute>
		<set_absolute get="inline" set="null" line="5">
			<f a="_v">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_absolute>
		<updateConstants public="1" set="method" line="5" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="5" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="35"><f a="?white:?black">
	<c path="h3d.Vector"/>
	<c path="h3d.Vector"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":src"><e><![CDATA[{
	@global var time:Float;
	@param var outlineColor:Vec4;
	@param var checkerSize:Float = 6;
	@param var speed:Float = 5;
	@param var blackColor:Vec4;
	@param var whiteColor:Vec4;
	@const var animate:Bool = true;
	@const var absolute:Bool = false;
	var pixelColor:Vec4;
	var absolutePosition:Vec4;
	var spritePosition:Vec4;
	function fragment() {
		if (pixelColor.r == outlineColor.r && pixelColor.g == outlineColor.g && pixelColor.b == outlineColor.b) {
			var tvec = ((absolute ? absolutePosition.xy : spritePosition.xy) - (animate ? time * speed : 0)) / vec2(checkerSize, checkerSize);
			if (((tvec.x + tvec.y) % 2) < 1) {
				pixelColor.rgb = blackColor.rgb;
				pixelColor.a *= blackColor.a;
			} else {
				pixelColor.rgb = whiteColor.rgb;
				pixelColor.a *= whiteColor.a;
			};
		};
	};
}]]></e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="hxd.res.Resource" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/res/Resource.hx">
		<LIVE_UPDATE public="1" expr="false" line="5" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</LIVE_UPDATE>
		<name public="1" get="accessor" set="null"><c path="String"/></name>
		<entry public="1" set="null"><c path="hxd.fs.FileEntry"/></entry>
		<get_name get="inline" set="null" line="14"><f a=""><c path="String"/></f></get_name>
		<toString set="method" line="18"><f a=""><c path="String"/></f></toString>
		<watch public="1" set="method" line="22"><f a="onChanged">
	<x path="Null"><f a=""><x path="Void"/></f></x>
	<x path="Void"/>
</f></watch>
		<new public="1" set="method" line="10"><f a="entry">
	<c path="hxd.fs.FileEntry"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="cherry.res.AtlAtlas" params="" file="./cherry/res/AtlAtlas.hx">
		<extends path="hxd.res.Resource"/>
		<ENABLE_AUTO_WATCH expr="true" line="15" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</ENABLE_AUTO_WATCH>
		<library><c path="cherry.fmt.atl.AtlasData"/></library>
		<toAtlas public="1" set="method" line="17"><f a=""><c path="cherry.fmt.atl.AtlasData"/></f></toAtlas>
		<updateAtlas set="method" line="28"><f a=""><x path="Void"/></f></updateAtlas>
		<new public="1" set="method" line="11"><f a="entry">
	<c path="hxd.fs.FileEntry"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":access"><e>h2d.Tile</e></m></meta>
	</class>
	<class path="hxd.fs.FileConverter" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fs/FileConverter.hx">
		<extraConfigs expr="[]" line="37" static="1">
			<c path="Array"><d/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</extraConfigs>
		<addConfig public="1" set="method" line="57" static="1">
			<f a="conf">
				<d/>
				<unknown/>
			</f>
			<haxe_doc>Add extra convert configuration. Should be props.json-compatible structure.  
		Can be used to add or override converts that are enabled by default.  
		Sample code of Convert registration and enabling it by default:
		```haxe
		// Register Convert
		static var _ = hxd.fs.Convert.register(new MyFancyConvert());
		// Enable it
		static var __ = hxd.fs.FileConverter.addConfig({
			"fs.convert": {
				// Converts are identified by output extension of Convert.
				"origext": { convert: "fancyext", priority: 0 },
				// Shorter declaration with default priority 0:
				"otherext": "fancyext"
			}
		});
		```</haxe_doc>
		</addConfig>
		<sortByRulePiority set="method" line="107" static="1"><f a="r1:r2">
	<t path="hxd.fs.ConvertRule"/>
	<t path="hxd.fs.ConvertRule"/>
	<x path="Int"/>
</f></sortByRulePiority>
		<configuration public="1" set="null"><c path="String"/></configuration>
		<baseDir><c path="String"/></baseDir>
		<tmpDir><c path="String"/></tmpDir>
		<configs expr="new Map()">
			<t path="Map">
				<c path="String"/>
				<t path="hxd.fs.ConvertConfig"/>
			</t>
			<meta><m n=":value"><e>new Map()</e></m></meta>
		</configs>
		<defaultConfig><t path="hxd.fs.ConvertConfig"/></defaultConfig>
		<cache><t path="Map">
	<c path="String"/>
	<c path="Array"><a>
	<ver><x path="Null"><x path="Int"/></x></ver>
	<time><x path="Int"/></time>
	<out><c path="String"/></out>
	<hash><c path="String"/></hash>
</a></c>
</t></cache>
		<onConvert public="1" set="dynamic" line="79"><f a="c">
	<c path="hxd.fs.Convert"/>
	<x path="Void"/>
</f></onConvert>
		<makeConfig set="method" line="82"><f a="obj">
	<d/>
	<t path="hxd.fs.ConvertConfig"/>
</f></makeConfig>
		<loadConvert set="method" line="113"><f a="name">
	<c path="String"/>
	<x path="Null"><c path="Array"><c path="hxd.fs.Convert"/></c></x>
</f></loadConvert>
		<makeCommmand set="method" line="120"><f a="obj">
	<d/>
	<a>
		<priority><x path="Int"/></priority>
		<cmd><t path="hxd.fs.ConvertCommand"/></cmd>
	</a>
</f></makeCommmand>
		<mergeRec set="method" line="147"><f a="a:b">
	<d/>
	<d/>
	<a/>
</f></mergeRec>
		<getFileTime set="method" line="167"><f a="filePath">
	<c path="String"/>
	<x path="Float"/>
</f></getFileTime>
		<loadConfig set="method" line="171"><f a="dir">
	<c path="String"/>
	<t path="hxd.fs.ConvertConfig"/>
</f></loadConfig>
		<getConvertRule set="method" line="189"><f a="path">
	<c path="String"/>
	<t path="hxd.fs.ConvertRule"/>
</f></getConvertRule>
		<run public="1" set="method" line="205"><f a="e">
	<c path="hxd.fs.LocalEntry"/>
	<x path="Void"/>
</f></run>
		<runConvert set="method" line="217">
			<f a="e:cmd:?replaceExt" v="::false">
				<c path="hxd.fs.LocalEntry"/>
				<t path="hxd.fs.ConvertCommand"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ replaceExt : false }</e></m></meta>
		</runConvert>
		<convertAndCache set="method" line="253"><f a="e:outFile:conv:params">
	<c path="hxd.fs.LocalEntry"/>
	<c path="String"/>
	<c path="hxd.fs.Convert"/>
	<d/>
	<x path="Void"/>
</f></convertAndCache>
		<new public="1" set="method" line="62"><f a="baseDir:configuration">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="cherry.res.GifImage" params="" file="./cherry/res/GifImage.hx">
		<extends path="hxd.res.Resource"/>
		<_ expr="hxd.fs.Convert.register(new cherry.fs.Convert.GifConvert())" line="52" static="1">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>hxd.fs.Convert.register(new cherry.fs.Convert.GifConvert())</e></m>
				<m n=":keep"/>
			</meta>
		</_>
		<__ expr="hxd.fs.FileConverter.addConfig({ &quot;fs.convert&quot; : { &quot;gif&quot; : &quot;giff&quot; } })" line="53" static="1">
			<unknown/>
			<meta>
				<m n=":value"><e>hxd.fs.FileConverter.addConfig({ "fs.convert" : { "gif" : "giff" } })</e></m>
				<m n=":keep"/>
			</meta>
		</__>
		<toImage public="1" set="method" line="17">
			<f a=""><c path="hxd.res.Image"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>Returns Image resource of gif spritesheet.</haxe_doc>
		</toImage>
		<toFrames public="1" set="method" line="25">
			<f a=""><c path="Array"><c path="ch2.AnimationFrame"/></c></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>Returns list of animation frames containing full gif animation.</haxe_doc>
		</toFrames>
		<toAnimation public="1" get="inline" set="null" line="47">
			<f a="?parent">
				<c path="h2d.Object"/>
				<c path="ch2.Animation"/>
			</f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>Returns an Animation object with frames contained in gif file.</haxe_doc>
		</toAnimation>
		<new public="1" set="method" line="12"><f a="entry">
	<c path="hxd.fs.FileEntry"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>A .gif image resource.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="hxd.res.Loader" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/res/Loader.hx">
		<currentInstance public="1" static="1">
			<c path="hxd.res.Loader"/>
			<haxe_doc>Set when initializing hxd.Res, or manually.
		Allows code to resolve resources without compiling hxd.Res</haxe_doc>
		</currentInstance>
		<fs public="1" set="null"><c path="hxd.fs.FileSystem"/></fs>
		<cache><t path="Map">
	<c path="String"/>
	<d/>
</t></cache>
		<cleanCache public="1" set="method" line="19"><f a=""><x path="Void"/></f></cleanCache>
		<dir public="1" set="method" line="23"><f a="path">
	<c path="String"/>
	<c path="Array"><c path="hxd.res.Any"/></c>
</f></dir>
		<exists public="1" set="method" line="31"><f a="path">
	<c path="String"/>
	<x path="Bool"/>
</f></exists>
		<load public="1" set="method" line="35"><f a="path">
	<c path="String"/>
	<c path="hxd.res.Any"/>
</f></load>
		<loadCache public="1" params="T" set="method" line="39"><f a="path:c">
	<c path="String"/>
	<x path="Class"><c path="loadCache.T"/></x>
	<c path="loadCache.T"/>
</f></loadCache>
		<dispose public="1" set="method" line="55"><f a=""><x path="Void"/></f></dispose>
		<new public="1" set="method" line="14"><f a="fs">
	<c path="hxd.fs.FileSystem"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="cherry.res.ManifestLoader" params="" file="./cherry/res/ManifestLoader.hx">
		<extends path="hxd.res.Loader"/>
		<concurrentFiles public="1" expr="1" line="12" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
			<haxe_doc>Amount of concurrent file loadings. Defaults to 4 on JS and to 1 native (since there's no threaded loading implemented for native)</haxe_doc>
		</concurrentFiles>
		<mfs public="1"><c path="cherry.fs.ManifestFileSystem"/></mfs>
		<totalFiles public="1" set="null"><x path="Int"/></totalFiles>
		<loadedFiles public="1" set="null"><x path="Int"/></loadedFiles>
		<loading public="1" set="null"><x path="Bool"/></loading>
		<entries><t path="Iterator"><c path="cherry.fs.ManifestEntry"/></t></entries>
		<current><c path="cherry.fs.ManifestEntry"/></current>
		<tasks public="1">
			<c path="Array"><c path="cherry.res.LoaderTask"/></c>
			<haxe_doc>List of loading tasks used during loading.</haxe_doc>
		</tasks>
		<loadManifestFiles public="1" set="method" line="37"><f a=""><x path="Void"/></f></loadManifestFiles>
		<next set="method" line="53"><f a="task">
	<c path="cherry.res.LoaderTask"/>
	<x path="Void"/>
</f></next>
		<onFileLoadStarted public="1" set="dynamic" line="68"><f a="task">
	<c path="cherry.res.LoaderTask"/>
	<x path="Void"/>
</f></onFileLoadStarted>
		<onFileProgress public="1" set="dynamic" line="74"><f a="task">
	<c path="cherry.res.LoaderTask"/>
	<x path="Void"/>
</f></onFileProgress>
		<onFileLoaded public="1" set="dynamic" line="80"><f a="task">
	<c path="cherry.res.LoaderTask"/>
	<x path="Void"/>
</f></onFileLoaded>
		<onLoaded public="1" set="dynamic" line="85"><f a=""><x path="Void"/></f></onLoaded>
		<new public="1" set="method" line="27"><f a="fs">
	<c path="cherry.fs.ManifestFileSystem"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>hxd.res.ManifestLoader.LoaderTask</e></m>
		</meta>
	</class>
	<class path="cherry.res.LoaderTask" params="" file="./cherry/res/ManifestLoader.hx" module="cherry.res.ManifestLoader">
		<entry public="1" set="null"><c path="cherry.fs.ManifestEntry"/></entry>
		<slot public="1" set="null">
			<x path="Int"/>
			<haxe_doc>Loading slot occupied by this task</haxe_doc>
		</slot>
		<loaded public="1" set="null"><x path="Int"/></loaded>
		<total public="1" set="null"><x path="Int"/></total>
		<owner public="1" set="null"><c path="cherry.res.ManifestLoader"/></owner>
		<busy public="1" set="null"><x path="Bool"/></busy>
		<load public="1" set="method" line="109"><f a="entry">
	<c path="cherry.fs.ManifestEntry"/>
	<x path="Void"/>
</f></load>
		<ready set="method" line="119"><f a=""><x path="Void"/></f></ready>
		<progress set="method" line="125"><f a="l:t">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></progress>
		<new set="method" line="103"><f a="slot:owner">
	<x path="Int"/>
	<c path="cherry.res.ManifestLoader"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="cherry.res.TiledMapData" params="" file="./cherry/res/TiledMapFile.hx" module="cherry.res.TiledMapFile">
		<tmx public="1"><c path="format.tmx.TmxMap"/></tmx>
		<tilesets public="1">
			<c path="Array"><c path="cherry.res.TiledMapTileset"/></c>
			<haxe_doc>Optional list of loaded tilesets when loading map with `loadTilesets = true`.</haxe_doc>
		</tilesets>
		<getTileset public="1" set="method" line="18"><f a="gid">
	<x path="Int"/>
	<c path="cherry.res.TiledMapTileset"/>
</f></getTileset>
		<getTile public="1" set="method" line="34"><f a="gid">
	<x path="Int"/>
	<c path="h2d.Tile"/>
</f></getTile>
		<new public="1" set="method" line="13">
			<f a="tmx:tilesets">
				<c path="format.tmx.TmxMap"/>
				<c path="Array"><c path="cherry.res.TiledMapTileset"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":compilerGenerated"/></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="cherry.res.TiledMapTileset" params="" file="./cherry/res/TiledMapFile.hx" module="cherry.res.TiledMapFile">
		<tileset public="1"><c path="format.tmx.TmxTileset"/></tileset>
		<tiles public="1">
			<c path="Array"><c path="h2d.Tile"/></c>
			<haxe_doc>List of all tiles in the tileset.
    Note that they are not guaranteed to share the same texture, if tileset is an image set.</haxe_doc>
		</tiles>
		<tileByGid public="1" get="inline" set="null" line="60"><f a="gid">
	<x path="Int"/>
	<c path="h2d.Tile"/>
</f></tileByGid>
		<new public="1" set="method" line="52">
			<f a="tileset:tiles">
				<c path="format.tmx.TmxTileset"/>
				<c path="Array"><c path="h2d.Tile"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":compilerGenerated"/></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="cherry.res.TiledMapFile" params="" file="./cherry/res/TiledMapFile.hx">
		<extends path="hxd.res.Resource"/>
		<tsxCache expr="[]" line="71" static="1">
			<t path="Map">
				<c path="String"/>
				<c path="format.tmx.TmxTileset"/>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
		</tsxCache>
		<tilesetCache expr="[]" line="72" static="1">
			<t path="Map">
				<c path="String"/>
				<c path="Array"><c path="h2d.Tile"/></c>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
		</tilesetCache>
		<reader><c path="format.tmx.Reader"/></reader>
		<toMap public="1" set="method" line="78">
			<f a="?resolveTsx:?loadTilesets:?objectTypes" v="true:true:">
				<x path="Bool"/>
				<x path="Bool"/>
				<t path="Map">
					<c path="String"/>
					<c path="format.tmx.TmxObjectTypeTemplate"/>
				</t>
				<c path="cherry.res.TiledMapData"/>
			</f>
			<meta><m n=":value"><e>{ loadTilesets : true, resolveTsx : true }</e></m></meta>
			<haxe_doc>Parses TMX file and optionally resolves TSX references and loads tileset images. objectTypes can be provided to add their properties to objects.</haxe_doc>
		</toMap>
		<loadTsx set="method" line="147"><f a="path">
	<c path="String"/>
	<c path="format.tmx.TmxTileset"/>
</f></loadTsx>
		<new public="1" set="method" line="67"><f a="entry">
	<c path="hxd.fs.FileEntry"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="cherry.soup._EventSignal.SignalListener" params="T" file="./cherry/soup/EventSignal.hx" private="1" module="cherry.soup.EventSignal">
		<listener public="1"><c path="cherry.soup._EventSignal.SignalListener.T"/></listener>
		<priority public="1"><x path="Int"/></priority>
		<once public="1"><x path="Bool"/></once>
		<new public="1" set="method" line="5">
			<f a="listener:priority:once">
				<c path="cherry.soup._EventSignal.SignalListener.T"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":compilerGenerated"/></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="cherry.soup.EventSignal" params="T" file="./cherry/soup/EventSignal.hx">
		<cancelled public="1">
			<x path="Bool"/>
			<haxe_doc>True, when listeners cancel signal invokation. Prevents further listeners being invoked.</haxe_doc>
		</cancelled>
		<softCancelled public="1">
			<x path="Bool"/>
			<haxe_doc>Will force dispatch function to return `false` and `cancelled` being true after call, but does not stop listener invokation.</haxe_doc>
		</softCancelled>
		<listeners><c path="Array"><c path="cherry.soup._EventSignal.SignalListener"><c path="cherry.soup.EventSignal.T"/></c></c></listeners>
		<dirty><x path="Bool"/></dirty>
		<cancel public="1" set="method" line="43">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Cancels futher listener invokation. Events further in listener list will not be invoked after this call.
    If called, `cancelled` will be true and `dispatch` will return false.</haxe_doc>
		</cancel>
		<softCancel public="1" set="method" line="52">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Cancels signal without preventing furhter listener invokation.
    If called, `cancelled` will be true and `dispatch` will return false.</haxe_doc>
		</softCancel>
		<add public="1" set="method" line="62">
			<f a="listener:?priority:?once" v=":0:false">
				<c path="cherry.soup.EventSignal.T"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ once : false, priority : 0 }</e></m></meta>
			<haxe_doc>Adds new listeners to the list.
    @param priority A priority of the listener. Higher priority listeners are called first. Same priority events are called on first-come-first-served basis.
    @param once If true, will trigger listener only once and then automatically unsubscribe from the list.</haxe_doc>
		</add>
		<remove public="1" set="method" line="75">
			<f a="listener">
				<c path="cherry.soup.EventSignal.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes listener from the list.</haxe_doc>
		</remove>
		<removeAll public="1" set="method" line="88"><f a=""><x path="Void"/></f></removeAll>
		<listenerSort set="method" line="93"><f a="a:b">
	<c path="cherry.soup._EventSignal.SignalListener"><c path="cherry.soup.EventSignal.T"/></c>
	<c path="cherry.soup._EventSignal.SignalListener"><c path="cherry.soup.EventSignal.T"/></c>
	<x path="Int"/>
</f></listenerSort>
		<reset get="inline" set="null" line="98"><f a=""><x path="Void"/></f></reset>
		<dispatchResult get="inline" set="null" line="108"><f a=""><x path="Bool"/></f></dispatchResult>
		<new public="1" set="method" line="34"><f a=""><x path="Void"/></f></new>
		<haxe_doc>A msignal-based event dispatcher class.
  Allows for easy setup of event dispatching.
  When cancelled, will stop next listeners invokation.
  
  Use subclasses to create instances of EventSignal and call their `dispatch` function to invoke listeners.</haxe_doc>
	</class>
	<class path="cherry.soup.EventSignal0" params="" file="./cherry/soup/EventSignal.hx" module="cherry.soup.EventSignal">
		<extends path="cherry.soup.EventSignal"><f a=""><x path="Void"/></f></extends>
		<dispatch public="1" set="method" line="119"><f a=""><x path="Bool"/></f></dispatch>
		<new public="1" set="method" line="116"><f a=""><x path="Void"/></f></new>
		<meta><m n=":dox"><e>hide</e></m></meta>
	</class>
	<class path="cherry.soup.EventSignal1" params="T" file="./cherry/soup/EventSignal.hx" module="cherry.soup.EventSignal">
		<extends path="cherry.soup.EventSignal"><f a="">
	<c path="cherry.soup.EventSignal1.T"/>
	<x path="Void"/>
</f></extends>
		<dispatch public="1" set="method" line="138"><f a="arg">
	<c path="cherry.soup.EventSignal1.T"/>
	<x path="Bool"/>
</f></dispatch>
		<new public="1" set="method" line="136"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</class>
	<class path="cherry.soup.EventSignal2" params="A0:A1" file="./cherry/soup/EventSignal.hx" module="cherry.soup.EventSignal">
		<extends path="cherry.soup.EventSignal"><f a=":">
	<c path="cherry.soup.EventSignal2.A0"/>
	<c path="cherry.soup.EventSignal2.A1"/>
	<x path="Void"/>
</f></extends>
		<dispatch public="1" set="method" line="156"><f a="arg0:arg1">
	<c path="cherry.soup.EventSignal2.A0"/>
	<c path="cherry.soup.EventSignal2.A1"/>
	<x path="Bool"/>
</f></dispatch>
		<new public="1" set="method" line="154"><f a=""><x path="Void"/></f></new>
		<meta><m n=":dox"><e>hide</e></m></meta>
	</class>
	<class path="cherry.soup.EventSignal3" params="A0:A1:A2" file="./cherry/soup/EventSignal.hx" module="cherry.soup.EventSignal">
		<extends path="cherry.soup.EventSignal"><f a="::">
	<c path="cherry.soup.EventSignal3.A0"/>
	<c path="cherry.soup.EventSignal3.A1"/>
	<c path="cherry.soup.EventSignal3.A2"/>
	<x path="Void"/>
</f></extends>
		<dispatch public="1" set="method" line="174"><f a="arg0:arg1:arg2">
	<c path="cherry.soup.EventSignal3.A0"/>
	<c path="cherry.soup.EventSignal3.A1"/>
	<c path="cherry.soup.EventSignal3.A2"/>
	<x path="Bool"/>
</f></dispatch>
		<new public="1" set="method" line="172"><f a=""><x path="Void"/></f></new>
		<meta><m n=":dox"><e>hide</e></m></meta>
	</class>
	<class path="cherry.soup.EventSignal4" params="A0:A1:A2:A3" file="./cherry/soup/EventSignal.hx" module="cherry.soup.EventSignal">
		<extends path="cherry.soup.EventSignal"><f a=":::">
	<c path="cherry.soup.EventSignal4.A0"/>
	<c path="cherry.soup.EventSignal4.A1"/>
	<c path="cherry.soup.EventSignal4.A2"/>
	<c path="cherry.soup.EventSignal4.A3"/>
	<x path="Void"/>
</f></extends>
		<dispatch public="1" set="method" line="192"><f a="arg0:arg1:arg2:arg3">
	<c path="cherry.soup.EventSignal4.A0"/>
	<c path="cherry.soup.EventSignal4.A1"/>
	<c path="cherry.soup.EventSignal4.A2"/>
	<c path="cherry.soup.EventSignal4.A3"/>
	<x path="Bool"/>
</f></dispatch>
		<new public="1" set="method" line="190"><f a=""><x path="Void"/></f></new>
		<meta><m n=":dox"><e>hide</e></m></meta>
	</class>
	<typedef path="format.gif.Data" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/gif/Data.hx">
		<a>
			<version>
				<e path="format.gif.Version"/>
				<haxe_doc>* Gif version. There is only 2 Gif version exists. 87a and 89a.
   * 87a have less features and does not support any extensions.
   * Unknown version is adviced to be interpreted as newest (89a) official version.</haxe_doc>
			</version>
			<logicalScreenDescriptor>
				<t path="format.gif.LogicalScreenDescriptor"/>
				<haxe_doc>* Information about logical screen of Gif that provides basic information about Gif.</haxe_doc>
			</logicalScreenDescriptor>
			<globalColorTable>
				<x path="Null"><t path="format.gif.ColorTable"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* Global color table used for Gif. Present only if Logical Screen Descriptor contained global color table flag.
   * Note that this color table not always present since frames can contain local color tables that overrides global color table.</haxe_doc>
			</globalColorTable>
			<blocks>
				<t path="List"><e path="format.gif.Block"/></t>
				<haxe_doc>* List of Gif data blocks.</haxe_doc>
			</blocks>
		</a>
		<haxe_doc>* Gif data.</haxe_doc>
	</typedef>
	<enum path="format.gif.Block" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/gif/Data.hx" module="format.gif.Data">
		<BFrame a="frame">
			<t path="format.gif.Frame"/>
			<haxe_doc>* Gif frame block.
   * Note that this block does not contain link to graphic control extension of Frame even if it is present. GraphicControl extension Block commonly present right before frame Block.</haxe_doc>
		</BFrame>
		<BExtension a="extension">
			<e path="format.gif.Extension"/>
			<haxe_doc>* Additional extension block. This Block does not supported in 87a Gif specification version.</haxe_doc>
		</BExtension>
		<BEOF><haxe_doc>* End of File block. Represents end of Gif data.</haxe_doc></BEOF>
		<haxe_doc>* Gif data block. Custom blocks are not supported.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<enum path="format.gif.Extension" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/gif/Data.hx" module="format.gif.Data">
		<EGraphicControl a="gce">
			<t path="format.gif.GraphicControlExtension"/>
			<haxe_doc>* Graphic Control extension gives additional control over next frame, like frame delay, disposal method, alpha channel and other information.</haxe_doc>
		</EGraphicControl>
		<EComment a="text">
			<c path="String"/>
			<haxe_doc>* Commentary extension. Not show up as any visual, just a text in file.</haxe_doc>
		</EComment>
		<EText a="pte">
			<t path="format.gif.PlainTextExtension"/>
			<haxe_doc>* Text extension. Must work as text rendering on the image, but ignored by all major Gif decoders.</haxe_doc>
		</EText>
		<EApplicationExtension a="ext">
			<e path="format.gif.ApplicationExtension"/>
			<haxe_doc>* Application extension allow to insert additional application data into Gif. Mostly used app extension is NETSCAPE2.0 looping extension, used to set up amount of loops in frame.</haxe_doc>
		</EApplicationExtension>
		<EUnknown a="id:data">
			<x path="Int"/>
			<c path="haxe.io.Bytes"/>
			<haxe_doc>* Unknown extension.</haxe_doc>
		</EUnknown>
		<haxe_doc>* Extension block contains additional data about Gif image. This block does not supported by 87a version.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<enum path="format.gif.ApplicationExtension" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/gif/Data.hx" module="format.gif.Data">
		<AENetscapeLooping a="loops">
			<x path="Int"/>
			<haxe_doc>* NETSCAPE2.0 looping extension. Contains only amount of animation repeats.
   * Note that there is two NETSCAPE2.0 app extensions for Gif format and the type of extension is stored in first byte of data. Looping extension have ID 1.</haxe_doc>
		</AENetscapeLooping>
		<AEUnknown a="name:version:data">
			<c path="String"/>
			<c path="String"/>
			<c path="haxe.io.Bytes"/>
			<haxe_doc>* Unknown or unsupported app extension.</haxe_doc>
		</AEUnknown>
		<haxe_doc>* Application extension. Mostly used only for one reason - setting up loops count. There is exist other app extensions but they are really rare.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<typedef path="format.gif.ColorTable" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/gif/Data.hx" module="format.gif.Data">
		<c path="haxe.io.Bytes"/>
		<haxe_doc>* Typical color table for Gif image.
 * Can contain 2, 4, 8, 16, 32, 64, 128 or 256 colors.
 * Data stored in RGB format. Information about alpha channel provided by Graohic Control Extension.</haxe_doc>
	</typedef>
	<typedef path="format.gif.Frame" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/gif/Data.hx" module="format.gif.Data">
		<a>
			<y>
				<x path="Int"/>
				<haxe_doc>* Y position of image on the Logical Screen</haxe_doc>
			</y>
			<x>
				<x path="Int"/>
				<haxe_doc>* X position of image on the Logical Screen</haxe_doc>
			</x>
			<width>
				<x path="Int"/>
				<haxe_doc>* Width of image in pixels</haxe_doc>
			</width>
			<sorted>
				<x path="Bool"/>
				<haxe_doc>* Is local color table sorted in order of decreasing priority?</haxe_doc>
			</sorted>
			<pixels>
				<c path="haxe.io.Bytes"/>
				<haxe_doc>* Pixel data of frame. Stored as Indexed colors, 1 byte per pixel.</haxe_doc>
			</pixels>
			<localColorTableSize>
				<x path="Int"/>
				<haxe_doc>* Size of local color table</haxe_doc>
			</localColorTableSize>
			<localColorTable>
				<x path="Bool"/>
				<haxe_doc>* Is this image uses local color table?</haxe_doc>
			</localColorTable>
			<interlaced>
				<x path="Bool"/>
				<haxe_doc>* Is this image written in interlace mode?
   * Note: The pixel data already deinterlaced and this flag presented only for information purpose (and for Writer when there is one).</haxe_doc>
			</interlaced>
			<height>
				<x path="Int"/>
				<haxe_doc>* Height of image in pixels</haxe_doc>
			</height>
			<colorTable>
				<t path="format.gif.ColorTable"/>
				<haxe_doc>* Local color table used by frame. Stored as 3-byte RGB colors. If value is null, must be used global color table.</haxe_doc>
			</colorTable>
		</a>
		<haxe_doc>* Single frame of the image.
 * Actually it's a merge of 3 consequent blocks:
 * 1. Image Descriptor.
 * Contains frame informations like position, size, existing of local color table and interlaced flag.
 * 2. [Local color table].
 * Only present if Image Descriptor contains local color table flag. Overrides global color table.
 * 3. Pixel data blocks.
 * LZW compressed pixel data.</haxe_doc>
	</typedef>
	<typedef path="format.gif.GraphicControlExtension" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/gif/Data.hx" module="format.gif.Data">
		<a>
			<userInput>
				<x path="Bool"/>
				<haxe_doc>* Is image must wait for user input, before dispose?
   * This flag may be used by user-defined program but absolutely ignored by any Gif players.</haxe_doc>
			</userInput>
			<transparentIndex>
				<x path="Int"/>
				<haxe_doc>* Index in color table that used as transparent.</haxe_doc>
			</transparentIndex>
			<hasTransparentColor>
				<x path="Bool"/>
				<haxe_doc>* Is image have transparency?</haxe_doc>
			</hasTransparentColor>
			<disposalMethod>
				<e path="format.gif.DisposalMethod"/>
				<haxe_doc>* Disposal method of frame.</haxe_doc>
			</disposalMethod>
			<delay>
				<x path="Int"/>
				<haxe_doc>* Delay, before next image appears. Delay is in centiseconds (1 centisecond = 1/100 seconds).
   * Note: Some players (like FastStone) cut fraction of elapsed time when progressing to next frame which results in small timing error.
   * Recommended to use `time -= delay` instead of `time = 0`.</haxe_doc>
			</delay>
		</a>
		<haxe_doc>* Graphic Control Extension block, used for setting up disposal method, transparency, delay and user input.</haxe_doc>
	</typedef>
	<typedef path="format.gif.PlainTextExtension" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/gif/Data.hx" module="format.gif.Data">
		<a>
			<textGridY>
				<x path="Int"/>
				<haxe_doc>* Y position of text grid on Logical Screen.</haxe_doc>
			</textGridY>
			<textGridX>
				<x path="Int"/>
				<haxe_doc>* X position of text grid on Logical Screen.</haxe_doc>
			</textGridX>
			<textGridWidth>
				<x path="Int"/>
				<haxe_doc>* Width of text grid in pixels.</haxe_doc>
			</textGridWidth>
			<textGridHeight>
				<x path="Int"/>
				<haxe_doc>* Height of text grid in pixels.</haxe_doc>
			</textGridHeight>
			<textForegroundColorIndex>
				<x path="Int"/>
				<haxe_doc>* Foreground/character color index.</haxe_doc>
			</textForegroundColorIndex>
			<textBackgroundColorIndex>
				<x path="Int"/>
				<haxe_doc>* Background color index.</haxe_doc>
			</textBackgroundColorIndex>
			<text>
				<c path="String"/>
				<haxe_doc>* Text to render.</haxe_doc>
			</text>
			<charCellWidth>
				<x path="Int"/>
				<haxe_doc>* Width of character cell in text grid.</haxe_doc>
			</charCellWidth>
			<charCellHeight>
				<x path="Int"/>
				<haxe_doc>* Height of character cell in text grid.</haxe_doc>
			</charCellHeight>
		</a>
		<haxe_doc>* Extension for rendering text on Gif logical screen. It does not supported by major Gif decoders.
 * Font and text size decision is left to decoder. (recommended to decide based on grid/cell size)
 * Text must be rendered with one character at cell.
 * It's recommended to replace any characters less than 0x20 and greater than 0xf7 to be rendered as Space (0x20)</haxe_doc>
	</typedef>
	<typedef path="format.gif.LogicalScreenDescriptor" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/gif/Data.hx" module="format.gif.Data">
		<a>
			<width>
				<x path="Int"/>
				<haxe_doc>* Width of GIF image in pixels</haxe_doc>
			</width>
			<sorted>
				<x path="Bool"/>
				<haxe_doc>* Specification:
   * Indicates whether the Global Color Table is sorted.
     If the flag is set, the Global Color Table is sorted, in order of
     decreasing importance. Typically, the order would be decreasing
     frequency, with most frequent color first. This assists a decoder,
     with fewer available colors, in choosing the best subset of colors;
     the decoder may use an initial segment of the table to render the
     graphic.</haxe_doc>
			</sorted>
			<pixelAspectRatio>
				<x path="Float"/>
				<haxe_doc>* Factor used to compute an approximation of the aspect ratio of the pixel in the original image.</haxe_doc>
			</pixelAspectRatio>
			<height>
				<x path="Int"/>
				<haxe_doc>* Height of GIF image in pixels</haxe_doc>
			</height>
			<hasGlobalColorTable>
				<x path="Bool"/>
				<haxe_doc>* Is this file uses global color table?</haxe_doc>
			</hasGlobalColorTable>
			<globalColorTableSize>
				<x path="Int"/>
				<haxe_doc>* Size of global color table.</haxe_doc>
			</globalColorTableSize>
			<colorResolution>
				<x path="Int"/>
				<haxe_doc>* Specification:
   * Number of bits per primary color available
     to the original image, minus 1. This value represents the size of
     the entire palette from which the colors in the graphic were
     selected, not the number of colors actually used in the graphic.
     For example, if the value in this field is 3, then the palette of
     the original image had 4 bits per primary color available to create
     the image.  This value should be set to indicate the richness of
     the original palette, even if not every color from the whole
     palette is available on the source machine.</haxe_doc>
			</colorResolution>
			<backgroundColorIndex>
				<x path="Int"/>
				<haxe_doc>* Background color index in global color table</haxe_doc>
			</backgroundColorIndex>
		</a>
		<haxe_doc>* Logical screen descriptor of GIF file.
 * Contains very basic information about Gif.</haxe_doc>
	</typedef>
	<enum path="format.gif.Version" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/gif/Data.hx" module="format.gif.Data">
		<GIF87a><haxe_doc>* First version of Gif file format from May 1987.
   * 
   * Note: The checking of unsupported blocks disabled by default to save some time. To enable supported blocks check set `yagp_strict_version_check` debug variable.</haxe_doc></GIF87a>
		<GIF89a><haxe_doc>* Second and actual version of Gif file format from July 1989.</haxe_doc></GIF89a>
		<Unknown a="version">
			<c path="String"/>
			<haxe_doc>* Unknown version of Gif file.</haxe_doc>
		</Unknown>
		<haxe_doc>* Version of Gif file.  
 * The only 2 official versions is GIF87a and GIF89a.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<enum path="format.gif.DisposalMethod" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/gif/Data.hx" module="format.gif.Data">
		<UNSPECIFIED><haxe_doc>* The disposal method is unspecified. Action on demand of viewer.
   * 
   * Mostly interpreted as NO_ACTION.</haxe_doc></UNSPECIFIED>
		<NO_ACTION><haxe_doc>* No action required.</haxe_doc></NO_ACTION>
		<FILL_BACKGROUND><haxe_doc>* Fill frame rectangle with background color.
   * 
   * Usage note: 
   * Most renderers clears to transparency instead of filling background color, when frame's transparent color index not equals to background color index.</haxe_doc></FILL_BACKGROUND>
		<RENDER_PREVIOUS><haxe_doc>* Render previous state of gif as it before rendering disposing frame.</haxe_doc></RENDER_PREVIOUS>
		<UNDEFINED a="index">
			<x path="Int"/>
			<haxe_doc>* Reserved disposal methods.</haxe_doc>
		</UNDEFINED>
		<haxe_doc>* Disposal method of GIF frame.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<class path="format.gif.Reader" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/gif/Reader.hx">
		<i><c path="haxe.io.Input"/></i>
		<read public="1" set="method" line="22"><f a=""><t path="format.gif.Data"/></f></read>
		<readBlock set="method" line="80"><f a=""><e path="format.gif.Block"/></f></readBlock>
		<readImage set="method" line="98"><f a=""><e path="format.gif.Block"/></f></readImage>
		<readPixels set="method" line="129"><f a="width:height:interlaced">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<c path="haxe.io.Bytes"/>
</f></readPixels>
		<deinterlace set="method" line="236"><f a="input:output:step:y:offset:width:height">
	<c path="haxe.io.Bytes"/>
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></deinterlace>
		<readExtension set="method" line="247"><f a=""><e path="format.gif.Block"/></f></readExtension>
		<readApplicationExtension set="method" line="302"><f a=""><e path="format.gif.Block"/></f></readApplicationExtension>
		<readBlocks get="inline" set="null" line="315"><f a=""><c path="haxe.io.Bytes"/></f></readBlocks>
		<readColorTable set="method" line="332"><f a="size">
	<x path="Int"/>
	<t path="format.gif.ColorTable"/>
</f></readColorTable>
		<new public="1" set="method" line="16"><f a="i">
	<c path="haxe.io.Input"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Yanrishatum</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="format.gif.Tools" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/gif/Tools.hx">
		<framesCount public="1" set="method" line="16" static="1">
			<f a="data">
				<t path="format.gif.Data"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Returns amount of frames in Gif data.</haxe_doc>
		</framesCount>
		<frame public="1" set="method" line="37" static="1">
			<f a="data:frameIndex">
				<t path="format.gif.Data"/>
				<x path="Int"/>
				<t path="format.gif.Frame"/>
			</f>
			<haxe_doc>* Returns frame at given index.
   * @param data Gif data.
   * @param frameIndex Index of frame.
   * @return Frame at given index or null, if there is no frame at that index.</haxe_doc>
		</frame>
		<graphicControl public="1" set="method" line="59" static="1">
			<f a="data:frameIndex">
				<t path="format.gif.Data"/>
				<x path="Int"/>
				<t path="format.gif.GraphicControlExtension"/>
			</f>
			<haxe_doc>* Returns Graphic Control extension for frame at given index.
   * @param data Gif data.
   * @param frameIndex Index of frame.
   * @return GCE extension if it is exists for given frame, null otherwise.</haxe_doc>
		</graphicControl>
		<extractBGRA public="1" set="method" line="90" static="1">
			<f a="data:frameIndex">
				<t path="format.gif.Data"/>
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>* Extracts frame pixel data in Blue-Green-Red-Alpha pixel format.
   * This function extracts only exact frame and does put previous frame pixel data into resulting Bytes. Note that frame size may not equal to Gif logical screen size.
   * @param data Gif data.
   * @param frameIndex Frame index.
   * @return BGRA pixel data with dimensions equals to specified Frame size. If frame does not present in Gif data returns null.</haxe_doc>
		</extractBGRA>
		<extractRGBA public="1" set="method" line="141" static="1">
			<f a="data:frameIndex">
				<t path="format.gif.Data"/>
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>* Extracts frame pixel data in Red-Green-Blue-Alpha pixel format.
   * This function extracts only exact frame and does put previous frame pixel data into resulting Bytes. Note that frame size may not equal to Gif logical screen size.
   * @param data Gif data.
   * @param frameIndex Frame index.
   * @return RGBA pixel data with dimensions equals to specified Frame size. If frame does not present in Gif data returns null.</haxe_doc>
		</extractRGBA>
		<extractFullBGRA public="1" set="method" line="192" static="1">
			<f a="data:frameIndex">
				<t path="format.gif.Data"/>
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>* Extracts full Gif pixel data to specified frame in Blue-Green-Red-Alpha pixel format.
   * This functions returns full representation of frame including rendering of all other frames before.
   * @param data Gif data.
   * @param frameIndex Frame index.
   * @return BGRA pixel data with dimensions equals to Gif logical screen with full pixel data of Gif image at specified frame.</haxe_doc>
		</extractFullBGRA>
		<extractFullRGBA public="1" set="method" line="278" static="1">
			<f a="data:frameIndex">
				<t path="format.gif.Data"/>
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>* Extracts full Gif pixel data to specified frame in Red-Green-Blue-Alpha pixel format.
   * This functions returns full representation of frame including rendering of all other frames before.
   * @param data Gif data.
   * @param frameIndex Frame index.
   * @return RGBA pixel data with dimensions equals to Gif logical screen with full pixel data of Gif image at specified frame.</haxe_doc>
		</extractFullRGBA>
		<loopCount public="1" set="method" line="363" static="1">
			<f a="data">
				<t path="format.gif.Data"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Returns amount of animation repeats stored in Gif data.
   * This is link to Netscape Looping application extension. If this extension does not present amount of loops equals to 1.
   * @param data Gif data.
   * @return Amount of animation repeats. Zero equals to infinite amount of repeats.</haxe_doc>
		</loopCount>
		<LN2 expr="Math.log(2)" line="385" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>Math.log(2)</e></m></meta>
		</LN2>
		<log2 public="1" get="inline" set="null" line="386" static="1">
			<f a="val">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</log2>
		<haxe_doc>* Tools for gif data.
 * @author Yanrishatum</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="format.gz.Header" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/gz/Data.hx" module="format.gz.Data"><a>
	<fileName><c path="String"/></fileName>
	<extraData><c path="haxe.io.Bytes"/></extraData>
	<comments><c path="String"/></comments>
</a></typedef>
	<class path="format.gz.Reader" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/gz/Reader.hx">
		<i><c path="haxe.io.Input"/></i>
		<read public="1" set="method" line="38"><f a=""><a>
	<file><c path="String"/></file>
	<data><c path="haxe.io.Bytes"/></data>
</a></f></read>
		<readHeader public="1" set="method" line="45"><f a=""><t path="format.gz.Header"/></f></readHeader>
		<readData public="1" set="method" line="76"><f a="o:?bufsize">
	<c path="haxe.io.Output"/>
	<x path="Int"/>
	<x path="Int"/>
</f></readData>
		<refill set="method" line="119"><f a="buf:pos">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></refill>
		<new public="1" set="method" line="34"><f a="i">
	<c path="haxe.io.Input"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="format.mp3.SamplingRate" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/mp3/Data.hx" module="format.mp3.Data">
		<SR_8000/>
		<SR_11025/>
		<SR_12000/>
		<SR_22050/>
		<SR_24000/>
		<SR_32000/>
		<SR_44100/>
		<SR_48000/>
		<SR_Bad/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="format.mp3.Bitrate" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/mp3/Data.hx" module="format.mp3.Data">
		<BR_8/>
		<BR_16/>
		<BR_24/>
		<BR_32/>
		<BR_40/>
		<BR_48/>
		<BR_56/>
		<BR_64/>
		<BR_80/>
		<BR_96/>
		<BR_112/>
		<BR_128/>
		<BR_144/>
		<BR_160/>
		<BR_176/>
		<BR_192/>
		<BR_224/>
		<BR_256/>
		<BR_288/>
		<BR_320/>
		<BR_352/>
		<BR_384/>
		<BR_416/>
		<BR_448/>
		<BR_Free/>
		<BR_Bad/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="format.mp3.MPEG" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/mp3/Constants.hx" module="format.mp3.Constants">
		<V1 public="1" get="inline" set="null" expr="3" line="11" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</V1>
		<V2 public="1" get="inline" set="null" expr="2" line="12" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</V2>
		<V25 public="1" get="inline" set="null" expr="0" line="13" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</V25>
		<Reserved public="1" expr="1" line="14" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</Reserved>
		<enum2Num public="1" set="method" line="16" static="1"><f a="m">
	<e path="format.mp3.MPEGVersion"/>
	<x path="Int"/>
</f></enum2Num>
		<num2Enum public="1" set="method" line="25" static="1"><f a="m">
	<x path="Int"/>
	<e path="format.mp3.MPEGVersion"/>
</f></num2Enum>
		<V1_Bitrates public="1" expr="[[BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad], [BR_Free, BR_32, BR_40, BR_48, BR_56, BR_64, BR_80, BR_96, BR_112, BR_128, BR_160, BR_192, BR_224, BR_256, BR_320, BR_Bad], [BR_Free, BR_32, BR_48, BR_56, BR_64, BR_80, BR_96, BR_112, BR_128, BR_160, BR_192, BR_224, BR_256, BR_320, BR_384, BR_Bad], [BR_Free, BR_32, BR_64, BR_96, BR_128, BR_160, BR_192, BR_224, BR_256, BR_288, BR_320, BR_352, BR_384, BR_416, BR_448, BR_Bad]]" line="35" static="1">
			<c path="Array"><c path="Array"><e path="format.mp3.Bitrate"/></c></c>
			<meta><m n=":value"><e>[[BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad], [BR_Free, BR_32, BR_40, BR_48, BR_56, BR_64, BR_80, BR_96, BR_112, BR_128, BR_160, BR_192, BR_224, BR_256, BR_320, BR_Bad], [BR_Free, BR_32, BR_48, BR_56, BR_64, BR_80, BR_96, BR_112, BR_128, BR_160, BR_192, BR_224, BR_256, BR_320, BR_384, BR_Bad], [BR_Free, BR_32, BR_64, BR_96, BR_128, BR_160, BR_192, BR_224, BR_256, BR_288, BR_320, BR_352, BR_384, BR_416, BR_448, BR_Bad]]</e></m></meta>
		</V1_Bitrates>
		<V2_Bitrates public="1" expr="[[BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad], [BR_Free, BR_8, BR_16, BR_24, BR_32, BR_40, BR_48, BR_56, BR_64, BR_80, BR_96, BR_112, BR_128, BR_144, BR_160, BR_Bad], [BR_Free, BR_8, BR_16, BR_24, BR_32, BR_40, BR_48, BR_56, BR_64, BR_80, BR_96, BR_112, BR_128, BR_144, BR_160, BR_Bad], [BR_Free, BR_32, BR_48, BR_56, BR_64, BR_80, BR_96, BR_112, BR_128, BR_144, BR_160, BR_176, BR_192, BR_224, BR_256, BR_Bad]]" line="43" static="1">
			<c path="Array"><c path="Array"><e path="format.mp3.Bitrate"/></c></c>
			<meta><m n=":value"><e>[[BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad], [BR_Free, BR_8, BR_16, BR_24, BR_32, BR_40, BR_48, BR_56, BR_64, BR_80, BR_96, BR_112, BR_128, BR_144, BR_160, BR_Bad], [BR_Free, BR_8, BR_16, BR_24, BR_32, BR_40, BR_48, BR_56, BR_64, BR_80, BR_96, BR_112, BR_128, BR_144, BR_160, BR_Bad], [BR_Free, BR_32, BR_48, BR_56, BR_64, BR_80, BR_96, BR_112, BR_128, BR_144, BR_160, BR_176, BR_192, BR_224, BR_256, BR_Bad]]</e></m></meta>
		</V2_Bitrates>
		<SamplingRates public="1" expr="[[SR_11025, SR_12000, SR_8000, SR_Bad], [SR_Bad, SR_Bad, SR_Bad, SR_Bad], [SR_22050, SR_24000, SR_12000, SR_Bad], [SR_44100, SR_48000, SR_32000, SR_Bad]]" line="51" static="1">
			<c path="Array"><c path="Array"><e path="format.mp3.SamplingRate"/></c></c>
			<meta><m n=":value"><e>[[SR_11025, SR_12000, SR_8000, SR_Bad], [SR_Bad, SR_Bad, SR_Bad, SR_Bad], [SR_22050, SR_24000, SR_12000, SR_Bad], [SR_44100, SR_48000, SR_32000, SR_Bad]]</e></m></meta>
		</SamplingRates>
		<srNum2Enum public="1" set="method" line="58" static="1"><f a="sr">
	<x path="Int"/>
	<e path="format.mp3.SamplingRate"/>
</f></srNum2Enum>
		<srEnum2Num public="1" set="method" line="72" static="1"><f a="sr">
	<e path="format.mp3.SamplingRate"/>
	<x path="Int"/>
</f></srEnum2Num>
		<getBitrateIdx public="1" set="method" line="87" static="1"><f a="br:mpeg:layer">
	<e path="format.mp3.Bitrate"/>
	<e path="format.mp3.MPEGVersion"/>
	<e path="format.mp3.Layer"/>
	<x path="Int"/>
</f></getBitrateIdx>
		<getSamplingRateIdx public="1" set="method" line="96" static="1"><f a="sr:mpeg">
	<e path="format.mp3.SamplingRate"/>
	<e path="format.mp3.MPEGVersion"/>
	<x path="Int"/>
</f></getSamplingRateIdx>
		<bitrateEnum2Num public="1" set="method" line="105" static="1"><f a="br">
	<e path="format.mp3.Bitrate"/>
	<x path="Int"/>
</f></bitrateEnum2Num>
		<bitrateNum2Enum public="1" set="method" line="136" static="1"><f a="br">
	<x path="Int"/>
	<e path="format.mp3.Bitrate"/>
</f></bitrateNum2Enum>
		<haxe_doc>* MPEG Version
 *
 * sored on 2 bits in the file,
 * values represent bit values</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="format.mp3.CLayer" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/mp3/Constants.hx" module="format.mp3.Constants">
		<LReserved public="1" expr="0" line="177" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</LReserved>
		<LLayer3 public="1" expr="1" line="178" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</LLayer3>
		<LLayer2 public="1" expr="2" line="179" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</LLayer2>
		<LLayer1 public="1" expr="3" line="180" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</LLayer1>
		<enum2Num public="1" set="method" line="182" static="1"><f a="l">
	<e path="format.mp3.Layer"/>
	<x path="Int"/>
</f></enum2Num>
		<num2Enum public="1" set="method" line="191" static="1"><f a="l">
	<x path="Int"/>
	<e path="format.mp3.Layer"/>
</f></num2Enum>
		<haxe_doc>* Layer
 *
 * stored on 2 bits in the file,
 * values represent bit values</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="format.mp3.CChannelMode" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/mp3/Constants.hx" module="format.mp3.Constants">
		<CStereo public="1" get="inline" set="null" expr="0" line="209" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</CStereo>
		<CJointStereo public="1" get="inline" set="null" expr="1" line="210" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</CJointStereo>
		<CDualChannel public="1" get="inline" set="null" expr="2" line="211" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</CDualChannel>
		<CMono public="1" get="inline" set="null" expr="3" line="212" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</CMono>
		<enum2Num public="1" set="method" line="214" static="1"><f a="c">
	<e path="format.mp3.ChannelMode"/>
	<x path="Int"/>
</f></enum2Num>
		<num2Enum public="1" set="method" line="223" static="1"><f a="c">
	<x path="Int"/>
	<e path="format.mp3.ChannelMode"/>
</f></num2Enum>
		<haxe_doc>* Sound channel mode
 *
 * stored on 2 bits in the file,
 * values represent bit values</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="format.mp3.CEmphasis" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/mp3/Constants.hx" module="format.mp3.Constants">
		<ENone public="1" get="inline" set="null" expr="0" line="240" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</ENone>
		<EMs50_15 public="1" get="inline" set="null" expr="1" line="241" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</EMs50_15>
		<EReserved public="1" get="inline" set="null" expr="2" line="242" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</EReserved>
		<ECCIT_J17 public="1" get="inline" set="null" expr="3" line="243" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</ECCIT_J17>
		<enum2Num public="1" set="method" line="245" static="1"><f a="c">
	<e path="format.mp3.Emphasis"/>
	<x path="Int"/>
</f></enum2Num>
		<num2Enum public="1" set="method" line="254" static="1"><f a="c">
	<x path="Int"/>
	<e path="format.mp3.Emphasis"/>
</f></num2Enum>
		<haxe_doc>* Emphasis
 *
 * 2 bits</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="format.mp3.MP3" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/mp3/Data.hx" module="format.mp3.Data"><a>
	<sampleSize><x path="Int"/></sampleSize>
	<sampleCount><x path="Int"/></sampleCount>
	<id3v2><t path="format.mp3.ID3v2Info"/></id3v2>
	<frames><c path="Array"><t path="format.mp3.MP3Frame"/></c></frames>
</a></typedef>
	<typedef path="format.mp3.ID3v2Info" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/mp3/Data.hx" module="format.mp3.Data"><a>
	<versionBytes><x path="Int"/></versionBytes>
	<flagByte><x path="Int"/></flagByte>
	<data><c path="haxe.io.Bytes"/></data>
</a></typedef>
	<typedef path="format.mp3.MP3Frame" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/mp3/Data.hx" module="format.mp3.Data"><a>
	<header><t path="format.mp3.MP3Header"/></header>
	<data><c path="haxe.io.Bytes"/></data>
</a></typedef>
	<typedef path="format.mp3.MP3Header" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/mp3/Data.hx" module="format.mp3.Data"><a>
	<version><e path="format.mp3.MPEGVersion"/></version>
	<samplingRate><e path="format.mp3.SamplingRate"/></samplingRate>
	<privateBit><x path="Bool"/></privateBit>
	<layer><e path="format.mp3.Layer"/></layer>
	<isPadded><x path="Bool"/></isPadded>
	<isOriginal><x path="Bool"/></isOriginal>
	<isMSStereo><x path="Bool"/></isMSStereo>
	<isIntensityStereo><x path="Bool"/></isIntensityStereo>
	<isCopyrighted><x path="Bool"/></isCopyrighted>
	<hasCrc><x path="Bool"/></hasCrc>
	<emphasis><e path="format.mp3.Emphasis"/></emphasis>
	<crc16><x path="Int"/></crc16>
	<channelMode><e path="format.mp3.ChannelMode"/></channelMode>
	<bitrate><e path="format.mp3.Bitrate"/></bitrate>
</a></typedef>
	<enum path="format.mp3.MPEGVersion" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/mp3/Data.hx" module="format.mp3.Data">
		<MPEG_V1/>
		<MPEG_V2/>
		<MPEG_V25/>
		<MPEG_Reserved/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="format.mp3.Layer" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/mp3/Data.hx" module="format.mp3.Data">
		<LayerReserved/>
		<Layer3/>
		<Layer2/>
		<Layer1/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="format.mp3.ChannelMode" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/mp3/Data.hx" module="format.mp3.Data">
		<Stereo/>
		<JointStereo/>
		<DualChannel/>
		<Mono/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="format.mp3.Emphasis" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/mp3/Data.hx" module="format.mp3.Data">
		<NoEmphasis/>
		<Ms50_15/>
		<CCIT_J17/>
		<InvalidEmphasis/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="format.mp3.FrameType" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/mp3/Reader.hx" module="format.mp3.Reader">
		<FT_MP3/>
		<FT_NONE/>
		<haxe_doc>* Used by seekFrame to retrun the type
 * of frame (possibly) found.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="format.mp3.Reader" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/mp3/Reader.hx">
		<i><c path="haxe.io.Input"/></i>
		<bits><c path="format.tools.BitsInput"/></bits>
		<version><x path="Int"/></version>
		<samples><x path="Int"/></samples>
		<sampleSize><x path="Int"/></sampleSize>
		<any_read><x path="Bool"/></any_read>
		<id3v2_data><c path="haxe.io.Bytes"/></id3v2_data>
		<id3v2_version><x path="Int"/></id3v2_version>
		<id3v2_flags><x path="Int"/></id3v2_flags>
		<skipID3v2 public="1" set="method" line="78">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called after found 'ID3' signature
    * at the beginning of the file.
    *
    * Records the raw tag data.</haxe_doc>
		</skipID3v2>
		<seekFrame public="1" set="method" line="101">
			<f a=""><e path="format.mp3.FrameType"/></f>
			<haxe_doc>* Winds the input stream until the 11-bit
    * syncword is found.
    *
    * @returns Bool false if not found (this should happen at eof).</haxe_doc>
		</seekFrame>
		<readFrames public="1" set="method" line="150">
			<f a=""><c path="Array"><t path="format.mp3.MP3Frame"/></c></f>
			<haxe_doc>* Returns all valid frames. Invalid frames
    * are discarded.</haxe_doc>
		</readFrames>
		<readFrameHeader public="1" set="method" line="170">
			<f a=""><t path="format.mp3.MP3Header"/></f>
			<haxe_doc>* Returns null if header proves to be invalid.</haxe_doc>
		</readFrameHeader>
		<readFrame public="1" set="method" line="250">
			<f a=""><t path="format.mp3.MP3Frame"/></f>
			<haxe_doc>* Reads a frame from the input.
    *
    * The input position should already be just past the
    * 11 bit syncword.
    *
    * Returns null if the header is invalid or the frame was incomplete.</haxe_doc>
		</readFrame>
		<read public="1" set="method" line="280">
			<f a=""><t path="format.mp3.MP3"/></f>
			<haxe_doc>* Reads the MP3 data.
    *
    * Currently returns all valid frames.</haxe_doc>
		</read>
		<new public="1" set="method" line="62"><f a="i">
	<c path="haxe.io.Input"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="format.mp3.Tools" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/mp3/Tools.hx">
		<getBitrate public="1" set="method" line="40" static="1">
			<f a="mpegVersion:layerIdx:bitrateIdx">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<e path="format.mp3.Bitrate"/>
			</f>
			<haxe_doc>* Returns kbps</haxe_doc>
		</getBitrate>
		<getSamplingRate public="1" set="method" line="50" static="1">
			<f a="mpegVersion:samplingRateIdx">
				<x path="Int"/>
				<x path="Int"/>
				<e path="format.mp3.SamplingRate"/>
			</f>
			<haxe_doc>* Returns Hz</haxe_doc>
		</getSamplingRate>
		<isInvalidFrameHeader public="1" set="method" line="57" static="1">
			<f a="hdr">
				<t path="format.mp3.MP3Header"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Tells whether the header is invalid.</haxe_doc>
		</isInvalidFrameHeader>
		<getSampleDataSize public="1" set="method" line="74" static="1">
			<f a="mpegVersion:bitrate:samplingRate:isPadded:hasCrc">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Return sample data size. Note that
    * the 4 bytes subtracted is the size of the header,
    * so this 4 bytes less the frame size.
    *
    * Also, 2 bytes are subtracted for CRC too, if present</haxe_doc>
		</getSampleDataSize>
		<getSampleDataSizeHdr public="1" set="method" line="78" static="1"><f a="hdr">
	<t path="format.mp3.MP3Header"/>
	<x path="Int"/>
</f></getSampleDataSizeHdr>
		<getSampleCount public="1" set="method" line="89" static="1">
			<f a="mpegVersion">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Returns the number of samples in the frame.</haxe_doc>
		</getSampleCount>
		<getSampleCountHdr public="1" set="method" line="94" static="1"><f a="hdr">
	<t path="format.mp3.MP3Header"/>
	<x path="Int"/>
</f></getSampleCountHdr>
		<getFrameInfo public="1" set="method" line="102" static="1">
			<f a="fr">
				<t path="format.mp3.MP3Frame"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Displays frame info in human-readable format.
    * Subject to change, do not use for programmatical parsing!</haxe_doc>
		</getFrameInfo>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="format.png.Color" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/png/Data.hx" module="format.png.Data">
		<ColGrey a="alpha"><x path="Bool"/></ColGrey>
		<ColTrue a="alpha"><x path="Bool"/></ColTrue>
		<ColIndexed/>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<typedef path="format.png.Header" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/png/Data.hx" module="format.png.Data"><a>
	<width><x path="Int"/></width>
	<interlaced><x path="Bool"/></interlaced>
	<height><x path="Int"/></height>
	<color><e path="format.png.Color"/></color>
	<colbits><x path="Int"/></colbits>
</a></typedef>
	<enum path="format.png.Chunk" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/png/Data.hx" module="format.png.Data">
		<CEnd/>
		<CHeader a="h"><t path="format.png.Header"/></CHeader>
		<CData a="b"><c path="haxe.io.Bytes"/></CData>
		<CPalette a="b"><c path="haxe.io.Bytes"/></CPalette>
		<CUnknown a="id:data">
			<c path="String"/>
			<c path="haxe.io.Bytes"/>
		</CUnknown>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<typedef path="format.png.Data" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/png/Data.hx"><t path="List"><e path="format.png.Chunk"/></t></typedef>
	<class path="format.png.Reader" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/png/Reader.hx">
		<i><c path="haxe.io.Input"/></i>
		<checkCRC public="1"><x path="Bool"/></checkCRC>
		<read public="1" set="method" line="41"><f a=""><t path="format.png.Data"/></f></read>
		<readHeader set="method" line="56"><f a="i">
	<c path="haxe.io.Input"/>
	<t path="format.png.Header"/>
</f></readHeader>
		<readChunk set="method" line="91"><f a=""><e path="format.png.Chunk"/></f></readChunk>
		<new public="1" set="method" line="35"><f a="i">
	<c path="haxe.io.Input"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="format.png.Tools" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/png/Tools.hx">
		<getHeader public="1" set="method" line="35" static="1">
			<f a="d">
				<t path="format.png.Data"/>
				<t path="format.png.Header"/>
			</f>
			<haxe_doc>Returns the PNG header informations. Throws an exception if no header found.</haxe_doc>
		</getHeader>
		<getPalette public="1" set="method" line="47" static="1">
			<f a="d">
				<t path="format.png.Data"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>Return the PNG palette colors, or null if no palette chunk was found</haxe_doc>
		</getPalette>
		<filter get="inline" set="null" line="56" static="1">
			<f a="data:x:y:stride:prev:p:?numChannels" v="::::::4">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ numChannels : 4 }</e></m></meta>
		</filter>
		<reverseBytes public="1" set="method" line="69" static="1">
			<f a="b">
				<c path="haxe.io.Bytes"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Converts from BGRA to ARGB and the other way by reversing bytes.</haxe_doc>
		</reverseBytes>
		<extractGrey public="1" set="method" line="106" static="1">
			<f a="d">
				<t path="format.png.Data"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":noDebug"/></meta>
			<haxe_doc>Decode the greyscale PNG data and apply filters, extracting only the grey channel if alpha is present.</haxe_doc>
		</extractGrey>
		<extract32 public="1" set="method" line="205" static="1">
			<f a="d:?bytes:?flipY">
				<t path="format.png.Data"/>
				<c path="haxe.io.Bytes"/>
				<x path="Bool"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":noDebug"/></meta>
			<haxe_doc>Decode the PNG data and apply filters. By default this will output BGRA low-endian format. You can use the [reverseBytes] function to inverse the bytes to ARGB big-endian format.</haxe_doc>
		</extract32>
		<buildGrey public="1" set="method" line="653" static="1">
			<f a="width:height:data:?level" v=":::9">
				<x path="Int"/>
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<t path="format.png.Data"/>
			</f>
			<meta><m n=":value"><e>{ level : 9 }</e></m></meta>
			<haxe_doc>Creates PNG data from bytes that contains one bytes (grey values) for each pixel.</haxe_doc>
		</buildGrey>
		<buildIndexed public="1" set="method" line="672" static="1">
			<f a="width:height:data:palette:?level" v="::::9">
				<x path="Int"/>
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<t path="format.png.Data"/>
			</f>
			<meta><m n=":value"><e>{ level : 9 }</e></m></meta>
			<haxe_doc>Creates PNG data from bytes that contains a one byte palette index for each pixel and a separate palette with 3 RGB bytes per color.</haxe_doc>
		</buildIndexed>
		<buildRGB public="1" set="method" line="691" static="1">
			<f a="width:height:data:?level" v=":::9">
				<x path="Int"/>
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<t path="format.png.Data"/>
			</f>
			<meta><m n=":value"><e>{ level : 9 }</e></m></meta>
			<haxe_doc>Creates PNG data from bytes that contains three bytes (R,G and B values) for each pixel.</haxe_doc>
		</buildRGB>
		<build32ARGB public="1" set="method" line="714" static="1">
			<f a="width:height:data:?level" v=":::9">
				<x path="Int"/>
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<t path="format.png.Data"/>
			</f>
			<meta><m n=":value"><e>{ level : 9 }</e></m></meta>
			<haxe_doc>Creates PNG data from bytes that contains four bytes in ARGB format for each pixel.</haxe_doc>
		</build32ARGB>
		<build32BGRA public="1" set="method" line="738" static="1">
			<f a="width:height:data:?level" v=":::9">
				<x path="Int"/>
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<t path="format.png.Data"/>
			</f>
			<meta><m n=":value"><e>{ level : 9 }</e></m></meta>
			<haxe_doc>Creates PNG data from bytes that contains four bytes in BGRA format for each pixel.</haxe_doc>
		</build32BGRA>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="format.png.Writer" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/png/Writer.hx">
		<o><c path="haxe.io.Output"/></o>
		<write public="1" set="method" line="39"><f a="png">
	<t path="format.png.Data"/>
	<x path="Void"/>
</f></write>
		<writeChunk set="method" line="75"><f a="id:data">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></writeChunk>
		<new public="1" set="method" line="34"><f a="o">
	<c path="haxe.io.Output"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="format.tga.Header" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/tga/Data.hx" module="format.tga.Data"><a>
	<yOrigin>
		<x path="Int"/>
		<haxe_doc>* These bytes specify the absolute vertical coordinate for the lower left
   * corner of the image as it is positioned on a display device having an
   * origin at the lower left of the screen (e.g., the TARGA series).</haxe_doc>
	</yOrigin>
	<xOrigin>
		<x path="Int"/>
		<haxe_doc>* These bytes specify the absolute horizontal coordinate for the lower left
   * corner of the image as it is positioned on a display device having an
   * origin at the lower left of the screen (e.g., the TARGA series).</haxe_doc>
	</xOrigin>
	<width>
		<x path="Int"/>
		<haxe_doc>This field specifies the width of the image in pixels.</haxe_doc>
	</width>
	<imageType>
		<e path="format.tga.ImageType"/>
		<haxe_doc>Image data type.</haxe_doc>
	</imageType>
	<imageOrigin><e path="format.tga.ImageOrigin"/></imageOrigin>
	<height>
		<x path="Int"/>
		<haxe_doc>This field specifies the height of the image in pixels.</haxe_doc>
	</height>
	<colorMapType>
		<x path="Int"/>
		<haxe_doc>* Indicated type of color map.
   * 0 = no color map present.
   * 1 = color map included.
   * 2-127 is reserved by Truevision
   * 128-255 may be used by app developers.</haxe_doc>
	</colorMapType>
	<colorMapLength>
		<x path="Int"/>
		<haxe_doc>Total number of color map entries included.</haxe_doc>
	</colorMapLength>
	<colorMapFirstIndex>
		<x path="Int"/>
		<haxe_doc>* Index of the first color map entry. Index refers to the starting entry in
   * loading the color map.</haxe_doc>
	</colorMapFirstIndex>
	<colorMapEntrySize>
		<x path="Int"/>
		<haxe_doc>* Establishes the number of bits per entry. Typically 15, 16, 24 or 32-bit
   * values are used.</haxe_doc>
	</colorMapEntrySize>
	<bitsPerPixel>
		<x path="Int"/>
		<haxe_doc>* This field indicates the number of bits per pixel. This number includes
   * the Attribute or Alpha channel bits. Common values are 8, 16, 24 and
   * 32 but other pixel depths could be used.</haxe_doc>
	</bitsPerPixel>
	<alphaChannelBits>
		<x path="Int"/>
		<haxe_doc>* the number of attribute bits per
   * pixel. In the case of the TrueVista, these bits
   * indicate the number of bits per pixel which are
   * designated as Alpha Channel bits. For the ICB
   * and TARGA products, these bits indicate the
   * number of overlay bits available per pixel.</haxe_doc>
	</alphaChannelBits>
</a></typedef>
	<enum path="format.tga.ImageOrigin" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/tga/Data.hx" module="format.tga.Data">
		<BottomLeft/>
		<BottomRight/>
		<TopLeft/>
		<TopRight/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="format.tga.ImageType" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/tga/Data.hx" module="format.tga.Data">
		<NoImage><haxe_doc>There is no image data present</haxe_doc></NoImage>
		<UncompressedColorMapped><haxe_doc>Uncompressed image with color-map usage</haxe_doc></UncompressedColorMapped>
		<UncompressedTrueColor><haxe_doc>True-color uncompressed image</haxe_doc></UncompressedTrueColor>
		<UncompressedBlackAndWhite><haxe_doc>Black-and-White uncompresed image</haxe_doc></UncompressedBlackAndWhite>
		<RunLengthColorMapped><haxe_doc>Run-length encoded image with color-map usage</haxe_doc></RunLengthColorMapped>
		<RunLengthTrueColor><haxe_doc>Run-length encoded true-color image</haxe_doc></RunLengthTrueColor>
		<RunLengthBlackAndWhite><haxe_doc>Run-length encoded black-and-white image</haxe_doc></RunLengthBlackAndWhite>
		<Unknown a="type">
			<x path="Int"/>
			<haxe_doc>Unknown type</haxe_doc>
		</Unknown>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<typedef path="format.tga.Data" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/tga/Data.hx"><a>
	<imageId><c path="String"/></imageId>
	<imageData><x path="haxe.ds.Vector"><x path="Int"/></x></imageData>
	<header><t path="format.tga.Header"/></header>
	<developerData><d/></developerData>
	<colorMapData><x path="haxe.ds.Vector"><x path="Int"/></x></colorMapData>
</a></typedef>
	<class path="format.tga.Reader" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/tga/Reader.hx">
		<i><c path="haxe.io.Input"/></i>
		<read public="1" set="method" line="21"><f a=""><t path="format.tga.Data"/></f></read>
		<readHeader set="method" line="37"><f a=""><t path="format.tga.Header"/></f></readHeader>
		<readColorMapData set="method" line="103"><f a="header">
	<t path="format.tga.Header"/>
	<x path="haxe.ds.Vector"><x path="Int"/></x>
</f></readColorMapData>
		<readImageData set="method" line="109"><f a="header:colorMap">
	<t path="format.tga.Header"/>
	<x path="haxe.ds.Vector"><x path="Int"/></x>
	<x path="haxe.ds.Vector"><x path="Int"/></x>
</f></readImageData>
		<readPixels set="method" line="136"><f a="bitsPerPixel:amount:alphaChannelBits:rle">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="haxe.ds.Vector"><x path="Int"/></x>
</f></readPixels>
		<readMono set="method" line="206"><f a="bitsPerPixel:amount:alphaChannelBits:rle">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="haxe.ds.Vector"><x path="Int"/></x>
</f></readMono>
		<readIndexes set="method" line="266"><f a="bitsPerPixel:amount:colorMap:offset:rle">
	<x path="Int"/>
	<x path="Int"/>
	<x path="haxe.ds.Vector"><x path="Int"/></x>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="haxe.ds.Vector"><x path="Int"/></x>
</f></readIndexes>
		<parsePixel1 set="method" line="324"><f a="value:alpha">
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
</f></parsePixel1>
		<parsePixelGreyAlpha set="method" line="329"><f a="value:alpha">
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
</f></parsePixelGreyAlpha>
		<parsePixel2 set="method" line="334"><f a="value:alpha">
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
</f></parsePixel2>
		<parsePixel3 set="method" line="342"><f a="value:alpha">
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
</f></parsePixel3>
		<parsePixel4 set="method" line="347"><f a="value:alpha">
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
</f></parsePixel4>
		<new public="1" set="method" line="15"><f a="i">
	<c path="haxe.io.Input"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Yanrishatum</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="format.tmx.TmxOrientation" params="" file="E:\HaxeToolkit\haxe\lib\format-tiled\git\format/tmx/Data.hx" module="format.tmx.Data">
		<Orthogonal/>
		<Isometric/>
		<Staggered><haxe_doc>Since 0.9</haxe_doc></Staggered>
		<Hexagonal><haxe_doc>Since 0.11</haxe_doc></Hexagonal>
		<Unknown a="value"><c path="String"/></Unknown>
		<haxe_doc>Map orientation</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<enum path="format.tmx.TmxRenderOrder" params="" file="E:\HaxeToolkit\haxe\lib\format-tiled\git\format/tmx/Data.hx" module="format.tmx.Data">
		<RightDown/>
		<RightUp/>
		<LeftDown/>
		<LeftUp/>
		<Unknown a="value"><c path="String"/></Unknown>
		<haxe_doc>Rendering order of tiles</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<enum path="format.tmx.TmxStaggerIndex" params="" file="E:\HaxeToolkit\haxe\lib\format-tiled\git\format/tmx/Data.hx" module="format.tmx.Data">
		<Even/>
		<Odd/>
		<Unknown a="value"><c path="String"/></Unknown>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<enum path="format.tmx.TmxStaggerAxis" params="" file="E:\HaxeToolkit\haxe\lib\format-tiled\git\format/tmx/Data.hx" module="format.tmx.Data">
		<AxisX/>
		<AxisY/>
		<Unknown a="value"><c path="String"/></Unknown>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<class path="format.tmx.TmxMap" params="" file="E:\HaxeToolkit\haxe\lib\format-tiled\git\format/tmx/Data.hx" module="format.tmx.Data">
		<version public="1">
			<c path="String"/>
			<haxe_doc>The TMX format version. Always 1.0 for pre 1.0 tiled, and matches major/minor version of Tiled for newer versions.</haxe_doc>
		</version>
		<tiledVersion public="1">
			<c path="String"/>
			<haxe_doc>The Tiled version used to save the file. May be a date (for snapshot builds).</haxe_doc>
		</tiledVersion>
		<orientation public="1">
			<e path="format.tmx.TmxOrientation"/>
			<haxe_doc>Map orientation.</haxe_doc>
		</orientation>
		<width public="1">
			<x path="Int"/>
			<haxe_doc>The map width in tiles.</haxe_doc>
		</width>
		<height public="1">
			<x path="Int"/>
			<haxe_doc>The map height in tiles.</haxe_doc>
		</height>
		<tileWidth public="1">
			<x path="Int"/>
			<haxe_doc>* The width of a tile.
   * 
   * The tilewidth and tileheight properties determine the general grid size of the map.  
   * The individual tiles may have different sizes. Larger tiles will extend at the top and right (anchored to the bottom left).
   *</haxe_doc>
		</tileWidth>
		<tileHeight public="1">
			<x path="Int"/>
			<haxe_doc>* The height of a tile.
   * 
   * The tilewidth and tileheight properties determine the general grid size of the map.  
   * The individual tiles may have different sizes. Larger tiles will extend at the top and right (anchored to the bottom left).</haxe_doc>
		</tileHeight>
		<backgroundColor public="1">
			<x path="Int"/>
			<haxe_doc>The background color of the map in ARGB format.</haxe_doc>
		</backgroundColor>
		<renderOrder public="1">
			<e path="format.tmx.TmxRenderOrder"/>
			<haxe_doc>The order in which tiles on tile layers are rendered. In all cases, the map is drawn row-by-row.</haxe_doc>
		</renderOrder>
		<staggerIndex public="1">
			<x path="Null"><e path="format.tmx.TmxStaggerIndex"/></x>
			<haxe_doc>For staggered and hexagonal maps, determines whether the "even" or "odd" indexes along the staggered axis are shifted.</haxe_doc>
		</staggerIndex>
		<staggerAxis public="1">
			<x path="Null"><e path="format.tmx.TmxStaggerAxis"/></x>
			<haxe_doc>* For staggered and hexagonal maps, determines which axis (x or y) is staggered.</haxe_doc>
		</staggerAxis>
		<hexSideLength public="1">
			<x path="Null"><x path="Int"/></x>
			<haxe_doc>Only for hexagonal maps. Determines the width or height (depending on the staggered axis) of the tile's edge, in pixels.</haxe_doc>
		</hexSideLength>
		<nextObjectId public="1">
			<x path="Int"/>
			<haxe_doc>Stores the next available ID for new objects. This number is stored to prevent reuse of the same ID after objects have been removed.</haxe_doc>
		</nextObjectId>
		<nextLayerId public="1">
			<x path="Int"/>
			<haxe_doc>Stores the next available ID for new layers. This number is stored to prevent reuse of the same ID after layers have been removed.</haxe_doc>
		</nextLayerId>
		<properties public="1">
			<x path="format.tmx.TmxProperties"/>
			<haxe_doc>Properties of the map</haxe_doc>
		</properties>
		<tilesets public="1">
			<c path="Array"><c path="format.tmx.TmxTileset"/></c>
			<haxe_doc>Tilesets used in map</haxe_doc>
		</tilesets>
		<layers public="1">
			<c path="Array"><e path="format.tmx.TmxLayer"/></c>
			<haxe_doc>Array of all layers in map. Tile layers, object groups and image layers.</haxe_doc>
		</layers>
		<infinite public="1">
			<x path="Bool"/>
			<haxe_doc>Is that map infinite?</haxe_doc>
		</infinite>
		<localPath public="1">
			<x path="Null"><c path="String"/></x>
			<haxe_doc>Local path of the TmxMap supplied during parsing. Not a part of tmx specification.</haxe_doc>
		</localPath>
		<new public="1" set="method" line="43">
			<f a="version:tiledVersion:orientation:width:height:tileWidth:tileHeight:backgroundColor:renderOrder:staggerIndex:staggerAxis:hexSideLength:nextObjectId:nextLayerId:properties:tilesets:layers:infinite:localPath">
				<c path="String"/>
				<c path="String"/>
				<e path="format.tmx.TmxOrientation"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<e path="format.tmx.TmxRenderOrder"/>
				<x path="Null"><e path="format.tmx.TmxStaggerIndex"/></x>
				<x path="Null"><e path="format.tmx.TmxStaggerAxis"/></x>
				<x path="Null"><x path="Int"/></x>
				<x path="Int"/>
				<x path="Int"/>
				<x path="format.tmx.TmxProperties"/>
				<c path="Array"><c path="format.tmx.TmxTileset"/></c>
				<c path="Array"><e path="format.tmx.TmxLayer"/></c>
				<x path="Bool"/>
				<x path="Null"><c path="String"/></x>
				<x path="Void"/>
			</f>
			<meta><m n=":compilerGenerated"/></meta>
		</new>
		<haxe_doc>General .tmx map file</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="format.tmx.TmxTileset" params="" file="E:\HaxeToolkit\haxe\lib\format-tiled\git\format/tmx/Data.hx" module="format.tmx.Data">
		<firstGID public="1">
			<x path="Null"><x path="Int"/></x>
			<meta><m n=":optional"/></meta>
			<haxe_doc>The first global tile ID of this tileset (this global ID maps to the first tile in this tileset).</haxe_doc>
		</firstGID>
		<source public="1">
			<c path="String"/>
			<meta><m n=":optional"/></meta>
			<haxe_doc><![CDATA[If this tileset is stored in an external TSX (Tile Set XML) file, this attribute refers to that file. That TSX file has the same structure as the <tileset> element described here. (There is the firstgid attribute missing and this source attribute is also not there. These two attributes are kept in the TMX map, since they are map specific.)]]></haxe_doc>
		</source>
		<name public="1">
			<c path="String"/>
			<meta><m n=":optional"/></meta>
			<haxe_doc>The name of this tileset.</haxe_doc>
		</name>
		<tileWidth public="1">
			<x path="Null"><x path="Int"/></x>
			<meta><m n=":optional"/></meta>
			<haxe_doc>The (maximum) width of the tiles in this tileset.</haxe_doc>
		</tileWidth>
		<tileHeight public="1">
			<x path="Null"><x path="Int"/></x>
			<meta><m n=":optional"/></meta>
			<haxe_doc>The (maximum) height of the tiles in this tileset.</haxe_doc>
		</tileHeight>
		<spacing public="1">
			<x path="Null"><x path="Int"/></x>
			<meta><m n=":optional"/></meta>
			<haxe_doc>The spacing in pixels between the tiles in this tileset (applies to the tileset image).</haxe_doc>
		</spacing>
		<margin public="1">
			<x path="Null"><x path="Int"/></x>
			<meta><m n=":optional"/></meta>
			<haxe_doc>The margin around the tiles in this tileset (applies to the tileset image).</haxe_doc>
		</margin>
		<tileCount public="1">
			<x path="Int"/>
			<meta><m n=":optional"/></meta>
			<haxe_doc>The number of tiles in this tileset (since 0.13)</haxe_doc>
		</tileCount>
		<columns public="1">
			<x path="Int"/>
			<meta><m n=":optional"/></meta>
			<haxe_doc>The number of tile columns in the tileset. For image collection tilesets it is editable and is used when displaying the tileset. (since 0.15)</haxe_doc>
		</columns>
		<tileOffset public="1">
			<c path="format.tmx.TmxTileOffset"/>
			<meta><m n=":optional"/></meta>
			<haxe_doc>This element is used to specify an offset in pixels, to be applied when drawing a tile from the related tileset. When not present, no offset is applied. Since 0.8</haxe_doc>
		</tileOffset>
		<properties public="1">
			<x path="format.tmx.TmxProperties"/>
			<meta><m n=":optional"/></meta>
			<haxe_doc>Since 0.8</haxe_doc>
		</properties>
		<image public="1">
			<c path="format.tmx.TmxImage"/>
			<meta><m n=":optional"/></meta>
			<haxe_doc>* As of the current version of Tiled Qt, each tileset has a single image associated with it,  
   * which is cut into smaller tiles based on the attributes defined on the tileset element.  
   * Later versions may add support for adding multiple images to a single tileset, as is possible in Tiled Java.</haxe_doc>
		</image>
		<terrainTypes public="1">
			<c path="Array"><c path="format.tmx.TmxTerrain"/></c>
			<meta><m n=":optional"/></meta>
			<haxe_doc>Terrain type defines. Since 0.9</haxe_doc>
		</terrainTypes>
		<tiles public="1">
			<c path="Array"><c path="format.tmx.TmxTilesetTile"/></c>
			<meta><m n=":optional"/></meta>
			<haxe_doc>Extended tiles data.</haxe_doc>
		</tiles>
		<grid public="1">
			<c path="format.tmx.TmxTilesetGrid"/>
			<meta><m n=":optional"/></meta>
			<haxe_doc>Since 1.0</haxe_doc>
		</grid>
		<wangSets public="1">
			<c path="Array"><c path="format.tmx.TmxWangSet"/></c>
			<meta><m n=":optional"/></meta>
			<haxe_doc>Since 1.1</haxe_doc>
		</wangSets>
		<new public="1" set="method" line="109">
			<f a="?firstGID:?source:?name:?tileWidth:?tileHeight:?spacing:?margin:?tileCount:?columns:?tileOffset:?properties:?image:?terrainTypes:?tiles:?grid:?wangSets">
				<x path="Int"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="format.tmx.TmxTileOffset"/>
				<x path="format.tmx.TmxProperties"/>
				<c path="format.tmx.TmxImage"/>
				<c path="Array"><c path="format.tmx.TmxTerrain"/></c>
				<c path="Array"><c path="format.tmx.TmxTilesetTile"/></c>
				<c path="format.tmx.TmxTilesetGrid"/>
				<c path="Array"><c path="format.tmx.TmxWangSet"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":compilerGenerated"/></meta>
		</new>
		<haxe_doc>* Tileset  
 * TSX files does not contains firstGID and source.  
 * TMX Tilesets can be both full tilesets or point to TSX file. In that case it contains only firstGID and source.  
 * You can merge TSX file TMX Tileset into one by using `new Reader(tsxXML).readTSX(tmxTileset);`.  
 * Since Tiled 0.15, image collection tilesets do not necessarily number their tiles consecutively since gaps can occur when removing tiles.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="format.tmx.TmxTilesetGrid" params="" file="E:\HaxeToolkit\haxe\lib\format-tiled\git\format/tmx/Data.hx" module="format.tmx.Data">
		<orientation public="1">
			<e path="format.tmx.TmxOrientation"/>
			<haxe_doc>Orientation of the grid for the tiles in this tileset (orthogonal or isometric)</haxe_doc>
		</orientation>
		<width public="1"><x path="Int"/></width>
		<height public="1"><x path="Int"/></height>
		<new public="1" set="method" line="155">
			<f a="orientation:width:height">
				<e path="format.tmx.TmxOrientation"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":compilerGenerated"/></meta>
		</new>
		<haxe_doc>This element is only used in case of isometric orientation, and determines how tile overlays for terrain and collision information are rendered.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="format.tmx.TmxTileOffset" params="" file="E:\HaxeToolkit\haxe\lib\format-tiled\git\format/tmx/Data.hx" module="format.tmx.Data">
		<x public="1">
			<x path="Int"/>
			<haxe_doc>Horizontal offset in pixels</haxe_doc>
		</x>
		<y public="1">
			<x path="Int"/>
			<haxe_doc>Vertical offset in pixels (positive is down)</haxe_doc>
		</y>
		<new public="1" set="method" line="167">
			<f a="x:y">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":compilerGenerated"/></meta>
		</new>
		<haxe_doc>This element is used to specify an offset in pixels, to be applied when drawing a tile from the related tileset. When not present, no offset is applied.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="format.tmx.TmxWangSet" params="" file="E:\HaxeToolkit\haxe\lib\format-tiled\git\format/tmx/Data.hx" module="format.tmx.Data">
		<name public="1">
			<c path="String"/>
			<haxe_doc>The name of the Wang set.</haxe_doc>
		</name>
		<tile public="1">
			<x path="Int"/>
			<haxe_doc>The tile ID of the tile representing this Wang set.</haxe_doc>
		</tile>
		<corners public="1">
			<c path="Array"><c path="format.tmx.TmxWangSetColor"/></c>
			<haxe_doc>A color that can be used to define the corner of a Wang tile.</haxe_doc>
		</corners>
		<edges public="1">
			<c path="Array"><c path="format.tmx.TmxWangSetColor"/></c>
			<haxe_doc>A color that can be used to define the edge of a Wang tile.</haxe_doc>
		</edges>
		<tiles public="1">
			<c path="Array"><c path="format.tmx.TmxWangSetTile"/></c>
			<haxe_doc>Defines a Wang tile, by referring to a tile in the tileset and associating it with a certain Wang ID.</haxe_doc>
		</tiles>
		<new public="1" set="method" line="177">
			<f a="name:tile:corners:edges:tiles">
				<c path="String"/>
				<x path="Int"/>
				<c path="Array"><c path="format.tmx.TmxWangSetColor"/></c>
				<c path="Array"><c path="format.tmx.TmxWangSetColor"/></c>
				<c path="Array"><c path="format.tmx.TmxWangSetTile"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":compilerGenerated"/></meta>
		</new>
		<haxe_doc>Defines a list of corner colors and a list of edge colors, and any number of Wang tiles using these colors.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="format.tmx.TmxWangSetColor" params="" file="E:\HaxeToolkit\haxe\lib\format-tiled\git\format/tmx/Data.hx" module="format.tmx.Data">
		<name public="1">
			<c path="String"/>
			<haxe_doc>The name of this color.</haxe_doc>
		</name>
		<color public="1">
			<x path="Int"/>
			<haxe_doc>The color in #RRGGBB format (example: #c17d11).</haxe_doc>
		</color>
		<tile public="1">
			<x path="Int"/>
			<haxe_doc>The tile ID of the tile representing this color.</haxe_doc>
		</tile>
		<probability public="1">
			<x path="Float"/>
			<haxe_doc>The relative probability that this color is chosen over others in case of multiple options.</haxe_doc>
		</probability>
		<new public="1" set="method" line="194">
			<f a="name:color:tile:probability">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":compilerGenerated"/></meta>
		</new>
		<haxe_doc>A color that can be used to define the corner or an edge of a Wang tile.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="format.tmx.TmxWangSetTile" params="" file="E:\HaxeToolkit\haxe\lib\format-tiled\git\format/tmx/Data.hx" module="format.tmx.Data">
		<tileID public="1">
			<x path="Int"/>
			<haxe_doc>The tile ID.</haxe_doc>
		</tileID>
		<wangID public="1">
			<x path="Int"/>
			<haxe_doc>* The Wang ID, which is a 32-bit unsigned integer stored in the format 0xCECECECE
   * (where each C is a corner color and each E is an edge color, from right to left clockwise, starting with the top edge)</haxe_doc>
		</wangID>
		<new public="1" set="method" line="208">
			<f a="tileID:wangID">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":compilerGenerated"/></meta>
		</new>
		<haxe_doc>Defines a Wang tile, by referring to a tile in the tileset and associating it with a certain Wang ID.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="format.tmx.TmxImage" params="" file="E:\HaxeToolkit\haxe\lib\format-tiled\git\format/tmx/Data.hx" module="format.tmx.Data">
		<format public="1">
			<c path="String"/>
			<meta><m n=":optional"/></meta>
			<haxe_doc>Used for embedded images, in combination with a data child element. Valid values are file extensions like png, gif, jpg, bmp, etc. (since 0.9.0)</haxe_doc>
		</format>
		<id public="1">
			<c path="String"/>
			<meta><m n=":optional"/></meta>
			<haxe_doc>Used by some versions of Tiled Java. Deprecated and unsupported by Tiled Qt.</haxe_doc>
		</id>
		<source public="1">
			<c path="String"/>
			<haxe_doc>The reference to the tileset image file (Tiled supports most common image formats).</haxe_doc>
		</source>
		<transparent public="1">
			<x path="Null"><x path="Int"/></x>
			<meta><m n=":optional"/></meta>
			<haxe_doc>* Defines a specific color that is treated as transparent (example value: "#FF00FF" for magenta). 
   * Up until Tiled 0.10 (upd: 0.12), this value is written out without a # but this is planned to change.</haxe_doc>
		</transparent>
		<width public="1">
			<x path="Null"><x path="Int"/></x>
			<meta><m n=":optional"/></meta>
			<haxe_doc>The image width in pixels (optional, used for tile index correction when the image changes)</haxe_doc>
		</width>
		<height public="1">
			<x path="Null"><x path="Int"/></x>
			<meta><m n=":optional"/></meta>
			<haxe_doc>The image height in pixels (optional)</haxe_doc>
		</height>
		<data public="1">
			<c path="format.tmx.TmxData"/>
			<meta><m n=":optional"/></meta>
			<haxe_doc>Since 0.9</haxe_doc>
		</data>
		<new public="1" set="method" line="225">
			<f a="?format:?id:source:?transparent:?width:?height:?data">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="format.tmx.TmxData"/>
				<x path="Void"/>
			</f>
			<meta><m n=":compilerGenerated"/></meta>
		</new>
		<haxe_doc>* As of the current version of Tiled Qt, each tileset has a single image associated with it,  
 * which is cut into smaller tiles based on the attributes defined on the tileset element.  
 * Later versions may add support for adding multiple images to a single tileset, as is possible in Tiled Java.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="format.tmx.TmxTerrain" params="" file="E:\HaxeToolkit\haxe\lib\format-tiled\git\format/tmx/Data.hx" module="format.tmx.Data">
		<name public="1">
			<c path="String"/>
			<haxe_doc>The name of the terrain type.</haxe_doc>
		</name>
		<tile public="1">
			<x path="Int"/>
			<haxe_doc>The local tile-id of the tile that represents the terrain visually.</haxe_doc>
		</tile>
		<properties public="1">
			<x path="format.tmx.TmxProperties"/>
			<meta><m n=":optional"/></meta>
		</properties>
		<new public="1" set="method" line="247">
			<f a="name:tile:?properties">
				<c path="String"/>
				<x path="Int"/>
				<x path="format.tmx.TmxProperties"/>
				<x path="Void"/>
			</f>
			<meta><m n=":compilerGenerated"/></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="format.tmx.TmxTilesetTile" params="" file="E:\HaxeToolkit\haxe\lib\format-tiled\git\format/tmx/Data.hx" module="format.tmx.Data">
		<id public="1">
			<x path="Int"/>
			<haxe_doc>The local tile ID within its tileset.</haxe_doc>
		</id>
		<type public="1">
			<c path="String"/>
			<meta><m n=":optional"/></meta>
		</type>
		<terrain public="1">
			<c path="String"/>
			<meta><m n=":optional"/></meta>
			<haxe_doc>* Defines the terrain type of each corner of the tile,
   * given as comma-separated indexes in the terrain types array in the order 
   * top-left, top-right, bottom-left, bottom-right. Leaving out a value means
   * that corner has no terrain. (optional) (since 0.9.0)</haxe_doc>
		</terrain>
		<probability public="1">
			<x path="Float"/>
			<meta><m n=":optional"/></meta>
			<haxe_doc>* A percentage indicating the probability that this tile is chosen when it
   * competes with others while editing with the terrain tool. (optional) (since 0.9.0)</haxe_doc>
		</probability>
		<properties public="1">
			<x path="format.tmx.TmxProperties"/>
			<meta><m n=":optional"/></meta>
		</properties>
		<image public="1">
			<c path="format.tmx.TmxImage"/>
			<meta><m n=":optional"/></meta>
			<haxe_doc>* Since 0.9</haxe_doc>
		</image>
		<objectGroup public="1">
			<c path="format.tmx.TmxObjectGroup"/>
			<meta><m n=":optional"/></meta>
			<haxe_doc>* Since 0.10.
   * This group represents collision of tile and never contains Tile object type.</haxe_doc>
		</objectGroup>
		<animation public="1">
			<c path="Array"><c path="format.tmx.TmxTilesetTileFrame"/></c>
			<meta><m n=":optional"/></meta>
			<haxe_doc>* Since 0.10.
   * Present, if tile does not static and contains animation.  
   * Contains a list of animation frames.  
   * As of Tiled 0.10, each tile can have exactly one animation associated with it. In the future, there could be support for multiple named animations on a tile.</haxe_doc>
		</animation>
		<new public="1" set="method" line="258">
			<f a="id:?type:?terrain:?probability:?properties:?image:?objectGroup:?animation">
				<x path="Int"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Float"/>
				<x path="format.tmx.TmxProperties"/>
				<c path="format.tmx.TmxImage"/>
				<c path="format.tmx.TmxObjectGroup"/>
				<c path="Array"><c path="format.tmx.TmxTilesetTileFrame"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":compilerGenerated"/></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="format.tmx.TmxTilesetTileFrame" params="" file="E:\HaxeToolkit\haxe\lib\format-tiled\git\format/tmx/Data.hx" module="format.tmx.Data">
		<tileId public="1">
			<x path="Int"/>
			<haxe_doc>The local ID of a tile within the parent tileset.</haxe_doc>
		</tileId>
		<duration public="1">
			<x path="Int"/>
			<haxe_doc>How long (in milliseconds) this frame should be displayed before advancing to the next frame.</haxe_doc>
		</duration>
		<new public="1" set="method" line="300">
			<f a="tileId:duration">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":compilerGenerated"/></meta>
		</new>
		<haxe_doc>* Animation frame of a single tile in tileset.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<enum path="format.tmx.TmxLayer" params="" file="E:\HaxeToolkit\haxe\lib\format-tiled\git\format/tmx/Data.hx" module="format.tmx.Data">
		<LTileLayer a="layer"><c path="format.tmx.TmxTileLayer"/></LTileLayer>
		<LObjectGroup a="group"><c path="format.tmx.TmxObjectGroup"/></LObjectGroup>
		<LImageLayer a="layer"><c path="format.tmx.TmxImageLayer"/></LImageLayer>
		<LGroup a="group"><c path="format.tmx.TmxGroup"/></LGroup>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<class path="format.tmx.TmxGroup" params="" file="E:\HaxeToolkit\haxe\lib\format-tiled\git\format/tmx/Data.hx" module="format.tmx.Data">
		<id public="1">
			<x path="Int"/>
			<haxe_doc>Unique ID of the layer. Each layer that added to a map gets a unique id. Even if a layer is deleted, no layer ever gets the same ID. Can not be changed in Tiled. (since Tiled 1.2)</haxe_doc>
		</id>
		<name public="1">
			<c path="String"/>
			<haxe_doc>The name of the group layer.</haxe_doc>
		</name>
		<offsetX public="1">
			<x path="Int"/>
			<haxe_doc>Rendering offset of the group layer in pixels. Defaults to 0.</haxe_doc>
		</offsetX>
		<offsetY public="1">
			<x path="Int"/>
			<haxe_doc>Rendering offset of the group layer in pixels. Defaults to 0.</haxe_doc>
		</offsetY>
		<opacity public="1">
			<x path="Float"/>
			<haxe_doc>The opacity of the layer as a value from 0 to 1. Defaults to 1.</haxe_doc>
		</opacity>
		<visible public="1">
			<x path="Bool"/>
			<haxe_doc>Whether the layer is shown (1) or hidden (0). Defaults to 1.</haxe_doc>
		</visible>
		<properties public="1"><x path="format.tmx.TmxProperties"/></properties>
		<layers public="1"><c path="Array"><e path="format.tmx.TmxLayer"/></c></layers>
		<new public="1" set="method" line="321">
			<f a="id:name:offsetX:offsetY:opacity:visible:properties:layers">
				<x path="Int"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="format.tmx.TmxProperties"/>
				<c path="Array"><e path="format.tmx.TmxLayer"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":compilerGenerated"/></meta>
		</new>
		<haxe_doc>* A group layer, used to organize the layers of the map in a hierarchy. 
 * Its attributes offsetx, offsety, opacity and visible recursively affect child layers.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="format.tmx.TmxBaseLayer" params="" file="E:\HaxeToolkit\haxe\lib\format-tiled\git\format/tmx/Data.hx" module="format.tmx.Data">
		<id public="1">
			<x path="Int"/>
			<haxe_doc>Unique ID of the layer. Each layer that added to a map gets a unique id. Even if a layer is deleted, no layer ever gets the same ID. Can not be changed in Tiled. (since Tiled 1.2)</haxe_doc>
		</id>
		<name public="1">
			<c path="String"/>
			<haxe_doc>The name of the layer.</haxe_doc>
		</name>
		<x public="1">
			<x path="Null"><x path="Float"/></x>
			<haxe_doc>The x coordinate of the layer in tiles. Defaults to 0 and can no longer be changed in Tiled Qt. (Except ImageLayer)</haxe_doc>
		</x>
		<y public="1">
			<x path="Null"><x path="Float"/></x>
			<haxe_doc>The y coordinate of the layer in tiles. Defaults to 0 and can no longer be changed in Tiled Qt. (Except ImageLayer)</haxe_doc>
		</y>
		<width public="1">
			<x path="Null"><x path="Int"/></x>
			<haxe_doc>The width of the layer in tiles. Traditionally required, but as of Tiled Qt always the same as the map width.</haxe_doc>
		</width>
		<height public="1">
			<x path="Null"><x path="Int"/></x>
			<haxe_doc>The height of the layer in tiles. Traditionally required, but as of Tiled Qt always the same as the map height.</haxe_doc>
		</height>
		<opacity public="1">
			<x path="Null"><x path="Float"/></x>
			<haxe_doc>The opacity of the layer as a value from 0 to 1. Defaults to 1.</haxe_doc>
		</opacity>
		<visible public="1">
			<x path="Null"><x path="Bool"/></x>
			<haxe_doc>Whether the layer is shown (1) or hidden (0). Defaults to 1.</haxe_doc>
		</visible>
		<offsetX public="1">
			<x path="Null"><x path="Int"/></x>
			<haxe_doc>Rendering offset for this layer in pixels. Defaults to 0. (since 0.14)</haxe_doc>
		</offsetX>
		<offsetY public="1">
			<x path="Null"><x path="Int"/></x>
			<haxe_doc>Rendering offset for this layer in pixels. Defaults to 0. (since 0.14)</haxe_doc>
		</offsetY>
		<properties public="1"><x path="format.tmx.TmxProperties"/></properties>
		<new public="1" set="method" line="366"><f a="id:name:x:y:offsetX:offsetY:width:height:opacity:visible:properties">
	<x path="Int"/>
	<c path="String"/>
	<x path="Null"><x path="Float"/></x>
	<x path="Null"><x path="Float"/></x>
	<x path="Null"><x path="Int"/></x>
	<x path="Null"><x path="Int"/></x>
	<x path="Null"><x path="Int"/></x>
	<x path="Null"><x path="Int"/></x>
	<x path="Null"><x path="Float"/></x>
	<x path="Bool"/>
	<x path="format.tmx.TmxProperties"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="format.tmx.TmxImageLayer" params="" file="E:\HaxeToolkit\haxe\lib\format-tiled\git\format/tmx/Data.hx" module="format.tmx.Data">
		<extends path="format.tmx.TmxBaseLayer"/>
		<image public="1">
			<c path="format.tmx.TmxImage"/>
			<meta><m n=":optional"/></meta>
		</image>
		<new public="1" set="method" line="393"><f a="image:id:name:x:y:offsetX:offsetY:width:height:opacity:visible:properties">
	<c path="format.tmx.TmxImage"/>
	<x path="Int"/>
	<c path="String"/>
	<x path="Null"><x path="Float"/></x>
	<x path="Null"><x path="Float"/></x>
	<x path="Null"><x path="Int"/></x>
	<x path="Null"><x path="Int"/></x>
	<x path="Null"><x path="Int"/></x>
	<x path="Null"><x path="Int"/></x>
	<x path="Null"><x path="Float"/></x>
	<x path="Bool"/>
	<x path="format.tmx.TmxProperties"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* A layer consisting of a single image.
 * Since 0.15 `x` and `y` position of layer is defined via `offsetX` and `offsetY`.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="format.tmx.TmxTileLayer" params="" file="E:\HaxeToolkit\haxe\lib\format-tiled\git\format/tmx/Data.hx" module="format.tmx.Data">
		<extends path="format.tmx.TmxBaseLayer"/>
		<data public="1">
			<c path="format.tmx.TmxData"/>
			<meta><m n=":optional"/></meta>
		</data>
		<new public="1" set="method" line="407"><f a="data:id:name:x:y:offsetX:offsetY:width:height:opacity:visible:properties">
	<c path="format.tmx.TmxData"/>
	<x path="Int"/>
	<c path="String"/>
	<x path="Null"><x path="Float"/></x>
	<x path="Null"><x path="Float"/></x>
	<x path="Null"><x path="Int"/></x>
	<x path="Null"><x path="Int"/></x>
	<x path="Null"><x path="Int"/></x>
	<x path="Null"><x path="Int"/></x>
	<x path="Null"><x path="Float"/></x>
	<x path="Bool"/>
	<x path="format.tmx.TmxProperties"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<enum path="format.tmx.TmxDataEncoding" params="" file="E:\HaxeToolkit\haxe\lib\format-tiled\git\format/tmx/Data.hx" module="format.tmx.Data">
		<None><haxe_doc>No encoding, data given in raw.</haxe_doc></None>
		<Base64><haxe_doc>Base64-encoded data.</haxe_doc></Base64>
		<CSV><haxe_doc>Comma-separated-values data. Can be applied only for tile data.</haxe_doc></CSV>
		<Unknown a="value">
			<c path="String"/>
			<haxe_doc>Unknown encoding</haxe_doc>
		</Unknown>
		<haxe_doc>Encoding of the data.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<enum path="format.tmx.TmxDataCompression" params="" file="E:\HaxeToolkit\haxe\lib\format-tiled\git\format/tmx/Data.hx" module="format.tmx.Data">
		<None><haxe_doc>No compression.</haxe_doc></None>
		<GZip><haxe_doc>GZip compression. Currently not supported.</haxe_doc></GZip>
		<ZLib><haxe_doc>ZLib compression.</haxe_doc></ZLib>
		<Unknown a="value">
			<c path="String"/>
			<haxe_doc>Unknown compression</haxe_doc>
		</Unknown>
		<haxe_doc>Compression type for data.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<class path="format.tmx.TmxData" params="" file="E:\HaxeToolkit\haxe\lib\format-tiled\git\format/tmx/Data.hx" module="format.tmx.Data">
		<encoding public="1">
			<e path="format.tmx.TmxDataEncoding"/>
			<meta><m n=":optional"/></meta>
			<haxe_doc>The encoding used to encode the tile layer data. When used, it can be "base64" and "csv" at the moment.</haxe_doc>
		</encoding>
		<compression public="1">
			<e path="format.tmx.TmxDataCompression"/>
			<meta><m n=":optional"/></meta>
			<haxe_doc>The compression used to compress the tile layer data. Tiled Qt supports "gzip" and "zlib". Optional</haxe_doc>
		</compression>
		<tiles public="1">
			<c path="Array"><x path="format.tmx.TmxTile"/></c>
			<meta><m n=":optional"/></meta>
			<haxe_doc>Decoded tile data</haxe_doc>
		</tiles>
		<chunks public="1">
			<c path="Array"><c path="format.tmx.TmxChunk"/></c>
			<meta><m n=":optional"/></meta>
			<haxe_doc>Infinite maps chunk data</haxe_doc>
		</chunks>
		<data public="1">
			<c path="haxe.io.Bytes"/>
			<meta><m n=":optional"/></meta>
			<haxe_doc>Raw data. Exists for non-tile-layer data objects.</haxe_doc>
		</data>
		<new public="1" set="method" line="456">
			<f a="?encoding:?compression:?tiles:?chunks:?data">
				<e path="format.tmx.TmxDataEncoding"/>
				<e path="format.tmx.TmxDataCompression"/>
				<c path="Array"><x path="format.tmx.TmxTile"/></c>
				<c path="Array"><c path="format.tmx.TmxChunk"/></c>
				<c path="haxe.io.Bytes"/>
				<x path="Void"/>
			</f>
			<meta><m n=":compilerGenerated"/></meta>
		</new>
		<haxe_doc>* When no encoding or compression is given, the tiles are stored as individual XML tile elements.
 * Next to that, the easiest format to parse is the "csv" (comma separated values) format.
 * 
 * The base64-encoded and optionally compressed layer data is somewhat more complicated to parse.
 * First you need to base64-decode it, then you may need to decompress it. Now you have an array of bytes,
 * which should be interpreted as an array of unsigned 32-bit integers using little-endian byte ordering.
 * 
 * Whatever format you choose for your layer data, you will always end up with so called "global tile IDs" (gids).
 * They are global, since they may refer to a tile from any of the tilesets used by the map.
 * In order to find out from which tileset the tile is you need to find the tileset with the highest
 * firstgid that is still lower or equal than the gid. The tilesets are always stored with increasing firstgids.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="format.tmx.TmxChunk" params="" file="E:\HaxeToolkit\haxe\lib\format-tiled\git\format/tmx/Data.hx" module="format.tmx.Data">
		<x public="1">
			<x path="Int"/>
			<haxe_doc>The x coordinate of the chunk in tiles.</haxe_doc>
		</x>
		<y public="1">
			<x path="Int"/>
			<haxe_doc>The y coordinate of the chunk in tiles.</haxe_doc>
		</y>
		<width public="1">
			<x path="Int"/>
			<haxe_doc>The width of the chunk in tiles.</haxe_doc>
		</width>
		<height public="1">
			<x path="Int"/>
			<haxe_doc>The height of the chunk in tiles.</haxe_doc>
		</height>
		<tiles public="1">
			<c path="Array"><x path="format.tmx.TmxTile"/></c>
			<haxe_doc>Decoded tile data</haxe_doc>
		</tiles>
		<new public="1" set="method" line="474">
			<f a="x:y:width:height:tiles">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><x path="format.tmx.TmxTile"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":compilerGenerated"/></meta>
		</new>
		<haxe_doc>* This is currently added only for infinite maps. The contents of a chunk element is same as that of 
 * the data element, except it stores the data of the area specified in the attributes.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<abstract path="format.tmx.TmxTile" params="" file="E:\HaxeToolkit\haxe\lib\format-tiled\git\format/tmx/Data.hx" module="format.tmx.Data">
		<this><x path="Int"/></this>
		<haxe_doc>Single tile in tile layer.</haxe_doc>
		<impl><class path="format.tmx._Data.TmxTile_Impl_" params="" file="E:\HaxeToolkit\haxe\lib\format-tiled\git\format/tmx/Data.hx" private="1" module="format.tmx.Data">
	<FLIPPED_HORIZONTALLY_FLAG get="inline" set="null" expr="0x80000000" line="492" static="1">
		<x path="Int"/>
		<meta><m n=":value"><e>0x80000000</e></m></meta>
	</FLIPPED_HORIZONTALLY_FLAG>
	<FLIPPED_VERTICALLY_FLAG get="inline" set="null" expr="0x40000000" line="493" static="1">
		<x path="Int"/>
		<meta><m n=":value"><e>0x40000000</e></m></meta>
	</FLIPPED_VERTICALLY_FLAG>
	<FLIPPED_DIAGONALLY_FLAG get="inline" set="null" expr="0x20000000" line="494" static="1">
		<x path="Int"/>
		<meta><m n=":value"><e>0x20000000</e></m></meta>
	</FLIPPED_DIAGONALLY_FLAG>
	<FLAGS_MASK get="inline" set="null" expr="0x1FFFFFFF" line="495" static="1">
		<x path="Int"/>
		<meta><m n=":value"><e>0x1FFFFFFF</e></m></meta>
	</FLAGS_MASK>
	<FLAGS_ONLY get="inline" set="null" expr="0xE0000000" line="496" static="1">
		<x path="Int"/>
		<meta><m n=":value"><e>0xE0000000</e></m></meta>
	</FLAGS_ONLY>
	<_new public="1" get="inline" set="null" line="498" static="1">
		<f a="tile">
			<x path="Int"/>
			<x path="format.tmx.TmxTile"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<gid public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Global ID of tile.</haxe_doc>
	</gid>
	<flippedHorizontally public="1" get="accessor" set="null" static="1">
		<x path="Bool"/>
		<meta>
			<m n=":impl"/>
			<m n=":optional"/>
		</meta>
		<haxe_doc>Is tile flipped horizontally? Default: false</haxe_doc>
	</flippedHorizontally>
	<flippedVertically public="1" get="accessor" set="null" static="1">
		<x path="Bool"/>
		<meta>
			<m n=":impl"/>
			<m n=":optional"/>
		</meta>
		<haxe_doc>Is tile flipped vertically? Default: false</haxe_doc>
	</flippedVertically>
	<flippedDiagonally public="1" get="accessor" set="null" static="1">
		<x path="Bool"/>
		<meta>
			<m n=":impl"/>
			<m n=":optional"/>
		</meta>
		<haxe_doc>Is tile flipped diagonally? Default: false</haxe_doc>
	</flippedDiagonally>
	<get_gid get="inline" set="null" line="509" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_gid>
	<get_flippedHorizontally get="inline" set="null" line="510" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_flippedHorizontally>
	<get_flippedVertically get="inline" set="null" line="511" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_flippedVertically>
	<get_flippedDiagonally get="inline" set="null" line="512" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_flippedDiagonally>
	<set_gid get="inline" set="null" line="513" static="1">
		<f a="this:v">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_gid>
</class></impl>
	</abstract>
	<class path="format.tmx._Data.TmxTile_Impl_" params="" file="E:\HaxeToolkit\haxe\lib\format-tiled\git\format/tmx/Data.hx" private="1" module="format.tmx.Data">
		<FLIPPED_HORIZONTALLY_FLAG get="inline" set="null" expr="0x80000000" line="492" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x80000000</e></m></meta>
		</FLIPPED_HORIZONTALLY_FLAG>
		<FLIPPED_VERTICALLY_FLAG get="inline" set="null" expr="0x40000000" line="493" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x40000000</e></m></meta>
		</FLIPPED_VERTICALLY_FLAG>
		<FLIPPED_DIAGONALLY_FLAG get="inline" set="null" expr="0x20000000" line="494" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x20000000</e></m></meta>
		</FLIPPED_DIAGONALLY_FLAG>
		<FLAGS_MASK get="inline" set="null" expr="0x1FFFFFFF" line="495" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1FFFFFFF</e></m></meta>
		</FLAGS_MASK>
		<FLAGS_ONLY get="inline" set="null" expr="0xE0000000" line="496" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xE0000000</e></m></meta>
		</FLAGS_ONLY>
		<_new public="1" get="inline" set="null" line="498" static="1">
			<f a="tile">
				<x path="Int"/>
				<x path="format.tmx.TmxTile"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<gid public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Global ID of tile.</haxe_doc>
		</gid>
		<flippedHorizontally public="1" get="accessor" set="null" static="1">
			<x path="Bool"/>
			<meta>
				<m n=":impl"/>
				<m n=":optional"/>
			</meta>
			<haxe_doc>Is tile flipped horizontally? Default: false</haxe_doc>
		</flippedHorizontally>
		<flippedVertically public="1" get="accessor" set="null" static="1">
			<x path="Bool"/>
			<meta>
				<m n=":impl"/>
				<m n=":optional"/>
			</meta>
			<haxe_doc>Is tile flipped vertically? Default: false</haxe_doc>
		</flippedVertically>
		<flippedDiagonally public="1" get="accessor" set="null" static="1">
			<x path="Bool"/>
			<meta>
				<m n=":impl"/>
				<m n=":optional"/>
			</meta>
			<haxe_doc>Is tile flipped diagonally? Default: false</haxe_doc>
		</flippedDiagonally>
		<get_gid get="inline" set="null" line="509" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_gid>
		<get_flippedHorizontally get="inline" set="null" line="510" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_flippedHorizontally>
		<get_flippedVertically get="inline" set="null" line="511" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_flippedVertically>
		<get_flippedDiagonally get="inline" set="null" line="512" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_flippedDiagonally>
		<set_gid get="inline" set="null" line="513" static="1">
			<f a="this:v">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_gid>
	</class>
	<enum path="format.tmx.TmxObjectGroupDrawOrder" params="" file="E:\HaxeToolkit\haxe\lib\format-tiled\git\format/tmx/Data.hx" module="format.tmx.Data">
		<Index><haxe_doc>Objects should be drawn according to it's position in `objects` array.</haxe_doc></Index>
		<Topdown><haxe_doc>Objects should be drawn according to their Y-coordinate. Default value.</haxe_doc></Topdown>
		<Unknown a="value">
			<c path="String"/>
			<haxe_doc>Unknown draw order.</haxe_doc>
		</Unknown>
		<haxe_doc>Whether the objects are drawn according to the order of appearance ("index") or sorted by their y-coordinate ("topdown"). Defaults to "topdown".</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<class path="format.tmx.TmxObjectGroup" params="" file="E:\HaxeToolkit\haxe\lib\format-tiled\git\format/tmx/Data.hx" module="format.tmx.Data">
		<extends path="format.tmx.TmxBaseLayer"/>
		<color public="1">
			<x path="Null"><x path="Int"/></x>
			<haxe_doc>The color used to display the objects in this group.</haxe_doc>
		</color>
		<drawOrder public="1">
			<e path="format.tmx.TmxObjectGroupDrawOrder"/>
			<haxe_doc>Whether the objects are drawn according to the order of appearance ("index") or sorted by their y-coordinate ("topdown"). Defaults to "topdown".</haxe_doc>
		</drawOrder>
		<objects public="1">
			<c path="Array"><c path="format.tmx.TmxObject"/></c>
			<haxe_doc>List of all objects.</haxe_doc>
		</objects>
		<new public="1" set="method" line="538"><f a="drawOrder:objects:color:id:name:x:y:offsetX:offsetY:width:height:opacity:visible:properties">
	<e path="format.tmx.TmxObjectGroupDrawOrder"/>
	<c path="Array"><c path="format.tmx.TmxObject"/></c>
	<x path="Null"><x path="Int"/></x>
	<x path="Int"/>
	<c path="String"/>
	<x path="Null"><x path="Float"/></x>
	<x path="Null"><x path="Float"/></x>
	<x path="Null"><x path="Int"/></x>
	<x path="Null"><x path="Int"/></x>
	<x path="Null"><x path="Int"/></x>
	<x path="Null"><x path="Int"/></x>
	<x path="Null"><x path="Float"/></x>
	<x path="Bool"/>
	<x path="format.tmx.TmxProperties"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Layer representing a group of objects.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="format.tmx.TmxPoint" params="" file="E:\HaxeToolkit\haxe\lib\format-tiled\git\format/tmx/Data.hx" module="format.tmx.Data">
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<new public="1" set="method" line="552">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":compilerGenerated"/></meta>
		</new>
		<haxe_doc>Utility for x/y object. Used for Polygon and Polyline object types.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<enum path="format.tmx.TmxObjectType" params="" file="E:\HaxeToolkit\haxe\lib\format-tiled\git\format/tmx/Data.hx" module="format.tmx.Data">
		<OTRectangle><haxe_doc>Standart rectangle. Use x/y/width/height to determine it's size and position.</haxe_doc></OTRectangle>
		<OTTile a="gid">
			<x path="Int"/>
			<haxe_doc>Tile-object, placed on x/y position.</haxe_doc>
		</OTTile>
		<OTExternalTile a="gid:tileset">
			<x path="Int"/>
			<c path="format.tmx.TmxTileset"/>
			<haxe_doc>Tile-object from a template. Using template's tileset.</haxe_doc>
		</OTExternalTile>
		<OTEllipse><haxe_doc>Ellipse. Fills area in x/y/w/h.</haxe_doc></OTEllipse>
		<OTPoint><haxe_doc>Singular point.</haxe_doc></OTPoint>
		<OTPolygon a="points">
			<c path="Array"><c path="format.tmx.TmxPoint"/></c>
			<haxe_doc>Enclosed polygon determined by points with origin of object x/y.</haxe_doc>
		</OTPolygon>
		<OTText a="text">
			<c path="format.tmx.TmxText"/>
			<haxe_doc>Used to mark an object as a text object. Contains the actual text as character data.</haxe_doc>
		</OTText>
		<OTPolyline a="points">
			<c path="Array"><c path="format.tmx.TmxPoint"/></c>
			<haxe_doc>Polyline determined by points with origin of object x/y.</haxe_doc>
		</OTPolyline>
		<haxe_doc>* Type of the object.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<class path="format.tmx.TmxObject" params="" file="E:\HaxeToolkit\haxe\lib\format-tiled\git\format/tmx/Data.hx" module="format.tmx.Data">
		<id public="1">
			<x path="Int"/>
			<haxe_doc>Id of the object. Each object that is placed on map gets unique id. And even if object was deleted no one gets it's id again. Can not be changed in Tiled Qt.</haxe_doc>
		</id>
		<name public="1">
			<c path="String"/>
			<meta><m n=":optional"/></meta>
			<haxe_doc>The name of the object. An arbitrary string.</haxe_doc>
		</name>
		<type public="1">
			<c path="String"/>
			<meta><m n=":optional"/></meta>
			<haxe_doc>The type of the object. An arbitrary string.</haxe_doc>
		</type>
		<x public="1">
			<x path="Float"/>
			<haxe_doc>The x coordinate of the object in pixels.</haxe_doc>
		</x>
		<y public="1">
			<x path="Float"/>
			<haxe_doc>The y coordinate of the object in pixels.</haxe_doc>
		</y>
		<width public="1">
			<x path="Float"/>
			<meta><m n=":optional"/></meta>
			<haxe_doc>The width of the object in pixels (defaults to 0).</haxe_doc>
		</width>
		<height public="1">
			<x path="Float"/>
			<meta><m n=":optional"/></meta>
			<haxe_doc>The height of the object in pixels (defaults to 0).</haxe_doc>
		</height>
		<rotation public="1">
			<x path="Float"/>
			<meta><m n=":optional"/></meta>
			<haxe_doc>The rotation of the object in degrees clockwise (defaults to 0). (Since 0.10)</haxe_doc>
		</rotation>
		<visible public="1">
			<x path="Bool"/>
			<meta><m n=":optional"/></meta>
			<haxe_doc>Whether the object is shown (1) or hidden (0). Defaults to 1. (since 0.9.0)</haxe_doc>
		</visible>
		<objectType public="1">
			<e path="format.tmx.TmxObjectType"/>
			<haxe_doc>Helper type to easily detect what exactly is that object.</haxe_doc>
		</objectType>
		<properties public="1">
			<x path="format.tmx.TmxProperties"/>
			<meta><m n=":optional"/></meta>
			<haxe_doc>Object properties.</haxe_doc>
		</properties>
		<flippedHorizontally public="1">
			<x path="Bool"/>
			<meta><m n=":optional"/></meta>
			<haxe_doc>Is tile flipped horizontally? Default: false</haxe_doc>
		</flippedHorizontally>
		<flippedVertically public="1">
			<x path="Bool"/>
			<meta><m n=":optional"/></meta>
			<haxe_doc>Is tile flipped vertically? Default: false</haxe_doc>
		</flippedVertically>
		<template public="1">
			<c path="String"/>
			<meta><m n=":optional"/></meta>
			<haxe_doc>A reference to a template file (optional).</haxe_doc>
		</template>
		<new public="1" set="method" line="582">
			<f a="id:?name:?type:x:y:?width:?height:?rotation:?visible:objectType:?properties:?flippedHorizontally:?flippedVertically:?template">
				<x path="Int"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<e path="format.tmx.TmxObjectType"/>
				<x path="format.tmx.TmxProperties"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":compilerGenerated"/></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="format.tmx.TmxText" params="" file="E:\HaxeToolkit\haxe\lib\format-tiled\git\format/tmx/Data.hx" module="format.tmx.Data">
		<fontFamily public="1">
			<c path="String"/>
			<haxe_doc>The font family used (default: â€œsans-serifâ€)</haxe_doc>
		</fontFamily>
		<pixelSize public="1">
			<x path="Int"/>
			<haxe_doc>The size of the font in pixels (not using points, because other sizes in the TMX format are also using pixels) (default: 16)</haxe_doc>
		</pixelSize>
		<wrap public="1">
			<x path="Bool"/>
			<haxe_doc>Whether word wrapping is enabled (1) or disabled (0). Defaults to 0.</haxe_doc>
		</wrap>
		<color public="1">
			<x path="Int"/>
			<haxe_doc>Color of the text in #AARRGGBB or #RRGGBB format (default: #000000)</haxe_doc>
		</color>
		<bold public="1">
			<x path="Bool"/>
			<haxe_doc>Whether the font is bold (1) or not (0). Defaults to 0.</haxe_doc>
		</bold>
		<italic public="1">
			<x path="Bool"/>
			<haxe_doc>Whether the font is italic (1) or not (0). Defaults to 0.</haxe_doc>
		</italic>
		<underline public="1">
			<x path="Bool"/>
			<haxe_doc>Whether a line should be drawn below the text (1) or not (0). Defaults to 0.</haxe_doc>
		</underline>
		<strikeout public="1">
			<x path="Bool"/>
			<haxe_doc>Whether a line should be drawn through the text (1) or not (0). Defaults to 0.</haxe_doc>
		</strikeout>
		<kerning public="1">
			<x path="Bool"/>
			<haxe_doc>Whether kerning should be used while rendering the text (1) or not (0). Default to 1.</haxe_doc>
		</kerning>
		<halign public="1">
			<x path="format.tmx.TmxHAlign"/>
			<haxe_doc>Horizontal alignment of the text within the object (left (default), center, right or justify (since Tiled 1.2.1))</haxe_doc>
		</halign>
		<valign public="1">
			<x path="format.tmx.TmxVAlign"/>
			<haxe_doc>Vertical alignment of the text within the object (top (default), center or bottom)</haxe_doc>
		</valign>
		<text public="1">
			<c path="String"/>
			<haxe_doc>Actual text of object</haxe_doc>
		</text>
		<new public="1" set="method" line="618">
			<f a="fontFamily:pixelSize:wrap:color:bold:italic:underline:strikeout:kerning:halign:valign:text">
				<c path="String"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="format.tmx.TmxHAlign"/>
				<x path="format.tmx.TmxVAlign"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":compilerGenerated"/></meta>
		</new>
		<haxe_doc>Used to mark an object as a text object. Contains the actual text as character data.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<abstract path="format.tmx.TmxHAlign" params="" file="E:\HaxeToolkit\haxe\lib\format-tiled\git\format/tmx/Data.hx" module="format.tmx.Data">
		<from><icast><c path="String"/></icast></from>
		<this><c path="String"/></this>
		<to><icast><c path="String"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="format.tmx._Data.TmxHAlign_Impl_" params="" file="E:\HaxeToolkit\haxe\lib\format-tiled\git\format/tmx/Data.hx" private="1" module="format.tmx.Data" extern="1">
	<Left public="1" get="inline" set="null" expr="cast &quot;left&quot;" line="649" static="1">
		<x path="format.tmx.TmxHAlign"/>
		<meta>
			<m n=":value"><e>cast "left"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Left>
	<Center public="1" get="inline" set="null" expr="cast &quot;center&quot;" line="650" static="1">
		<x path="format.tmx.TmxHAlign"/>
		<meta>
			<m n=":value"><e>cast "center"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Center>
	<Right public="1" get="inline" set="null" expr="cast &quot;right&quot;" line="651" static="1">
		<x path="format.tmx.TmxHAlign"/>
		<meta>
			<m n=":value"><e>cast "right"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Right>
	<Justify public="1" get="inline" set="null" expr="cast &quot;justify&quot;" line="652" static="1">
		<x path="format.tmx.TmxHAlign"/>
		<meta>
			<m n=":value"><e>cast "justify"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Justify>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="format.tmx._Data.TmxHAlign_Impl_" params="" file="E:\HaxeToolkit\haxe\lib\format-tiled\git\format/tmx/Data.hx" private="1" module="format.tmx.Data" extern="1">
		<Left public="1" get="inline" set="null" expr="cast &quot;left&quot;" line="649" static="1">
			<x path="format.tmx.TmxHAlign"/>
			<meta>
				<m n=":value"><e>cast "left"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Left>
		<Center public="1" get="inline" set="null" expr="cast &quot;center&quot;" line="650" static="1">
			<x path="format.tmx.TmxHAlign"/>
			<meta>
				<m n=":value"><e>cast "center"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Center>
		<Right public="1" get="inline" set="null" expr="cast &quot;right&quot;" line="651" static="1">
			<x path="format.tmx.TmxHAlign"/>
			<meta>
				<m n=":value"><e>cast "right"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Right>
		<Justify public="1" get="inline" set="null" expr="cast &quot;justify&quot;" line="652" static="1">
			<x path="format.tmx.TmxHAlign"/>
			<meta>
				<m n=":value"><e>cast "justify"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Justify>
		<meta><m n=":enum"/></meta>
	</class>
	<abstract path="format.tmx.TmxVAlign" params="" file="E:\HaxeToolkit\haxe\lib\format-tiled\git\format/tmx/Data.hx" module="format.tmx.Data">
		<from><icast><c path="String"/></icast></from>
		<this><c path="String"/></this>
		<to><icast><c path="String"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="format.tmx._Data.TmxVAlign_Impl_" params="" file="E:\HaxeToolkit\haxe\lib\format-tiled\git\format/tmx/Data.hx" private="1" module="format.tmx.Data" extern="1">
	<Top public="1" get="inline" set="null" expr="cast &quot;top&quot;" line="658" static="1">
		<x path="format.tmx.TmxVAlign"/>
		<meta>
			<m n=":value"><e>cast "top"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Top>
	<Center public="1" get="inline" set="null" expr="cast &quot;center&quot;" line="659" static="1">
		<x path="format.tmx.TmxVAlign"/>
		<meta>
			<m n=":value"><e>cast "center"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Center>
	<Bottom public="1" get="inline" set="null" expr="cast &quot;bottom&quot;" line="660" static="1">
		<x path="format.tmx.TmxVAlign"/>
		<meta>
			<m n=":value"><e>cast "bottom"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Bottom>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="format.tmx._Data.TmxVAlign_Impl_" params="" file="E:\HaxeToolkit\haxe\lib\format-tiled\git\format/tmx/Data.hx" private="1" module="format.tmx.Data" extern="1">
		<Top public="1" get="inline" set="null" expr="cast &quot;top&quot;" line="658" static="1">
			<x path="format.tmx.TmxVAlign"/>
			<meta>
				<m n=":value"><e>cast "top"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Top>
		<Center public="1" get="inline" set="null" expr="cast &quot;center&quot;" line="659" static="1">
			<x path="format.tmx.TmxVAlign"/>
			<meta>
				<m n=":value"><e>cast "center"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Center>
		<Bottom public="1" get="inline" set="null" expr="cast &quot;bottom&quot;" line="660" static="1">
			<x path="format.tmx.TmxVAlign"/>
			<meta>
				<m n=":value"><e>cast "bottom"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Bottom>
		<meta><m n=":enum"/></meta>
	</class>
	<enum path="format.tmx.TmxPropertyType" params="" file="E:\HaxeToolkit\haxe\lib\format-tiled\git\format/tmx/Data.hx" module="format.tmx.Data">
		<PTString/>
		<PTInt/>
		<PTBool/>
		<PTFloat/>
		<PTFile><haxe_doc>Since 0.17</haxe_doc></PTFile>
		<PTColor/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<abstract path="format.tmx.TmxProperties" params="" file="E:\HaxeToolkit\haxe\lib\format-tiled\git\format/tmx/Data.hx" module="format.tmx.Data">
		<this><c path="format.tmx._Data.ImplTmxProperties"/></this>
		<meta><m n=":forward"/></meta>
		<impl><class path="format.tmx._Data.TmxProperties_Impl_" params="" file="E:\HaxeToolkit\haxe\lib\format-tiled\git\format/tmx/Data.hx" private="1" module="format.tmx.Data">
	<_new public="1" get="inline" set="null" line="678" static="1">
		<f a=""><x path="format.tmx.TmxProperties"/></f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<_get get="inline" set="null" line="681" static="1">
		<f a="this:v">
			<c path="format.tmx._Data.ImplTmxProperties"/>
			<c path="String"/>
			<c path="String"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":arrayAccess"/>
		</meta>
	</_get>
	<_set get="inline" set="null" line="684" static="1">
		<f a="this:k:v">
			<c path="format.tmx._Data.ImplTmxProperties"/>
			<c path="String"/>
			<c path="String"/>
			<c path="String"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":arrayAccess"/>
		</meta>
	</_set>
</class></impl>
	</abstract>
	<class path="format.tmx._Data.TmxProperties_Impl_" params="" file="E:\HaxeToolkit\haxe\lib\format-tiled\git\format/tmx/Data.hx" private="1" module="format.tmx.Data">
		<_new public="1" get="inline" set="null" line="678" static="1">
			<f a=""><x path="format.tmx.TmxProperties"/></f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<_get get="inline" set="null" line="681" static="1">
			<f a="this:v">
				<c path="format.tmx._Data.ImplTmxProperties"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":arrayAccess"/>
			</meta>
		</_get>
		<_set get="inline" set="null" line="684" static="1">
			<f a="this:k:v">
				<c path="format.tmx._Data.ImplTmxProperties"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":arrayAccess"/>
			</meta>
		</_set>
	</class>
	<class path="format.tmx._Data.ImplTmxProperties" params="" file="E:\HaxeToolkit\haxe\lib\format-tiled\git\format/tmx/Data.hx" private="1" module="format.tmx.Data">
		<names><c path="Array"><c path="String"/></c></names>
		<types><c path="Array"><e path="format.tmx.TmxPropertyType"/></c></types>
		<strings><c path="Array"><c path="String"/></c></strings>
		<cache><c path="Array"><x path="Null"><x path="Int"/></x></c></cache>
		<ints><c path="Array"><x path="Int"/></c></ints>
		<floats><c path="Array"><x path="Float"/></c></floats>
		<propertyCount public="1" get="inline" set="null" line="702"><f a=""><x path="Int"/></f></propertyCount>
		<exists public="1" set="method" line="715"><f a="name">
	<c path="String"/>
	<x path="Bool"/>
</f></exists>
		<existsType public="1" set="method" line="720"><f a="name:type">
	<c path="String"/>
	<e path="format.tmx.TmxPropertyType"/>
	<x path="Bool"/>
</f></existsType>
		<setRaw public="1" set="method" line="728">
			<f a="name:value:type">
				<c path="String"/>
				<c path="String"/>
				<e path="format.tmx.TmxPropertyType"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</setRaw>
		<setString public="1" set="method" line="745"><f a="name:value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></setString>
		<setFile public="1" set="method" line="762"><f a="name:value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></setFile>
		<setInt public="1" set="method" line="779"><f a="name:value">
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setInt>
		<setColor public="1" set="method" line="806"><f a="name:value">
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setColor>
		<setFloat public="1" set="method" line="833"><f a="name:value">
	<c path="String"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setFloat>
		<setBool public="1" set="method" line="860"><f a="name:value">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></setBool>
		<getType public="1" set="method" line="877"><f a="name">
	<c path="String"/>
	<e path="format.tmx.TmxPropertyType"/>
</f></getType>
		<get public="1" get="inline" set="null" line="884"><f a="name">
	<c path="String"/>
	<c path="String"/>
</f></get>
		<keys public="1" get="inline" set="null" line="886"><f a=""><t path="Iterator"><c path="String"/></t></f></keys>
		<getString public="1" set="method" line="888"><f a="name">
	<c path="String"/>
	<c path="String"/>
</f></getString>
		<getFile public="1" get="inline" set="null" line="895"><f a="name">
	<c path="String"/>
	<c path="String"/>
</f></getFile>
		<getInt public="1" set="method" line="897"><f a="name">
	<c path="String"/>
	<x path="Null"><x path="Int"/></x>
</f></getInt>
		<getColor public="1" get="inline" set="null" line="914"><f a="name">
	<c path="String"/>
	<x path="Null"><x path="Int"/></x>
</f></getColor>
		<getFloat public="1" set="method" line="916"><f a="name">
	<c path="String"/>
	<x path="Float"/>
</f></getFloat>
		<getBool public="1" set="method" line="935"><f a="name">
	<c path="String"/>
	<x path="Bool"/>
</f></getBool>
		<propagateTo public="1" set="method" line="945">
			<f a="other:?_override" v=":false">
				<x path="format.tmx.TmxProperties"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ _override : false }</e></m></meta>
		</propagateTo>
		<new public="1" set="method" line="704"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="format.tmx.TmxObjectTemplate" params="" file="E:\HaxeToolkit\haxe\lib\format-tiled\git\format/tmx/Data.hx" module="format.tmx.Data">
		<tileset public="1">
			<x path="Null"><c path="format.tmx.TmxTileset"/></x>
			<haxe_doc>Tileset used by template. Only present if template is of OTTile type.</haxe_doc>
		</tileset>
		<object public="1"><c path="format.tmx.TmxObject"/></object>
		<new public="1" set="method" line="962">
			<f a="tileset:object">
				<x path="Null"><c path="format.tmx.TmxTileset"/></x>
				<c path="format.tmx.TmxObject"/>
				<x path="Void"/>
			</f>
			<meta><m n=":compilerGenerated"/></meta>
		</new>
		<haxe_doc>An object template description.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="format.tmx.TmxObjectTypeTemplate" params="" file="E:\HaxeToolkit\haxe\lib\format-tiled\git\format/tmx/Data.hx" module="format.tmx.Data">
		<name public="1"><c path="String"/></name>
		<color public="1"><x path="Int"/></color>
		<properties public="1"><c path="Array"><c path="format.tmx.TmxObjectTypeProperty"/></c></properties>
		<new public="1" set="method" line="970">
			<f a="name:color:properties">
				<c path="String"/>
				<x path="Int"/>
				<c path="Array"><c path="format.tmx.TmxObjectTypeProperty"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":compilerGenerated"/></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="format.tmx.TmxObjectTypeProperty" params="" file="E:\HaxeToolkit\haxe\lib\format-tiled\git\format/tmx/Data.hx" module="format.tmx.Data">
		<name public="1"><c path="String"/></name>
		<type public="1"><e path="format.tmx.TmxPropertyType"/></type>
		<defaultValue public="1">
			<c path="String"/>
			<meta><m n=":optional"/></meta>
		</defaultValue>
		<new public="1" set="method" line="978">
			<f a="name:type:?defaultValue">
				<c path="String"/>
				<e path="format.tmx.TmxPropertyType"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":compilerGenerated"/></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<typedef path="format.tmx.TmxWorld" params="" file="E:\HaxeToolkit\haxe\lib\format-tiled\git\format/tmx/Data.hx" module="format.tmx.Data">
		<a>
			<type><c path="String"/></type>
			<patterns><x path="Null"><c path="Array"><t path="format.tmx.TmxWorldPattern"/></c></x></patterns>
			<onlyShowAdjacentMaps><x path="Null"><x path="Bool"/></x></onlyShowAdjacentMaps>
			<maps><x path="Null"><c path="Array"><t path="format.tmx.TmxWorldMap"/></c></x></maps>
		</a>
		<haxe_doc>A descriptor of world Tiled world json file. See manual: https://doc.mapeditor.org/en/stable/manual/worlds/</haxe_doc>
	</typedef>
	<typedef path="format.tmx.TmxWorldMap" params="" file="E:\HaxeToolkit\haxe\lib\format-tiled\git\format/tmx/Data.hx" module="format.tmx.Data"><a>
	<y><x path="Int"/></y>
	<x><x path="Int"/></x>
	<width><x path="Null"><x path="Int"/></x></width>
	<height><x path="Null"><x path="Int"/></x></height>
	<fileName><c path="String"/></fileName>
</a></typedef>
	<typedef path="format.tmx.TmxWorldPattern" params="" file="E:\HaxeToolkit\haxe\lib\format-tiled\git\format/tmx/Data.hx" module="format.tmx.Data"><a>
	<regexp><c path="String"/></regexp>
	<offsetY><x path="Int"/></offsetY>
	<offsetX><x path="Int"/></offsetX>
	<multiplierY><x path="Int"/></multiplierY>
	<multiplierX><x path="Int"/></multiplierX>
	<mapWidth><x path="Null"><x path="Int"/></x></mapWidth>
	<mapHeight><x path="Null"><x path="Int"/></x></mapHeight>
</a></typedef>
	<class path="format.tmx.Reader" params="" file="E:\HaxeToolkit\haxe\lib\format-tiled\git\format/tmx/Reader.hx">
		<customUncompressors><t path="Map">
	<c path="String"/>
	<f a="">
		<c path="String"/>
		<c path="haxe.io.Bytes"/>
	</f>
</t></customUncompressors>
		<customEncoders><t path="Map">
	<c path="String"/>
	<f a=":">
		<c path="haxe.io.Bytes"/>
		<c path="String"/>
		<c path="Array"><x path="format.tmx.TmxTile"/></c>
	</f>
</t></customEncoders>
		<width><x path="Int"/></width>
		<height><x path="Int"/></height>
		<resolveTSX public="1">
			<f a="">
				<c path="String"/>
				<c path="format.tmx.TmxTileset"/>
			</f>
			<haxe_doc>For seamless TSX resolving during initial parsing. Should return corresponding TSX. Caching should be done from outside.</haxe_doc>
		</resolveTSX>
		<resolveTemplate public="1">
			<f a="">
				<c path="String"/>
				<c path="format.tmx.TmxObjectTemplate"/>
			</f>
			<haxe_doc>For seamless Template resolving during initial parsing.</haxe_doc>
		</resolveTemplate>
		<resolveTypeTemplate public="1">
			<f a="">
				<c path="String"/>
				<c path="format.tmx.TmxObjectTypeTemplate"/>
			</f>
			<haxe_doc>For seamless Type Template resolving during initial parsing.</haxe_doc>
		</resolveTypeTemplate>
		<read public="1" set="method" line="44">
			<f a="xml:?localPath">
				<c path="Xml"/>
				<c path="String"/>
				<c path="format.tmx.TmxMap"/>
			</f>
			<haxe_doc>* Reads TMX file.
   * @return</haxe_doc>
		</read>
		<readTSX public="1" get="inline" set="null" line="95">
			<f a="xml:?root" v=":null">
				<c path="Xml"/>
				<c path="format.tmx.TmxTileset"/>
				<c path="format.tmx.TmxTileset"/>
			</f>
			<meta><m n=":value"><e>{ root : null }</e></m></meta>
			<haxe_doc>* Reads TSX file.
   * @param root Root Tileset into which read TSX data.
   * @return Resulting TmxTileset. If `root` is null - returns new TmxTileset object, otherwise `root` is returned.</haxe_doc>
		</readTSX>
		<readObjectTypes public="1" set="method" line="105">
			<f a="xml:?root" v=":null">
				<c path="Xml"/>
				<c path="format.tmx.TmxMap"/>
				<t path="Map">
					<c path="String"/>
					<c path="format.tmx.TmxObjectTypeTemplate"/>
				</t>
			</f>
			<meta><m n=":value"><e>{ root : null }</e></m></meta>
			<haxe_doc>* Reads objecttypes.xml file.
   * @param root Optional root TMX file to propagate those types into. It uses `Tools.propagateObjectTypes` function with default propagation rules.
   * @return Map with object type templates. Always pass null, if using during resolveTypeTemplate</haxe_doc>
		</readObjectTypes>
		<readTemplate public="1" set="method" line="149">
			<f a="xml">
				<c path="Xml"/>
				<c path="format.tmx.TmxObjectTemplate"/>
			</f>
			<haxe_doc>Reads TX file.</haxe_doc>
		</readTemplate>
		<resolveGroup set="method" line="160"><f a="input">
	<t path="haxe.xml._Access.Fast"/>
	<c path="format.tmx.TmxGroup"/>
</f></resolveGroup>
		<resolveStaggerIndex get="inline" set="null" line="187"><f a="input">
	<c path="String"/>
	<e path="format.tmx.TmxStaggerIndex"/>
</f></resolveStaggerIndex>
		<resolveStaggerAxis get="inline" set="null" line="197"><f a="input">
	<c path="String"/>
	<e path="format.tmx.TmxStaggerAxis"/>
</f></resolveStaggerAxis>
		<resolveOrientation get="inline" set="null" line="207"><f a="input">
	<c path="String"/>
	<e path="format.tmx.TmxOrientation"/>
</f></resolveOrientation>
		<resolveColor get="inline" set="null" line="219"><f a="input">
	<c path="String"/>
	<x path="Int"/>
</f></resolveColor>
		<resolveRenderOrder get="inline" set="null" line="225"><f a="input">
	<c path="String"/>
	<e path="format.tmx.TmxRenderOrder"/>
</f></resolveRenderOrder>
		<resolveTileset get="inline" set="null" line="237"><f a="input:root">
	<t path="haxe.xml._Access.Fast"/>
	<c path="format.tmx.TmxTileset"/>
	<c path="format.tmx.TmxTileset"/>
</f></resolveTileset>
		<resolveWangSet set="method" line="370"><f a="input">
	<t path="haxe.xml._Access.Fast"/>
	<c path="format.tmx.TmxWangSet"/>
</f></resolveWangSet>
		<resolveWangSetColor get="inline" set="null" line="404"><f a="input">
	<t path="haxe.xml._Access.Fast"/>
	<c path="format.tmx.TmxWangSetColor"/>
</f></resolveWangSetColor>
		<resolveImage set="method" line="414"><f a="input">
	<t path="haxe.xml._Access.Fast"/>
	<c path="format.tmx.TmxImage"/>
</f></resolveImage>
		<resolveData set="method" line="428">
			<f a="input:?isTileData" v=":true">
				<t path="haxe.xml._Access.Fast"/>
				<x path="Bool"/>
				<c path="format.tmx.TmxData"/>
			</f>
			<meta><m n=":value"><e>{ isTileData : true }</e></m></meta>
		</resolveData>
		<uncompressData set="method" line="594"><f a="i:compression">
	<c path="haxe.io.Input"/>
	<e path="format.tmx.TmxDataCompression"/>
	<c path="haxe.io.Bytes"/>
</f></uncompressData>
		<resolveTileLayer set="method" line="619"><f a="input">
	<t path="haxe.xml._Access.Fast"/>
	<c path="format.tmx.TmxTileLayer"/>
</f></resolveTileLayer>
		<resolveDraworder get="inline" set="null" line="640"><f a="input">
	<c path="String"/>
	<e path="format.tmx.TmxObjectGroupDrawOrder"/>
</f></resolveDraworder>
		<resolveObjectGroup set="method" line="650"><f a="input">
	<t path="haxe.xml._Access.Fast"/>
	<c path="format.tmx.TmxObjectGroup"/>
</f></resolveObjectGroup>
		<resolveObject set="method" line="682">
			<f a="obj:?applyObjectTypeTemplate" v=":true">
				<t path="haxe.xml._Access.Fast"/>
				<x path="Bool"/>
				<c path="format.tmx.TmxObject"/>
			</f>
			<meta><m n=":value"><e>{ applyObjectTypeTemplate : true }</e></m></meta>
		</resolveObject>
		<readPoints set="method" line="776"><f a="input">
	<t path="haxe.xml._Access.Fast"/>
	<c path="Array"><c path="format.tmx.TmxPoint"/></c>
</f></readPoints>
		<resolveText set="method" line="791"><f a="input">
	<t path="haxe.xml._Access.Fast"/>
	<c path="format.tmx.TmxText"/>
</f></resolveText>
		<resolveImageLayer set="method" line="809"><f a="input">
	<t path="haxe.xml._Access.Fast"/>
	<c path="format.tmx.TmxImageLayer"/>
</f></resolveImageLayer>
		<resolveProperties set="method" line="828"><f a="input">
	<t path="haxe.xml._Access.Fast"/>
	<x path="format.tmx.TmxProperties"/>
</f></resolveProperties>
		<new public="1" set="method" line="35"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* ...
 * @author Yanrishatum</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="format.tmx.Tools" params="" file="E:\HaxeToolkit\haxe\lib\format-tiled\git\format/tmx/Tools.hx">
		<applyTSX public="1" set="method" line="12" static="1"><f a="tsx:base">
	<c path="format.tmx.TmxTileset"/>
	<c path="format.tmx.TmxTileset"/>
	<x path="Void"/>
</f></applyTSX>
		<applyObjectTypeTemplate public="1" set="method" line="31" static="1"><f a="obj:ot">
	<c path="format.tmx.TmxObject"/>
	<c path="format.tmx.TmxObjectTypeTemplate"/>
	<x path="Void"/>
</f></applyObjectTypeTemplate>
		<resolveOTExternalTile public="1" set="method" line="48" static="1">
			<f a="map:?mapPath">
				<c path="format.tmx.TmxMap"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Resolves OTExternalTile into OTTile.
   * Only works if templates and tilesets were resolved and their paths are relative.
   * @param mapPath Optional local path to the map file used for accurate TSX path resolving when comparing tilesets.</haxe_doc>
		</resolveOTExternalTile>
		<resolveOTExternalTileInternal set="method" line="71" static="1"><f a="map:layer:mapPath:paths">
	<c path="format.tmx.TmxMap"/>
	<e path="format.tmx.TmxLayer"/>
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
	<x path="Void"/>
</f></resolveOTExternalTileInternal>
		<linearLayers public="1" set="method" line="103" static="1">
			<f a="map">
				<c path="format.tmx.TmxMap"/>
				<c path="Array"><e path="format.tmx.TmxLayer"/></c>
			</f>
			<haxe_doc>* Returns linear array of layers removing all nested groups. 
   * IMPORTANT! This function will apply group offset/opacity/visibility values to nested layers, don't use it if you need to keep them unchanged.</haxe_doc>
		</linearLayers>
		<linearLayersInternal set="method" line="119" static="1"><f a="group:output">
	<c path="format.tmx.TmxGroup"/>
	<c path="Array"><e path="format.tmx.TmxLayer"/></c>
	<x path="Void"/>
</f></linearLayersInternal>
		<propagateObjectTypeToObject public="1" set="method" line="158" static="1">
			<f a="obj:types">
				<c path="format.tmx.TmxObject"/>
				<t path="Map">
					<c path="String"/>
					<c path="format.tmx.TmxObjectTypeTemplate"/>
				</t>
				<x path="Void"/>
			</f>
			<haxe_doc>Propagates properties from Object Type Template for specific object
     @param obj
     @param types</haxe_doc>
		</propagateObjectTypeToObject>
		<propagateTilePropertiesToObject public="1" set="method" line="183" static="1">
			<f a="obj:map:gid">
				<c path="format.tmx.TmxObject"/>
				<c path="format.tmx.TmxMap"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Propagates tile properties of tile object in tileset to specific object.
     @param obj Object to propagate tile data to.
     @param map 
     @param gid Global tile ID from which to take properties.</haxe_doc>
		</propagateTilePropertiesToObject>
		<propagateTileProperties public="1" set="method" line="200" static="1"><f a="map">
	<c path="format.tmx.TmxMap"/>
	<x path="Void"/>
</f></propagateTileProperties>
		<propagateTilePropertiesLayer set="method" line="208" static="1"><f a="map:layer">
	<c path="format.tmx.TmxMap"/>
	<e path="format.tmx.TmxLayer"/>
	<x path="Void"/>
</f></propagateTilePropertiesLayer>
		<propagateObjectTypes public="1" set="method" line="248" static="1">
			<f a="map:types:?propagateObjectLayers:?propagateTileColliders" v="::true:true">
				<c path="format.tmx.TmxMap"/>
				<t path="Map">
					<c path="String"/>
					<c path="format.tmx.TmxObjectTypeTemplate"/>
				</t>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ propagateTileColliders : true, propagateObjectLayers : true }</e></m></meta>
			<haxe_doc>Propagates properties from Object Type templates to all objects on the map.
     @param map Map to which properties should propagate.
     @param types List of Object Type Templates by names.
     @param propagateObjectLayers Should propagate to objects on ObjectLayers?
     @param propagateTileColliders Should propagate to objects in collisions of tile objects?</haxe_doc>
		</propagateObjectTypes>
		<getTileByGid public="1" set="method" line="294" static="1">
			<f a="map:gid">
				<c path="format.tmx.TmxMap"/>
				<x path="Int"/>
				<c path="format.tmx.TmxTilesetTile"/>
			</f>
			<haxe_doc>Returns Tile settings for given tile global ID.</haxe_doc>
		</getTileByGid>
		<getTilesetByGid public="1" set="method" line="311" static="1">
			<f a="map:gid">
				<c path="format.tmx.TmxMap"/>
				<x path="Int"/>
				<c path="format.tmx.TmxTileset"/>
			</f>
			<haxe_doc>Returns tileset in which given global ID present.</haxe_doc>
		</getTilesetByGid>
		<getTilesetIndexByGid public="1" set="method" line="326" static="1">
			<f a="map:gid">
				<c path="format.tmx.TmxMap"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns tileset index in which given global ID present.</haxe_doc>
		</getTilesetIndexByGid>
		<getTileUVByLidUnsafe public="1" set="method" line="345" static="1">
			<f a="tileset:localId:output">
				<c path="format.tmx.TmxTileset"/>
				<x path="Int"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `x` and `y` values to `output` relative to tile position on source image of tileset.
   * Note: Currently do not supports non-zero margin and spacing values.
   * @param tileset
   * @param localId
   * @param output</haxe_doc>
		</getTileUVByLidUnsafe>
		<fixObjectPlacement public="1" get="inline" set="null" line="357" static="1">
			<f a="map">
				<c path="format.tmx.TmxMap"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Shifts origin of objects from bottom-left edge to top-left edge.
   * Left out for compatibility
   * @param map</haxe_doc>
		</fixObjectPlacement>
		<topLeftObjectOrigin public="1" set="method" line="362" static="1">
			<f a="map">
				<c path="format.tmx.TmxMap"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Shifts origin of objects from bottom-left edge to top-left edge.
   * @param map</haxe_doc>
		</topLeftObjectOrigin>
		<getTilesCountInLineOnTileset public="1" set="method" line="397" static="1">
			<f a="tileset">
				<c path="format.tmx.TmxTileset"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns amount of tiles in one line in given tileset. Use it for UV calculation.</haxe_doc>
		</getTilesCountInLineOnTileset>
		<getTilesCountInColumnOnTileset public="1" set="method" line="405" static="1">
			<f a="tileset">
				<c path="format.tmx.TmxTileset"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns amount of tiles in one column in given tileset. UV calculation.</haxe_doc>
		</getTilesCountInColumnOnTileset>
		<getTilesCountInTileset public="1" set="method" line="413" static="1">
			<f a="tileset">
				<c path="format.tmx.TmxTileset"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns total amount of tiles in tileset.</haxe_doc>
		</getTilesCountInTileset>
		<tilePosition public="1" set="method" line="425" static="1">
			<f a="map:tx:ty:?tileset:?lid">
				<c path="format.tmx.TmxMap"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="format.tmx.TmxTileset"/>
				<x path="Int"/>
				<a>
					<y><x path="Float"/></y>
					<x><x path="Float"/></x>
				</a>
			</f>
			<haxe_doc>Returns visual tile position based on the map parameters and optionally on tileset sizes.
    @param tileset Optional tileset reference. If present, it's tile sizes will be used for position calculation.
    @param lid Optional local tile ID on tileset. Required for imageset tilesets.</haxe_doc>
		</tilePosition>
		<haxe_doc>* ...
 * @author Yanrishatum</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="format.tools.BitsInput" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/tools/BitsInput.hx">
		<i><c path="haxe.io.Input"/></i>
		<nbits><x path="Int"/></nbits>
		<bits><x path="Int"/></bits>
		<readBits public="1" set="method" line="41"><f a="n">
	<x path="Int"/>
	<x path="Int"/>
</f></readBits>
		<readBit public="1" set="method" line="63"><f a=""><x path="Bool"/></f></readBit>
		<reset public="1" get="inline" set="null" line="72"><f a=""><x path="Void"/></f></reset>
		<new public="1" set="method" line="35"><f a="i">
	<c path="haxe.io.Input"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="format.tools.Deflate" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/tools/Deflate.hx">
		<run public="1" set="method" line="31" static="1">
			<f a="b:?level" v=":9">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":value"><e>{ level : 9 }</e></m></meta>
		</run>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="format.tools.Inflate" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/tools/Inflate.hx">
		<run public="1" set="method" line="31" static="1"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<c path="haxe.io.Bytes"/>
</f></run>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="format.tools.InflateImpl" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/tools/InflateImpl.hx"><c path="haxe.zip.InflateImpl"/></typedef>
	<typedef path="format.wav.WAVE" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/wav/Data.hx" module="format.wav.Data"><a>
	<header><t path="format.wav.WAVEHeader"/></header>
	<data><c path="haxe.io.Bytes"/></data>
	<cuePoints><c path="Array"><t path="format.wav.CuePoint"/></c></cuePoints>
</a></typedef>
	<typedef path="format.wav.WAVEHeader" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/wav/Data.hx" module="format.wav.Data"><a>
	<samplingRate><x path="Int"/></samplingRate>
	<format><e path="format.wav.WAVEFormat"/></format>
	<channels><x path="Int"/></channels>
	<byteRate><x path="Int"/></byteRate>
	<blockAlign><x path="Int"/></blockAlign>
	<bitsPerSample><x path="Int"/></bitsPerSample>
</a></typedef>
	<typedef path="format.wav.CuePoint" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/wav/Data.hx" module="format.wav.Data"><a>
	<sampleOffset><x path="Int"/></sampleOffset>
	<id><x path="Int"/></id>
</a></typedef>
	<enum path="format.wav.WAVEFormat" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/wav/Data.hx" module="format.wav.Data">
		<WF_PCM/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="format.wav.Reader" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/wav/Reader.hx">
		<i><c path="haxe.io.Input"/></i>
		<version><x path="Int"/></version>
		<readInt get="inline" set="null" line="43"><f a=""><x path="Int"/></f></readInt>
		<read public="1" set="method" line="51"><f a=""><t path="format.wav.WAVE"/></f></read>
		<new public="1" set="method" line="38"><f a="i">
	<c path="haxe.io.Input"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h2d.Anim" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h2d/Anim.hx">
		<extends path="h2d.Drawable"/>
		<frames public="1" set="null">
			<c path="Array"><c path="h2d.Tile"/></c>
			<haxe_doc>The current animation, as a list of tile frames to display.
		If the frames are empty or if a tile is frames is null, a pink 5x5 bitmap will be displayed instead. Use remove() or visible=false to hide a h2d.Anim</haxe_doc>
		</frames>
		<currentFrame public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>The current frame the animation is currently playing. Always in `[0,frames.length]` range</haxe_doc>
		</currentFrame>
		<speed public="1">
			<x path="Float"/>
			<haxe_doc>The speed (in frames per second) at which the animation is playing (default 15.)</haxe_doc>
		</speed>
		<pause public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>Setting pause will pause the animation, preventing any automatic change to currentFrame.</haxe_doc>
		</pause>
		<loop public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>Disabling loop will stop the animation at the last frame (default : true)</haxe_doc>
		</loop>
		<fading public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>When enable, fading will draw two consecutive frames with alpha transition between
		them instead of directly switching from one to another when it reaches the next frame.
		This can be used to have smoother animation on some effects.</haxe_doc>
		</fading>
		<curFrame><x path="Float"/></curFrame>
		<get_currentFrame get="inline" set="null" line="53"><f a=""><x path="Float"/></f></get_currentFrame>
		<play public="1" set="method" line="60">
			<f a="frames:?atFrame" v=":0.">
				<c path="Array"><c path="h2d.Tile"/></c>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ atFrame : 0. }</e></m></meta>
			<haxe_doc>Change the currently playing animation and unset the pause if it was set.</haxe_doc>
		</play>
		<onAnimEnd public="1" set="dynamic" line="71">
			<f a=""><x path="Void"/></f>
			<haxe_doc>onAnimEnd is automatically called each time the animation will reach past the last frame.
		If loop is true, it is called everytime the animation loops.
		If loop is false, it is called once when the animation reachs `currentFrame == frames.length`</haxe_doc>
		</onAnimEnd>
		<set_currentFrame set="method" line="74"><f a="frame">
	<x path="Float"/>
	<x path="Float"/>
</f></set_currentFrame>
		<getBoundsRec set="method" line="80" override="1"><f a="relativeTo:out:forSize">
	<c path="h2d.Object"/>
	<c path="h2d.col.Bounds"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></getBoundsRec>
		<sync set="method" line="86" override="1"><f a="ctx">
	<c path="h2d.RenderContext"/>
	<x path="Void"/>
</f></sync>
		<getFrame public="1" set="method" line="108">
			<f a=""><c path="h2d.Tile"/></f>
			<haxe_doc>Return the tile at current frame.</haxe_doc>
		</getFrame>
		<draw set="method" line="114" override="1"><f a="ctx">
	<c path="h2d.RenderContext"/>
	<x path="Void"/>
</f></draw>
		<new public="1" set="method" line="46">
			<f a="?frames:?speed:?parent">
				<c path="Array"><c path="h2d.Tile"/></c>
				<x path="Float"/>
				<c path="h2d.Object"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Create a new animation with the specified frames, speed and parent object</haxe_doc>
		</new>
		<haxe_doc>h2d.Anim is used to display an animated sequence of bitmap tiles on the screen.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h2d.Bitmap" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h2d/Bitmap.hx">
		<extends path="h2d.Drawable"/>
		<tile public="1" set="accessor">
			<c path="h2d.Tile"/>
			<haxe_doc>The tile to display see `h2d.Tile` documentation for details.
		If the tile is null, a pink 5x5 bitmap will be displayed instead. Use remove() or visible=false to hide a h2d.Bitmap</haxe_doc>
		</tile>
		<width public="1" set="accessor">
			<x path="Null"><x path="Float"/></x>
			<haxe_doc>* 	If set, rescale the tile to match the given width, keeping the aspect ratio unless height is also set.</haxe_doc>
		</width>
		<height public="1" set="accessor">
			<x path="Null"><x path="Float"/></x>
			<haxe_doc>* 	If set, rescale the tile to match the given height, keeping the aspect ratio unless width is also set.</haxe_doc>
		</height>
		<set_tileWrap set="method" line="32" override="1"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_tileWrap>
		<getBoundsRec set="method" line="38" override="1"><f a="relativeTo:out:forSize">
	<c path="h2d.Object"/>
	<c path="h2d.col.Bounds"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></getBoundsRec>
		<set_width set="method" line="48"><f a="w">
	<x path="Null"><x path="Float"/></x>
	<x path="Null"><x path="Float"/></x>
</f></set_width>
		<set_height set="method" line="55"><f a="h">
	<x path="Null"><x path="Float"/></x>
	<x path="Null"><x path="Float"/></x>
</f></set_height>
		<set_tile set="method" line="62"><f a="t">
	<c path="h2d.Tile"/>
	<c path="h2d.Tile"/>
</f></set_tile>
		<draw set="method" line="69" override="1"><f a="ctx">
	<c path="h2d.RenderContext"/>
	<x path="Void"/>
</f></draw>
		<new public="1" set="method" line="27">
			<f a="?tile:?parent">
				<c path="h2d.Tile"/>
				<c path="h2d.Object"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Create a Bitmap with specified tile and parent object.</haxe_doc>
		</new>
		<haxe_doc>h2d.Bitmap is used to display a single bitmap Tile on the screen.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="h2d.BlendMode" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h2d/BlendMode.hx">
		<None/>
		<Alpha/>
		<Add/>
		<AlphaAdd/>
		<SoftAdd/>
		<Multiply/>
		<AlphaMultiply/>
		<Erase/>
		<Screen/>
		<Sub/>
		<Max/>
		<Min/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="h2d._Dropdown.Fake" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h2d/Dropdown.hx" private="1" module="h2d.Dropdown">
		<extends path="h2d.Object"/>
		<dd><c path="h2d.Dropdown"/></dd>
		<getBoundsRec set="method" line="10" override="1"><f a="relativeTo:out:forSize">
	<c path="h2d.Object"/>
	<c path="h2d.col.Bounds"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></getBoundsRec>
		<draw set="method" line="19" override="1"><f a="ctx">
	<c path="h2d.RenderContext"/>
	<x path="Void"/>
</f></draw>
		<new public="1" set="method" line="5"><f a="dd">
	<c path="h2d.Dropdown"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h2d.Flow" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h2d/Flow.hx">
		<extends path="h2d.Object"/>
		<tmpBounds expr="new h2d.col.Bounds()">
			<c path="h2d.col.Bounds"/>
			<meta><m n=":value"><e>new h2d.col.Bounds()</e></m></meta>
		</tmpBounds>
		<needReflow public="1" set="accessor" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>If some sub element gets resized, you need to set reflow to true in order to force
		the reflow of elements. You can also directly call reflow() which will immediately
		update all elements positions.

		If a reflow is needed, reflow() will be called before rendering the flow.
		Each change in one of the flow properties or addition/removal of elements will set needReflow to true.</haxe_doc>
		</needReflow>
		<horizontalAlign public="1" set="accessor">
			<x path="Null"><e path="h2d.FlowAlign"/></x>
			<haxe_doc>Horizontal alignment of elements inside the flow.</haxe_doc>
		</horizontalAlign>
		<verticalAlign public="1" set="accessor">
			<x path="Null"><e path="h2d.FlowAlign"/></x>
			<haxe_doc>Vertical alignment of elements inside the flow.</haxe_doc>
		</verticalAlign>
		<minWidth public="1" set="accessor"><x path="Null"><x path="Int"/></x></minWidth>
		<minHeight public="1" set="accessor"><x path="Null"><x path="Int"/></x></minHeight>
		<maxWidth public="1" set="accessor"><x path="Null"><x path="Int"/></x></maxWidth>
		<maxHeight public="1" set="accessor"><x path="Null"><x path="Int"/></x></maxHeight>
		<lineHeight public="1" set="accessor"><x path="Null"><x path="Int"/></x></lineHeight>
		<colWidth public="1" set="accessor"><x path="Null"><x path="Int"/></x></colWidth>
		<overflow public="1" set="accessor" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>Enabling overflow will treat maxWidth/maxHeight and lineHeight/colWidth constraints as absolute : bigger elements will overflow instead of expanding the limit.</haxe_doc>
		</overflow>
		<padding public="1" get="null" set="accessor">
			<x path="Int"/>
			<haxe_doc>Will set all padding values at the same time.</haxe_doc>
		</padding>
		<paddingHorizontal public="1" get="null" set="accessor"><x path="Int"/></paddingHorizontal>
		<paddingVertical public="1" get="null" set="accessor"><x path="Int"/></paddingVertical>
		<paddingLeft public="1" set="accessor" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</paddingLeft>
		<paddingRight public="1" set="accessor" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</paddingRight>
		<paddingTop public="1" set="accessor" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</paddingTop>
		<paddingBottom public="1" set="accessor" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</paddingBottom>
		<horizontalSpacing public="1" set="accessor" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>The horizontal space between two flowed elements.</haxe_doc>
		</horizontalSpacing>
		<verticalSpacing public="1" set="accessor" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>The vertical space between two flowed elements.</haxe_doc>
		</verticalSpacing>
		<enableInteractive public="1" set="accessor">
			<x path="Bool"/>
			<haxe_doc>Set enableInteractive to true to create an h2d.Interactive accessible through
		the interactive field which will automatically cover the whole Flow area.</haxe_doc>
		</enableInteractive>
		<interactive public="1" set="null">
			<c path="h2d.Interactive"/>
			<haxe_doc>See enableInteractive.</haxe_doc>
		</interactive>
		<backgroundTile public="1" set="accessor">
			<c path="h2d.Tile"/>
			<haxe_doc>Setting a background tile will create a ScaleGrid background which uses the borderWidth/Height values for its borders.
		It will automatically resize when the reflow is done to cover the whole Flow area.</haxe_doc>
		</backgroundTile>
		<borderWidth public="1" set="accessor" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</borderWidth>
		<borderHeight public="1" set="accessor" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</borderHeight>
		<innerWidth public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>Calculate the client width, which is the innner size of the flow without the borders and padding.</haxe_doc>
		</innerWidth>
		<innerHeight public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>Calculate the client height, which is the innner size of the flow without the borders and padding.</haxe_doc>
		</innerHeight>
		<outerWidth public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>Flow total width (inlcudes borders and paddings)</haxe_doc>
		</outerWidth>
		<outerHeight public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>Flow total height (inlcudes borders and paddings)</haxe_doc>
		</outerHeight>
		<layout public="1" set="accessor" expr="Horizontal">
			<e path="h2d.FlowLayout"/>
			<meta><m n=":value"><e>Horizontal</e></m></meta>
			<haxe_doc>When set to `Horizontal` (default), children are aligned horizontally from left to right (right to left using `reverse`).
		When set to `Vertical`, children are aligned vertically from tom to bottom (bottom to top using `reverse`).
		When set to `Stack`, children are aligned independently (`reverse` has no effect).
		Both `Horizontal` and `Vertical` alignments can overflow to the next row/column if the available space is constrained.</haxe_doc>
		</layout>
		<isVertical public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":deprecated"><e>"isVertical is replaced by layout=Vertical"</e></m></meta>
		</isVertical>
		<isInline public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>When isInline is set to false, the flow size will be reported based on its bounds instead of its calculated size.
		See getSize() documentation.</haxe_doc>
		</isInline>
		<debug public="1" set="accessor">
			<x path="Bool"/>
			<haxe_doc>When set to true, the debug will display red box around the flow, green box for the client space and blue boxes for each element.</haxe_doc>
		</debug>
		<multiline public="1" set="accessor" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>When set to true, uses specified lineHeight/colWidth instead of maxWidth/maxHeight for alignment.</haxe_doc>
		</multiline>
		<reverse public="1" set="accessor" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>When set to true, children are aligned in reverse order</haxe_doc>
		</reverse>
		<fillWidth public="1" set="accessor" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>When set to true, if a width constraint is present and `minWidth` is null, will expand to fill all the available horizontal space</haxe_doc>
		</fillWidth>
		<fillHeight public="1" set="accessor" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>When set to true, if a height constraint is present and `minHeight` is null, will expand to fill all the available vertical space</haxe_doc>
		</fillHeight>
		<background><c path="h2d.ScaleGrid"/></background>
		<debugGraphics><c path="h2d.Graphics"/></debugGraphics>
		<properties expr="[]">
			<c path="Array"><c path="h2d.FlowProperties"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</properties>
		<calculatedWidth expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</calculatedWidth>
		<calculatedHeight expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</calculatedHeight>
		<constraintWidth expr="-1">
			<x path="Float"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</constraintWidth>
		<constraintHeight expr="-1">
			<x path="Float"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</constraintHeight>
		<realMaxWidth expr="-1">
			<x path="Float"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</realMaxWidth>
		<realMaxHeight expr="-1">
			<x path="Float"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</realMaxHeight>
		<realMinWidth expr="-1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</realMinWidth>
		<realMinHeight expr="-1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</realMinHeight>
		<isConstraint><x path="Bool"/></isConstraint>
		<getProperties public="1" set="method" line="225">
			<f a="e">
				<c path="h2d.Object"/>
				<c path="h2d.FlowProperties"/>
			</f>
			<haxe_doc>Get the per-element properties. Returns null if the element is not currently part of the flow.</haxe_doc>
		</getProperties>
		<set_layout set="method" line="230"><f a="v">
	<e path="h2d.FlowLayout"/>
	<e path="h2d.FlowLayout"/>
</f></set_layout>
		<get_isVertical set="method" line="237">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":deprecated"><e>"isVertical is replaced by layout=Vertical"</e></m></meta>
		</get_isVertical>
		<set_isVertical set="method" line="241">
			<f a="v">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":deprecated"><e>"isVertical is replaced by layout=Vertical"</e></m></meta>
		</set_isVertical>
		<set_horizontalAlign set="method" line="246"><f a="v">
	<x path="Null"><e path="h2d.FlowAlign"/></x>
	<x path="Null"><e path="h2d.FlowAlign"/></x>
</f></set_horizontalAlign>
		<set_debug set="method" line="253"><f a="v">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_debug>
		<set_verticalAlign set="method" line="267"><f a="v">
	<x path="Null"><e path="h2d.FlowAlign"/></x>
	<x path="Null"><e path="h2d.FlowAlign"/></x>
</f></set_verticalAlign>
		<set_overflow set="method" line="274"><f a="v">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_overflow>
		<set_multiline set="method" line="281"><f a="v">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_multiline>
		<set_reverse set="method" line="288"><f a="v">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_reverse>
		<set_needReflow set="method" line="295"><f a="v">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_needReflow>
		<set_lineHeight set="method" line="303"><f a="v">
	<x path="Null"><x path="Int"/></x>
	<x path="Null"><x path="Int"/></x>
</f></set_lineHeight>
		<set_colWidth set="method" line="310"><f a="v">
	<x path="Null"><x path="Int"/></x>
	<x path="Null"><x path="Int"/></x>
</f></set_colWidth>
		<set_padding set="method" line="317"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></set_padding>
		<set_paddingHorizontal get="inline" set="null" line="325"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></set_paddingHorizontal>
		<set_paddingVertical get="inline" set="null" line="331"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></set_paddingVertical>
		<get_outerWidth set="method" line="337"><f a=""><x path="Int"/></f></get_outerWidth>
		<get_outerHeight set="method" line="342"><f a=""><x path="Int"/></f></get_outerHeight>
		<get_innerWidth set="method" line="347"><f a=""><x path="Int"/></f></get_innerWidth>
		<get_innerHeight set="method" line="352"><f a=""><x path="Int"/></f></get_innerHeight>
		<set_paddingLeft set="method" line="357"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></set_paddingLeft>
		<set_paddingRight set="method" line="363"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></set_paddingRight>
		<set_paddingTop set="method" line="369"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></set_paddingTop>
		<set_paddingBottom set="method" line="375"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></set_paddingBottom>
		<set_fillWidth set="method" line="381"><f a="v">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_fillWidth>
		<set_fillHeight set="method" line="388"><f a="v">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_fillHeight>
		<constraintSize set="method" line="395" override="1"><f a="width:height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></constraintSize>
		<contentChanged set="method" line="402" override="1"><f a="s">
	<c path="h2d.Object"/>
	<x path="Void"/>
</f></contentChanged>
		<addSpacing public="1" set="method" line="416">
			<f a="v">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds some spacing by either increasing the padding of the latest
		non absolute element or the padding of the flow if no element was found.
		The padding affected depends on the isVertical property.</haxe_doc>
		</addSpacing>
		<getBoundsRec set="method" line="436" override="1"><f a="relativeTo:out:forSize">
	<c path="h2d.Object"/>
	<c path="h2d.col.Bounds"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></getBoundsRec>
		<setParentContainer set="method" line="454" override="1"><f a="c">
	<c path="h2d.Object"/>
	<x path="Void"/>
</f></setParentContainer>
		<addChildAt public="1" set="method" line="459" override="1"><f a="s:pos">
	<c path="h2d.Object"/>
	<x path="Int"/>
	<x path="Void"/>
</f></addChildAt>
		<removeChild public="1" set="method" line="470" override="1"><f a="s">
	<c path="h2d.Object"/>
	<x path="Void"/>
</f></removeChild>
		<removeChildren public="1" set="method" line="486" override="1"><f a=""><x path="Void"/></f></removeChildren>
		<sync set="method" line="494" override="1"><f a="ctx">
	<c path="h2d.RenderContext"/>
	<x path="Void"/>
</f></sync>
		<set_maxWidth set="method" line="503"><f a="w">
	<x path="Null"><x path="Int"/></x>
	<x path="Null"><x path="Int"/></x>
</f></set_maxWidth>
		<set_maxHeight set="method" line="511"><f a="h">
	<x path="Null"><x path="Int"/></x>
	<x path="Null"><x path="Int"/></x>
</f></set_maxHeight>
		<updateConstraint set="method" line="519"><f a=""><x path="Void"/></f></updateConstraint>
		<set_minWidth set="method" line="537"><f a="w">
	<x path="Null"><x path="Int"/></x>
	<x path="Null"><x path="Int"/></x>
</f></set_minWidth>
		<set_minHeight set="method" line="546"><f a="h">
	<x path="Null"><x path="Int"/></x>
	<x path="Null"><x path="Int"/></x>
</f></set_minHeight>
		<set_horizontalSpacing set="method" line="555"><f a="s">
	<x path="Int"/>
	<x path="Int"/>
</f></set_horizontalSpacing>
		<set_verticalSpacing set="method" line="562"><f a="s">
	<x path="Int"/>
	<x path="Int"/>
</f></set_verticalSpacing>
		<set_enableInteractive set="method" line="569"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_enableInteractive>
		<set_backgroundTile set="method" line="593"><f a="t">
	<c path="h2d.Tile"/>
	<c path="h2d.Tile"/>
</f></set_backgroundTile>
		<set_borderWidth set="method" line="617"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></set_borderWidth>
		<set_borderHeight set="method" line="625"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></set_borderHeight>
		<reflow public="1" set="method" line="637">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Call to force all flowed elements position to be updated.
		See needReflow for more informations.</haxe_doc>
		</reflow>
		<onBeforeReflow public="1" set="dynamic" line="1084">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Called before each reflow() is done.</haxe_doc>
		</onBeforeReflow>
		<onAfterReflow public="1" set="dynamic" line="1090">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Called after each time a reflow() was done.</haxe_doc>
		</onAfterReflow>
		<new public="1" set="method" line="218"><f a="?parent">
	<c path="h2d.Object"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h2d.Dropdown" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h2d/Dropdown.hx">
		<extends path="h2d.Flow"/>
		<items><c path="Array"><c path="h2d.Object"/></c></items>
		<fake><c path="h2d._Dropdown.Fake"/></fake>
		<cursor><c path="h2d.Bitmap"/></cursor>
		<arrow><c path="h2d.Bitmap"/></arrow>
		<tileOverItem public="1" set="accessor"><c path="h2d.Tile"/></tileOverItem>
		<tileArrow public="1" set="accessor"><c path="h2d.Tile"/></tileArrow>
		<tileArrowOpen public="1"><c path="h2d.Tile"/></tileArrowOpen>
		<canEdit public="1" set="accessor" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</canEdit>
		<dropdownList public="1"><c path="h2d.Flow"/></dropdownList>
		<dropdownLayer public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</dropdownLayer>
		<selectedItem public="1" set="accessor" expr="-1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</selectedItem>
		<highlightedItem public="1" set="null" expr="-1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</highlightedItem>
		<rollUp public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</rollUp>
		<set_backgroundTile set="method" line="144" override="1"><f a="t">
	<c path="h2d.Tile"/>
	<c path="h2d.Tile"/>
</f></set_backgroundTile>
		<set_tileArrow set="method" line="150"><f a="t">
	<c path="h2d.Tile"/>
	<c path="h2d.Tile"/>
</f></set_tileArrow>
		<set_tileOverItem set="method" line="155"><f a="t">
	<c path="h2d.Tile"/>
	<c path="h2d.Tile"/>
</f></set_tileOverItem>
		<addItem public="1" set="method" line="160"><f a="s">
	<c path="h2d.Object"/>
	<x path="Void"/>
</f></addItem>
		<set_canEdit set="method" line="168"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_canEdit>
		<set_selectedItem set="method" line="174"><f a="s">
	<x path="Int"/>
	<x path="Int"/>
</f></set_selectedItem>
		<open public="1" set="method" line="186"><f a=""><x path="Void"/></f></open>
		<close public="1" set="method" line="195"><f a=""><x path="Void"/></f></close>
		<onRemove set="method" line="204" override="1"><f a=""><x path="Void"/></f></onRemove>
		<onOpen public="1" set="dynamic" line="210"><f a=""><x path="Void"/></f></onOpen>
		<onClose public="1" set="dynamic" line="213"><f a=""><x path="Void"/></f></onClose>
		<onOverItem public="1" set="dynamic" line="216"><f a="item">
	<c path="h2d.Object"/>
	<x path="Void"/>
</f></onOverItem>
		<onOutItem public="1" set="dynamic" line="219"><f a="item">
	<c path="h2d.Object"/>
	<x path="Void"/>
</f></onOutItem>
		<new public="1" set="method" line="51"><f a="?parent">
	<c path="h2d.Object"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="h2d.FlowAlign" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h2d/Flow.hx" module="h2d.Flow">
		<Top/>
		<Left/>
		<Right/>
		<Middle/>
		<Bottom/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="h2d.FlowLayout" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h2d/Flow.hx" module="h2d.Flow">
		<Horizontal/>
		<Vertical/>
		<Stack/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="h2d.FlowProperties" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h2d/Flow.hx" module="h2d.Flow">
		<elt><c path="h2d.Object"/></elt>
		<paddingLeft public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</paddingLeft>
		<paddingTop public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</paddingTop>
		<paddingRight public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</paddingRight>
		<paddingBottom public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</paddingBottom>
		<isAbsolute public="1" set="accessor" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</isAbsolute>
		<horizontalAlign public="1"><x path="Null"><e path="h2d.FlowAlign"/></x></horizontalAlign>
		<verticalAlign public="1"><x path="Null"><e path="h2d.FlowAlign"/></x></verticalAlign>
		<offsetX public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</offsetX>
		<offsetY public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</offsetY>
		<minWidth public="1"><x path="Null"><x path="Int"/></x></minWidth>
		<minHeight public="1"><x path="Null"><x path="Int"/></x></minHeight>
		<calculatedWidth public="1" set="null" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</calculatedWidth>
		<calculatedHeight public="1" set="null" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</calculatedHeight>
		<isBreak public="1" set="null"><x path="Bool"/></isBreak>
		<lineBreak public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</lineBreak>
		<constraint public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>If our flow have a maximum size, it will constraint the children by using .constraintSize()</haxe_doc>
		</constraint>
		<align public="1" get="inline" set="null" line="52"><f a="vertical:horizontal">
	<x path="Null"><e path="h2d.FlowAlign"/></x>
	<x path="Null"><e path="h2d.FlowAlign"/></x>
	<x path="Void"/>
</f></align>
		<set_isAbsolute set="method" line="57"><f a="a">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_isAbsolute>
		<new public="1" set="method" line="48"><f a="elt">
	<c path="h2d.Object"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>h2d.Flow</e></m>
		</meta>
	</class>
	<class path="h2d.Kerning" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h2d/Font.hx" module="h2d.Font">
		<prevChar public="1"><x path="Int"/></prevChar>
		<offset public="1"><x path="Float"/></offset>
		<next public="1"><x path="Null"><c path="h2d.Kerning"/></x></next>
		<new public="1" set="method" line="7"><f a="c:o">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h2d.FontChar" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h2d/Font.hx" module="h2d.Font">
		<t public="1"><c path="h2d.Tile"/></t>
		<width public="1"><x path="Float"/></width>
		<kerning><x path="Null"><c path="h2d.Kerning"/></x></kerning>
		<addKerning public="1" set="method" line="24"><f a="prevChar:offset">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></addKerning>
		<getKerningOffset public="1" set="method" line="30"><f a="prevChar">
	<x path="Int"/>
	<x path="Float"/>
</f></getKerningOffset>
		<clone public="1" set="method" line="40"><f a=""><c path="h2d.FontChar"/></f></clone>
		<new public="1" set="method" line="19"><f a="t:w">
	<c path="h2d.Tile"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="h2d.SDFChannel" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h2d/Font.hx" module="h2d.Font">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<haxe_doc>Channel reading method for SDF.</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="h2d._Font.SDFChannel_Impl_" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h2d/Font.hx" private="1" module="h2d.Font" extern="1">
	<Red public="1" get="inline" set="null" expr="cast 0" line="62" static="1">
		<x path="h2d.SDFChannel"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Use red channel of a texture to determine distance.</haxe_doc>
	</Red>
	<Green public="1" get="inline" set="null" expr="cast 1" line="64" static="1">
		<x path="h2d.SDFChannel"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Use green channel of a texture to determine distance.</haxe_doc>
	</Green>
	<Blue public="1" get="inline" set="null" expr="cast 2" line="66" static="1">
		<x path="h2d.SDFChannel"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Use blue channel of a texture to determine distance.</haxe_doc>
	</Blue>
	<Alpha public="1" get="inline" set="null" expr="cast 3" line="68" static="1">
		<x path="h2d.SDFChannel"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Use alpha channel of a texture to determine distance.</haxe_doc>
	</Alpha>
	<MultiChannel public="1" get="inline" set="null" expr="cast 4" line="70" static="1">
		<x path="h2d.SDFChannel"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Use RGB channels of a texture to determine distance. See here for details: https://github.com/Chlumsky/msdfgen</haxe_doc>
	</MultiChannel>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="h2d._Font.SDFChannel_Impl_" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h2d/Font.hx" private="1" module="h2d.Font" extern="1">
		<Red public="1" get="inline" set="null" expr="cast 0" line="62" static="1">
			<x path="h2d.SDFChannel"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Use red channel of a texture to determine distance.</haxe_doc>
		</Red>
		<Green public="1" get="inline" set="null" expr="cast 1" line="64" static="1">
			<x path="h2d.SDFChannel"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Use green channel of a texture to determine distance.</haxe_doc>
		</Green>
		<Blue public="1" get="inline" set="null" expr="cast 2" line="66" static="1">
			<x path="h2d.SDFChannel"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Use blue channel of a texture to determine distance.</haxe_doc>
		</Blue>
		<Alpha public="1" get="inline" set="null" expr="cast 3" line="68" static="1">
			<x path="h2d.SDFChannel"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Use alpha channel of a texture to determine distance.</haxe_doc>
		</Alpha>
		<MultiChannel public="1" get="inline" set="null" expr="cast 4" line="70" static="1">
			<x path="h2d.SDFChannel"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Use RGB channels of a texture to determine distance. See here for details: https://github.com/Chlumsky/msdfgen</haxe_doc>
		</MultiChannel>
		<meta><m n=":enum"/></meta>
	</class>
	<enum path="h2d.FontType" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h2d/Font.hx" module="h2d.Font">
		<BitmapFont/>
		<SignedDistanceField a="channel:alphaCutoff:smoothing">
			<x path="h2d.SDFChannel"/>
			<x path="Float"/>
			<x path="Float"/>
			<haxe_doc>Signed Distance Field font. Channel indexes are in RGBA order. See here for info: https://github.com/libgdx/libgdx/wiki/Distance-field-fonts</haxe_doc>
		</SignedDistanceField>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<class path="h2d.Font" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h2d/Font.hx">
		<name public="1" set="null"><c path="String"/></name>
		<size public="1" set="null"><x path="Int"/></size>
		<baseLine public="1" set="null"><x path="Float"/></baseLine>
		<lineHeight public="1" set="null"><x path="Float"/></lineHeight>
		<tile public="1" set="null"><c path="h2d.Tile"/></tile>
		<tilePath public="1" set="null"><c path="String"/></tilePath>
		<type public="1"><e path="h2d.FontType"/></type>
		<charset public="1"><c path="hxd.Charset"/></charset>
		<glyphs><t path="Map">
	<x path="Int"/>
	<c path="h2d.FontChar"/>
</t></glyphs>
		<nullChar><c path="h2d.FontChar"/></nullChar>
		<defaultChar><c path="h2d.FontChar"/></defaultChar>
		<initSize><x path="Int"/></initSize>
		<offsetX expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</offsetX>
		<offsetY expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</offsetY>
		<getChar public="1" get="inline" set="null" line="111"><f a="code">
	<x path="Int"/>
	<x path="Null"><c path="h2d.FontChar"/></x>
</f></getChar>
		<setOffset public="1" set="method" line="121"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setOffset>
		<clone public="1" set="method" line="133"><f a=""><c path="h2d.Font"/></f></clone>
		<resizeTo public="1" set="method" line="154">
			<f a="size">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>This is meant to create smoother fonts by creating them with double size while still keeping the original glyph size.</haxe_doc>
		</resizeTo>
		<hasChar public="1" set="method" line="172"><f a="code">
	<x path="Int"/>
	<x path="Bool"/>
</f></hasChar>
		<dispose public="1" set="method" line="176"><f a=""><x path="Void"/></f></dispose>
		<new set="method" line="96"><f a="name:size:?type">
	<c path="String"/>
	<x path="Int"/>
	<e path="h2d.FontType"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="h2d._Graphics.GraphicsPoint" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h2d/Graphics.hx" private="1" module="h2d.Graphics"><c path="hxd.poly2tri.Point"/></typedef>
	<class path="h2d.GPoint" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h2d/Graphics.hx" module="h2d.Graphics">
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<r public="1"><x path="Float"/></r>
		<g public="1"><x path="Float"/></g>
		<b public="1"><x path="Float"/></b>
		<a public="1"><x path="Float"/></a>
		<load public="1" set="method" line="17"><f a="x:y:r:g:b:a">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></load>
		<new public="1" set="method" line="14"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h2d._Graphics.GraphicsContent" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h2d/Graphics.hx" private="1" module="h2d.Graphics">
		<extends path="h3d.prim.Primitive"/>
		<tmp><x path="hxd.FloatBuffer"/></tmp>
		<index><x path="hxd.IndexBuffer"/></index>
		<buffers><c path="Array"><a>
	<vbuf><c path="h3d.Buffer"/></vbuf>
	<idx><x path="hxd.IndexBuffer"/></idx>
	<ibuf><c path="h3d.Indexes"/></ibuf>
	<buf><x path="hxd.FloatBuffer"/></buf>
</a></c></buffers>
		<bufferDirty><x path="Bool"/></bufferDirty>
		<indexDirty><x path="Bool"/></indexDirty>
		<addIndex public="1" get="inline" set="null" line="46"><f a="i">
	<x path="Int"/>
	<x path="Void"/>
</f></addIndex>
		<add public="1" get="inline" set="null" line="51"><f a="x:y:u:v:r:g:b:a">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></add>
		<next public="1" set="method" line="63"><f a=""><x path="Bool"/></f></next>
		<alloc public="1" set="method" line="74" override="1"><f a="engine">
	<c path="h3d.Engine"/>
	<x path="Void"/>
</f></alloc>
		<render public="1" set="method" line="89" override="1"><f a="engine">
	<c path="h3d.Engine"/>
	<x path="Void"/>
</f></render>
		<flush public="1" get="inline" set="null" line="97"><f a=""><x path="Void"/></f></flush>
		<dispose public="1" set="method" line="114" override="1"><f a=""><x path="Void"/></f></dispose>
		<clear public="1" set="method" line="125"><f a=""><x path="Void"/></f></clear>
		<new public="1" set="method" line="39"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h2d.Graphics" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h2d/Graphics.hx">
		<extends path="h2d.Drawable"/>
		<EARCUT expr="null" line="335" static="1">
			<c path="hxd.earcut.Earcut"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</EARCUT>
		<content><c path="h2d._Graphics.GraphicsContent"/></content>
		<tmpPoints><c path="Array"><c path="h2d.GPoint"/></c></tmpPoints>
		<pindex><x path="Int"/></pindex>
		<curR><x path="Float"/></curR>
		<curG><x path="Float"/></curG>
		<curB><x path="Float"/></curB>
		<curA><x path="Float"/></curA>
		<lineSize><x path="Float"/></lineSize>
		<lineR><x path="Float"/></lineR>
		<lineG><x path="Float"/></lineG>
		<lineB><x path="Float"/></lineB>
		<lineA><x path="Float"/></lineA>
		<doFill><x path="Bool"/></doFill>
		<xMin><x path="Float"/></xMin>
		<yMin><x path="Float"/></yMin>
		<xMax><x path="Float"/></xMax>
		<yMax><x path="Float"/></yMax>
		<ma expr="1.">
			<x path="Float"/>
			<meta><m n=":value"><e>1.</e></m></meta>
		</ma>
		<mb expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</mb>
		<mc expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</mc>
		<md expr="1.">
			<x path="Float"/>
			<meta><m n=":value"><e>1.</e></m></meta>
		</md>
		<mx expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</mx>
		<my expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</my>
		<tile public="1"><c path="h2d.Tile"/></tile>
		<bevel public="1" expr="0.25">
			<x path="Float"/>
			<meta><m n=":value"><e>0.25</e></m></meta>
		</bevel>
		<onRemove set="method" line="172" override="1"><f a=""><x path="Void"/></f></onRemove>
		<clear public="1" set="method" line="177"><f a=""><x path="Void"/></f></clear>
		<getBoundsRec set="method" line="188" override="1"><f a="relativeTo:out:forSize">
	<c path="h2d.Object"/>
	<c path="h2d.col.Bounds"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></getBoundsRec>
		<isConvex set="method" line="193"><f a="points">
	<c path="Array"><c path="h2d.GPoint"/></c>
	<x path="Bool"/>
</f></isConvex>
		<flushLine set="method" line="209"><f a="start">
	<x path="Int"/>
	<x path="Void"/>
</f></flushLine>
		<flushFill set="method" line="337"><f a="i0">
	<x path="Int"/>
	<x path="Void"/>
</f></flushFill>
		<flush set="method" line="368"><f a=""><x path="Void"/></f></flush>
		<beginFill public="1" set="method" line="385">
			<f a="?color:?alpha" v="0:1.">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ alpha : 1., color : 0 }</e></m></meta>
		</beginFill>
		<beginTileFill public="1" set="method" line="395">
			<f a="?dx:?dy:?scaleX:?scaleY:?tile">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="h2d.Tile"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Position a virtual tile at the given position and scale. Every draw will display a part of this tile relative
		to these coordinates.</haxe_doc>
		</beginTileFill>
		<drawTile public="1" set="method" line="428"><f a="x:y:tile">
	<x path="Float"/>
	<x path="Float"/>
	<c path="h2d.Tile"/>
	<x path="Void"/>
</f></drawTile>
		<lineStyle public="1" set="method" line="434">
			<f a="?size:?color:?alpha" v="0:0:1.">
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ alpha : 1., color : 0, size : 0 }</e></m></meta>
		</lineStyle>
		<moveTo public="1" get="inline" set="null" line="443"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></moveTo>
		<endFill public="1" set="method" line="448"><f a=""><x path="Void"/></f></endFill>
		<setColor public="1" get="inline" set="null" line="453">
			<f a="color:?alpha" v=":1.">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ alpha : 1. }</e></m></meta>
		</setColor>
		<drawRect public="1" set="method" line="460"><f a="x:y:w:h">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawRect>
		<drawRoundedRect public="1" set="method" line="477">
			<f a="x:y:w:h:radius:?nsegments" v=":::::0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ nsegments : 0 }</e></m></meta>
		</drawRoundedRect>
		<drawCircle public="1" set="method" line="508">
			<f a="cx:cy:radius:?nsegments" v=":::0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ nsegments : 0 }</e></m></meta>
		</drawCircle>
		<drawEllipse public="1" set="method" line="521">
			<f a="cx:cy:radiusX:radiusY:?rotationAngle:?nsegments" v="::::0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ nsegments : 0, rotationAngle : 0 }</e></m></meta>
		</drawEllipse>
		<drawPie public="1" set="method" line="537">
			<f a="cx:cy:radius:angleStart:angleLength:?nsegments" v=":::::0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ nsegments : 0 }</e></m></meta>
		</drawPie>
		<drawRectanglePie public="1" set="method" line="555">
			<f a="cx:cy:width:height:angleStart:angleLength:?nsegments" v="::::::0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ nsegments : 0 }</e></m></meta>
		</drawRectanglePie>
		<curveTo public="1" set="method" line="585">
			<f a="bx:by:cx:cy">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Draws a quadratic Bezier curve using the current line style from the current drawing position to (cx, cy) and using the control point that (bx, by) specifies.
	 * IvanK Lib port ( http://lib.ivank.net )</haxe_doc>
		</curveTo>
		<cubicCurveTo public="1" set="method" line="603">
			<f a="bx:by:cx:cy:dx:dy:?nsegments" v="::::::40">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ nsegments : 40 }</e></m></meta>
			<haxe_doc>* Draws a cubic Bezier curve from the current drawing position to the specified anchor point.
	 * IvanK Lib port ( http://lib.ivank.net )
	 * @param bx control X for start point
	 * @param by control Y for start point
	 * @param cx control X for end point
	 * @param cy control Y for end point
	 * @param dx end X
	 * @param dy end Y
	 * @param nsegments = 40</haxe_doc>
		</cubicCurveTo>
		<lineTo public="1" get="inline" set="null" line="627"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></lineTo>
		<addVertex public="1" set="method" line="631">
			<f a="x:y:r:g:b:a:?u:?v" v="::::::0.:0.">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ v : 0., u : 0. }</e></m></meta>
		</addVertex>
		<draw set="method" line="643" override="1"><f a="ctx">
	<c path="h2d.RenderContext"/>
	<x path="Void"/>
</f></draw>
		<sync set="method" line="648" override="1"><f a="ctx">
	<c path="h2d.RenderContext"/>
	<x path="Void"/>
</f></sync>
		<new public="1" set="method" line="165"><f a="?parent">
	<c path="h2d.Object"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="h2d.LineHeightMode" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h2d/HtmlText.hx" module="h2d.HtmlText">
		<Accurate><haxe_doc>Accurate line height calculations. Each line will adjust it's height according to it's contents.</haxe_doc></Accurate>
		<TextOnly><haxe_doc><![CDATA[Only text adjusts line heights, and `<img>` tags do not affect it (partial legacy behavior).]]></haxe_doc></TextOnly>
		<Constant><haxe_doc>Legacy line height mode. When used, line heights are remain constant based on `HtmlText.font` variable.</haxe_doc></Constant>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="h2d.Text" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h2d/Text.hx">
		<extends path="h2d.Drawable"/>
		<font public="1" set="accessor"><c path="h2d.Font"/></font>
		<text public="1" set="accessor"><c path="String"/></text>
		<textColor public="1" set="accessor"><x path="Int"/></textColor>
		<maxWidth public="1" set="accessor"><x path="Null"><x path="Float"/></x></maxWidth>
		<dropShadow public="1"><a>
	<dy><x path="Float"/></dy>
	<dx><x path="Float"/></dx>
	<color><x path="Int"/></color>
	<alpha><x path="Float"/></alpha>
</a></dropShadow>
		<textWidth public="1" get="accessor" set="null"><x path="Float"/></textWidth>
		<textHeight public="1" get="accessor" set="null"><x path="Float"/></textHeight>
		<textAlign public="1" set="accessor"><e path="h2d.Align"/></textAlign>
		<letterSpacing public="1" set="accessor"><x path="Float"/></letterSpacing>
		<lineSpacing public="1" set="accessor"><x path="Float"/></lineSpacing>
		<glyphs><c path="h2d.TileGroup"/></glyphs>
		<needsRebuild><x path="Bool"/></needsRebuild>
		<currentText><c path="String"/></currentText>
		<textChanged><x path="Bool"/></textChanged>
		<calcDone><x path="Bool"/></calcDone>
		<calcXMin><x path="Float"/></calcXMin>
		<calcYMin><x path="Float"/></calcYMin>
		<calcWidth><x path="Float"/></calcWidth>
		<calcHeight><x path="Float"/></calcHeight>
		<calcSizeHeight><x path="Float"/></calcSizeHeight>
		<constraintWidth expr="-1">
			<x path="Float"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</constraintWidth>
		<realMaxWidth expr="-1">
			<x path="Float"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</realMaxWidth>
		<sdfShader><c path="h3d.shader.SignedDistanceField"/></sdfShader>
		<set_font set="method" line="52"><f a="font">
	<c path="h2d.Font"/>
	<c path="h2d.Font"/>
</f></set_font>
		<set_textAlign set="method" line="79"><f a="a">
	<e path="h2d.Align"/>
	<e path="h2d.Align"/>
</f></set_textAlign>
		<set_letterSpacing set="method" line="86"><f a="s">
	<x path="Float"/>
	<x path="Float"/>
</f></set_letterSpacing>
		<set_lineSpacing set="method" line="93"><f a="s">
	<x path="Float"/>
	<x path="Float"/>
</f></set_lineSpacing>
		<constraintSize set="method" line="100" override="1"><f a="width:height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></constraintSize>
		<onAdd set="method" line="105" override="1"><f a=""><x path="Void"/></f></onAdd>
		<checkText get="inline" set="null" line="110"><f a=""><x path="Void"/></f></checkText>
		<sync set="method" line="119" override="1"><f a="ctx">
	<c path="h2d.RenderContext"/>
	<x path="Void"/>
</f></sync>
		<draw set="method" line="125" override="1"><f a="ctx">
	<c path="h2d.RenderContext"/>
	<x path="Void"/>
</f></draw>
		<set_text set="method" line="151"><f a="t">
	<c path="String"/>
	<c path="String"/>
</f></set_text>
		<validateText set="method" line="161"><f a=""><x path="Void"/></f></validateText>
		<rebuild set="method" line="164"><f a=""><x path="Void"/></f></rebuild>
		<calcTextWidth public="1" set="method" line="170"><f a="text">
	<c path="String"/>
	<x path="Float"/>
</f></calcTextWidth>
		<splitText public="1" set="method" line="191">
			<f a="text">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Word-wrap the text based on this Text settings.</haxe_doc>
		</splitText>
		<splitRawText set="method" line="204">
			<f a="text:?leftMargin:?afterData:?font:?sizes:?prevChar" v=":0.:0.:::-1">
				<c path="String"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="h2d.Font"/>
				<c path="Array"><x path="Float"/></c>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ prevChar : -1, afterData : 0., leftMargin : 0. }</e></m></meta>
			<haxe_doc>Word-wrap the text based on this Text settings.  
		@param text String to word-wrap.
		@param leftMargin Starting x offset of the first line.
		@param afterData Minimum remaining space required at the end of the line.
		@param font Optional overriding font to use instead of currently set.
		@param sizes Optional line width array. Will be populated with sizes of split lines if present. Sizes will include both `leftMargin` in it's first line entry.
		@param prevChar Optional character code for concatenation purposes (proper kernings).</haxe_doc>
		</splitRawText>
		<getTextProgress public="1" set="method" line="273"><f a="text:progress">
	<c path="String"/>
	<x path="Float"/>
	<c path="String"/>
</f></getTextProgress>
		<initGlyphs set="method" line="278">
			<f a="text:?rebuild" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ rebuild : true }</e></m></meta>
		</initGlyphs>
		<updateSize get="inline" set="null" line="341"><f a=""><x path="Void"/></f></updateSize>
		<get_textHeight set="method" line="346"><f a=""><x path="Float"/></f></get_textHeight>
		<get_textWidth set="method" line="351"><f a=""><x path="Float"/></f></get_textWidth>
		<set_maxWidth set="method" line="356"><f a="w">
	<x path="Null"><x path="Float"/></x>
	<x path="Null"><x path="Float"/></x>
</f></set_maxWidth>
		<updateConstraint set="method" line="363"><f a=""><x path="Void"/></f></updateConstraint>
		<set_textColor set="method" line="375"><f a="c">
	<x path="Int"/>
	<x path="Int"/>
</f></set_textColor>
		<getBoundsRec set="method" line="384" override="1"><f a="relativeTo:out:forSize">
	<c path="h2d.Object"/>
	<c path="h2d.col.Bounds"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></getBoundsRec>
		<new public="1" set="method" line="41"><f a="font:?parent">
	<c path="h2d.Font"/>
	<c path="h2d.Object"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h2d.HtmlText" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h2d/HtmlText.hx">
		<extends path="h2d.Text"/>
		<defaultLoadImage public="1" set="dynamic" line="25" static="1">
			<f a="url">
				<c path="String"/>
				<c path="h2d.Tile"/>
			</f>
			<haxe_doc><![CDATA[A default method HtmlText uses to load images for `<img>` tag. See `HtmlText.loadImage` for details.]]></haxe_doc>
		</defaultLoadImage>
		<defaultLoadFont public="1" set="dynamic" line="32" static="1">
			<f a="name">
				<c path="String"/>
				<c path="h2d.Font"/>
			</f>
			<haxe_doc><![CDATA[A default method HtmlText uses to load fonts for `<font>` tags with `face` attribute. See `HtmlText.loadFont` for details.]]></haxe_doc>
		</defaultLoadFont>
		<defaultFormatText public="1" set="dynamic" line="39" static="1">
			<f a="text">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>A default method HtmlText uses to format assigned text.</haxe_doc>
		</defaultFormatText>
		<REG_SPACES expr="~/[
	 ]+/" line="410" static="1">
			<c path="EReg"/>
			<meta><m n=":value"><e>~/[
	 ]+/</e></m></meta>
		</REG_SPACES>
		<condenseWhite public="1" set="accessor" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</condenseWhite>
		<lineHeightMode public="1" set="accessor" expr="Accurate">
			<e path="h2d.LineHeightMode"/>
			<meta><m n=":value"><e>Accurate</e></m></meta>
			<haxe_doc>Line height calculation mode controls how much space lines take up vertically. ( default : Accurate )
		Changing mode to `Constant` restores legacy behavior of HtmlText.</haxe_doc>
		</lineHeightMode>
		<elements expr="[]">
			<c path="Array"><c path="h2d.Object"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</elements>
		<xPos><x path="Float"/></xPos>
		<yPos><x path="Float"/></yPos>
		<xMax><x path="Float"/></xMax>
		<xMin><x path="Float"/></xMin>
		<textXml><c path="Xml"/></textXml>
		<sizePos><x path="Int"/></sizePos>
		<dropMatrix><c path="h3d.shader.ColorMatrix"/></dropMatrix>
		<prevChar><x path="Int"/></prevChar>
		<newLine><x path="Bool"/></newLine>
		<draw set="method" line="62" override="1"><f a="ctx">
	<c path="h2d.RenderContext"/>
	<x path="Void"/>
</f></draw>
		<loadImage public="1" set="dynamic" line="91">
			<f a="url">
				<c path="String"/>
				<c path="h2d.Tile"/>
			</f>
			<haxe_doc><![CDATA[Method that should return `h2d.Tile` instance for `<img>` tags. By default calls `HtmlText.defaultLoadImage` method.
		HtmlText does not cache tile instances.
		Due to internal structure, method should be determenistic and always return same Tile on consequent calls with same `url` input.
		@param url A value contained in `src` attribute.]]></haxe_doc>
		</loadImage>
		<loadFont public="1" set="dynamic" line="102">
			<f a="name">
				<c path="String"/>
				<c path="h2d.Font"/>
			</f>
			<haxe_doc><![CDATA[Method that should return `h2d.Font` instance for `<font>` tags with `face` attribute. By default calls `HtmlText.defaultLoadFont` method.
		HtmlText does not cache font instances and it's recommended to perform said caching from outside.
		Due to internal structure, method should be determenistic and always return same Font instance on consequent calls with same `name` input.
		@param name A value contained in `face` attribute.
		@returns Method should return loaded font instance or `null`. If `null` is returned - currently active font is used.]]></haxe_doc>
		</loadFont>
		<formatText public="1" set="dynamic" line="108"><f a="text">
	<c path="String"/>
	<c path="String"/>
</f></formatText>
		<set_text set="method" line="112" override="1"><f a="t">
	<c path="String"/>
	<c path="String"/>
</f></set_text>
		<parseText set="method" line="117"><f a="text">
	<c path="String"/>
	<c path="Xml"/>
</f></parseText>
		<makeLineInfo get="inline" set="null" line="121"><f a="width:height:baseLine">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<t path="h2d._HtmlText.LineInfo"/>
</f></makeLineInfo>
		<validateText set="method" line="125" override="1"><f a=""><x path="Void"/></f></validateText>
		<validateNodes set="method" line="131"><f a="xml">
	<c path="Xml"/>
	<x path="Void"/>
</f></validateNodes>
		<initGlyphs set="method" line="153" override="1">
			<f a="text:?rebuild" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ rebuild : true }</e></m></meta>
		</initGlyphs>
		<buildSizes set="method" line="209"><f a="e:font:metrics:splitNode">
	<c path="Xml"/>
	<c path="h2d.Font"/>
	<c path="Array"><t path="h2d._HtmlText.LineInfo"/></c>
	<t path="h2d._HtmlText.SplitNode"/>
	<x path="Void"/>
</f></buildSizes>
		<htmlToText set="method" line="411"><f a="t">
	<c path="String"/>
	<c path="String"/>
</f></htmlToText>
		<nextLine get="inline" set="null" line="417"><f a="align:size">
	<e path="h2d.Align"/>
	<x path="Float"/>
	<x path="Void"/>
</f></nextLine>
		<splitText public="1" set="method" line="431" override="1"><f a="text">
	<c path="String"/>
	<c path="String"/>
</f></splitText>
		<getTextProgress public="1" set="method" line="483" override="1"><f a="text:progress">
	<c path="String"/>
	<x path="Float"/>
	<c path="String"/>
</f></getTextProgress>
		<addNode set="method" line="510"><f a="e:font:align:rebuild:metrics">
	<c path="Xml"/>
	<c path="h2d.Font"/>
	<e path="h2d.Align"/>
	<x path="Bool"/>
	<c path="Array"><t path="h2d._HtmlText.LineInfo"/></c>
	<x path="Void"/>
</f></addNode>
		<set_textColor set="method" line="658" override="1"><f a="c">
	<x path="Int"/>
	<x path="Int"/>
</f></set_textColor>
		<set_condenseWhite set="method" line="665"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_condenseWhite>
		<set_lineHeightMode set="method" line="673"><f a="v">
	<e path="h2d.LineHeightMode"/>
	<e path="h2d.LineHeightMode"/>
</f></set_lineHeightMode>
		<getBoundsRec set="method" line="681" override="1"><f a="relativeTo:out:forSize">
	<c path="h2d.Object"/>
	<c path="h2d.col.Bounds"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></getBoundsRec>
		<new public="1" set="method" line="20"><f a="font:?parent">
	<c path="h2d.Font"/>
	<c path="h2d.Object"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="h2d._HtmlText.LineInfo" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h2d/HtmlText.hx" private="1" module="h2d.HtmlText"><a>
	<width><x path="Float"/></width>
	<height><x path="Float"/></height>
	<baseLine><x path="Float"/></baseLine>
</a></typedef>
	<typedef path="h2d._HtmlText.SplitNode" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h2d/HtmlText.hx" private="1" module="h2d.HtmlText"><a>
	<width><x path="Float"/></width>
	<prevChar><x path="Int"/></prevChar>
	<pos><x path="Int"/></pos>
	<node><c path="Xml"/></node>
	<height><x path="Float"/></height>
	<font><c path="h2d.Font"/></font>
	<baseLine><x path="Float"/></baseLine>
</a></typedef>
	<class path="hxd.Interactive" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/SceneEvents.hx" module="hxd.SceneEvents" interface="1">
		<set_cursor public="1" set="method">
			<f a="value">
				<e path="hxd.Cursor"/>
				<e path="hxd.Cursor"/>
			</f>
			<meta><m n=":compilerGenerated"/></meta>
		</set_cursor>
		<propagateEvents public="1"><x path="Bool"/></propagateEvents>
		<cursor public="1" set="accessor"><e path="hxd.Cursor"/></cursor>
		<handleEvent public="1" set="method"><f a="e">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></handleEvent>
		<getInteractiveScene public="1" set="method"><f a=""><c path="hxd.InteractiveScene"/></f></getInteractiveScene>
	</class>
	<class path="h2d.Interactive" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h2d/Interactive.hx">
		<extends path="h2d.Drawable"/>
		<implements path="hxd.Interactive"/>
		<width public="1">
			<x path="Float"/>
			<haxe_doc>Width of the Interactive. Ignored if `shape` is set.</haxe_doc>
		</width>
		<height public="1">
			<x path="Float"/>
			<haxe_doc>Height of the Interactive. Ignored if `shape` is set.</haxe_doc>
		</height>
		<cursor public="1" set="accessor">
			<x path="Null"><e path="hxd.Cursor"/></x>
			<haxe_doc>Cursor used when Interactive is under mouse cursor ( default : Button )</haxe_doc>
		</cursor>
		<isEllipse public="1">
			<x path="Bool"/>
			<haxe_doc>Should object collision be in rectangle or ellipse form? Ignored if `shape` is set.</haxe_doc>
		</isEllipse>
		<cancelEvents public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>Set the default `cancel` mode (see `hxd.Event`), default to false.</haxe_doc>
		</cancelEvents>
		<propagateEvents public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>Set the default `propagate` mode (see `hxd.Event`), default to false.</haxe_doc>
		</propagateEvents>
		<backgroundColor public="1"><x path="Null"><x path="Int"/></x></backgroundColor>
		<enableRightButton public="1"><x path="Bool"/></enableRightButton>
		<scene><c path="h2d.Scene"/></scene>
		<mouseDownButton expr="-1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</mouseDownButton>
		<parentMask><c path="h2d.Mask"/></parentMask>
		<invDet><x path="Float"/></invDet>
		<shape public="1">
			<c path="h2d.col.Collider"/>
			<haxe_doc>Detailed shape collider for Interactive.
		If set, `width` and `height` properties are ignored for collision checks.</haxe_doc>
		</shape>
		<shapeX public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>Detailed shape X offset from Interactive.</haxe_doc>
		</shapeX>
		<shapeY public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>Detailed shape Y offset from Interactive.</haxe_doc>
		</shapeY>
		<onAdd set="method" line="59" override="1"><f a=""><x path="Void"/></f></onAdd>
		<draw set="method" line="66" override="1"><f a="ctx">
	<c path="h2d.RenderContext"/>
	<x path="Void"/>
</f></draw>
		<getBoundsRec set="method" line="70" override="1"><f a="relativeTo:out:forSize">
	<c path="h2d.Object"/>
	<c path="h2d.col.Bounds"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></getBoundsRec>
		<onHierarchyMoved set="method" line="75" override="1"><f a="parentChanged">
	<x path="Bool"/>
	<x path="Void"/>
</f></onHierarchyMoved>
		<updateMask set="method" line="88"><f a=""><x path="Void"/></f></updateMask>
		<onRemove set="method" line="101" override="1"><f a=""><x path="Void"/></f></onRemove>
		<checkBounds set="method" line="109"><f a="e">
	<c path="hxd.Event"/>
	<x path="Bool"/>
</f></checkBounds>
		<preventClick public="1" set="method" line="119">
			<f a=""><x path="Void"/></f>
			<haxe_doc>This can be called during or after a push event in order to prevent the release from triggering a click.</haxe_doc>
		</preventClick>
		<getInteractiveScene public="1" set="method" line="123">
			<f a=""><c path="hxd.InteractiveScene"/></f>
			<meta><m n=":noCompletion"/></meta>
		</getInteractiveScene>
		<handleEvent public="1" set="method" line="127">
			<f a="e">
				<c path="hxd.Event"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</handleEvent>
		<calcAbsPos set="method" line="198" override="1"><f a=""><x path="Void"/></f></calcAbsPos>
		<set_cursor set="method" line="204"><f a="c">
	<x path="Null"><e path="hxd.Cursor"/></x>
	<x path="Null"><e path="hxd.Cursor"/></x>
</f></set_cursor>
		<eventToLocal set="method" line="211"><f a="e">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></eventToLocal>
		<startDrag public="1" set="method" line="222"><f a="callb:?onCancel">
	<f a="">
		<c path="hxd.Event"/>
		<unknown/>
	</f>
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></startDrag>
		<stopDrag public="1" set="method" line="232"><f a=""><x path="Void"/></f></stopDrag>
		<focus public="1" set="method" line="236"><f a=""><x path="Void"/></f></focus>
		<blur public="1" set="method" line="242"><f a=""><x path="Void"/></f></blur>
		<isOver public="1" set="method" line="246"><f a=""><x path="Bool"/></f></isOver>
		<hasFocus public="1" set="method" line="250"><f a=""><x path="Bool"/></f></hasFocus>
		<onOver public="1" set="dynamic" line="259">
			<f a="e">
				<c path="hxd.Event"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sent when mouse enters Interactive hitbox area.
		`event.propagate` and `event.cancel` are ignored during `onOver`.
		Propagation can be set with `onMove` event, as well as cancelling `onMove` will prevent `onOver`.</haxe_doc>
		</onOver>
		<onOut public="1" set="dynamic" line="265">
			<f a="e">
				<c path="hxd.Event"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sent when mouse exits Interactive hitbox area.
		`event.propagate` and `event.cancel` are ignored during `onOut`.</haxe_doc>
		</onOut>
		<onPush public="1" set="dynamic" line="269">
			<f a="e">
				<c path="hxd.Event"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sent when Interactive is pressed by user.</haxe_doc>
		</onPush>
		<onRelease public="1" set="dynamic" line="280">
			<f a="e">
				<c path="hxd.Event"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sent on multiple conditions.
		A. Always sent if user releases mouse while it is inside Interactive hitbox area.
			This happends regardless if that Interactive was pressed prior or not.
		B. Sent before `onReleaseOutside` if this Interactive was pressed, but released outside it's bounds.
		For first case `event.kind` will be `ERelease`, for second case - `EReleaseOutside`.
		See `onClick` and `onReleaseOutside` functions for separate events that trigger only when user interacts with this particular Interactive.</haxe_doc>
		</onRelease>
		<onReleaseOutside public="1" set="dynamic" line="287">
			<f a="e">
				<c path="hxd.Event"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sent when user presses Interactive, moves mouse outside and releases it.
		This event fired only on Interactive that user pressed, but released mouse after moving it outside of Interactive hitbox area.</haxe_doc>
		</onReleaseOutside>
		<onClick public="1" set="dynamic" line="294">
			<f a="e">
				<c path="hxd.Event"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sent when Interactive is clicked by user.
		This event fired only on Interactive that user pressed and released when mouse is inside Interactive hitbox area.</haxe_doc>
		</onClick>
		<onMove public="1" set="dynamic" line="297"><f a="e">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></onMove>
		<onWheel public="1" set="dynamic" line="300"><f a="e">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></onWheel>
		<onFocus public="1" set="dynamic" line="303"><f a="e">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></onFocus>
		<onFocusLost public="1" set="dynamic" line="306"><f a="e">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></onFocusLost>
		<onKeyUp public="1" set="dynamic" line="309"><f a="e">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></onKeyUp>
		<onKeyDown public="1" set="dynamic" line="312"><f a="e">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></onKeyDown>
		<onCheck public="1" set="dynamic" line="315"><f a="e">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></onCheck>
		<onTextInput public="1" set="dynamic" line="318"><f a="e">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></onTextInput>
		<new public="1" set="method" line="51"><f a="width:height:?parent:?shape">
	<x path="Float"/>
	<x path="Float"/>
	<c path="h2d.Object"/>
	<c path="h2d.col.Collider"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>h2d.Scene</e></m>
		</meta>
	</class>
	<class path="h2d.Layers" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h2d/Layers.hx">
		<extends path="h2d.Object"/>
		<layersIndexes><c path="Array"><x path="Int"/></c></layersIndexes>
		<layerCount><x path="Int"/></layerCount>
		<addChild public="1" set="method" line="18" override="1"><f a="s">
	<c path="h2d.Object"/>
	<x path="Void"/>
</f></addChild>
		<add public="1" get="inline" set="null" line="28">
			<f a="s:layer">
				<c path="h2d.Object"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Adds a child `h2d.Object` at `layer:Int`. 
	 * `h2d.Layers.addChildAt` can be used as an alternative.
	 * @param s `h2d.Object` child to be added.
	 * @param layer `Int` index of the layer, 0 is the bottom layer.</haxe_doc>
		</add>
		<addChildAt public="1" set="method" line="32" override="1"><f a="s:layer">
	<c path="h2d.Object"/>
	<x path="Int"/>
	<x path="Void"/>
</f></addChildAt>
		<removeChild public="1" set="method" line="47" override="1"><f a="s">
	<c path="h2d.Object"/>
	<x path="Void"/>
</f></removeChild>
		<under public="1" set="method" line="70">
			<f a="s">
				<c path="h2d.Object"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Moves an `h2d.Object` to the bottom of its layer (rendered first, behind the other Objects in layer).
	 * @param s `h2d.Object` to be moved.</haxe_doc>
		</under>
		<over public="1" set="method" line="96">
			<f a="s">
				<c path="h2d.Object"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Moves an `h2d.Object` to the top of its layer (rendered last, in front of other Objects in layer).
	 * @param s `h2d.Object` to be moved.</haxe_doc>
		</over>
		<getLayer public="1" set="method" line="120">
			<f a="layer">
				<x path="Int"/>
				<t path="Iterator"><c path="h2d.Object"/></t>
			</f>
			<haxe_doc><![CDATA[* Returns an `Iterator<h2d.Object>` contained in specified layer.  
	 * Returns empty iterator if layer does not exists.  
	 * Objects added or removed from Layers during iteration are not added/removed from the `Iterator`.
	 * @param layer `Int` index of the desired layer.
	 * @return `Iterator<Object>`]]></haxe_doc>
		</getLayer>
		<getChildLayer public="1" set="method" line="137">
			<f a="s">
				<c path="h2d.Object"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Returns the layer on which the child `h2d.Object` resides.  
	 * @param s `h2d.Object` 
	 * @return `Int` index of the layer where `s:h2d.Object` resides or -1 if it's not a child.</haxe_doc>
		</getChildLayer>
		<drawLayer set="method" line="146"><f a="ctx:layer">
	<c path="h2d.RenderContext"/>
	<x path="Int"/>
	<x path="Void"/>
</f></drawLayer>
		<ysort public="1" set="method" line="165">
			<f a="layer">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sorts specified layer based on Y value of it's children.
	 * @param layer `Int` index of the layer.</haxe_doc>
		</ysort>
		<new public="1" set="method" line="12"><f a="?parent">
	<c path="h2d.Object"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* `h2d.Layers` allows to hierarchically organize objects on different layers and supports Y-sorting.</haxe_doc>
	</class>
	<class path="h2d.Mask" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h2d/Mask.hx">
		<extends path="h2d.Object"/>
		<width public="1"><x path="Int"/></width>
		<height public="1"><x path="Int"/></height>
		<parentMask><c path="h2d.Mask"/></parentMask>
		<scrollX public="1" set="accessor" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>Horizontal scroll offset of the Mask content in pixels. Can be clamped by `scrollBounds`.</haxe_doc>
		</scrollX>
		<scrollY public="1" set="accessor" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>Vertical scroll offset of the Mask content in pixels. Can be clamped by `scrollBounds`.</haxe_doc>
		</scrollY>
		<scrollBounds public="1">
			<c path="h2d.col.Bounds"/>
			<haxe_doc>Optional scroll boundaries that prevent content from overscroll.</haxe_doc>
		</scrollBounds>
		<scrollTo public="1" set="method" line="33">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Scroll Mask content to specified offset.</haxe_doc>
		</scrollTo>
		<scrollBy public="1" set="method" line="41">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Scroll Mask content by specified offset relative to current scroll offset.</haxe_doc>
		</scrollBy>
		<onHierarchyMoved set="method" line="46" override="1"><f a="parentChanged">
	<x path="Bool"/>
	<x path="Void"/>
</f></onHierarchyMoved>
		<onAdd set="method" line="52" override="1"><f a=""><x path="Void"/></f></onAdd>
		<updateMask set="method" line="57"><f a=""><x path="Void"/></f></updateMask>
		<set_scrollX set="method" line="70"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_scrollX>
		<set_scrollY set="method" line="76"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_scrollY>
		<calcAbsPos set="method" line="82" override="1"><f a=""><x path="Void"/></f></calcAbsPos>
		<getBoundsRec set="method" line="89" override="1"><f a="relativeTo:out:forSize">
	<c path="h2d.Object"/>
	<c path="h2d.col.Bounds"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></getBoundsRec>
		<drawRec set="method" line="111" override="1"><f a="ctx">
	<c path="h2d.RenderContext"/>
	<x path="Void"/>
</f></drawRec>
		<new public="1" set="method" line="24"><f a="width:height:?parent">
	<x path="Int"/>
	<x path="Int"/>
	<c path="h2d.Object"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.impl.RenderContext" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/impl/RenderContext.hx">
		<engine public="1"><c path="h3d.Engine"/></engine>
		<time public="1"><x path="Float"/></time>
		<elapsedTime public="1"><x path="Float"/></elapsedTime>
		<frame public="1"><x path="Int"/></frame>
		<textures public="1"><c path="h3d.impl.TextureCache"/></textures>
		<dispose public="1" set="method" line="19"><f a=""><x path="Void"/></f></dispose>
		<new set="method" line="11"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="h2d.RenderContext" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h2d/RenderContext.hx">
		<extends path="h3d.impl.RenderContext"/>
		<BUFFERING get="inline" set="null" expr="false" line="5" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</BUFFERING>
		<globalAlpha public="1" expr="1.">
			<x path="Float"/>
			<meta><m n=":value"><e>1.</e></m></meta>
		</globalAlpha>
		<buffer public="1"><x path="hxd.FloatBuffer"/></buffer>
		<bufPos public="1"><x path="Int"/></bufPos>
		<scene public="1"><c path="h2d.Scene"/></scene>
		<defaultSmooth public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</defaultSmooth>
		<killAlpha public="1"><x path="Bool"/></killAlpha>
		<front2back public="1"><x path="Bool"/></front2back>
		<onBeginDraw public="1"><f a="">
	<c path="h2d.Drawable"/>
	<x path="Bool"/>
</f></onBeginDraw>
		<onEnterFilter public="1"><f a="">
	<c path="h2d.Object"/>
	<x path="Bool"/>
</f></onEnterFilter>
		<onLeaveFilter public="1"><f a="">
	<c path="h2d.Object"/>
	<x path="Void"/>
</f></onLeaveFilter>
		<tmpBounds public="1" expr="new h2d.col.Bounds()">
			<c path="h2d.col.Bounds"/>
			<meta><m n=":value"><e>new h2d.col.Bounds()</e></m></meta>
		</tmpBounds>
		<texture><c path="h3d.mat.Texture"/></texture>
		<baseShader><c path="h3d.shader.Base2d"/></baseShader>
		<manager><c path="h3d.pass.ShaderManager"/></manager>
		<compiledShader><c path="hxsl.RuntimeShader"/></compiledShader>
		<buffers><c path="h3d.shader.Buffers"/></buffers>
		<fixedBuffer><c path="h3d.Buffer"/></fixedBuffer>
		<pass><c path="h3d.mat.Pass"/></pass>
		<currentShaders><c path="hxsl.ShaderList"/></currentShaders>
		<baseShaderList><c path="hxsl.ShaderList"/></baseShaderList>
		<currentObj><c path="h2d.Drawable"/></currentObj>
		<stride><x path="Int"/></stride>
		<targetsStack><c path="Array"><a>
	<y><x path="Int"/></y>
	<x><x path="Int"/></x>
	<w><x path="Int"/></w>
	<t><c path="h3d.mat.Texture"/></t>
	<rzY><x path="Float"/></rzY>
	<rzX><x path="Float"/></rzX>
	<rzW><x path="Float"/></rzW>
	<rzH><x path="Float"/></rzH>
	<hasRZ><x path="Bool"/></hasRZ>
	<h><x path="Int"/></h>
</a></c></targetsStack>
		<targetsStackIndex><x path="Int"/></targetsStackIndex>
		<hasUVPos><x path="Bool"/></hasUVPos>
		<filterStack><c path="Array"><c path="h2d.Object"/></c></filterStack>
		<inFilter><c path="h2d.Object"/></inFilter>
		<inFilterBlend><e path="h2d.BlendMode"/></inFilterBlend>
		<curX><x path="Int"/></curX>
		<curY><x path="Int"/></curY>
		<curWidth><x path="Int"/></curWidth>
		<curHeight><x path="Int"/></curHeight>
		<hasRenderZone><x path="Bool"/></hasRenderZone>
		<renderX><x path="Float"/></renderX>
		<renderY><x path="Float"/></renderY>
		<renderW><x path="Float"/></renderW>
		<renderH><x path="Float"/></renderH>
		<currentBlend><e path="h2d.BlendMode"/></currentBlend>
		<baseFlipY><x path="Float"/></baseFlipY>
		<targetFlipY><x path="Float"/></targetFlipY>
		<dispose public="1" set="method" line="71" override="1"><f a=""><x path="Void"/></f></dispose>
		<hasBuffering public="1" get="inline" set="null" line="76"><f a=""><x path="Bool"/></f></hasBuffering>
		<begin public="1" set="method" line="80"><f a=""><x path="Void"/></f></begin>
		<allocTarget public="1" set="method" line="106">
			<f a="name:?filter" v=":false">
				<c path="String"/>
				<x path="Bool"/>
				<c path="h3d.mat.Texture"/>
			</f>
			<meta><m n=":value"><e>{ filter : false }</e></m></meta>
		</allocTarget>
		<clear public="1" set="method" line="112"><f a="color">
	<x path="Null"><x path="Int"/></x>
	<x path="Void"/>
</f></clear>
		<initShaders set="method" line="116"><f a="shaders">
	<c path="hxsl.ShaderList"/>
	<x path="Void"/>
</f></initShaders>
		<end public="1" set="method" line="128"><f a=""><x path="Void"/></f></end>
		<pushFilter public="1" set="method" line="136"><f a="spr">
	<c path="h2d.Object"/>
	<x path="Bool"/>
</f></pushFilter>
		<popFilter public="1" set="method" line="144"><f a=""><x path="Void"/></f></popFilter>
		<pushTarget public="1" set="method" line="154">
			<f a="t:?startX:?startY:?width:?height" v=":0:0:-1:-1">
				<c path="h3d.mat.Texture"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ height : -1, width : -1, startY : 0, startX : 0 }</e></m></meta>
		</pushTarget>
		<pushTargets public="1" set="method" line="186"><f a="texs">
	<c path="Array"><c path="h3d.mat.Texture"/></c>
	<x path="Void"/>
</f></pushTargets>
		<popTarget public="1" set="method" line="194">
			<f a="?restore" v="true">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ restore : true }</e></m></meta>
		</popTarget>
		<setRenderZone public="1" set="method" line="238"><f a="x:y:w:h">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setRenderZone>
		<clearRenderZone public="1" get="inline" set="null" line="262"><f a=""><x path="Void"/></f></clearRenderZone>
		<drawLayer set="method" line="267"><f a="layer">
	<x path="Int"/>
	<x path="Void"/>
</f></drawLayer>
		<drawScene public="1" set="method" line="271"><f a=""><x path="Void"/></f></drawScene>
		<flush public="1" get="inline" set="null" line="275"><f a=""><x path="Void"/></f></flush>
		<_flush set="method" line="279"><f a=""><x path="Void"/></f></_flush>
		<beforeDraw public="1" set="method" line="291"><f a=""><x path="Void"/></f></beforeDraw>
		<setupColor get="inline" set="null" line="322"><f a="obj">
	<c path="h2d.Drawable"/>
	<x path="Void"/>
</f></setupColor>
		<beginDrawObject public="1" set="method" line="333">
			<f a="obj:texture">
				<c path="h2d.Drawable"/>
				<c path="h3d.mat.Texture"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":access"><e>h2d.Drawable</e></m></meta>
		</beginDrawObject>
		<beginDrawBatch public="1" set="method" line="343">
			<f a="obj:texture">
				<c path="h2d.Drawable"/>
				<c path="h3d.mat.Texture"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":access"><e>h2d.Drawable</e></m></meta>
		</beginDrawBatch>
		<drawTile public="1" set="method" line="348">
			<f a="obj:tile">
				<c path="h2d.Drawable"/>
				<c path="h2d.Tile"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":access"><e>h2d.Drawable</e></m></meta>
		</drawTile>
		<beginDraw set="method" line="417">
			<f a="obj:texture:isRelative:?hasUVPos" v=":::false">
				<c path="h2d.Drawable"/>
				<c path="h3d.mat.Texture"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":value"><e>{ hasUVPos : false }</e></m>
				<m n=":access"><e>h2d.Drawable</e></m>
			</meta>
		</beginDraw>
		<new public="1" set="method" line="52"><f a="scene">
	<c path="h2d.Scene"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h2d.ScaleGrid" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h2d/ScaleGrid.hx">
		<extends path="h2d.TileGroup"/>
		<borderWidth public="1" set="accessor"><x path="Int"/></borderWidth>
		<borderHeight public="1" set="accessor"><x path="Int"/></borderHeight>
		<width public="1" set="accessor"><x path="Float"/></width>
		<height public="1" set="accessor"><x path="Float"/></height>
		<tileBorders public="1" set="accessor"><x path="Bool"/></tileBorders>
		<contentTile><c path="h2d.Tile"/></contentTile>
		<set_tileBorders set="method" line="24"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_tileBorders>
		<set_width set="method" line="31"><f a="w">
	<x path="Float"/>
	<x path="Float"/>
</f></set_width>
		<set_height set="method" line="38"><f a="h">
	<x path="Float"/>
	<x path="Float"/>
</f></set_height>
		<set_borderWidth set="method" line="45"><f a="w">
	<x path="Int"/>
	<x path="Int"/>
</f></set_borderWidth>
		<set_borderHeight set="method" line="52"><f a="h">
	<x path="Int"/>
	<x path="Int"/>
</f></set_borderHeight>
		<getBoundsRec set="method" line="59" override="1"><f a="relativeTo:out:forSize">
	<c path="h2d.Object"/>
	<c path="h2d.col.Bounds"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></getBoundsRec>
		<checkUpdate set="method" line="64"><f a=""><x path="Void"/></f></checkUpdate>
		<updateContent set="method" line="72"><f a=""><x path="Void"/></f></updateContent>
		<sync set="method" line="135" override="1"><f a="ctx">
	<c path="h2d.RenderContext"/>
	<x path="Void"/>
</f></sync>
		<new public="1" set="method" line="16"><f a="tile:borderW:borderH:?parent">
	<c path="h2d.Tile"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="h2d.Object"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="h2d.ScaleModeAlign" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h2d/Scene.hx" module="h2d.Scene">
		<Left><haxe_doc>Anchor Scene viewport horizontally to left side of the window. When passed to verticalAlign it will be treated as Center.</haxe_doc></Left>
		<Right><haxe_doc>Anchor Scene viewport horizontally to right side of the window. When passed to verticalAlign it will be treated as Center.</haxe_doc></Right>
		<Center><haxe_doc>Anchor to the center of window.</haxe_doc></Center>
		<Top><haxe_doc>Anchor Scene viewport vertically to the top of a window. When passed to horizontalAlign it will be treated as Center.</haxe_doc></Top>
		<Bottom><haxe_doc>Anchor Scene viewport vertically to the bottom of a window. When passed to horizontalAlign it will be treated as Center.</haxe_doc></Bottom>
		<haxe_doc>Viewport alignment when scaling mode supports it.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="h2d.ScaleMode" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h2d/Scene.hx" module="h2d.Scene">
		<Resize><haxe_doc>Matches scene size to window size. `width` and `height` of Scene will match window size. Default scaling mode.</haxe_doc></Resize>
		<Stretch a="width:height">
			<x path="Int"/>
			<x path="Int"/>
			<haxe_doc>Sets constant Scene size and stretches it to cover entire window. This behavior is same as old `setFixedSize` method.</haxe_doc>
		</Stretch>
		<LetterBox a="width:height:?integerScale:?horizontalAlign:?verticalAlign">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Bool"/>
			<e path="h2d.ScaleModeAlign"/>
			<e path="h2d.ScaleModeAlign"/>
			<haxe_doc>Sets constant scene size and upscales it with preserving aspect-ratio to fit the window.
		If `integerScale` is `true` - scaling will be performed  with only integer increments (1x, 2x, 3x, ...). Default: `false`
		`horizontalAlign` controls viewport anchoring horizontally. Accepted values are `Left`, `Center` and `Right`. Default: `Center`
		`verticalAlign` controls viewport anchoring vertically. Accepted values are `Top`, `Center` and `Bottom`. Default: `Center`
		With `800x600` window, `LetterBox(320, 260)` will result in center-aligned Scene of size `320x260` upscaled to fit into screen.</haxe_doc>
		</LetterBox>
		<Fixed a="width:height:zoom:?horizontalAlign:?verticalAlign">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Float"/>
			<e path="h2d.ScaleModeAlign"/>
			<e path="h2d.ScaleModeAlign"/>
			<haxe_doc>Sets constant Scene size, scale and alignment. Does not perform any adaptation to the screen apart from alignment.
		`horizontalAlign` controls viewport anchoring horizontally. Accepted values are `Left`, `Center` and `Right`. Default: `Center`
		`verticalAlign` controls viewport anchoring vertically. Accepted values are `Top`, `Center` and `Bottom`. Default: `Center`
		With `800x600` window, `Fixed(200, 150, 2, Left, Center)` will result in Scene size of `200x150`, and visually upscaled to `400x300`, and aligned to middle-left of the window.</haxe_doc>
		</Fixed>
		<Zoom a="level">
			<x path="Float"/>
			<haxe_doc>Upscales/downscales Scene according to `level` and matches Scene size to `ceil(window size / level)`.
		With `800x600` window, `Zoom(2)` will result in `400x300` Scene size upscaled to fill entire window.</haxe_doc>
		</Zoom>
		<AutoZoom a="minWidth:minHeight:?integerScaling">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Bool"/>
			<haxe_doc>Ensures that Scene size will be of minimum specified size.
		Automatically calculates zoom level based on provided size according to `min(window width / min width, window height / min height)`, then applies same scaling as `Zoom(level)`.
		Behavior is similiar to LetterBox, however instead of letterboxing effect, Scene size will change to cover the letterboxed parts.
		`minWidth` or `minHeight` can be set to `0` in order to force scaling adjustment account only for either horizontal of vertical window size.
		If `integerScale` is `true` - scaling will be performed  with only integer increments (1x, 2x, 3x, ...). Default: `false`
		With `800x600` window, `AutoZoom(320, 260, false)` will result in Scene size of `347x260`. `AutoZoom(320, 260, true)` will result in size of `400x300`.</haxe_doc>
		</AutoZoom>
		<haxe_doc>Scaling mode of the 2D Scene.
	See `ScaleMode2D` sample for showcase.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<class path="hxd.InteractiveScene" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/SceneEvents.hx" module="hxd.SceneEvents" interface="1">
		<setEvents public="1" set="method"><f a="s">
	<c path="hxd.SceneEvents"/>
	<x path="Void"/>
</f></setEvents>
		<handleEvent public="1" set="method"><f a="e:last">
	<c path="hxd.Event"/>
	<c path="hxd.Interactive"/>
	<c path="hxd.Interactive"/>
</f></handleEvent>
		<dispatchEvent public="1" set="method"><f a="e:to">
	<c path="hxd.Event"/>
	<c path="hxd.Interactive"/>
	<x path="Void"/>
</f></dispatchEvent>
		<dispatchListeners public="1" set="method"><f a="e">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></dispatchListeners>
		<isInteractiveVisible public="1" set="method"><f a="i">
	<c path="hxd.Interactive"/>
	<x path="Bool"/>
</f></isInteractiveVisible>
	</class>
	<class path="h3d.IDrawable" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/IDrawable.hx" interface="1"><render public="1" set="method"><f a="engine">
	<c path="h3d.Engine"/>
	<x path="Void"/>
</f></render></class>
	<class path="h2d.Scene" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h2d/Scene.hx">
		<extends path="h2d.Layers"/>
		<implements path="hxd.InteractiveScene"/>
		<implements path="h3d.IDrawable"/>
		<width public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The current width (in pixels) of the scene. Can change if the screen gets resized or `scaleMode` changes.</haxe_doc>
		</width>
		<height public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The current height (in pixels) of the scene. Can change if the screen gets resized or `scaleMode` changes.</haxe_doc>
		</height>
		<viewportX public="1" set="null">
			<x path="Float"/>
			<haxe_doc>Horizontal viewport offset relative to top-left corner of the window. Can change if the screen gets resized or `scaleMode` changes.
		Offset is in internal Scene resolution pixels.</haxe_doc>
		</viewportX>
		<viewportY public="1" set="null">
			<x path="Float"/>
			<haxe_doc>Vertical viewport offset relative to top-left corner of the window. Can change if the screen gets resized or `scaleMode` changes.
		Offset is in internal Scene resolution pixels.</haxe_doc>
		</viewportY>
		<offsetX public="1">
			<x path="Float"/>
			<haxe_doc>Physical vertical viewport offset relative to the center of the window. Assigned if the screen gets resized or `scaleMode` changes.
		Offset is in internal Scene resolution pixels.</haxe_doc>
		</offsetX>
		<offsetY public="1">
			<x path="Float"/>
			<haxe_doc>Physical horizontal viewport offset relative to the center of the window. Assigned if the screen gets resized or `scaleMode` changes.
		Offset is in internal Scene resolution pixels.</haxe_doc>
		</offsetY>
		<ratioX public="1" set="null">
			<x path="Float"/>
			<haxe_doc>Horizontal ratio of the window used by the Scene (including scaling). Can change if the screen gets resized or `scaleMode` changes.</haxe_doc>
		</ratioX>
		<ratioY public="1" set="null">
			<x path="Float"/>
			<haxe_doc>Vertical ratio of the window used by the Scene (including scaling). Can change if the screen gets resized or `scaleMode` changes.</haxe_doc>
		</ratioY>
		<mouseX public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>The current mouse X coordinates (in pixel) relative to the scene.</haxe_doc>
		</mouseX>
		<mouseY public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>The current mouse Y coordinates (in pixel) relative to the scene.</haxe_doc>
		</mouseY>
		<zoom public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<meta><m n=":deprecated"><e>"zoom is deprecated, use scaleMode = Zoom(v) instead"</e></m></meta>
			<haxe_doc><![CDATA[The zoom factor of the scene, allows to set a fixed x2, x4 etc. zoom for pixel art
		When setting a zoom > 0, the scene resize will be automaticaly managed.]]></haxe_doc>
		</zoom>
		<scaleMode public="1" set="accessor" expr="Resize">
			<e path="h2d.ScaleMode"/>
			<meta><m n=":value"><e>Resize</e></m></meta>
			<haxe_doc>Scene scaling mode. ( default : Resize )
		Important thing to keep in mind - Scene does not clip rendering to it's scaled size and
		graphics can render outside of it. However `drawTile` does check for those bounds and
		will clip out tiles that are outside of the scene bounds.</haxe_doc>
		</scaleMode>
		<defaultSmooth public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>Set the default value for `h2d.Drawable.smooth` (default: false)</haxe_doc>
		</defaultSmooth>
		<renderer public="1" get="accessor" set="accessor">
			<c path="h2d.RenderContext"/>
			<haxe_doc>The scene current renderer. Can be customized.</haxe_doc>
		</renderer>
		<interactive><c path="Array"><c path="h2d.Interactive"/></c></interactive>
		<eventListeners><c path="Array"><f a="">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></c></eventListeners>
		<ctx><c path="h2d.RenderContext"/></ctx>
		<window><c path="hxd.Window"/></window>
		<events>
			<c path="hxd.SceneEvents"/>
			<meta><m n=":allow"><e>h2d.Interactive</e></m></meta>
		</events>
		<shapePoint><c path="h2d.col.Point"/></shapePoint>
		<get_defaultSmooth get="inline" set="null" line="180"><f a=""><x path="Bool"/></f></get_defaultSmooth>
		<set_defaultSmooth get="inline" set="null" line="181"><f a="v">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_defaultSmooth>
		<setEvents public="1" set="method" line="184">
			<f a="events">
				<c path="hxd.SceneEvents"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":dox"><e>hide</e></m>
				<m n=":noCompletion"/>
			</meta>
		</setEvents>
		<get_zoom set="method" line="188">
			<f a=""><x path="Int"/></f>
			<meta><m n=":deprecated"><e>"zoom is deprecated, use scaleMode = Zoom(v) instead"</e></m></meta>
		</get_zoom>
		<set_zoom set="method" line="195">
			<f a="v">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":deprecated"><e>"zoom is deprecated, use scaleMode = Zoom(v) instead"</e></m></meta>
		</set_zoom>
		<set_scaleMode set="method" line="200"><f a="v">
	<e path="h2d.ScaleMode"/>
	<e path="h2d.ScaleMode"/>
</f></set_scaleMode>
		<get_renderer set="method" line="206"><f a=""><c path="h2d.RenderContext"/></f></get_renderer>
		<set_renderer set="method" line="207"><f a="v">
	<c path="h2d.RenderContext"/>
	<c path="h2d.RenderContext"/>
</f></set_renderer>
		<setFixedSize public="1" set="method" line="213">
			<f a="w:h">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":deprecated"><e>"setFixedSize is deprecated, use scaleMode = Stretch(w, h) instead"</e></m></meta>
			<haxe_doc>Set the fixed size for the scene, will prevent automatic scene resizing when screen size changes.</haxe_doc>
		</setFixedSize>
		<checkResize public="1" set="method" line="218">
			<f a=""><x path="Void"/></f>
			<meta>
				<m n=":dox"><e>hide</e></m>
				<m n=":noCompletion"/>
			</meta>
		</checkResize>
		<screenXToViewport get="inline" set="null" line="309"><f a="mx">
	<x path="Float"/>
	<x path="Float"/>
</f></screenXToViewport>
		<screenYToViewport get="inline" set="null" line="313"><f a="my">
	<x path="Float"/>
	<x path="Float"/>
</f></screenYToViewport>
		<get_mouseX set="method" line="317"><f a=""><x path="Float"/></f></get_mouseX>
		<get_mouseY set="method" line="325"><f a=""><x path="Float"/></f></get_mouseY>
		<dispatchListeners public="1" set="method" line="334">
			<f a="event">
				<c path="hxd.Event"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":dox"><e>hide</e></m>
				<m n=":noCompletion"/>
			</meta>
		</dispatchListeners>
		<isInteractiveVisible public="1" set="method" line="343">
			<f a="i">
				<c path="hxd.Interactive"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":dox"><e>hide</e></m>
				<m n=":noCompletion"/>
			</meta>
		</isInteractiveVisible>
		<getInteractive public="1" set="method" line="355">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<c path="h2d.Interactive"/>
			</f>
			<haxe_doc>Return the topmost visible Interactive at the specific coordinates</haxe_doc>
		</getInteractive>
		<screenToViewport set="method" line="390"><f a="e">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></screenToViewport>
		<dispatchEvent public="1" set="method" line="396">
			<f a="event:to">
				<c path="hxd.Event"/>
				<c path="hxd.Interactive"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":dox"><e>hide</e></m>
				<m n=":noCompletion"/>
			</meta>
		</dispatchEvent>
		<handleEvent public="1" set="method" line="409">
			<f a="event:last">
				<c path="hxd.Event"/>
				<c path="hxd.Interactive"/>
				<c path="hxd.Interactive"/>
			</f>
			<meta>
				<m n=":dox"><e>hide</e></m>
				<m n=":noCompletion"/>
			</meta>
		</handleEvent>
		<addEventListener public="1" set="method" line="471">
			<f a="f">
				<f a="">
					<c path="hxd.Event"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>Add an event listener that will capture all events not caught by an h2d.Interactive</haxe_doc>
		</addEventListener>
		<removeEventListener public="1" set="method" line="478">
			<f a="f">
				<f a="">
					<c path="hxd.Event"/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
			</f>
			<haxe_doc>Remove a previously added event listener, return false it was not part of our event listeners.</haxe_doc>
		</removeEventListener>
		<startDrag public="1" set="method" line="492">
			<f a="onEvent:?onCancel:?refEvent">
				<f a="">
					<c path="hxd.Event"/>
					<x path="Void"/>
				</f>
				<f a=""><x path="Void"/></f>
				<c path="hxd.Event"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Start a drag and drop operation, sending all events to `onEvent` instead of the scene until `stopDrag()` is called.
		@param	onCancel	If defined, will be called when stopDrag is called
		@param	refEvent	For touch events, only capture events that matches the reference event touchId</haxe_doc>
		</startDrag>
		<stopDrag public="1" set="method" line="502">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Stop the current drag and drop operation</haxe_doc>
		</stopDrag>
		<getFocus public="1" set="method" line="509">
			<f a=""><c path="h2d.Interactive"/></f>
			<haxe_doc>Get the currently focused Interactive</haxe_doc>
		</getFocus>
		<addEventTarget set="method" line="522">
			<f a="i">
				<c path="h2d.Interactive"/>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>h2d</e></m></meta>
		</addEventTarget>
		<removeEventTarget set="method" line="574">
			<f a="i:?notify" v=":false">
				<c path="h2d.Interactive"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ notify : false }</e></m>
				<m n=":allow"><e>h2d</e></m>
			</meta>
		</removeEventTarget>
		<dispose public="1" set="method" line="583">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Dispose the scene and all its children, freeing used GPU memory</haxe_doc>
		</dispose>
		<setElapsedTime public="1" set="method" line="593">
			<f a="v">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Before render() or sync() are called, allow to set how much time has elapsed (in seconds) since the last frame in order to update scene animations.
		This is managed automatically by hxd.App</haxe_doc>
		</setElapsedTime>
		<drawImplTo set="method" line="597"><f a="s:texs:?outputs">
	<c path="h2d.Object"/>
	<c path="Array"><c path="h3d.mat.Texture"/></c>
	<c path="Array"><e path="hxsl.Output"/></c>
	<x path="Void"/>
</f></drawImplTo>
		<syncOnly public="1" set="method" line="620">
			<f a="et">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Synchronize the scene without rendering, updating all objects and animations by the given amount of time, in seconds.</haxe_doc>
		</syncOnly>
		<render public="1" set="method" line="633">
			<f a="engine">
				<c path="h3d.Engine"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Render the scene on screen. Internal usage only.</haxe_doc>
		</render>
		<sync set="method" line="645" override="1"><f a="ctx">
	<c path="h2d.RenderContext"/>
	<x path="Void"/>
</f></sync>
		<onAdd set="method" line="651" override="1"><f a=""><x path="Void"/></f></onAdd>
		<onRemove set="method" line="658" override="1"><f a=""><x path="Void"/></f></onRemove>
		<captureBitmap public="1" set="method" line="667">
			<f a="?target">
				<c path="h2d.Tile"/>
				<c path="h2d.Bitmap"/>
			</f>
			<haxe_doc>Capture the scene into a texture and render the resulting Bitmap</haxe_doc>
		</captureBitmap>
		<new public="1" set="method" line="161">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Create a new scene. A default 2D scene is already available in `hxd.App.s2d`</haxe_doc>
		</new>
		<haxe_doc>h2d.Scene is the root class for a 2D scene. All root objects are added to it before being drawn on screen.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h2d._SpriteBatch.ElementsIterator" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h2d/SpriteBatch.hx" private="1" module="h2d.SpriteBatch">
		<e><c path="h2d.BatchElement"/></e>
		<hasNext public="1" get="inline" set="null" line="8"><f a=""><x path="Bool"/></f></hasNext>
		<next public="1" get="inline" set="null" line="11"><f a=""><c path="h2d.BatchElement"/></f></next>
		<new public="1" get="inline" set="null" line="5"><f a="e">
	<c path="h2d.BatchElement"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h2d.BatchElement" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h2d/SpriteBatch.hx" module="h2d.SpriteBatch">
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<scale public="1" get="null" set="accessor"><x path="Float"/></scale>
		<scaleX public="1"><x path="Float"/></scaleX>
		<scaleY public="1"><x path="Float"/></scaleY>
		<rotation public="1"><x path="Float"/></rotation>
		<r public="1"><x path="Float"/></r>
		<g public="1"><x path="Float"/></g>
		<b public="1"><x path="Float"/></b>
		<a public="1"><x path="Float"/></a>
		<t public="1"><c path="h2d.Tile"/></t>
		<alpha public="1" get="accessor" set="accessor"><x path="Float"/></alpha>
		<visible public="1"><x path="Bool"/></visible>
		<batch public="1" set="null"><c path="h2d.SpriteBatch"/></batch>
		<prev><c path="h2d.BatchElement"/></prev>
		<next><c path="h2d.BatchElement"/></next>
		<set_scale get="inline" set="null" line="45"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_scale>
		<get_alpha get="inline" set="null" line="49"><f a=""><x path="Float"/></f></get_alpha>
		<set_alpha get="inline" set="null" line="53"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_alpha>
		<update set="method" line="57"><f a="et">
	<x path="Float"/>
	<x path="Bool"/>
</f></update>
		<remove public="1" set="method" line="61"><f a=""><x path="Void"/></f></remove>
		<new public="1" set="method" line="38"><f a="t">
	<c path="h2d.Tile"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>h2d.SpriteBatch</e></m>
		</meta>
	</class>
	<class path="h2d.BasicElement" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h2d/SpriteBatch.hx" module="h2d.SpriteBatch">
		<extends path="h2d.BatchElement"/>
		<vx public="1" expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</vx>
		<vy public="1" expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</vy>
		<friction public="1" expr="1.">
			<x path="Float"/>
			<meta><m n=":value"><e>1.</e></m></meta>
		</friction>
		<gravity public="1" expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</gravity>
		<update set="method" line="75" override="1"><f a="dt">
	<x path="Float"/>
	<x path="Bool"/>
</f></update>
		<new public="1" set="method" line="68"><f a="t">
	<c path="h2d.Tile"/>
	<x path="Void"/>
</f></new>
	</class>
	<enum path="h2d.Align" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h2d/Text.hx" module="h2d.Text">
		<Left/>
		<Right/>
		<Center/>
		<MultilineRight/>
		<MultilineCenter/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="h2d.Tile" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h2d/Tile.hx">
		<fromColor public="1" set="method" line="197" static="1">
			<f a="color:?width:?height:?alpha" v=":1:1:1.">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<c path="h2d.Tile"/>
			</f>
			<meta><m n=":value"><e>{ alpha : 1., height : 1, width : 1 }</e></m></meta>
		</fromColor>
		<fromBitmap public="1" set="method" line="205" static="1"><f a="bmp">
	<c path="hxd.BitmapData"/>
	<c path="h2d.Tile"/>
</f></fromBitmap>
		<autoCut public="1" set="method" line="210" static="1"><f a="bmp:width:?height">
	<c path="hxd.BitmapData"/>
	<x path="Int"/>
	<x path="Int"/>
	<a>
		<tiles><c path="Array"><c path="Array"><c path="h2d.Tile"/></c></c></tiles>
		<main><c path="h2d.Tile"/></main>
	</a>
</f></autoCut>
		<fromTexture public="1" set="method" line="241" static="1"><f a="t">
	<c path="h3d.mat.Texture"/>
	<c path="h2d.Tile"/>
</f></fromTexture>
		<fromPixels public="1" set="method" line="245" static="1"><f a="pixels">
	<c path="hxd.Pixels"/>
	<c path="h2d.Tile"/>
</f></fromPixels>
		<isEmpty set="method" line="252" static="1"><f a="b:px:py:width:height:bg">
	<c path="hxd.BitmapData"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Null"><a>
	<w><x path="Int"/></w>
	<h><x path="Int"/></h>
	<dy><x path="Int"/></dy>
	<dx><x path="Int"/></dx>
</a></x>
</f></isEmpty>
		<innerTex><c path="h3d.mat.Texture"/></innerTex>
		<u><x path="Float"/></u>
		<v><x path="Float"/></v>
		<u2><x path="Float"/></u2>
		<v2><x path="Float"/></v2>
		<dx public="1"><x path="Float"/></dx>
		<dy public="1"><x path="Float"/></dy>
		<x public="1" set="null"><x path="Float"/></x>
		<y public="1" set="null"><x path="Float"/></y>
		<width public="1" set="null"><x path="Float"/></width>
		<height public="1" set="null"><x path="Float"/></height>
		<ix public="1" get="accessor" set="null"><x path="Int"/></ix>
		<get_ix get="inline" set="null" line="21"><f a=""><x path="Int"/></f></get_ix>
		<iy public="1" get="accessor" set="null"><x path="Int"/></iy>
		<get_iy get="inline" set="null" line="24"><f a=""><x path="Int"/></f></get_iy>
		<iwidth public="1" get="accessor" set="null"><x path="Int"/></iwidth>
		<get_iwidth get="inline" set="null" line="27"><f a=""><x path="Int"/></f></get_iwidth>
		<iheight public="1" get="accessor" set="null"><x path="Int"/></iheight>
		<get_iheight get="inline" set="null" line="30"><f a=""><x path="Int"/></f></get_iheight>
		<getTexture public="1" get="inline" set="null" line="43"><f a=""><c path="h3d.mat.Texture"/></f></getTexture>
		<isDisposed public="1" set="method" line="47"><f a=""><x path="Bool"/></f></isDisposed>
		<setTexture set="method" line="51"><f a="tex">
	<c path="h3d.mat.Texture"/>
	<x path="Void"/>
</f></setTexture>
		<switchTexture public="1" get="inline" set="null" line="61"><f a="t">
	<c path="h2d.Tile"/>
	<x path="Void"/>
</f></switchTexture>
		<sub public="1" set="method" line="65">
			<f a="x:y:w:h:?dx:?dy" v="::::0.:0.">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="h2d.Tile"/>
			</f>
			<meta><m n=":value"><e>{ dy : 0., dx : 0. }</e></m></meta>
		</sub>
		<center public="1" set="method" line="69"><f a=""><c path="h2d.Tile"/></f></center>
		<setCenterRatio public="1" get="inline" set="null" line="73">
			<f a="?px:?py" v="0.5:0.5">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ py : 0.5, px : 0.5 }</e></m></meta>
		</setCenterRatio>
		<flipX public="1" set="method" line="78"><f a=""><x path="Void"/></f></flipX>
		<flipY public="1" set="method" line="83"><f a=""><x path="Void"/></f></flipY>
		<setPosition public="1" set="method" line="88"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setPosition>
		<setSize public="1" set="method" line="100"><f a="w:h">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setSize>
		<scaleToSize public="1" set="method" line="110"><f a="w:h">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></scaleToSize>
		<scrollDiscrete public="1" set="method" line="115"><f a="dx:dy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></scrollDiscrete>
		<dispose public="1" set="method" line="125"><f a=""><x path="Void"/></f></dispose>
		<clone public="1" set="method" line="130"><f a=""><c path="h2d.Tile"/></f></clone>
		<split public="1" set="method" line="143">
			<f a="?frames:?vertical:?subpixel" v="0:false:false">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="Array"><c path="h2d.Tile"/></c>
			</f>
			<meta><m n=":value"><e>{ subpixel : false, vertical : false, frames : 0 }</e></m></meta>
			<haxe_doc>Split horizontaly or verticaly the number of given frames</haxe_doc>
		</split>
		<gridFlatten public="1" set="method" line="165">
			<f a="size:?dx:?dy" v=":0.:0.">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="Array"><c path="h2d.Tile"/></c>
			</f>
			<meta><m n=":value"><e>{ dy : 0., dx : 0. }</e></m></meta>
			<haxe_doc>Split the tile into a list of tiles of Size x Size pixels.
		Unlike grid which is X/Y ordered, gridFlatten returns a single dimensional array ordered in Y/X.</haxe_doc>
		</gridFlatten>
		<grid public="1" set="method" line="172">
			<f a="size:?dx:?dy" v=":0.:0.">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="Array"><c path="Array"><c path="h2d.Tile"/></c></c>
			</f>
			<meta><m n=":value"><e>{ dy : 0., dx : 0. }</e></m></meta>
			<haxe_doc>Split the tile into a list of tiles of Size x Size pixels.</haxe_doc>
		</grid>
		<toString public="1" set="method" line="176"><f a=""><c path="String"/></f></toString>
		<upload set="method" line="180"><f a="bmp">
	<c path="hxd.BitmapData"/>
	<x path="Void"/>
</f></upload>
		<new set="method" line="32">
			<f a="tex:x:y:w:h:?dx:?dy" v=":::::0:0">
				<c path="h3d.mat.Texture"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ dy : 0, dx : 0 }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>h2d</e></m>
		</meta>
	</class>
	<class path="h2d.TileLayerContent" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h2d/TileGroup.hx" module="h2d.TileGroup">
		<extends path="h3d.prim.Primitive"/>
		<tmp><x path="hxd.FloatBuffer"/></tmp>
		<xMin public="1"><x path="Float"/></xMin>
		<yMin public="1"><x path="Float"/></yMin>
		<xMax public="1"><x path="Float"/></xMax>
		<yMax public="1"><x path="Float"/></yMax>
		<clear public="1" set="method" line="15"><f a=""><x path="Void"/></f></clear>
		<isEmpty public="1" set="method" line="25"><f a=""><x path="Bool"/></f></isEmpty>
		<triCount public="1" set="method" line="29" override="1"><f a=""><x path="Int"/></f></triCount>
		<addColor public="1" get="inline" set="null" line="33"><f a="x:y:color:t">
	<x path="Float"/>
	<x path="Float"/>
	<c path="h3d.Vector"/>
	<c path="h2d.Tile"/>
	<x path="Void"/>
</f></addColor>
		<add public="1" set="method" line="37"><f a="x:y:r:g:b:a:t">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="h2d.Tile"/>
	<x path="Void"/>
</f></add>
		<addTransform public="1" set="method" line="82"><f a="x:y:sx:sy:r:c:t">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="h3d.Vector"/>
	<c path="h2d.Tile"/>
	<x path="Void"/>
</f></addTransform>
		<addPoint public="1" set="method" line="151"><f a="x:y:color">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></addPoint>
		<insertColor get="inline" set="null" line="163"><f a="c">
	<x path="Int"/>
	<x path="Void"/>
</f></insertColor>
		<rectColor public="1" get="inline" set="null" line="170"><f a="x:y:w:h:color">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></rectColor>
		<rectGradient public="1" get="inline" set="null" line="200"><f a="x:y:w:h:ctl:ctr:cbl:cbr">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></rectGradient>
		<fillArc public="1" get="inline" set="null" line="230"><f a="x:y:ray:c:start:end">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></fillArc>
		<fillCircle public="1" get="inline" set="null" line="264"><f a="x:y:radius:c">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></fillCircle>
		<circle public="1" get="inline" set="null" line="296"><f a="x:y:ray:size:c">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></circle>
		<arc public="1" get="inline" set="null" line="325"><f a="x:y:ray:size:start:end:c">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></arc>
		<alloc public="1" set="method" line="369" override="1"><f a="engine">
	<c path="h3d.Engine"/>
	<x path="Void"/>
</f></alloc>
		<flush public="1" get="inline" set="null" line="375"><f a=""><x path="Void"/></f></flush>
		<doRender public="1" set="method" line="379"><f a="engine:min:len">
	<c path="h3d.Engine"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></doRender>
		<new public="1" set="method" line="11"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h2d.col.Bounds" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h2d/col/Bounds.hx">
		<fromValues public="1" get="inline" set="null" line="234" static="1"><f a="x0:y0:width:height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="h2d.col.Bounds"/>
</f></fromValues>
		<fromPoints public="1" get="inline" set="null" line="243" static="1"><f a="min:max">
	<c path="h2d.col.Point"/>
	<c path="h2d.col.Point"/>
	<c path="h2d.col.Bounds"/>
</f></fromPoints>
		<xMin public="1"><x path="Float"/></xMin>
		<yMin public="1"><x path="Float"/></yMin>
		<xMax public="1"><x path="Float"/></xMax>
		<yMax public="1"><x path="Float"/></yMax>
		<x public="1" get="accessor" set="accessor"><x path="Float"/></x>
		<y public="1" get="accessor" set="accessor"><x path="Float"/></y>
		<width public="1" get="accessor" set="accessor"><x path="Float"/></width>
		<height public="1" get="accessor" set="accessor"><x path="Float"/></height>
		<toIBounds public="1" get="inline" set="null" line="22">
			<f a="?scale" v="1.">
				<x path="Float"/>
				<c path="h2d.col.IBounds"/>
			</f>
			<meta><m n=":value"><e>{ scale : 1. }</e></m></meta>
		</toIBounds>
		<intersects public="1" get="inline" set="null" line="28"><f a="b">
	<c path="h2d.col.Bounds"/>
	<x path="Bool"/>
</f></intersects>
		<contains public="1" get="inline" set="null" line="32"><f a="p">
	<c path="h2d.col.Point"/>
	<x path="Bool"/>
</f></contains>
		<addBounds public="1" get="inline" set="null" line="36"><f a="b">
	<c path="h2d.col.Bounds"/>
	<x path="Void"/>
</f></addBounds>
		<addPoint public="1" get="inline" set="null" line="43"><f a="p">
	<c path="h2d.col.Point"/>
	<x path="Void"/>
</f></addPoint>
		<addPos public="1" get="inline" set="null" line="50"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></addPos>
		<set public="1" get="inline" set="null" line="57"><f a="x:y:width:height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></set>
		<setMin public="1" get="inline" set="null" line="64"><f a="p">
	<c path="h2d.col.Point"/>
	<x path="Void"/>
</f></setMin>
		<setMax public="1" get="inline" set="null" line="69"><f a="p">
	<c path="h2d.col.Point"/>
	<x path="Void"/>
</f></setMax>
		<doIntersect public="1" get="inline" set="null" line="74"><f a="b">
	<c path="h2d.col.Bounds"/>
	<x path="Void"/>
</f></doIntersect>
		<doUnion public="1" get="inline" set="null" line="81"><f a="b">
	<c path="h2d.col.Bounds"/>
	<x path="Void"/>
</f></doUnion>
		<intersection public="1" set="method" line="88"><f a="b">
	<c path="h2d.col.Bounds"/>
	<c path="h2d.col.Bounds"/>
</f></intersection>
		<union public="1" set="method" line="99"><f a="b">
	<c path="h2d.col.Bounds"/>
	<c path="h2d.col.Bounds"/>
</f></union>
		<load public="1" set="method" line="108"><f a="b">
	<c path="h2d.col.Bounds"/>
	<x path="Void"/>
</f></load>
		<scalePivot public="1" get="inline" set="null" line="115"><f a="v">
	<x path="Float"/>
	<x path="Void"/>
</f></scalePivot>
		<scaleCenter public="1" set="method" line="122"><f a="v">
	<x path="Float"/>
	<x path="Void"/>
</f></scaleCenter>
		<rotate public="1" set="method" line="133"><f a="angle">
	<x path="Float"/>
	<x path="Void"/>
</f></rotate>
		<offset public="1" get="inline" set="null" line="144"><f a="dx:dy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></offset>
		<getMin public="1" get="inline" set="null" line="151"><f a=""><c path="h2d.col.Point"/></f></getMin>
		<getCenter public="1" get="inline" set="null" line="155"><f a=""><c path="h2d.col.Point"/></f></getCenter>
		<getSize public="1" get="inline" set="null" line="159"><f a=""><c path="h2d.col.Point"/></f></getSize>
		<getMax public="1" get="inline" set="null" line="163"><f a=""><c path="h2d.col.Point"/></f></getMax>
		<isEmpty public="1" get="inline" set="null" line="167"><f a=""><x path="Bool"/></f></isEmpty>
		<empty public="1" get="inline" set="null" line="171"><f a=""><x path="Void"/></f></empty>
		<all public="1" get="inline" set="null" line="178"><f a=""><x path="Void"/></f></all>
		<clone public="1" get="inline" set="null" line="185"><f a=""><c path="h2d.col.Bounds"/></f></clone>
		<get_x get="inline" set="null" line="194"><f a=""><x path="Float"/></f></get_x>
		<get_y get="inline" set="null" line="198"><f a=""><x path="Float"/></f></get_y>
		<set_x get="inline" set="null" line="202"><f a="x">
	<x path="Float"/>
	<x path="Float"/>
</f></set_x>
		<set_y get="inline" set="null" line="207"><f a="y">
	<x path="Float"/>
	<x path="Float"/>
</f></set_y>
		<get_width get="inline" set="null" line="212"><f a=""><x path="Float"/></f></get_width>
		<get_height get="inline" set="null" line="216"><f a=""><x path="Float"/></f></get_height>
		<set_width get="inline" set="null" line="220"><f a="w">
	<x path="Float"/>
	<x path="Float"/>
</f></set_width>
		<set_height get="inline" set="null" line="225"><f a="h">
	<x path="Float"/>
	<x path="Float"/>
</f></set_height>
		<toString public="1" set="method" line="230"><f a=""><c path="String"/></f></toString>
		<new public="1" get="inline" set="null" line="18"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h2d.col.Collider" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h2d/col/Collider.hx" interface="1"><contains public="1" set="method"><f a="p">
	<c path="h2d.col.Point"/>
	<x path="Bool"/>
</f></contains></class>
	<class path="h2d.col.IBounds" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h2d/col/IBounds.hx">
		<fromValues public="1" get="inline" set="null" line="203" static="1"><f a="x0:y0:width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="h2d.col.IBounds"/>
</f></fromValues>
		<fromPoints public="1" get="inline" set="null" line="212" static="1"><f a="min:max">
	<c path="h2d.col.IPoint"/>
	<c path="h2d.col.IPoint"/>
	<c path="h2d.col.IBounds"/>
</f></fromPoints>
		<xMin public="1"><x path="Int"/></xMin>
		<yMin public="1"><x path="Int"/></yMin>
		<xMax public="1"><x path="Int"/></xMax>
		<yMax public="1"><x path="Int"/></yMax>
		<x public="1" get="accessor" set="accessor"><x path="Int"/></x>
		<y public="1" get="accessor" set="accessor"><x path="Int"/></y>
		<width public="1" get="accessor" set="accessor"><x path="Int"/></width>
		<height public="1" get="accessor" set="accessor"><x path="Int"/></height>
		<toBounds public="1" get="inline" set="null" line="22">
			<f a="?scale" v="1.">
				<x path="Float"/>
				<c path="h2d.col.Bounds"/>
			</f>
			<meta><m n=":value"><e>{ scale : 1. }</e></m></meta>
		</toBounds>
		<intersects public="1" get="inline" set="null" line="26"><f a="b">
	<c path="h2d.col.IBounds"/>
	<x path="Bool"/>
</f></intersects>
		<contains public="1" get="inline" set="null" line="30"><f a="p">
	<c path="h2d.col.IPoint"/>
	<x path="Bool"/>
</f></contains>
		<addBounds public="1" get="inline" set="null" line="34"><f a="b">
	<c path="h2d.col.IBounds"/>
	<x path="Void"/>
</f></addBounds>
		<addPoint public="1" get="inline" set="null" line="41"><f a="p">
	<c path="h2d.col.IPoint"/>
	<x path="Void"/>
</f></addPoint>
		<addPos public="1" get="inline" set="null" line="48"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></addPos>
		<set public="1" get="inline" set="null" line="55"><f a="x:y:width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></set>
		<setMin public="1" get="inline" set="null" line="62"><f a="p">
	<c path="h2d.col.IPoint"/>
	<x path="Void"/>
</f></setMin>
		<setMax public="1" get="inline" set="null" line="67"><f a="p">
	<c path="h2d.col.IPoint"/>
	<x path="Void"/>
</f></setMax>
		<doIntersect public="1" get="inline" set="null" line="72"><f a="b">
	<c path="h2d.col.IBounds"/>
	<x path="Void"/>
</f></doIntersect>
		<doUnion public="1" get="inline" set="null" line="79"><f a="b">
	<c path="h2d.col.IBounds"/>
	<x path="Void"/>
</f></doUnion>
		<intersection public="1" set="method" line="86"><f a="b">
	<c path="h2d.col.IBounds"/>
	<c path="h2d.col.Bounds"/>
</f></intersection>
		<union public="1" set="method" line="97"><f a="b">
	<c path="h2d.col.IBounds"/>
	<c path="h2d.col.Bounds"/>
</f></union>
		<load public="1" set="method" line="106"><f a="b">
	<c path="h2d.col.IBounds"/>
	<x path="Void"/>
</f></load>
		<offset public="1" get="inline" set="null" line="113"><f a="dx:dy">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></offset>
		<getMin public="1" get="inline" set="null" line="120"><f a=""><c path="h2d.col.IPoint"/></f></getMin>
		<getCenter public="1" get="inline" set="null" line="124"><f a=""><c path="h2d.col.IPoint"/></f></getCenter>
		<getSize public="1" get="inline" set="null" line="128"><f a=""><c path="h2d.col.IPoint"/></f></getSize>
		<getMax public="1" get="inline" set="null" line="132"><f a=""><c path="h2d.col.IPoint"/></f></getMax>
		<isEmpty public="1" get="inline" set="null" line="136"><f a=""><x path="Bool"/></f></isEmpty>
		<empty public="1" get="inline" set="null" line="140"><f a=""><x path="Void"/></f></empty>
		<all public="1" get="inline" set="null" line="147"><f a=""><x path="Void"/></f></all>
		<clone public="1" get="inline" set="null" line="154"><f a=""><c path="h2d.col.IBounds"/></f></clone>
		<get_x get="inline" set="null" line="163"><f a=""><x path="Int"/></f></get_x>
		<get_y get="inline" set="null" line="167"><f a=""><x path="Int"/></f></get_y>
		<set_x get="inline" set="null" line="171"><f a="x">
	<x path="Int"/>
	<x path="Int"/>
</f></set_x>
		<set_y get="inline" set="null" line="176"><f a="y">
	<x path="Int"/>
	<x path="Int"/>
</f></set_y>
		<get_width get="inline" set="null" line="181"><f a=""><x path="Int"/></f></get_width>
		<get_height get="inline" set="null" line="185"><f a=""><x path="Int"/></f></get_height>
		<set_width get="inline" set="null" line="189"><f a="w">
	<x path="Int"/>
	<x path="Int"/>
</f></set_width>
		<set_height get="inline" set="null" line="194"><f a="h">
	<x path="Int"/>
	<x path="Int"/>
</f></set_height>
		<toString public="1" set="method" line="199"><f a=""><c path="String"/></f></toString>
		<new public="1" get="inline" set="null" line="18"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h2d.col.IPoint" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h2d/col/IPoint.hx">
		<x public="1"><x path="Int"/></x>
		<y public="1"><x path="Int"/></y>
		<toPoint public="1" get="inline" set="null" line="14">
			<f a="?scale" v="1.">
				<x path="Float"/>
				<c path="h2d.col.Point"/>
			</f>
			<meta><m n=":value"><e>{ scale : 1. }</e></m></meta>
		</toPoint>
		<distanceSq public="1" get="inline" set="null" line="18"><f a="p">
	<c path="h2d.col.IPoint"/>
	<x path="Int"/>
</f></distanceSq>
		<distance public="1" get="inline" set="null" line="24"><f a="p">
	<c path="h2d.col.IPoint"/>
	<x path="Float"/>
</f></distance>
		<toString public="1" set="method" line="28"><f a=""><c path="String"/></f></toString>
		<sub public="1" get="inline" set="null" line="32"><f a="p">
	<c path="h2d.col.IPoint"/>
	<c path="h2d.col.Point"/>
</f></sub>
		<add public="1" get="inline" set="null" line="36"><f a="p">
	<c path="h2d.col.IPoint"/>
	<c path="h2d.col.Point"/>
</f></add>
		<equals public="1" get="inline" set="null" line="40"><f a="other">
	<c path="h2d.col.IPoint"/>
	<x path="Bool"/>
</f></equals>
		<dot public="1" get="inline" set="null" line="44"><f a="p">
	<c path="h2d.col.IPoint"/>
	<x path="Int"/>
</f></dot>
		<lengthSq public="1" get="inline" set="null" line="48"><f a=""><x path="Int"/></f></lengthSq>
		<length public="1" get="inline" set="null" line="52"><f a=""><x path="Float"/></f></length>
		<set public="1" get="inline" set="null" line="56"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></set>
		<clone public="1" get="inline" set="null" line="61"><f a=""><c path="h2d.col.IPoint"/></f></clone>
		<new public="1" get="inline" set="null" line="9">
			<f a="?x:?y" v="0:0">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ y : 0, x : 0 }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h2d.col.Matrix" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h2d/col/Matrix.hx">
		<tmp expr="new Matrix()" line="9" static="1">
			<c path="h2d.col.Matrix"/>
			<meta><m n=":value"><e>new Matrix()</e></m></meta>
		</tmp>
		<a public="1"><x path="Float"/></a>
		<b public="1"><x path="Float"/></b>
		<c public="1"><x path="Float"/></c>
		<d public="1"><x path="Float"/></d>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<identity public="1" get="inline" set="null" line="22"><f a=""><x path="Void"/></f></identity>
		<initTranslate public="1" get="inline" set="null" line="27"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></initTranslate>
		<initScale public="1" get="inline" set="null" line="33"><f a="sx:sy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></initScale>
		<initRotate public="1" get="inline" set="null" line="38"><f a="angle">
	<x path="Float"/>
	<x path="Void"/>
</f></initRotate>
		<invert public="1" set="method" line="49"><f a=""><x path="Void"/></f></invert>
		<getDeterminant public="1" get="inline" set="null" line="53"><f a=""><x path="Float"/></f></getDeterminant>
		<inverse public="1" set="method" line="57"><f a="m">
	<c path="h2d.col.Matrix"/>
	<x path="Void"/>
</f></inverse>
		<transform public="1" get="inline" set="null" line="70"><f a="pt">
	<c path="h2d.col.Point"/>
	<c path="h2d.col.Point"/>
</f></transform>
		<translate public="1" get="inline" set="null" line="74"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></translate>
		<prependTranslate public="1" get="inline" set="null" line="79"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></prependTranslate>
		<multiply public="1" set="method" line="84"><f a="a:b">
	<c path="h2d.col.Matrix"/>
	<c path="h2d.col.Matrix"/>
	<x path="Void"/>
</f></multiply>
		<getScale public="1" get="inline" set="null" line="95"><f a="?p">
	<c path="h2d.col.Point"/>
	<x path="Null"><c path="h2d.col.Point"/></x>
</f></getScale>
		<scale public="1" get="inline" set="null" line="108"><f a="sx:sy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></scale>
		<rotate public="1" set="method" line="117"><f a="angle">
	<x path="Float"/>
	<x path="Void"/>
</f></rotate>
		<clone public="1" set="method" line="122"><f a=""><c path="h2d.col.Matrix"/></f></clone>
		<getPosition public="1" get="inline" set="null" line="133"><f a="?p">
	<c path="h2d.col.Point"/>
	<x path="Null"><c path="h2d.col.Point"/></x>
</f></getPosition>
		<toString public="1" set="method" line="139"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="18"><f a=""><x path="Void"/></f></new>
		<haxe_doc>Affine 2D 2x3 matrix</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h2d.col.Point" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h2d/col/Point.hx">
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<toIPoint public="1" get="inline" set="null" line="14">
			<f a="?scale" v="1.">
				<x path="Float"/>
				<c path="h2d.col.IPoint"/>
			</f>
			<meta><m n=":value"><e>{ scale : 1. }</e></m></meta>
		</toIPoint>
		<distanceSq public="1" get="inline" set="null" line="18"><f a="p">
	<c path="h2d.col.Point"/>
	<x path="Float"/>
</f></distanceSq>
		<distance public="1" get="inline" set="null" line="24"><f a="p">
	<c path="h2d.col.Point"/>
	<x path="Float"/>
</f></distance>
		<toString public="1" set="method" line="28"><f a=""><c path="String"/></f></toString>
		<sub public="1" get="inline" set="null" line="32"><f a="p">
	<c path="h2d.col.Point"/>
	<c path="h2d.col.Point"/>
</f></sub>
		<add public="1" get="inline" set="null" line="36"><f a="p">
	<c path="h2d.col.Point"/>
	<c path="h2d.col.Point"/>
</f></add>
		<equals public="1" get="inline" set="null" line="40"><f a="other">
	<c path="h2d.col.Point"/>
	<x path="Bool"/>
</f></equals>
		<dot public="1" get="inline" set="null" line="44"><f a="p">
	<c path="h2d.col.Point"/>
	<x path="Float"/>
</f></dot>
		<rotate public="1" get="inline" set="null" line="48"><f a="angle">
	<x path="Float"/>
	<x path="Void"/>
</f></rotate>
		<lengthSq public="1" get="inline" set="null" line="57"><f a=""><x path="Float"/></f></lengthSq>
		<length public="1" get="inline" set="null" line="61"><f a=""><x path="Float"/></f></length>
		<normalize public="1" set="method" line="65"><f a=""><x path="Void"/></f></normalize>
		<normalizeFast public="1" get="inline" set="null" line="72"><f a=""><x path="Void"/></f></normalizeFast>
		<set public="1" get="inline" set="null" line="79"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></set>
		<load public="1" get="inline" set="null" line="84"><f a="p">
	<c path="h2d.col.Point"/>
	<x path="Void"/>
</f></load>
		<scale public="1" get="inline" set="null" line="89"><f a="f">
	<x path="Float"/>
	<c path="h2d.col.Point"/>
</f></scale>
		<clone public="1" get="inline" set="null" line="95"><f a=""><c path="h2d.col.Point"/></f></clone>
		<new public="1" get="inline" set="null" line="9">
			<f a="?x:?y" v="0.:0.">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ y : 0., x : 0. }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h2d.filter.Filter" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h2d/filter/Filter.hx">
		<autoBounds public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</autoBounds>
		<boundsExtend public="1" expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</boundsExtend>
		<smooth public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</smooth>
		<enable public="1" get="accessor" set="accessor" expr="true">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>true</e></m>
				<m n=":isVar"/>
			</meta>
		</enable>
		<get_enable set="method" line="16"><f a=""><x path="Bool"/></f></get_enable>
		<set_enable set="method" line="17"><f a="v">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_enable>
		<sync public="1" set="method" line="19"><f a="ctx:s">
	<c path="h2d.RenderContext"/>
	<c path="h2d.Object"/>
	<x path="Void"/>
</f></sync>
		<bind public="1" set="method" line="22"><f a="s">
	<c path="h2d.Object"/>
	<x path="Void"/>
</f></bind>
		<unbind public="1" set="method" line="25"><f a="s">
	<c path="h2d.Object"/>
	<x path="Void"/>
</f></unbind>
		<getBounds public="1" set="method" line="28"><f a="s:bounds">
	<c path="h2d.Object"/>
	<c path="h2d.col.Bounds"/>
	<x path="Void"/>
</f></getBounds>
		<draw public="1" set="method" line="36"><f a="ctx:input">
	<c path="h2d.RenderContext"/>
	<c path="h2d.Tile"/>
	<c path="h2d.Tile"/>
</f></draw>
		<new set="method" line="13"><f a=""><x path="Void"/></f></new>
		<haxe_doc>The base filter class, you can extend it in order to define your own filters, although ShaderFilter will be the most straightforward way to define simple custom filter.</haxe_doc>
	</class>
	<class path="h2d.ui.Button" params="" file="./h2d/ui/Button.hx">
		<extends path="h2d.Interactive"/>
		<bg><c path="h2d.Tile"/></bg>
		<hover><c path="h2d.Tile"/></hover>
		<down><c path="h2d.Tile"/></down>
		<pressed><x path="Bool"/></pressed>
		<draw set="method" line="38" override="1"><f a="ctx">
	<c path="h2d.RenderContext"/>
	<x path="Void"/>
</f></draw>
		<handleEvent public="1" set="method" line="50" override="1"><f a="e">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></handleEvent>
		<new public="1" set="method" line="19">
			<f a="?w:?h:label:?parent" v="-1:-1::">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
				<c path="h2d.Object"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ h : -1, w : -1 }</e></m></meta>
		</new>
		<haxe_doc>Primitive Button with label.
  Can be used for fast UI creation for debugging purposes.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h2d.ui.Checkbox" params="" file="./h2d/ui/Checkbox.hx">
		<extends path="h2d.Interactive"/>
		<bg static="1"><c path="h2d.Tile"/></bg>
		<check static="1"><c path="h2d.Tile"/></check>
		<checked public="1">
			<x path="Bool"/>
			<haxe_doc>Current checkbox state. Does not trigger `onChange` when changed, use `setChecked` function instead if even is required.</haxe_doc>
		</checked>
		<label public="1"><c path="h2d.Text"/></label>
		<setChecked public="1" set="method" line="54">
			<f a="v">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets `checked` flag and triggers `onChange` if value changes.</haxe_doc>
		</setChecked>
		<draw set="method" line="63" override="1"><f a="ctx">
	<c path="h2d.RenderContext"/>
	<x path="Void"/>
</f></draw>
		<handleEvent public="1" set="method" line="69" override="1"><f a="e">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></handleEvent>
		<onChange public="1" set="dynamic" line="85"><f a="value">
	<x path="Bool"/>
	<x path="Void"/>
</f></onChange>
		<new public="1" set="method" line="21"><f a="?parent:?_label">
	<c path="h2d.Object"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Primitive checkbox.
  Can be used for fast UI creation for debugging purposes.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h2d.ui.EventInteractive" params="" file="./h2d/ui/EventInteractive.hx">
		<extends path="h2d.Interactive"/>
		<onOverEvent public="1" expr="new EventSignal1()">
			<c path="cherry.soup.EventSignal1"><c path="hxd.Event"/></c>
			<meta><m n=":value"><e>new EventSignal1()</e></m></meta>
		</onOverEvent>
		<onOutEvent public="1" expr="new EventSignal1()">
			<c path="cherry.soup.EventSignal1"><c path="hxd.Event"/></c>
			<meta><m n=":value"><e>new EventSignal1()</e></m></meta>
		</onOutEvent>
		<onPushEvent public="1" expr="new EventSignal1()">
			<c path="cherry.soup.EventSignal1"><c path="hxd.Event"/></c>
			<meta><m n=":value"><e>new EventSignal1()</e></m></meta>
		</onPushEvent>
		<onReleaseEvent public="1" expr="new EventSignal1()">
			<c path="cherry.soup.EventSignal1"><c path="hxd.Event"/></c>
			<meta><m n=":value"><e>new EventSignal1()</e></m></meta>
		</onReleaseEvent>
		<onReleaseOutsideEvent public="1" expr="new EventSignal1()">
			<c path="cherry.soup.EventSignal1"><c path="hxd.Event"/></c>
			<meta><m n=":value"><e>new EventSignal1()</e></m></meta>
		</onReleaseOutsideEvent>
		<onClickEvent public="1" expr="new EventSignal1()">
			<c path="cherry.soup.EventSignal1"><c path="hxd.Event"/></c>
			<meta><m n=":value"><e>new EventSignal1()</e></m></meta>
		</onClickEvent>
		<onMoveEvent public="1" expr="new EventSignal1()">
			<c path="cherry.soup.EventSignal1"><c path="hxd.Event"/></c>
			<meta><m n=":value"><e>new EventSignal1()</e></m></meta>
		</onMoveEvent>
		<onWheelEvent public="1" expr="new EventSignal1()">
			<c path="cherry.soup.EventSignal1"><c path="hxd.Event"/></c>
			<meta><m n=":value"><e>new EventSignal1()</e></m></meta>
		</onWheelEvent>
		<onFocusEvent public="1" expr="new EventSignal1()">
			<c path="cherry.soup.EventSignal1"><c path="hxd.Event"/></c>
			<meta><m n=":value"><e>new EventSignal1()</e></m></meta>
		</onFocusEvent>
		<onFocusLostEvent public="1" expr="new EventSignal1()">
			<c path="cherry.soup.EventSignal1"><c path="hxd.Event"/></c>
			<meta><m n=":value"><e>new EventSignal1()</e></m></meta>
		</onFocusLostEvent>
		<onKeyUpEvent public="1" expr="new EventSignal1()">
			<c path="cherry.soup.EventSignal1"><c path="hxd.Event"/></c>
			<meta><m n=":value"><e>new EventSignal1()</e></m></meta>
		</onKeyUpEvent>
		<onKeyDownEvent public="1" expr="new EventSignal1()">
			<c path="cherry.soup.EventSignal1"><c path="hxd.Event"/></c>
			<meta><m n=":value"><e>new EventSignal1()</e></m></meta>
		</onKeyDownEvent>
		<onCheckEvent public="1" expr="new EventSignal1()">
			<c path="cherry.soup.EventSignal1"><c path="hxd.Event"/></c>
			<meta><m n=":value"><e>new EventSignal1()</e></m></meta>
		</onCheckEvent>
		<onTextInputEvent public="1" expr="new EventSignal1()">
			<c path="cherry.soup.EventSignal1"><c path="hxd.Event"/></c>
			<meta><m n=":value"><e>new EventSignal1()</e></m></meta>
		</onTextInputEvent>
		<handleEvent public="1" set="method" line="29" override="1"><f a="e">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></handleEvent>
		<new public="1" set="method" line="11"><f a="width:height:?parent:?shape">
	<x path="Float"/>
	<x path="Float"/>
	<c path="h2d.Object"/>
	<c path="h2d.col.Collider"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Simple wrapper to Interactive that allows multiple subscriptions to on* events.
  Overriding on* functions still possible.</haxe_doc>
	</class>
	<class path="h2d.ui.CustomButton" params="" file="./h2d/ui/CustomButton.hx">
		<extends path="h2d.ui.EventInteractive"/>
		<views public="1"><c path="Array"><c path="h2d.ui.IButtonStateView"/></c></views>
		<flags public="1" set="null">
			<x path="h2d.ui.ButtonFlags"/>
			<haxe_doc>Current state of the button in regard to mouse interaction.</haxe_doc>
		</flags>
		<state public="1" set="null">
			<x path="h2d.ui.ButtonState"/>
			<haxe_doc>Flag list the button currently contains. Does not affect state invalidation and used solely for views to utilize.  
    Most simple use-case is disabling the button.</haxe_doc>
		</state>
		<simState public="1" set="null" expr="0xff">
			<x path="h2d.ui.ButtonState"/>
			<meta><m n=":value"><e>0xff</e></m></meta>
			<haxe_doc>Current simulated state. Disabled if set to 0xff.
    While simulated state is active, CustomButton keeps track of real button state, but does not invalidate the view.</haxe_doc>
		</simState>
		<addChildAt public="1" set="method" line="49" override="1"><f a="s:pos">
	<c path="h2d.Object"/>
	<x path="Int"/>
	<x path="Void"/>
</f></addChildAt>
		<setStateOver set="method" line="58"><f a="_">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></setStateOver>
		<setStateOut set="method" line="59"><f a="_">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></setStateOut>
		<setStatePress set="method" line="60"><f a="e">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></setStatePress>
		<setStateUnpress set="method" line="65"><f a="e">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></setStateUnpress>
		<updateState get="inline" set="null" line="71"><f a="to">
	<x path="h2d.ui.ButtonState"/>
	<x path="Void"/>
</f></updateState>
		<setFlag public="1" set="method" line="76"><f a="flag:value">
	<x path="h2d.ui.ButtonFlags"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></setFlag>
		<simulateState public="1" get="inline" set="null" line="82"><f a="state">
	<x path="h2d.ui.ButtonState"/>
	<x path="Void"/>
</f></simulateState>
		<clearSimulatedState public="1" get="inline" set="null" line="88"><f a=""><x path="Void"/></f></clearSimulatedState>
		<invalidate public="1" set="method" line="95">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Invalidates button and forces invalidate to be called.</haxe_doc>
		</invalidate>
		<new public="1" set="method" line="31"><f a="width:height:?parent:?shape:?views">
	<x path="Float"/>
	<x path="Float"/>
	<c path="h2d.Object"/>
	<c path="h2d.col.Collider"/>
	<c path="Array"><c path="h2d.ui.IButtonStateView"/></c>
	<x path="Void"/>
</f></new>
		<haxe_doc>When regular Interactive is too little, but SimpleButton is too inflexible. Write your own state view!
  Class handles keeping track of current button state as well as lets you simulate the state.
  More specific behavior can be achieved by using flags.
  All View have to do is implement `setState(state, flags)` method and handle viewing specific state.</haxe_doc>
	</class>
	<class path="h2d.ui.IButtonStateView" params="" file="./h2d/ui/CustomButton.hx" module="h2d.ui.CustomButton" interface="1">
		<setState public="1" set="method"><f a="state:flags">
	<x path="h2d.ui.ButtonState"/>
	<x path="h2d.ui.ButtonFlags"/>
	<x path="Void"/>
</f></setState>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="h2d.ui.ButtonFlags" params="" file="./h2d/ui/CustomButton.hx" module="h2d.ui.CustomButton">
		<this><x path="Int"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="h2d.ui._CustomButton.ButtonFlags_Impl_" params="" file="./h2d/ui/CustomButton.hx" private="1" module="h2d.ui.CustomButton">
	<None public="1" get="inline" set="null" expr="cast 0" line="118" static="1">
		<x path="h2d.ui.ButtonFlags"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</None>
	<Toggled public="1" get="inline" set="null" expr="cast 1" line="119" static="1">
		<x path="h2d.ui.ButtonFlags"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Toggled>
	<Disabled public="1" get="inline" set="null" expr="cast 2" line="120" static="1">
		<x path="h2d.ui.ButtonFlags"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Disabled>
	<Focused public="1" get="inline" set="null" expr="cast 4" line="121" static="1">
		<x path="h2d.ui.ButtonFlags"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Focused>
	<Clicked public="1" get="inline" set="null" expr="cast 8" line="122" static="1">
		<x path="h2d.ui.ButtonFlags"/>
		<meta>
			<m n=":value"><e>cast 8</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Clicked>
	<Error public="1" get="inline" set="null" expr="cast 16" line="123" static="1">
		<x path="h2d.ui.ButtonFlags"/>
		<meta>
			<m n=":value"><e>cast 16</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Error>
	<Success public="1" get="inline" set="null" expr="cast 32" line="124" static="1">
		<x path="h2d.ui.ButtonFlags"/>
		<meta>
			<m n=":value"><e>cast 32</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Success>
	<LeftButtonPress public="1" get="inline" set="null" expr="cast 64" line="125" static="1">
		<x path="h2d.ui.ButtonFlags"/>
		<meta>
			<m n=":value"><e>cast 64</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LeftButtonPress>
	<RightButtonPress public="1" get="inline" set="null" expr="cast 128" line="126" static="1">
		<x path="h2d.ui.ButtonFlags"/>
		<meta>
			<m n=":value"><e>cast 128</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RightButtonPress>
	<Custom1 public="1" get="inline" set="null" expr="cast 256" line="127" static="1">
		<x path="h2d.ui.ButtonFlags"/>
		<meta>
			<m n=":value"><e>cast 256</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Custom1>
	<Custom2 public="1" get="inline" set="null" expr="cast 512" line="128" static="1">
		<x path="h2d.ui.ButtonFlags"/>
		<meta>
			<m n=":value"><e>cast 512</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Custom2>
	<Custom3 public="1" get="inline" set="null" expr="cast 1024" line="129" static="1">
		<x path="h2d.ui.ButtonFlags"/>
		<meta>
			<m n=":value"><e>cast 1024</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Custom3>
	<Custom4 public="1" get="inline" set="null" expr="cast 2048" line="130" static="1">
		<x path="h2d.ui.ButtonFlags"/>
		<meta>
			<m n=":value"><e>cast 2048</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Custom4>
	<has public="1" get="inline" set="null" line="132" static="1">
		<f a="this:flag">
			<x path="Int"/>
			<x path="h2d.ui.ButtonFlags"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</has>
	<set public="1" get="inline" set="null" line="136" static="1">
		<f a="this:flag">
			<x path="Int"/>
			<x path="h2d.ui.ButtonFlags"/>
			<x path="h2d.ui.ButtonFlags"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set>
	<reset public="1" get="inline" set="null" line="140" static="1">
		<f a="this:flag">
			<x path="Int"/>
			<x path="h2d.ui.ButtonFlags"/>
			<x path="h2d.ui.ButtonFlags"/>
		</f>
		<meta><m n=":impl"/></meta>
	</reset>
	<asFlag public="1" get="inline" set="null" line="144" static="1"><f a="i">
	<x path="Int"/>
	<x path="h2d.ui.ButtonFlags"/>
</f></asFlag>
	<toInt public="1" get="inline" set="null" line="145" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toInt>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="h2d.ui._CustomButton.ButtonFlags_Impl_" params="" file="./h2d/ui/CustomButton.hx" private="1" module="h2d.ui.CustomButton">
		<None public="1" get="inline" set="null" expr="cast 0" line="118" static="1">
			<x path="h2d.ui.ButtonFlags"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</None>
		<Toggled public="1" get="inline" set="null" expr="cast 1" line="119" static="1">
			<x path="h2d.ui.ButtonFlags"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Toggled>
		<Disabled public="1" get="inline" set="null" expr="cast 2" line="120" static="1">
			<x path="h2d.ui.ButtonFlags"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Disabled>
		<Focused public="1" get="inline" set="null" expr="cast 4" line="121" static="1">
			<x path="h2d.ui.ButtonFlags"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Focused>
		<Clicked public="1" get="inline" set="null" expr="cast 8" line="122" static="1">
			<x path="h2d.ui.ButtonFlags"/>
			<meta>
				<m n=":value"><e>cast 8</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Clicked>
		<Error public="1" get="inline" set="null" expr="cast 16" line="123" static="1">
			<x path="h2d.ui.ButtonFlags"/>
			<meta>
				<m n=":value"><e>cast 16</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Error>
		<Success public="1" get="inline" set="null" expr="cast 32" line="124" static="1">
			<x path="h2d.ui.ButtonFlags"/>
			<meta>
				<m n=":value"><e>cast 32</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Success>
		<LeftButtonPress public="1" get="inline" set="null" expr="cast 64" line="125" static="1">
			<x path="h2d.ui.ButtonFlags"/>
			<meta>
				<m n=":value"><e>cast 64</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LeftButtonPress>
		<RightButtonPress public="1" get="inline" set="null" expr="cast 128" line="126" static="1">
			<x path="h2d.ui.ButtonFlags"/>
			<meta>
				<m n=":value"><e>cast 128</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RightButtonPress>
		<Custom1 public="1" get="inline" set="null" expr="cast 256" line="127" static="1">
			<x path="h2d.ui.ButtonFlags"/>
			<meta>
				<m n=":value"><e>cast 256</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Custom1>
		<Custom2 public="1" get="inline" set="null" expr="cast 512" line="128" static="1">
			<x path="h2d.ui.ButtonFlags"/>
			<meta>
				<m n=":value"><e>cast 512</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Custom2>
		<Custom3 public="1" get="inline" set="null" expr="cast 1024" line="129" static="1">
			<x path="h2d.ui.ButtonFlags"/>
			<meta>
				<m n=":value"><e>cast 1024</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Custom3>
		<Custom4 public="1" get="inline" set="null" expr="cast 2048" line="130" static="1">
			<x path="h2d.ui.ButtonFlags"/>
			<meta>
				<m n=":value"><e>cast 2048</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Custom4>
		<has public="1" get="inline" set="null" line="132" static="1">
			<f a="this:flag">
				<x path="Int"/>
				<x path="h2d.ui.ButtonFlags"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</has>
		<set public="1" get="inline" set="null" line="136" static="1">
			<f a="this:flag">
				<x path="Int"/>
				<x path="h2d.ui.ButtonFlags"/>
				<x path="h2d.ui.ButtonFlags"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set>
		<reset public="1" get="inline" set="null" line="140" static="1">
			<f a="this:flag">
				<x path="Int"/>
				<x path="h2d.ui.ButtonFlags"/>
				<x path="h2d.ui.ButtonFlags"/>
			</f>
			<meta><m n=":impl"/></meta>
		</reset>
		<asFlag public="1" get="inline" set="null" line="144" static="1"><f a="i">
	<x path="Int"/>
	<x path="h2d.ui.ButtonFlags"/>
</f></asFlag>
		<toInt public="1" get="inline" set="null" line="145" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toInt>
		<meta><m n=":enum"/></meta>
	</class>
	<abstract path="h2d.ui.ButtonState" params="" file="./h2d/ui/CustomButton.hx" module="h2d.ui.CustomButton">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="h2d.ui._CustomButton.ButtonState_Impl_" params="" file="./h2d/ui/CustomButton.hx" private="1" module="h2d.ui.CustomButton" extern="1">
	<Idle public="1" get="inline" set="null" expr="cast 0" line="152" static="1">
		<x path="h2d.ui.ButtonState"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Idle>
	<Hover public="1" get="inline" set="null" expr="cast 1" line="154" static="1">
		<x path="h2d.ui.ButtonState"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Hover>
	<Press public="1" get="inline" set="null" expr="cast 3" line="156" static="1">
		<x path="h2d.ui.ButtonState"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Press>
	<Hold public="1" get="inline" set="null" expr="cast 2" line="158" static="1">
		<x path="h2d.ui.ButtonState"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Hold>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="h2d.ui._CustomButton.ButtonState_Impl_" params="" file="./h2d/ui/CustomButton.hx" private="1" module="h2d.ui.CustomButton" extern="1">
		<Idle public="1" get="inline" set="null" expr="cast 0" line="152" static="1">
			<x path="h2d.ui.ButtonState"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Idle>
		<Hover public="1" get="inline" set="null" expr="cast 1" line="154" static="1">
			<x path="h2d.ui.ButtonState"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Hover>
		<Press public="1" get="inline" set="null" expr="cast 3" line="156" static="1">
			<x path="h2d.ui.ButtonState"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Press>
		<Hold public="1" get="inline" set="null" expr="cast 2" line="158" static="1">
			<x path="h2d.ui.ButtonState"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Hold>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="h2d.ui.DevOverlay" params="" file="./h2d/ui/DevOverlay.hx">
		<extends path="h2d.Object"/>
		<ui public="1"><c path="h2d.ui.DevUI"/></ui>
		<labelContainer><c path="h2d.Object"/></labelContainer>
		<g public="1"><c path="h2d.Graphics"/></g>
		<labels><c path="Array"><c path="h2d.Text"/></c></labels>
		<labelCount><x path="Int"/></labelCount>
		<labelPool><x path="Int"/></labelPool>
		<textAt public="1" set="method" line="28">
			<f a="x:y:label:?align" v=":::Center">
				<x path="Float"/>
				<x path="Float"/>
				<c path="String"/>
				<e path="h2d.Align"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ align : Center }</e></m></meta>
		</textAt>
		<drawRec set="method" line="49" override="1"><f a="ctx">
	<c path="h2d.RenderContext"/>
	<x path="Void"/>
</f></drawRec>
		<new public="1" set="method" line="16"><f a="?parent">
	<c path="h2d.Object"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="h2d.ui.DevUI" params="" file="./h2d/ui/DevUI.hx">
		<extends path="h2d.Flow"/>
		<groupStack><c path="Array"><c path="h2d.Flow"/></c></groupStack>
		<group><c path="h2d.Flow"/></group>
		<autoWatch public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</autoWatch>
		<watchers><c path="Array"><c path="h2d.ui._DevUI.IWatcher"/></c></watchers>
		<button public="1" set="method" line="27"><f a="label:callback">
	<c path="String"/>
	<f a=""><x path="Void"/></f>
	<c path="h2d.ui.Button"/>
</f></button>
		<label public="1" set="method" line="34">
			<f a="text:?align:?color" v=":Left:0xffffff">
				<c path="String"/>
				<e path="h2d.Align"/>
				<x path="Int"/>
				<c path="h2d.Text"/>
			</f>
			<meta><m n=":value"><e>{ color : 0xffffff, align : Left }</e></m></meta>
		</label>
		<checkbox public="1" set="method" line="42">
			<f a="get:set:?label:?watch" v=":::false">
				<f a=""><x path="Bool"/></f>
				<f a="">
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<c path="String"/>
				<x path="Bool"/>
				<c path="h2d.ui.Checkbox"/>
			</f>
			<meta><m n=":value"><e>{ watch : false }</e></m></meta>
		</checkbox>
		<dropdown public="1" set="method" line="51">
			<f a="get:set:name:labels:?watch" v="::::false">
				<f a=""><x path="Int"/></f>
				<f a="">
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
				<x path="Bool"/>
				<c path="h2d.Dropdown"/>
			</f>
			<meta><m n=":value"><e>{ watch : false }</e></m></meta>
		</dropdown>
		<stat public="1" set="method" line="83"><f a="get:?label">
	<f a=""><c path="String"/></f>
	<c path="String"/>
	<c path="h2d.Text"/>
</f></stat>
		<statI public="1" set="method" line="92"><f a="get:?label">
	<f a=""><x path="Int"/></f>
	<c path="String"/>
	<c path="h2d.Text"/>
</f></statI>
		<statF public="1" set="method" line="97"><f a="get:?label">
	<f a=""><x path="Float"/></f>
	<c path="String"/>
	<c path="h2d.Text"/>
</f></statF>
		<object public="1" set="method" line="102"><f a="obj">
	<c path="h2d.Object"/>
	<x path="Void"/>
</f></object>
		<beginGroup public="1" set="method" line="108">
			<f a="name:?open" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="h2d.Flow"/>
			</f>
			<meta><m n=":value"><e>{ open : true }</e></m></meta>
		</beginGroup>
		<beginFlowGroup public="1" set="method" line="119"><f a="layout">
	<e path="h2d.FlowLayout"/>
	<c path="h2d.Flow"/>
</f></beginFlowGroup>
		<addGroup get="inline" set="null" line="127"><f a="g">
	<c path="h2d.Flow"/>
	<x path="Void"/>
</f></addGroup>
		<endGroup public="1" set="method" line="133"><f a=""><x path="Void"/></f></endGroup>
		<sync set="method" line="138" override="1"><f a="ctx">
	<c path="h2d.RenderContext"/>
	<x path="Void"/>
</f></sync>
		<new public="1" set="method" line="18"><f a="?parent">
	<c path="h2d.Object"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h2d.ui._DevUI.IWatcher" params="" file="./h2d/ui/DevUI.hx" private="1" module="h2d.ui.DevUI" interface="1"><invalidate public="1" set="method"><f a=""><x path="Void"/></f></invalidate></class>
	<class path="h2d.ui._DevUI.WatchDropdown" params="" file="./h2d/ui/DevUI.hx" private="1" module="h2d.ui.DevUI">
		<implements path="h2d.ui._DevUI.IWatcher"/>
		<d><c path="h2d.Dropdown"/></d>
		<get><f a=""><x path="Int"/></f></get>
		<invalidate public="1" set="method" line="160"><f a=""><x path="Void"/></f></invalidate>
		<new public="1" set="method" line="154"><f a="d:get">
	<c path="h2d.Dropdown"/>
	<f a=""><x path="Int"/></f>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h2d.ui._DevUI.WatchStat" params="" file="./h2d/ui/DevUI.hx" private="1" module="h2d.ui.DevUI">
		<implements path="h2d.ui._DevUI.IWatcher"/>
		<t><c path="h2d.Text"/></t>
		<get><f a=""><c path="String"/></f></get>
		<prefix><c path="String"/></prefix>
		<invalidate public="1" set="method" line="181"><f a=""><x path="Void"/></f></invalidate>
		<new public="1" set="method" line="174"><f a="t:get:prefix">
	<c path="h2d.Text"/>
	<f a=""><c path="String"/></f>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h2d.ui._DevUI.WatchCheckbox" params="" file="./h2d/ui/DevUI.hx" private="1" module="h2d.ui.DevUI">
		<implements path="h2d.ui._DevUI.IWatcher"/>
		<c><c path="h2d.ui.Checkbox"/></c>
		<get><f a=""><x path="Bool"/></f></get>
		<invalidate public="1" set="method" line="199"><f a=""><x path="Void"/></f></invalidate>
		<new public="1" set="method" line="193"><f a="get:c">
	<f a=""><x path="Bool"/></f>
	<c path="h2d.ui.Checkbox"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h2d.ui._DevUI.GroupFold" params="" file="./h2d/ui/DevUI.hx" private="1" module="h2d.ui.DevUI">
		<extends path="h2d.Interactive"/>
		<_arrow static="1"><c path="h2d.Tile"/></_arrow>
		<_rot static="1"><x path="Float"/></_rot>
		<arrow><c path="h2d.Bitmap"/></arrow>
		<label><c path="h2d.Text"/></label>
		<group public="1"><c path="h2d.Object"/></group>
		<shown><x path="Bool"/></shown>
		<onClick public="1" set="dynamic" line="241" override="1"><f a="e">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></onClick>
		<set public="1" get="inline" set="null" line="246"><f a="open">
	<x path="Bool"/>
	<x path="Void"/>
</f></set>
		<sync set="method" line="252" override="1"><f a="ctx">
	<c path="h2d.RenderContext"/>
	<x path="Void"/>
</f></sync>
		<new public="1" set="method" line="217"><f a="text:?parent">
	<c path="String"/>
	<c path="h2d.Object"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h2d.ui.FPS" params="" file="./h2d/ui/FPS.hx">
		<extends path="h2d.Object"/>
		<currentFPS public="1" set="null"><x path="Int"/></currentFPS>
		<averageFPS public="1" set="null"><x path="Int"/></averageFPS>
		<minFPS public="1" set="null"><x path="Int"/></minFPS>
		<maxFPS public="1" set="null"><x path="Int"/></maxFPS>
		<graph><c path="h2d.Bitmap"/></graph>
		<graphShader><c path="h2d.ui.GraphShader"/></graphShader>
		<stats><c path="h2d.Text"/></stats>
		<avgStat><c path="h2d.Text"/></avgStat>
		<minStat><c path="h2d.Text"/></minStat>
		<maxStat><c path="h2d.Text"/></maxStat>
		<resolution><x path="Int"/></resolution>
		<packedResolution><x path="Int"/></packedResolution>
		<frames><x path="haxe.ds.Vector"><x path="Int"/></x></frames>
		<goodThreshold public="1" expr="60">
			<x path="Int"/>
			<meta><m n=":value"><e>60</e></m></meta>
		</goodThreshold>
		<cautionThreshold public="1" expr="30">
			<x path="Int"/>
			<meta><m n=":value"><e>30</e></m></meta>
		</cautionThreshold>
		<alignSelf public="1" set="method" line="72">
			<f a="?hor:?ver" v="Right:Top">
				<e path="h2d.FlowAlign"/>
				<e path="h2d.FlowAlign"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ ver : Top, hor : Right }</e></m></meta>
		</alignSelf>
		<sync set="method" line="87" override="1"><f a="ctx">
	<c path="h2d.RenderContext"/>
	<x path="Void"/>
</f></sync>
		<new public="1" set="method" line="33">
			<f a="?resolution:?parent" v="150:">
				<x path="Int"/>
				<c path="h2d.Object"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ resolution : 150 }</e></m></meta>
		</new>
		<haxe_doc>Primitive FPS counter.
  Adapted from openfl.display.FPS</haxe_doc>
	</class>
	<class path="h2d.ui.GraphShader" params="" file="./h2d/ui/FPS.hx" module="h2d.ui.FPS">
		<extends path="hxsl.Shader"/>
		<SRC expr="&quot;HXSLEmgyZC51aS5HcmFwaFNoYWRlcg0BCnBpeGVsQ29sb3IFDAQAAAIMY2FsY3VsYXRlZFVWBQoDAAADCWdvb2RDb2xvcgUMAgAABAxjYXV0aW9uQ29sb3IFDAIAAAUNY3JpdGljYWxDb2xvcgUMAgAABg1nb29kVGhyZXNob2xkAwIAAAcQY2F1dGlvblRocmVzaG9sZAMCAAAIB2F2ZXJhZ2UDAgAACQ9HcmFwaFZhbHVlc1NpemUBAgABAAAAAAAKC2dyYXBoVmFsdWVzDwUMCQIAAAsQZ3JhcGhWYWx1ZXNDb3VudAMCAAAMBmhlaWdodAMCAAANCGZyYWdtZW50DgYAAAEBDQAABQcIDgZ4Q29vcmQDBAAACgICBQoAAAMACA8GeUNvb3JkAwQAAAYDAQMAAAAAAADwPwMKAgIFCgQAAwMACBAGcHhTaXplAwQAAAsGBgIMAwEDAAAAAAAAAAADAgYCAQMAAAAAAADwPwMCDAMDAQN7FK5H4XqUPwMDAAgRBWNvbG9yBQwEAAAAAAsGDgYJAg8DAggDAgYHAg8DBgMCCAMCEAMDAgIFAQYEAhEFDAkDKg4EAQMAAAAAAADwPwMBAwAAAAAAAPA/AwEDAAAAAAAA8D8DAQMAAAAAAADwPwMFDAUMAAsGDgYJAg8DAgcDAgYHAg8DBgMCBwMCEAMDAgIFAQYEAhEFDAIEBQwFDAALBg4GCQIPAwIGAwIGBwIPAwYDAgYDAhADAwICBQEGBAIRBQwCAwUMBQwABQUIEgVpbmRleAEEAAAJAyUOAQYBAg4DAgsDAwEACBMGcGFja2VkBQwEAAARAgoPBQwJCQMlDgEGAgISAQECBAAAAAEBAQUMAAaTAhIBAQIEAAAAAQEIFApncmFwaFZhbHVlAwQAAAsGBQISAQECAAAAAAECCgITBQwAAAMLBgUCEgEBAgEAAAABAgoCEwUMBAADCwYFAhIBAQIDAAAAAQIKAhMFDAgAAwoCEwUMDAADAwMDAAsGBwIPAwIUAwIFAQwAAAUCCwYHAhQDAgYDAgUBBgQCEQUMAgMFDAUMAAsGBwIUAwIHAwIFAQYEAhEFDAIEBQwFDAAFAQYEAhEFDAIFBQwFDAAAAAsGBwYDAhQDAg8DAwYBBAYCAQMAAAAAAADwPwMEBgMCCwMBAwAAAAAAAPA/AwMDAwMBAwAAAAAAABBAAwMCBQEGBAoCEQUMDAADBgIGAQIPAwEDMzMzMzMz0z8DAwIUAwMDAAAAAAAAAAAACwYJAg4DAQO4HoXrUbiePwMCBQEGgQoCEQUMDAADBgMBAwAAAAAAAPA/AwYCBAYDAQO4HoXrUbiePwMCDgMDAwEDuB6F61G4nj8DAwMDAAsGBwIOAwEDCtejcD0K7z8DAgUBBoEKAhEFDAwAAwYCBAYDAQMAAAAAAADwPwMCDgMDAwEDuB6F61G4nj8DAwMAAAAABgQCAQUMAhEFDAUMAA&quot;" line="151" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"HXSLEmgyZC51aS5HcmFwaFNoYWRlcg0BCnBpeGVsQ29sb3IFDAQAAAIMY2FsY3VsYXRlZFVWBQoDAAADCWdvb2RDb2xvcgUMAgAABAxjYXV0aW9uQ29sb3IFDAIAAAUNY3JpdGljYWxDb2xvcgUMAgAABg1nb29kVGhyZXNob2xkAwIAAAcQY2F1dGlvblRocmVzaG9sZAMCAAAIB2F2ZXJhZ2UDAgAACQ9HcmFwaFZhbHVlc1NpemUBAgABAAAAAAAKC2dyYXBoVmFsdWVzDwUMCQIAAAsQZ3JhcGhWYWx1ZXNDb3VudAMCAAAMBmhlaWdodAMCAAANCGZyYWdtZW50DgYAAAEBDQAABQcIDgZ4Q29vcmQDBAAACgICBQoAAAMACA8GeUNvb3JkAwQAAAYDAQMAAAAAAADwPwMKAgIFCgQAAwMACBAGcHhTaXplAwQAAAsGBgIMAwEDAAAAAAAAAAADAgYCAQMAAAAAAADwPwMCDAMDAQN7FK5H4XqUPwMDAAgRBWNvbG9yBQwEAAAAAAsGDgYJAg8DAggDAgYHAg8DBgMCCAMCEAMDAgIFAQYEAhEFDAkDKg4EAQMAAAAAAADwPwMBAwAAAAAAAPA/AwEDAAAAAAAA8D8DAQMAAAAAAADwPwMFDAUMAAsGDgYJAg8DAgcDAgYHAg8DBgMCBwMCEAMDAgIFAQYEAhEFDAIEBQwFDAALBg4GCQIPAwIGAwIGBwIPAwYDAgYDAhADAwICBQEGBAIRBQwCAwUMBQwABQUIEgVpbmRleAEEAAAJAyUOAQYBAg4DAgsDAwEACBMGcGFja2VkBQwEAAARAgoPBQwJCQMlDgEGAgISAQECBAAAAAEBAQUMAAaTAhIBAQIEAAAAAQEIFApncmFwaFZhbHVlAwQAAAsGBQISAQECAAAAAAECCgITBQwAAAMLBgUCEgEBAgEAAAABAgoCEwUMBAADCwYFAhIBAQIDAAAAAQIKAhMFDAgAAwoCEwUMDAADAwMDAAsGBwIPAwIUAwIFAQwAAAUCCwYHAhQDAgYDAgUBBgQCEQUMAgMFDAUMAAsGBwIUAwIHAwIFAQYEAhEFDAIEBQwFDAAFAQYEAhEFDAIFBQwFDAAAAAsGBwYDAhQDAg8DAwYBBAYCAQMAAAAAAADwPwMEBgMCCwMBAwAAAAAAAPA/AwMDAwMBAwAAAAAAABBAAwMCBQEGBAoCEQUMDAADBgIGAQIPAwEDMzMzMzMz0z8DAwIUAwMDAAAAAAAAAAAACwYJAg4DAQO4HoXrUbiePwMCBQEGgQoCEQUMDAADBgMBAwAAAAAAAPA/AwYCBAYDAQO4HoXrUbiePwMCDgMDAwEDuB6F61G4nj8DAwMDAAsGBwIOAwEDCtejcD0K7z8DAgUBBoEKAhEFDAwAAwYCBAYDAQMAAAAAAADwPwMCDgMDAwEDuB6F61G4nj8DAwMAAAAABgQCAQUMAhEFDAUMAA"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<goodColor public="1" get="accessor" set="accessor"><t path="hxsl.Vec"/></goodColor>
		<goodColor__ expr="new h3d.Vector(0.462745, 0.831372, 0.22745, 1)">
			<t path="hxsl.Vec"/>
			<meta>
				<m n=":value"><e>new h3d.Vector(0.462745, 0.831372, 0.22745, 1)</e></m>
				<m n=":noCompletion"/>
			</meta>
		</goodColor__>
		<get_goodColor get="inline" set="null" line="151">
			<f a=""><t path="hxsl.Vec"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_goodColor>
		<set_goodColor get="inline" set="null" line="151">
			<f a="_v">
				<t path="hxsl.Vec"/>
				<t path="hxsl.Vec"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_goodColor>
		<cautionColor public="1" get="accessor" set="accessor"><t path="hxsl.Vec"/></cautionColor>
		<cautionColor__ expr="new h3d.Vector(0.952941, 0.909803, 0, 1)">
			<t path="hxsl.Vec"/>
			<meta>
				<m n=":value"><e>new h3d.Vector(0.952941, 0.909803, 0, 1)</e></m>
				<m n=":noCompletion"/>
			</meta>
		</cautionColor__>
		<get_cautionColor get="inline" set="null" line="151">
			<f a=""><t path="hxsl.Vec"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_cautionColor>
		<set_cautionColor get="inline" set="null" line="151">
			<f a="_v">
				<t path="hxsl.Vec"/>
				<t path="hxsl.Vec"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_cautionColor>
		<criticalColor public="1" get="accessor" set="accessor"><t path="hxsl.Vec"/></criticalColor>
		<criticalColor__ expr="new h3d.Vector(0.862745, 0.160784, 0.117647, 1)">
			<t path="hxsl.Vec"/>
			<meta>
				<m n=":value"><e>new h3d.Vector(0.862745, 0.160784, 0.117647, 1)</e></m>
				<m n=":noCompletion"/>
			</meta>
		</criticalColor__>
		<get_criticalColor get="inline" set="null" line="151">
			<f a=""><t path="hxsl.Vec"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_criticalColor>
		<set_criticalColor get="inline" set="null" line="151">
			<f a="_v">
				<t path="hxsl.Vec"/>
				<t path="hxsl.Vec"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_criticalColor>
		<goodThreshold public="1" get="accessor" set="accessor"><x path="Float"/></goodThreshold>
		<goodThreshold__ expr="0.5">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0.5</e></m>
				<m n=":noCompletion"/>
			</meta>
		</goodThreshold__>
		<get_goodThreshold get="inline" set="null" line="151">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_goodThreshold>
		<set_goodThreshold get="inline" set="null" line="151">
			<f a="_v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_goodThreshold>
		<cautionThreshold public="1" get="accessor" set="accessor"><x path="Float"/></cautionThreshold>
		<cautionThreshold__ expr="0.25">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0.25</e></m>
				<m n=":noCompletion"/>
			</meta>
		</cautionThreshold__>
		<get_cautionThreshold get="inline" set="null" line="151">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_cautionThreshold>
		<set_cautionThreshold get="inline" set="null" line="151">
			<f a="_v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_cautionThreshold>
		<average public="1" get="accessor" set="accessor"><x path="Float"/></average>
		<average__ expr="0">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":noCompletion"/>
			</meta>
		</average__>
		<get_average get="inline" set="null" line="151">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_average>
		<set_average get="inline" set="null" line="151">
			<f a="_v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_average>
		<GraphValuesSize public="1" get="accessor" set="accessor"><x path="Int"/></GraphValuesSize>
		<GraphValuesSize__ expr="0">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":noCompletion"/>
			</meta>
		</GraphValuesSize__>
		<get_GraphValuesSize get="inline" set="null" line="151">
			<f a=""><x path="Int"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_GraphValuesSize>
		<set_GraphValuesSize get="inline" set="null" line="151">
			<f a="_v">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_GraphValuesSize>
		<graphValues public="1" get="accessor" set="accessor"><c path="Array"><t path="hxsl.Vec"/></c></graphValues>
		<graphValues__ expr="new Array()">
			<c path="Array"><t path="hxsl.Vec"/></c>
			<meta>
				<m n=":value"><e>new Array()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</graphValues__>
		<get_graphValues get="inline" set="null" line="151">
			<f a=""><c path="Array"><t path="hxsl.Vec"/></c></f>
			<meta><m n=":noCompletion"/></meta>
		</get_graphValues>
		<set_graphValues get="inline" set="null" line="151">
			<f a="_v">
				<c path="Array"><t path="hxsl.Vec"/></c>
				<c path="Array"><t path="hxsl.Vec"/></c>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_graphValues>
		<graphValuesCount public="1" get="accessor" set="accessor"><x path="Float"/></graphValuesCount>
		<graphValuesCount__ expr="0">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":noCompletion"/>
			</meta>
		</graphValuesCount__>
		<get_graphValuesCount get="inline" set="null" line="151">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_graphValuesCount>
		<set_graphValuesCount get="inline" set="null" line="151">
			<f a="_v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_graphValuesCount>
		<height public="1" get="accessor" set="accessor"><x path="Float"/></height>
		<height__ expr="0">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":noCompletion"/>
			</meta>
		</height__>
		<get_height get="inline" set="null" line="151">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_height>
		<set_height get="inline" set="null" line="151">
			<f a="_v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_height>
		<updateConstants public="1" set="method" line="151" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="151" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="151" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="151" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="149"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":src"><e><![CDATA[{
	var pixelColor:Vec4;
	@var var calculatedUV:Vec2;
	@param var goodColor:Vec4 = vec4(0.462745, 0.831372, 0.227450, 1);
	@param var cautionColor:Vec4 = vec4(0.952941, 0.909803, 0, 1);
	@param var criticalColor:Vec4 = vec4(0.862745, 0.160784, 0.117647, 1);
	@param var goodThreshold:Float = 0.5;
	@param var cautionThreshold:Float = 0.25;
	@param var average:Float;
	@param @const var GraphValuesSize:Int;
	@param var graphValues:Array<Vec4,GraphValuesSize>;
	@param var graphValuesCount:Float;
	@param var height:Float = 0;
	function fragment() {
		var xCoord = calculatedUV.x;
		var yCoord = 1 - calculatedUV.y;
		var pxSize = if (height != 0) 1 / height else 0.02;
		var color:Vec4;
		if (yCoord < average && yCoord > average - pxSize) {
			color = vec4(1, 1, 1, 1);
		} else if (yCoord < cautionThreshold && yCoord > cautionThreshold - pxSize) {
			color = cautionColor;
		} else if (yCoord < goodThreshold && yCoord > goodThreshold - pxSize) {
			color = goodColor;
		} else {
			var index = int(xCoord * graphValuesCount);
			var packed = graphValues[int(index / 4)];
			index %= 4;
			var graphValue = if (index == 0) packed.r else if (index == 1) packed.g else if (index == 3) packed.b else packed.a;
			if (yCoord > graphValue) {
				discard;
			} else {
				if (graphValue > goodThreshold) {
					color = goodColor;
				} else if (graphValue > cautionThreshold) {
					color = cautionColor;
				} else {
					color = criticalColor;
				};
				if (graphValue - yCoord > (1. / (graphValuesCount - 1.)) * 4) {
					color.a = yCoord * .3 / graphValue;
				};
			};
		};
		if (xCoord < 0.03) {
			color.a *= 1 - (0.03 - xCoord) / 0.03;
		} else if (xCoord > 0.97) {
			color.a *= (1 - xCoord) / 0.03;
		};
		pixelColor = color;
	};
}]]></e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="h2d.ui.Label" params="" file="./h2d/ui/Label.hx">
		<extends path="h2d.Interactive"/>
		<target public="1"><c path="h2d.Interactive"/></target>
		<text public="1"><c path="h2d.Text"/></text>
		<handleEvent public="1" set="method" line="27" override="1"><f a="e">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></handleEvent>
		<new public="1" set="method" line="12"><f a="label:?font:?align:?maxW:target:?parent">
	<c path="String"/>
	<c path="h2d.Font"/>
	<e path="h2d.Align"/>
	<x path="Float"/>
	<c path="h2d.Interactive"/>
	<c path="h2d.Object"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="h2d.ui.ManifestProgress" params="" file="./h2d/ui/ManifestProgress.hx">
		<extends path="h2d.Object"/>
		<g><c path="h2d.Graphics"/></g>
		<text><c path="h2d.Text"/></text>
		<loader><c path="cherry.res.ManifestLoader"/></loader>
		<color><x path="Int"/></color>
		<onLoaded><f a=""><x path="Void"/></f></onLoaded>
		<totalBarHeight><x path="Float"/></totalBarHeight>
		<subBarHeight><x path="Float"/></subBarHeight>
		<barWidth><x path="Float"/></barWidth>
		<removeSelf public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</removeSelf>
		<start public="1" set="method" line="35"><f a=""><x path="Void"/></f></start>
		<repaint set="method" line="56"><f a=""><x path="Void"/></f></repaint>
		<setProgress set="method" line="82"><f a="b:t">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setProgress>
		<finish set="method" line="92"><f a=""><x path="Void"/></f></finish>
		<showFileName set="method" line="101"><f a="task">
	<c path="cherry.res.LoaderTask"/>
	<x path="Void"/>
</f></showFileName>
		<fileLoaded set="method" line="107"><f a="task">
	<c path="cherry.res.LoaderTask"/>
	<x path="Void"/>
</f></fileLoaded>
		<fileProgress set="method" line="114"><f a="task">
	<c path="cherry.res.LoaderTask"/>
	<x path="Void"/>
</f></fileProgress>
		<new public="1" set="method" line="21">
			<f a="loader:?color:onLoaded:?parent" v=":0xffffff::">
				<c path="cherry.res.ManifestLoader"/>
				<x path="Int"/>
				<f a=""><x path="Void"/></f>
				<c path="h2d.Object"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ color : 0xffffff }</e></m></meta>
		</new>
	</class>
	<class path="h2d.ui.RadioButton" params="" file="./h2d/ui/RadioButton.hx">
		<extends path="h2d.ui.Checkbox"/>
		<bg static="1"><c path="h2d.Tile"/></bg>
		<check static="1"><c path="h2d.Tile"/></check>
		<group public="1" set="null">
			<c path="h2d.ui.RadioGroup"/>
			<haxe_doc>Group this Radiobutton belongs to.</haxe_doc>
		</group>
		<index public="1" set="null">
			<x path="Int"/>
			<haxe_doc>Index of this checkbox in the group.</haxe_doc>
		</index>
		<setChecked public="1" set="method" line="56" override="1"><f a="v">
	<x path="Bool"/>
	<x path="Void"/>
</f></setChecked>
		<draw set="method" line="61" override="1"><f a="ctx">
	<c path="h2d.RenderContext"/>
	<x path="Void"/>
</f></draw>
		<onRadio public="1" set="dynamic" line="72">
			<f a="value">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Triggers when RadioGroup changes selected button.
    Happens on all buttons.</haxe_doc>
		</onRadio>
		<new public="1" set="method" line="24"><f a="?parent:?group">
	<c path="h2d.Object"/>
	<c path="h2d.ui.RadioGroup"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Primitive radio button.
  Can be used for fast UI creation for debugging purposes.</haxe_doc>
	</class>
	<class path="h2d.ui.RadioGroup" params="" file="./h2d/ui/RadioButton.hx" module="h2d.ui.RadioButton">
		<buttons><c path="Array"><c path="h2d.ui.RadioButton"/></c></buttons>
		<selectedIndex public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<haxe_doc>Currently selected index.
    Always triggers onChange and onRadio in buttons when changed.</haxe_doc>
		</selectedIndex>
		<get_selectedIndex set="method" line="102"><f a=""><x path="Int"/></f></get_selectedIndex>
		<set_selectedIndex set="method" line="108"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></set_selectedIndex>
		<add public="1" set="method" line="133">
			<f a="radio">
				<c path="h2d.ui.RadioButton"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds new RadioButton to the group.</haxe_doc>
		</add>
		<remove public="1" set="method" line="144">
			<f a="radio">
				<c path="h2d.ui.RadioButton"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Removes RadioButton from the group.</haxe_doc>
		</remove>
		<onChange public="1" set="dynamic" line="157">
			<f a="index">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Triggers when selected index changes.</haxe_doc>
		</onChange>
		<new public="1" set="method" line="93"><f a="?buttons">
	<c path="Array"><c path="h2d.ui.RadioButton"/></c>
	<x path="Void"/>
</f></new>
		<haxe_doc>A group of RadioButtons for, duh, grouping of RadioButtons.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>h2d.ui.RadioButton</e></m>
		</meta>
	</class>
	<class path="h2d.ui.ScrollArea" params="" file="./h2d/ui/ScrollArea.hx">
		<extends path="h2d.Mask"/>
		<scrollStep public="1">
			<x path="Int"/>
			<haxe_doc>A scroll step when scrolled via `scrollBy`</haxe_doc>
		</scrollStep>
		<scrollBy public="1" set="method" line="24" override="1"><f a="deltaX:deltaY">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></scrollBy>
		<scrollPixels public="1" set="method" line="30"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></scrollPixels>
		<calcAbsPos set="method" line="36" override="1"><f a=""><x path="Void"/></f></calcAbsPos>
		<drawRec set="method" line="58" override="1"><f a="ctx">
	<c path="h2d.RenderContext"/>
	<x path="Void"/>
</f></drawRec>
		<objDrawRec set="method" line="104"><f a="ctx">
	<c path="h2d.RenderContext"/>
	<x path="Void"/>
</f></objDrawRec>
		<new public="1" set="method" line="17">
			<f a="width:height:?scrollStep:?bounds:?parent" v="::16::">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="h2d.col.Bounds"/>
				<c path="h2d.Object"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ scrollStep : 16 }</e></m></meta>
		</new>
		<haxe_doc>Scrollable container.</haxe_doc>
	</class>
	<class path="h2d.ui.ScrollText" params="" file="./h2d/ui/ScrollText.hx">
		<extends path="h2d.Mask"/>
		<text public="1">
			<c path="h2d.Text"/>
			<haxe_doc>Reference to Text instance.</haxe_doc>
		</text>
		<htmlText public="1">
			<c path="h2d.HtmlText"/>
			<haxe_doc>Reference to HtmlText instance if passed one at creation.</haxe_doc>
		</htmlText>
		<maxScrollV public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>Maxiumm possible `scrollV` value.</haxe_doc>
		</maxScrollV>
		<scrollV public="1" set="accessor" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>Current scrollV value. Starts at 0, up to maxScrollV.  
    Note: Does not invoke onScrollV.</haxe_doc>
		</scrollV>
		<bottomScrollV public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>Bottom of current scrollV value. Represents bottom of visible Text area.</haxe_doc>
		</bottomScrollV>
		<scrollStep public="1">
			<x path="Float"/>
			<haxe_doc>Amount of pixels one scroll step uses. Defaults to Text font line height + lineSpacing.</haxe_doc>
		</scrollStep>
		<inter><c path="h2d.Interactive"/></inter>
		<dragX><x path="Float"/></dragX>
		<dragY><x path="Float"/></dragY>
		<refV><x path="Float"/></refV>
		<scrollVLimit get="inline" set="null" line="58"><f a=""><x path="Int"/></f></scrollVLimit>
		<get_maxScrollV set="method" line="63"><f a=""><x path="Int"/></f></get_maxScrollV>
		<get_bottomScrollV set="method" line="70"><f a=""><x path="Float"/></f></get_bottomScrollV>
		<set_scrollV set="method" line="78"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_scrollV>
		<sync set="method" line="86" override="1"><f a="ctx">
	<c path="h2d.RenderContext"/>
	<x path="Void"/>
</f></sync>
		<hookListeners public="1" set="method" line="96">
			<f a="?mouseDrag" v="true">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ mouseDrag : true }</e></m></meta>
		</hookListeners>
		<unhookListeners public="1" set="method" line="111"><f a=""><x path="Void"/></f></unhookListeners>
		<startMouseDrag set="method" line="123"><f a="e">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></startMouseDrag>
		<stopMouseDrag set="method" line="131"><f a="e">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></stopMouseDrag>
		<mouseDrag set="method" line="136"><f a="e">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></mouseDrag>
		<onWheel set="method" line="142"><f a="e">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></onWheel>
		<scrollTextBy public="1" get="inline" set="null" line="150">
			<f a="steps">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Shifts current `scrollV` by `steps` and invokes `onScrollV`.</haxe_doc>
		</scrollTextBy>
		<scrollTextTo public="1" set="method" line="158">
			<f a="v">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets `scrollV` and invokes `onScrollV`.</haxe_doc>
		</scrollTextTo>
		<toScrollV public="1" get="inline" set="null" line="168">
			<f a="pixels">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Converts provided position in pixels to scroll stepped value.  
    Shortcut to `pixels / scrollStep`</haxe_doc>
		</toScrollV>
		<onScrollV public="1" set="dynamic" line="173"><f a="v:oldV">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></onScrollV>
		<new public="1" set="method" line="49"><f a="text:width:height:?parent">
	<c path="h2d.Text"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="h2d.Object"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Vertically scrollable text container.
  Useful for creation of walls of text.</haxe_doc>
	</class>
	<class path="h2d.ui.SimpleButton" params="" file="./h2d/ui/SimpleButton.hx">
		<extends path="h2d.ui.EventInteractive"/>
		<idle><c path="h2d.Object"/></idle>
		<hover><c path="h2d.Object"/></hover>
		<press><c path="h2d.Object"/></press>
		<disabled><c path="h2d.Object"/></disabled>
		<pressed><x path="Bool"/></pressed>
		<over><x path="Bool"/></over>
		<enabled public="1" set="accessor" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>Button availability state. If `false`, does not Interact with mouse and showns `disabled` state.</haxe_doc>
		</enabled>
		<set_enabled set="method" line="46"><f a="v">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_enabled>
		<updateState set="method" line="54"><f a=""><x path="Void"/></f></updateState>
		<handleEvent public="1" set="method" line="81" override="1"><f a="e">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></handleEvent>
		<new public="1" set="method" line="26"><f a="w:h:idle:hover:press:?disabled:?parent:?shape">
	<x path="Int"/>
	<x path="Int"/>
	<c path="h2d.Object"/>
	<c path="h2d.Object"/>
	<c path="h2d.Object"/>
	<c path="h2d.Object"/>
	<c path="h2d.Object"/>
	<c path="h2d.col.Collider"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>A simple button with simple premade 4 states.
  Based on openfl.display.SimpleButton design.</haxe_doc>
	</class>
	<enum path="h3d.BufferFlag" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/Buffer.hx" module="h3d.Buffer">
		<Dynamic><haxe_doc>Indicate that the buffer content will be often modified.</haxe_doc></Dynamic>
		<Triangles><haxe_doc>The buffer contains only triangles. Imply Managed. Make sure the position is aligned on 3 vertices multiples.</haxe_doc></Triangles>
		<Quads><haxe_doc>The buffer contains only quads. Imply Managed. Make sure the position is aligned on 4 vertices multiples.</haxe_doc></Quads>
		<Managed><haxe_doc>Will allocate the memory as part of an shared buffer pool, preventing a lot of small GPU buffers to be allocated.</haxe_doc></Managed>
		<RawFormat><haxe_doc>Directly map the buffer content to the shader inputs, without assuming [pos:vec3,normal:vec3,uv:vec2] default prefix.</haxe_doc></RawFormat>
		<NoAlloc><haxe_doc>Used internaly</haxe_doc></NoAlloc>
		<UniformBuffer><haxe_doc>Used for shader input buffer</haxe_doc></UniformBuffer>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="h3d.Buffer" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/Buffer.hx">
		<GUID public="1" expr="0" line="35" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</GUID>
		<ofFloats public="1" set="method" line="139" static="1"><f a="v:stride:?flags">
	<x path="hxd.FloatBuffer"/>
	<x path="Int"/>
	<c path="Array"><e path="h3d.BufferFlag"/></c>
	<c path="h3d.Buffer"/>
</f></ofFloats>
		<ofSubFloats public="1" set="method" line="146" static="1"><f a="v:stride:vertices:?flags">
	<x path="hxd.FloatBuffer"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><e path="h3d.BufferFlag"/></c>
	<c path="h3d.Buffer"/>
</f></ofSubFloats>
		<id public="1"><x path="Int"/></id>
		<buffer public="1" set="null"><c path="h3d.impl.ManagedBuffer"/></buffer>
		<position public="1" set="null"><x path="Int"/></position>
		<vertices public="1" set="null"><x path="Int"/></vertices>
		<next public="1" set="null"><c path="h3d.Buffer"/></next>
		<flags public="1" set="null"><x path="haxe.EnumFlags"><e path="h3d.BufferFlag"/></x></flags>
		<isDisposed public="1" set="method" line="68"><f a=""><x path="Bool"/></f></isDisposed>
		<dispose public="1" set="method" line="72"><f a=""><x path="Void"/></f></dispose>
		<totalVertices public="1" set="method" line="83">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the total number of vertices including the potential next buffers if it is split.</haxe_doc>
		</totalVertices>
		<uploadVector public="1" set="method" line="93">
			<f a="buf:bufPos:vertices:?startVertice" v=":::0">
				<x path="hxd.FloatBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ startVertice : 0 }</e></m></meta>
		</uploadVector>
		<uploadBytes public="1" set="method" line="110"><f a="data:dataPos:vertices">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uploadBytes>
		<readBytes public="1" set="method" line="122">
			<f a="bytes:bytesPosition:vertices:?startVertice" v=":::0">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ startVertice : 0 }</e></m></meta>
		</readBytes>
		<new public="1" set="method" line="48"><f a="vertices:stride:?flags">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><e path="h3d.BufferFlag"/></c>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.BufferOffset" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/Buffer.hx" module="h3d.Buffer">
		<buffer public="1"><c path="h3d.Buffer"/></buffer>
		<offset public="1"><x path="Int"/></offset>
		<next public="1"><c path="h3d.BufferOffset"/></next>
		<clone public="1" get="inline" set="null" line="176"><f a=""><c path="h3d.BufferOffset"/></f></clone>
		<dispose public="1" set="method" line="184"><f a=""><x path="Void"/></f></dispose>
		<new public="1" set="method" line="168"><f a="buffer:offset">
	<c path="h3d.Buffer"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.Camera" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/Camera.hx">
		<zoom public="1"><x path="Float"/></zoom>
		<screenRatio public="1">
			<x path="Float"/>
			<haxe_doc>The screenRatio represents the W/H screen ratio.</haxe_doc>
		</screenRatio>
		<fovY public="1">
			<x path="Float"/>
			<haxe_doc>The vertical FieldOfView, in degrees.
		Usually cameras are using an horizontal FOV, but the value will change depending on the screen ratio.
		For instance a 4:3 screen will have a lower horizontal FOV than a 16:9 one, however the vertical FOV remains constant.
		Use setFovX to initialize fovY based on an horizontal FOV and an initial screen ratio.</haxe_doc>
		</fovY>
		<zNear public="1"><x path="Float"/></zNear>
		<zFar public="1"><x path="Float"/></zFar>
		<orthoBounds public="1">
			<c path="h3d.col.Bounds"/>
			<haxe_doc>Set orthographic bounds.</haxe_doc>
		</orthoBounds>
		<rightHanded public="1"><x path="Bool"/></rightHanded>
		<mproj public="1"><c path="h3d.Matrix"/></mproj>
		<mcam public="1"><c path="h3d.Matrix"/></mcam>
		<m public="1"><c path="h3d.Matrix"/></m>
		<pos public="1"><c path="h3d.Vector"/></pos>
		<up public="1"><c path="h3d.Vector"/></up>
		<target public="1"><c path="h3d.Vector"/></target>
		<viewX public="1" expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</viewX>
		<viewY public="1" expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</viewY>
		<follow public="1"><a>
	<target><c path="h3d.scene.Object"/></target>
	<pos><c path="h3d.scene.Object"/></pos>
</a></follow>
		<frustum public="1" set="null"><c path="h3d.col.Frustum"/></frustum>
		<minv><c path="h3d.Matrix"/></minv>
		<mcamInv><c path="h3d.Matrix"/></mcamInv>
		<mprojInv><c path="h3d.Matrix"/></mprojInv>
		<needInv><x path="Bool"/></needInv>
		<setFovX public="1" set="method" line="71">
			<f a="fovX:withRatio">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Set the vertical fov based on a given horizontal fov (in degrees) for a specified screen ratio.</haxe_doc>
		</setFovX>
		<getFovX public="1" set="method" line="79">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Calculate the current horizontal fov (in degrees).</haxe_doc>
		</getFovX>
		<clone public="1" set="method" line="86"><f a=""><c path="h3d.Camera"/></f></clone>
		<getInverseViewProj public="1" set="method" line="98">
			<f a=""><c path="h3d.Matrix"/></f>
			<haxe_doc>Returns the inverse of the camera matrix view and projection. Cache the result until the next update().</haxe_doc>
		</getInverseViewProj>
		<getInverseProj public="1" set="method" line="110">
			<f a=""><c path="h3d.Matrix"/></f>
			<haxe_doc>Returns the inverse of the camera matrix projection. Cache the result until the next update().</haxe_doc>
		</getInverseProj>
		<getInverseView public="1" set="method" line="123">
			<f a=""><c path="h3d.Matrix"/></f>
			<haxe_doc>Returns the inverse of the camera matrix view only. Cache the result until the next update().</haxe_doc>
		</getInverseView>
		<setCubeMap public="1" set="method" line="136">
			<f a="face:?position">
				<x path="Int"/>
				<c path="h3d.Vector"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Setup camera for cubemap rendering on the given face.</haxe_doc>
		</setCubeMap>
		<unproject public="1" set="method" line="158">
			<f a="screenX:screenY:camZ">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="h3d.Vector"/>
			</f>
			<haxe_doc>Transforms a 2D screen position into the 3D one according to the current camera.
		The screenX and screenY values must be in the [-1,1] range.
		The camZ value represents the normalized z in the frustum in the [0,1] range.
		[unproject] can be used to get the ray from the camera position to a given screen position by using two different camZ values.
		For instance the 3D ray between unproject(0,0,0) and unproject(0,0,1) is the center axis of the 3D frustum.</haxe_doc>
		</unproject>
		<rayFromScreen public="1" set="method" line="164"><f a="pixelX:pixelY">
	<x path="Float"/>
	<x path="Float"/>
	<c path="h3d.col.Ray"/>
</f></rayFromScreen>
		<update public="1" set="method" line="171"><f a=""><x path="Void"/></f></update>
		<getFrustumCorners public="1" set="method" line="204">
			<f a="?zMax" v="1.">
				<x path="Float"/>
				<c path="Array"><c path="h3d.Vector"/></c>
			</f>
			<meta><m n=":value"><e>{ zMax : 1. }</e></m></meta>
		</getFrustumCorners>
		<lostUp public="1" set="method" line="211"><f a=""><x path="Bool"/></f></lostUp>
		<movePosAxis public="1" set="method" line="217">
			<f a="dx:dy:?dz" v="::0.">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ dz : 0. }</e></m></meta>
		</movePosAxis>
		<moveTargetAxis public="1" set="method" line="225">
			<f a="dx:dy:?dz" v="::0.">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ dz : 0. }</e></m></meta>
		</moveTargetAxis>
		<forward public="1" set="method" line="233">
			<f a="?speed" v="1.">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ speed : 1. }</e></m></meta>
		</forward>
		<backward public="1" set="method" line="242">
			<f a="?speed" v="1.">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ speed : 1. }</e></m></meta>
		</backward>
		<makeCameraMatrix set="method" line="251"><f a="m">
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></makeCameraMatrix>
		<makeFrustumMatrix set="method" line="284"><f a="m">
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></makeFrustumMatrix>
		<project public="1" set="method" line="342">
			<f a="x:y:z:screenWidth:screenHeight:?snapToPixel" v=":::::true">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="h3d.Vector"/>
			</f>
			<meta><m n=":value"><e>{ snapToPixel : true }</e></m></meta>
			<haxe_doc>Project a 3D point into the 2D screen. Make sure to update() the camera if it's been moved before using that.</haxe_doc>
		</project>
		<load public="1" set="method" line="354"><f a="cam">
	<c path="h3d.Camera"/>
	<x path="Void"/>
</f></load>
		<new public="1" set="method" line="51">
			<f a="?fovY:?zoom:?screenRatio:?zNear:?zFar:?rightHanded" v="25.:1.:1.333333:0.02:4000.:false">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ rightHanded : false, zFar : 4000., zNear : 0.02, screenRatio : 1.333333, zoom : 1., fovY : 25. }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d._Engine.TargetTmp" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/Engine.hx" private="1" module="h3d.Engine">
		<t public="1"><c path="h3d.mat.Texture"/></t>
		<textures public="1"><c path="Array"><c path="h3d.mat.Texture"/></c></textures>
		<next public="1"><c path="h3d._Engine.TargetTmp"/></next>
		<layer public="1"><x path="Int"/></layer>
		<mipLevel public="1"><x path="Int"/></mipLevel>
		<new public="1" set="method" line="10"><f a="t:n:l:m">
	<c path="h3d.mat.Texture"/>
	<c path="h3d._Engine.TargetTmp"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.Engine" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/Engine.hx">
		<SOFTWARE_DRIVER public="1" expr="false" line="56" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</SOFTWARE_DRIVER>
		<ANTIALIASING public="1" expr="0" line="57" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</ANTIALIASING>
		<CURRENT expr="null" line="87" static="1">
			<c path="h3d.Engine"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</CURRENT>
		<getCurrent public="1" get="inline" set="null" line="94" static="1"><f a=""><c path="h3d.Engine"/></f></getCurrent>
		<driver public="1" set="null"><c path="h3d.impl.Driver"/></driver>
		<mem public="1" set="null"><c path="h3d.impl.MemoryManager"/></mem>
		<hardware public="1" set="null"><x path="Bool"/></hardware>
		<width public="1" set="null"><x path="Int"/></width>
		<height public="1" set="null"><x path="Int"/></height>
		<debug public="1" set="accessor"><x path="Bool"/></debug>
		<drawTriangles public="1" set="null"><x path="Int"/></drawTriangles>
		<drawCalls public="1" set="null"><x path="Int"/></drawCalls>
		<shaderSwitches public="1" set="null"><x path="Int"/></shaderSwitches>
		<backgroundColor public="1" expr="0xFF000000">
			<x path="Null"><x path="Int"/></x>
			<meta><m n=":value"><e>0xFF000000</e></m></meta>
		</backgroundColor>
		<autoResize public="1"><x path="Bool"/></autoResize>
		<fullScreen public="1" set="accessor"><x path="Bool"/></fullScreen>
		<fps public="1" get="accessor" set="null"><x path="Float"/></fps>
		<realFps><x path="Float"/></realFps>
		<lastTime><x path="Float"/></lastTime>
		<antiAlias><x path="Int"/></antiAlias>
		<tmpVector expr="new h3d.Vector()">
			<c path="h3d.Vector"/>
			<meta><m n=":value"><e>new h3d.Vector()</e></m></meta>
		</tmpVector>
		<window><c path="hxd.Window"/></window>
		<targetTmp><c path="h3d._Engine.TargetTmp"/></targetTmp>
		<targetStack><c path="h3d._Engine.TargetTmp"/></targetStack>
		<currentTargetTex><c path="h3d.mat.Texture"/></currentTargetTex>
		<currentTargetLayer><x path="Int"/></currentTargetLayer>
		<currentTargetMip><x path="Int"/></currentTargetMip>
		<needFlushTarget><x path="Bool"/></needFlushTarget>
		<nullTexture><c path="h3d.mat.Texture"/></nullTexture>
		<textureColorCache expr="new Map&lt;Int,h3d.mat.Texture&gt;()">
			<x path="haxe.ds.Map">
				<x path="Int"/>
				<c path="h3d.mat.Texture"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new Map<Int,h3d.mat.Texture>()]]></e></m></meta>
		</textureColorCache>
		<ready public="1" set="null" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</ready>
		<resCache expr="new Map&lt;{ },Dynamic&gt;()">
			<x path="haxe.ds.Map">
				<a/>
				<d/>
			</x>
			<meta>
				<m n=":value"><e><![CDATA[new Map<{ },Dynamic>()]]></e></m>
				<m n=":allow"><e>hxd.res</e></m>
			</meta>
		</resCache>
		<setDriver public="1" set="method" line="89"><f a="d">
	<c path="h3d.impl.Driver"/>
	<x path="Void"/>
</f></setDriver>
		<setCurrent public="1" get="inline" set="null" line="98"><f a=""><x path="Void"/></f></setCurrent>
		<init public="1" set="method" line="102"><f a=""><x path="Void"/></f></init>
		<driverName public="1" set="method" line="106">
			<f a="?details" v="false">
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ details : false }</e></m></meta>
		</driverName>
		<selectShader public="1" set="method" line="110"><f a="shader">
	<c path="hxsl.RuntimeShader"/>
	<x path="Void"/>
</f></selectShader>
		<selectMaterial public="1" set="method" line="116"><f a="pass">
	<c path="h3d.mat.Pass"/>
	<x path="Void"/>
</f></selectMaterial>
		<uploadShaderBuffers public="1" set="method" line="120"><f a="buffers:which">
	<c path="h3d.shader.Buffers"/>
	<x path="h3d.shader.BufferKind"/>
	<x path="Void"/>
</f></uploadShaderBuffers>
		<selectBuffer set="method" line="124"><f a="buf">
	<c path="h3d.Buffer"/>
	<x path="Bool"/>
</f></selectBuffer>
		<renderTriBuffer public="1" get="inline" set="null" line="132">
			<f a="b:?start:?max" v=":0:-1">
				<c path="h3d.Buffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ max : -1, start : 0 }</e></m></meta>
		</renderTriBuffer>
		<renderQuadBuffer public="1" get="inline" set="null" line="136">
			<f a="b:?start:?max" v=":0:-1">
				<c path="h3d.Buffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ max : -1, start : 0 }</e></m></meta>
		</renderQuadBuffer>
		<renderBuffer set="method" line="141">
			<f a="b:indexes:vertPerTri:?startTri:?drawTri" v=":::0:-1">
				<c path="h3d.Buffer"/>
				<c path="h3d.Indexes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ drawTri : -1, startTri : 0 }</e></m></meta>
		</renderBuffer>
		<renderIndexed public="1" set="method" line="176">
			<f a="b:indexes:?startTri:?drawTri" v="::0:-1">
				<c path="h3d.Buffer"/>
				<c path="h3d.Indexes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ drawTri : -1, startTri : 0 }</e></m></meta>
		</renderIndexed>
		<renderMultiBuffers public="1" set="method" line="191">
			<f a="buffers:indexes:?startTri:?drawTri" v="::0:-1">
				<c path="h3d.BufferOffset"/>
				<c path="h3d.Indexes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ drawTri : -1, startTri : 0 }</e></m></meta>
		</renderMultiBuffers>
		<renderInstanced public="1" set="method" line="207"><f a="buffers:indexes:commands">
	<c path="h3d.BufferOffset"/>
	<c path="h3d.Indexes"/>
	<c path="h3d.impl.InstanceBuffer"/>
	<x path="Void"/>
</f></renderInstanced>
		<set_debug set="method" line="219"><f a="d">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_debug>
		<onCreate set="method" line="225"><f a="disposed">
	<x path="Bool"/>
	<x path="Void"/>
</f></onCreate>
		<onContextLost public="1" set="dynamic" line="250"><f a=""><x path="Void"/></f></onContextLost>
		<onReady public="1" set="dynamic" line="253"><f a=""><x path="Void"/></f></onReady>
		<onWindowResize set="method" line="256"><f a=""><x path="Void"/></f></onWindowResize>
		<set_fullScreen set="method" line="265"><f a="v">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_fullScreen>
		<onResized public="1" set="dynamic" line="273"><f a=""><x path="Void"/></f></onResized>
		<resize public="1" set="method" line="276"><f a="width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></resize>
		<begin public="1" set="method" line="285"><f a=""><x path="Bool"/></f></begin>
		<hasFeature public="1" set="method" line="302"><f a="f">
	<e path="h3d.impl.Feature"/>
	<x path="Bool"/>
</f></hasFeature>
		<end public="1" set="method" line="306"><f a=""><x path="Void"/></f></end>
		<getCurrentTarget public="1" set="method" line="310"><f a=""><x path="Null"><c path="h3d.mat.Texture"/></x></f></getCurrentTarget>
		<pushTarget public="1" set="method" line="314">
			<f a="tex:?layer:?mipLevel" v=":0:0">
				<c path="h3d.mat.Texture"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ mipLevel : 0, layer : 0 }</e></m></meta>
		</pushTarget>
		<updateNeedFlush set="method" line="329"><f a=""><x path="Void"/></f></updateNeedFlush>
		<pushTargets public="1" set="method" line="337"><f a="textures">
	<c path="Array"><c path="h3d.mat.Texture"/></c>
	<x path="Void"/>
</f></pushTargets>
		<popTarget public="1" set="method" line="343"><f a=""><x path="Void"/></f></popTarget>
		<flushTarget get="inline" set="null" line="356"><f a=""><x path="Void"/></f></flushTarget>
		<doFlushTarget set="method" line="360"><f a=""><x path="Void"/></f></doFlushTarget>
		<clearF public="1" set="method" line="377"><f a="color:?depth:?stencil">
	<c path="h3d.Vector"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></clearF>
		<clear public="1" set="method" line="382"><f a="?color:?depth:?stencil">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></clear>
		<setRenderZone public="1" set="method" line="393">
			<f a="?x:?y:?width:?height" v="0:0:-1:-1">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ height : -1, width : -1, y : 0, x : 0 }</e></m></meta>
			<haxe_doc>* Sets up a scissored zone to eliminate pixels outside the given range.
	 * Call with no parameters to reset to full viewport.</haxe_doc>
		</setRenderZone>
		<render public="1" set="method" line="398"><f a="obj">
	<a><render set="method"><f a="engine">
	<c path="h3d.Engine"/>
	<x path="Void"/>
</f></render></a>
	<x path="Bool"/>
</f></render>
		<dispose public="1" set="method" line="415"><f a=""><x path="Void"/></f></dispose>
		<get_fps set="method" line="420"><f a=""><x path="Float"/></f></get_fps>
		<new set="method" line="60">
			<f a=""><x path="Void"/></f>
			<meta><m n=":access"><e>hxd.Window</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.Indexes" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/Indexes.hx">
		<alloc public="1" set="method" line="46" static="1">
			<f a="i:?startPos:?length" v=":0:-1">
				<x path="hxd.IndexBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="h3d.Indexes"/>
			</f>
			<meta><m n=":value"><e>{ length : -1, startPos : 0 }</e></m></meta>
		</alloc>
		<mem><c path="h3d.impl.MemoryManager"/></mem>
		<ibuf><t path="h3d.impl.IndexBuffer"/></ibuf>
		<is32 public="1" set="null"><x path="Bool"/></is32>
		<count public="1" set="null"><x path="Int"/></count>
		<isDisposed public="1" set="method" line="25"><f a=""><x path="Bool"/></f></isDisposed>
		<upload public="1" set="method" line="29">
			<f a="indexes:pos:count:?bufferPos" v=":::0">
				<x path="hxd.IndexBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ bufferPos : 0 }</e></m></meta>
		</upload>
		<uploadBytes public="1" set="method" line="33"><f a="bytes:dataPos:indices">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uploadBytes>
		<readBytes public="1" set="method" line="37">
			<f a="bytes:bytesPosition:indices:?startIndice" v=":::0">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ startIndice : 0 }</e></m></meta>
		</readBytes>
		<dispose public="1" set="method" line="41"><f a=""><x path="Void"/></f></dispose>
		<new public="1" set="method" line="15">
			<f a="count:?is32" v=":false">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ is32 : false }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>h3d.impl.MemoryManager</e></m>
			<m n=":allow"><e>h3d.Engine</e></m>
		</meta>
	</class>
	<typedef path="h3d.ColorAdjust" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/Matrix.hx" module="h3d.Matrix"><a>
	<saturation>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
	</saturation>
	<lightness>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
	</lightness>
	<hue>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
	</hue>
	<gain>
		<x path="Null"><a>
	<color><x path="Int"/></color>
	<alpha><x path="Float"/></alpha>
</a></x>
		<meta><m n=":optional"/></meta>
	</gain>
	<contrast>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
	</contrast>
</a></typedef>
	<class path="h3d.Quat" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/Quat.hx">
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<z public="1"><x path="Float"/></z>
		<w public="1"><x path="Float"/></w>
		<set public="1" get="inline" set="null" line="19"><f a="x:y:z:w">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></set>
		<identity public="1" get="inline" set="null" line="26"><f a=""><x path="Void"/></f></identity>
		<lengthSq public="1" get="inline" set="null" line="31"><f a=""><x path="Float"/></f></lengthSq>
		<length public="1" get="inline" set="null" line="35"><f a=""><x path="Float"/></f></length>
		<load public="1" get="inline" set="null" line="39"><f a="q">
	<c path="h3d.Quat"/>
	<x path="Void"/>
</f></load>
		<clone public="1" set="method" line="46"><f a=""><c path="h3d.Quat"/></f></clone>
		<initMoveTo public="1" set="method" line="50"><f a="from:to">
	<c path="h3d.Vector"/>
	<c path="h3d.Vector"/>
	<x path="Void"/>
</f></initMoveTo>
		<initDirection public="1" set="method" line="66"><f a="dir">
	<c path="h3d.Vector"/>
	<x path="Void"/>
</f></initDirection>
		<initRotateAxis public="1" set="method" line="108"><f a="x:y:z:a">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></initRotateAxis>
		<initRotateMatrix public="1" set="method" line="118"><f a="m">
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></initRotateMatrix>
		<normalize public="1" set="method" line="151"><f a=""><x path="Void"/></f></normalize>
		<initRotation public="1" set="method" line="165"><f a="ax:ay:az">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></initRotation>
		<multiply public="1" set="method" line="180"><f a="q1:q2">
	<c path="h3d.Quat"/>
	<c path="h3d.Quat"/>
	<x path="Void"/>
</f></multiply>
		<toEuler public="1" set="method" line="191"><f a=""><c path="h3d.Vector"/></f></toEuler>
		<lerp public="1" get="inline" set="null" line="195">
			<f a="q1:q2:v:?nearest" v=":::false">
				<c path="h3d.Quat"/>
				<c path="h3d.Quat"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ nearest : false }</e></m></meta>
		</lerp>
		<slerp public="1" set="method" line="211"><f a="q1:q2:v">
	<c path="h3d.Quat"/>
	<c path="h3d.Quat"/>
	<x path="Float"/>
	<x path="Void"/>
</f></slerp>
		<conjugate public="1" get="inline" set="null" line="234"><f a=""><x path="Void"/></f></conjugate>
		<negate public="1" get="inline" set="null" line="243">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Negate the quaternion: this will not change the actual angle, use `conjugate` for that.</haxe_doc>
		</negate>
		<dot public="1" get="inline" set="null" line="250"><f a="q">
	<c path="h3d.Quat"/>
	<x path="Float"/>
</f></dot>
		<getDirection public="1" get="inline" set="null" line="254"><f a=""><c path="h3d.Vector"/></f></getDirection>
		<toMatrix public="1" set="method" line="261">
			<f a="?m">
				<c path="h3d.Matrix"/>
				<x path="Null"><c path="h3d.Matrix"/></x>
			</f>
			<haxe_doc>Save to a Left-Handed matrix</haxe_doc>
		</toMatrix>
		<toString public="1" set="method" line="291"><f a=""><c path="String"/></f></toString>
		<new public="1" get="inline" set="null" line="12">
			<f a="?x:?y:?z:?w" v="0.:0.:0.:1.">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ w : 1., z : 0., y : 0., x : 0. }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="h3d.anim.AnimatedObject" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/anim/Animation.hx" module="h3d.anim.Animation">
		<objectName public="1"><c path="String"/></objectName>
		<targetObject public="1"><c path="h3d.scene.Object"/></targetObject>
		<targetSkin public="1"><c path="h3d.scene.Skin"/></targetSkin>
		<targetJoint public="1"><x path="Int"/></targetJoint>
		<clone public="1" set="method" line="16"><f a=""><c path="h3d.anim.AnimatedObject"/></f></clone>
		<new public="1" set="method" line="12"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="h3d.anim.Animation" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/anim/Animation.hx">
		<implements path="hxd.impl._Serializable.NoSerializeSupport"/>
		<EPSILON get="inline" set="null" expr="0.000001" line="24" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.000001</e></m></meta>
		</EPSILON>
		<name public="1">
			<c path="String"/>
			<meta><m n=":s"/></meta>
		</name>
		<resourcePath public="1">
			<c path="String"/>
			<meta><m n=":s"/></meta>
		</resourcePath>
		<frameCount public="1" set="null">
			<x path="Int"/>
			<meta><m n=":s"/></meta>
		</frameCount>
		<sampling public="1" set="null">
			<x path="Float"/>
			<meta><m n=":s"/></meta>
		</sampling>
		<frame public="1" set="null">
			<x path="Float"/>
			<meta><m n=":s"/></meta>
		</frame>
		<speed public="1">
			<x path="Float"/>
			<meta><m n=":s"/></meta>
		</speed>
		<onAnimEnd public="1"><f a=""><x path="Void"/></f></onAnimEnd>
		<onEvent public="1"><f a="">
	<c path="String"/>
	<x path="Void"/>
</f></onEvent>
		<pause public="1">
			<x path="Bool"/>
			<meta><m n=":s"/></meta>
		</pause>
		<loop public="1">
			<x path="Bool"/>
			<meta><m n=":s"/></meta>
		</loop>
		<events public="1" set="null"><c path="Array"><c path="Array"><c path="String"/></c></c></events>
		<isInstance><x path="Bool"/></isInstance>
		<objects><c path="Array"><c path="h3d.anim.AnimatedObject"/></c></objects>
		<isSync><x path="Bool"/></isSync>
		<lastEvent><x path="Int"/></lastEvent>
		<getDuration public="1" set="method" line="58"><f a=""><x path="Float"/></f></getDuration>
		<getIFrame get="inline" set="null" line="62"><f a=""><x path="Int"/></f></getIFrame>
		<unbind public="1" set="method" line="69"><f a="objectName">
	<c path="String"/>
	<x path="Void"/>
</f></unbind>
		<setEvents public="1" set="method" line="84">
			<f a="el">
				<t path="Iterable"><a>
	<frame><x path="Int"/></frame>
	<data><c path="String"/></data>
</a></t>
				<x path="Void"/>
			</f>
			<haxe_doc>Register a callback function that will be called once when a frame is reached.</haxe_doc>
		</setEvents>
		<addEvent public="1" set="method" line="92"><f a="frame:data">
	<x path="Int"/>
	<c path="String"/>
	<x path="Void"/>
</f></addEvent>
		<getEvents public="1" set="method" line="101"><f a=""><c path="Array"><c path="Array"><c path="String"/></c></c></f></getEvents>
		<getObjects public="1" set="method" line="103"><f a=""><c path="Array"><c path="h3d.anim.AnimatedObject"/></c></f></getObjects>
		<setFrame public="1" set="method" line="105"><f a="f">
	<x path="Float"/>
	<x path="Void"/>
</f></setFrame>
		<clone set="method" line="112"><f a="?a">
	<c path="h3d.anim.Animation"/>
	<c path="h3d.anim.Animation"/>
</f></clone>
		<initInstance set="method" line="124"><f a=""><x path="Void"/></f></initInstance>
		<createInstance public="1" set="method" line="129"><f a="base">
	<c path="h3d.scene.Object"/>
	<c path="h3d.anim.Animation"/>
</f></createInstance>
		<bind public="1" set="method" line="142">
			<f a="base">
				<c path="h3d.scene.Object"/>
				<x path="Void"/>
			</f>
			<meta><m n=":access"><e>h3d.scene.Skin.skinData</e></m></meta>
			<haxe_doc>If one of the animated object has been changed, it is necessary to call bind() so the animation can keep with the change.</haxe_doc>
		</bind>
		<getPropValue public="1" set="method" line="175">
			<f a="objectName:propName">
				<c path="String"/>
				<c path="String"/>
				<x path="Null"><x path="Float"/></x>
			</f>
			<haxe_doc>Returns the current value of animation property for the given object, or null if not found.</haxe_doc>
		</getPropValue>
		<sync public="1" set="method" line="183">
			<f a="?decompose" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ decompose : false }</e></m></meta>
			<haxe_doc>Synchronize the target object matrix.
		If decompose is true, then the rotation quaternion is stored in [m12,m13,m21,m23] instead of mixed with the scale.</haxe_doc>
		</sync>
		<isPlaying set="method" line="188"><f a=""><x path="Bool"/></f></isPlaying>
		<endFrame set="method" line="192"><f a=""><x path="Int"/></f></endFrame>
		<update public="1" set="method" line="196"><f a="dt">
	<x path="Float"/>
	<x path="Float"/>
</f></update>
		<initAndBind set="method" line="260"><f a="obj">
	<c path="h3d.scene.Object"/>
	<x path="Void"/>
</f></initAndBind>
		<toString public="1" set="method" line="267"><f a=""><c path="String"/></f></toString>
		<new set="method" line="46"><f a="name:frameCount:sampling">
	<c path="String"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<enum path="h3d.anim.DataLayout" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/anim/BufferAnimation.hx" module="h3d.anim.BufferAnimation">
		<Position/>
		<Rotation/>
		<Scale/>
		<UV/>
		<Alpha/>
		<Property/>
		<SingleFrame/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="h3d.anim.BufferObject" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/anim/BufferAnimation.hx" module="h3d.anim.BufferAnimation">
		<extends path="h3d.anim.AnimatedObject"/>
		<layout public="1"><x path="haxe.EnumFlags"><e path="h3d.anim.DataLayout"/></x></layout>
		<dataOffset public="1"><x path="Int"/></dataOffset>
		<propCurrentValue public="1"><x path="Float"/></propCurrentValue>
		<propName public="1"><c path="String"/></propName>
		<matrix public="1"><c path="h3d.Matrix"/></matrix>
		<getStride public="1" set="method" line="28"><f a=""><x path="Int"/></f></getStride>
		<clone public="1" set="method" line="39" override="1"><f a=""><c path="h3d.anim.AnimatedObject"/></f></clone>
		<new public="1" set="method" line="23"><f a="objectName:dataOffset">
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.anim.BufferAnimation" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/anim/BufferAnimation.hx">
		<extends path="h3d.anim.Animation"/>
		<syncFrame><x path="Float"/></syncFrame>
		<data><t path="hxd.impl.Float32Array"/></data>
		<stride><x path="Int"/></stride>
		<setData public="1" set="method" line="58"><f a="data:stride">
	<t path="hxd.impl.Float32Array"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setData>
		<addObject public="1" set="method" line="63"><f a="objName:offset">
	<c path="String"/>
	<x path="Int"/>
	<c path="h3d.anim.BufferObject"/>
</f></addObject>
		<getPropValue public="1" set="method" line="69" override="1"><f a="objName:propName">
	<c path="String"/>
	<c path="String"/>
	<x path="Null"><x path="Float"/></x>
</f></getPropValue>
		<getFrames get="inline" set="null" line="76"><f a=""><c path="Array"><c path="h3d.anim.BufferObject"/></c></f></getFrames>
		<clone set="method" line="80" override="1"><f a="?a">
	<c path="h3d.anim.Animation"/>
	<x path="Null"><c path="h3d.anim.Animation"/></x>
</f></clone>
		<endFrame set="method" line="89" override="1"><f a=""><x path="Int"/></f></endFrame>
		<initInstance set="method" line="95" override="1"><f a=""><x path="Void"/></f></initInstance>
		<sortByFrameCountDesc set="method" line="119"><f a="o1:o2">
	<c path="h3d.anim.BufferObject"/>
	<c path="h3d.anim.BufferObject"/>
	<x path="Int"/>
</f></sortByFrameCountDesc>
		<uvLerp get="inline" set="null" line="123"><f a="v1:v2:k">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></uvLerp>
		<sync public="1" set="method" line="135" override="1">
			<f a="?decompose" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ decompose : false }</e></m>
				<m n=":access"><e>h3d.scene.Skin</e></m>
				<m n=":noDebug"/>
			</meta>
		</sync>
		<new public="1" set="method" line="53"><f a="name:frame:sampling">
	<c path="String"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.anim.LinearFrame" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/anim/LinearAnimation.hx" module="h3d.anim.LinearAnimation">
		<tx public="1"><x path="Float"/></tx>
		<ty public="1"><x path="Float"/></ty>
		<tz public="1"><x path="Float"/></tz>
		<qx public="1"><x path="Float"/></qx>
		<qy public="1"><x path="Float"/></qy>
		<qz public="1"><x path="Float"/></qz>
		<qw public="1"><x path="Float"/></qw>
		<sx public="1"><x path="Float"/></sx>
		<sy public="1"><x path="Float"/></sy>
		<sz public="1"><x path="Float"/></sz>
		<toMatrix public="1" set="method" line="17"><f a=""><c path="h3d.Matrix"/></f></toMatrix>
		<new public="1" set="method" line="15"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.anim.LinearObject" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/anim/LinearAnimation.hx" module="h3d.anim.LinearAnimation">
		<extends path="h3d.anim.AnimatedObject"/>
		<hasPosition public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</hasPosition>
		<hasRotation public="1"><x path="Bool"/></hasRotation>
		<hasScale public="1"><x path="Bool"/></hasScale>
		<frames public="1"><x path="haxe.ds.Vector"><c path="h3d.anim.LinearFrame"/></x></frames>
		<alphas public="1"><x path="haxe.ds.Vector"><x path="Float"/></x></alphas>
		<uvs public="1"><x path="haxe.ds.Vector"><x path="Float"/></x></uvs>
		<propName public="1"><c path="String"/></propName>
		<propValues public="1"><x path="haxe.ds.Vector"><x path="Float"/></x></propValues>
		<matrix public="1"><c path="h3d.Matrix"/></matrix>
		<propCurrentValue public="1"><x path="Float"/></propCurrentValue>
		<clone public="1" set="method" line="37" override="1"><f a=""><c path="h3d.anim.AnimatedObject"/></f></clone>
		<new public="1" set="method" line="26"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.anim.LinearAnimation" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/anim/LinearAnimation.hx">
		<extends path="h3d.anim.Animation"/>
		<syncFrame><x path="Float"/></syncFrame>
		<addCurve public="1" set="method" line="60"><f a="objName:frames:hasPos:hasRot:hasScale">
	<c path="String"/>
	<x path="haxe.ds.Vector"><c path="h3d.anim.LinearFrame"/></x>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></addCurve>
		<addAlphaCurve public="1" set="method" line="69"><f a="objName:alphas">
	<c path="String"/>
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<x path="Void"/>
</f></addAlphaCurve>
		<addUVCurve public="1" set="method" line="75"><f a="objName:uvs">
	<c path="String"/>
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<x path="Void"/>
</f></addUVCurve>
		<addPropCurve public="1" set="method" line="81"><f a="objName:propName:values">
	<c path="String"/>
	<c path="String"/>
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<x path="Void"/>
</f></addPropCurve>
		<getPropValue public="1" set="method" line="88" override="1"><f a="objName:propName">
	<c path="String"/>
	<c path="String"/>
	<x path="Null"><x path="Float"/></x>
</f></getPropValue>
		<getFrames get="inline" set="null" line="95"><f a=""><c path="Array"><c path="h3d.anim.LinearObject"/></c></f></getFrames>
		<clone set="method" line="99" override="1"><f a="?a">
	<c path="h3d.anim.Animation"/>
	<x path="Null"><c path="h3d.anim.Animation"/></x>
</f></clone>
		<endFrame set="method" line="106" override="1"><f a=""><x path="Int"/></f></endFrame>
		<initInstance set="method" line="112" override="1"><f a=""><x path="Void"/></f></initInstance>
		<sortByFrameCountDesc set="method" line="130"><f a="o1:o2">
	<c path="h3d.anim.LinearObject"/>
	<c path="h3d.anim.LinearObject"/>
	<x path="Int"/>
</f></sortByFrameCountDesc>
		<uvLerp get="inline" set="null" line="134"><f a="v1:v2:k">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></uvLerp>
		<sync public="1" set="method" line="146" override="1">
			<f a="?decompose" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ decompose : false }</e></m>
				<m n=":access"><e>h3d.scene.Skin</e></m>
				<m n=":noDebug"/>
			</meta>
		</sync>
		<new public="1" set="method" line="55"><f a="name:frame:sampling">
	<c path="String"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.anim.Joint" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/anim/Skin.hx" module="h3d.anim.Skin">
		<index public="1"><x path="Int"/></index>
		<name public="1"><c path="String"/></name>
		<bindIndex public="1"><x path="Int"/></bindIndex>
		<splitIndex public="1"><x path="Int"/></splitIndex>
		<defMat public="1"><c path="h3d.Matrix"/></defMat>
		<transPos public="1"><c path="h3d.Matrix"/></transPos>
		<parent public="1"><c path="h3d.anim.Joint"/></parent>
		<subs public="1"><c path="Array"><c path="h3d.anim.Joint"/></c></subs>
		<retargetAnim public="1">
			<x path="Bool"/>
			<haxe_doc>When animated, we will use the default bind pose translation instead of the animated translation,
		enabling retargeting on a skeleton with different proportions</haxe_doc>
		</retargetAnim>
		<new public="1" set="method" line="19"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.anim._Skin.Permut" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/anim/Skin.hx" private="1" module="h3d.anim.Skin">
		<joints public="1"><c path="Array"><c path="h3d.anim.Joint"/></c></joints>
		<triangles public="1"><c path="Array"><x path="Int"/></c></triangles>
		<material public="1"><x path="Int"/></material>
		<indexedJoints public="1"><c path="Array"><c path="h3d.anim.Joint"/></c></indexedJoints>
		<new public="1" set="method" line="32"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.anim._Skin.Influence" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/anim/Skin.hx" private="1" module="h3d.anim.Skin">
		<j public="1"><c path="h3d.anim.Joint"/></j>
		<w public="1"><x path="Float"/></w>
		<new public="1" set="method" line="39"><f a="j:w">
	<c path="h3d.anim.Joint"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.anim.Skin" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/anim/Skin.hx">
		<name public="1"><c path="String"/></name>
		<vertexCount public="1" set="null"><x path="Int"/></vertexCount>
		<bonesPerVertex public="1" set="null"><x path="Int"/></bonesPerVertex>
		<vertexJoints public="1"><x path="haxe.ds.Vector"><x path="Int"/></x></vertexJoints>
		<vertexWeights public="1"><x path="haxe.ds.Vector"><x path="Float"/></x></vertexWeights>
		<rootJoints public="1" set="null"><c path="Array"><c path="h3d.anim.Joint"/></c></rootJoints>
		<namedJoints public="1" set="null"><t path="Map">
	<c path="String"/>
	<c path="h3d.anim.Joint"/>
</t></namedJoints>
		<allJoints public="1" set="null"><c path="Array"><c path="h3d.anim.Joint"/></c></allJoints>
		<boundJoints public="1" set="null"><c path="Array"><c path="h3d.anim.Joint"/></c></boundJoints>
		<primitive public="1"><c path="h3d.prim.Primitive"/></primitive>
		<splitJoints public="1" set="null"><c path="Array"><a>
	<material><x path="Int"/></material>
	<joints><c path="Array"><c path="h3d.anim.Joint"/></c></joints>
</a></c></splitJoints>
		<triangleGroups public="1"><x path="haxe.ds.Vector"><x path="Int"/></x></triangleGroups>
		<envelop><c path="Array"><c path="Array"><c path="h3d.anim._Skin.Influence"/></c></c></envelop>
		<setJoints public="1" set="method" line="77"><f a="joints:roots">
	<c path="Array"><c path="h3d.anim.Joint"/></c>
	<c path="Array"><c path="h3d.anim.Joint"/></c>
	<x path="Void"/>
</f></setJoints>
		<addInfluence public="1" get="inline" set="null" line="86"><f a="vid:j:w">
	<x path="Int"/>
	<c path="h3d.anim.Joint"/>
	<x path="Float"/>
	<x path="Void"/>
</f></addInfluence>
		<sortInfluences set="method" line="93"><f a="i1:i2">
	<c path="h3d.anim._Skin.Influence"/>
	<c path="h3d.anim._Skin.Influence"/>
	<x path="Int"/>
</f></sortInfluences>
		<isSplit public="1" get="inline" set="null" line="97"><f a=""><x path="Bool"/></f></isSplit>
		<initWeights public="1" set="method" line="101"><f a=""><x path="Void"/></f></initWeights>
		<sortByBindIndex set="method" line="133"><f a="j1:j2">
	<c path="h3d.anim.Joint"/>
	<c path="h3d.anim.Joint"/>
	<x path="Int"/>
</f></sortByBindIndex>
		<isSub set="method" line="137"><f a="a:b">
	<c path="Array"><c path="h3d.anim.Joint"/></c>
	<c path="Array"><c path="h3d.anim.Joint"/></c>
	<x path="Bool"/>
</f></isSub>
		<merge set="method" line="149"><f a="permuts">
	<c path="Array"><c path="h3d.anim._Skin.Permut"/></c>
	<x path="Bool"/>
</f></merge>
		<jointsDiff set="method" line="161"><f a="p1:p2">
	<c path="h3d.anim._Skin.Permut"/>
	<c path="h3d.anim._Skin.Permut"/>
	<x path="Int"/>
</f></jointsDiff>
		<split public="1" set="method" line="182"><f a="maxBones:index:triangleMaterials">
	<x path="Int"/>
	<c path="Array"><x path="Int"/></c>
	<x path="Null"><c path="Array"><x path="Int"/></c></x>
	<x path="Bool"/>
</f></split>
		<new public="1" set="method" line="66"><f a="name:vertexCount:bonesPerVertex">
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.col.Collider" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/col/Collider.hx" interface="1">
		<extends path="hxd.impl._Serializable.NoSerializeSupport"/>
		<rayIntersection public="1" set="method">
			<f a="r:bestMatch">
				<c path="h3d.col.Ray"/>
				<x path="Bool"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the distance of intersection between the ray and the collider, or negative if no collision.
		If bestMatch is false, only negative/positive value needs to be returned, with no additional precision.</haxe_doc>
		</rayIntersection>
		<contains public="1" set="method"><f a="p">
	<c path="h3d.col.Point"/>
	<x path="Bool"/>
</f></contains>
		<inFrustum public="1" set="method"><f a="f:?localMatrix">
	<c path="h3d.col.Frustum"/>
	<c path="h3d.Matrix"/>
	<x path="Bool"/>
</f></inFrustum>
		<inSphere public="1" set="method"><f a="s">
	<c path="h3d.col.Sphere"/>
	<x path="Bool"/>
</f></inSphere>
	</class>
	<class path="h3d.col.Bounds" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/col/Bounds.hx">
		<implements path="h3d.col.Collider"/>
		<fromPoints public="1" get="inline" set="null" line="361" static="1"><f a="min:max">
	<c path="h3d.col.Point"/>
	<c path="h3d.col.Point"/>
	<c path="h3d.col.Bounds"/>
</f></fromPoints>
		<fromValues public="1" get="inline" set="null" line="368" static="1"><f a="x:y:z:dx:dy:dz">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="h3d.col.Bounds"/>
</f></fromValues>
		<xMin public="1"><x path="Float"/></xMin>
		<xMax public="1"><x path="Float"/></xMax>
		<yMin public="1"><x path="Float"/></yMin>
		<yMax public="1"><x path="Float"/></yMax>
		<zMin public="1"><x path="Float"/></zMin>
		<zMax public="1"><x path="Float"/></zMax>
		<xSize public="1" get="accessor" set="accessor"><x path="Float"/></xSize>
		<ySize public="1" get="accessor" set="accessor"><x path="Float"/></ySize>
		<zSize public="1" get="accessor" set="accessor"><x path="Float"/></zSize>
		<inFrustum public="1" get="inline" set="null" line="21"><f a="f:?m">
	<c path="h3d.col.Frustum"/>
	<c path="h3d.Matrix"/>
	<x path="Bool"/>
</f></inFrustum>
		<inSphere public="1" get="inline" set="null" line="27"><f a="s">
	<c path="h3d.col.Sphere"/>
	<x path="Bool"/>
</f></inSphere>
		<testPlane get="inline" set="null" line="33"><f a="p">
	<c path="h3d.col.Plane"/>
	<x path="Float"/>
</f></testPlane>
		<rayIntersection public="1" set="method" line="45"><f a="r:bestMatch">
	<c path="h3d.col.Ray"/>
	<x path="Bool"/>
	<x path="Float"/>
</f></rayIntersection>
		<inFrustumDetails public="1" set="method" line="73">
			<f a="mvp:?checkZ" v=":true">
				<c path="h3d.Matrix"/>
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ checkZ : true }</e></m></meta>
			<haxe_doc>* Check if the camera model-view-projection Matrix intersects with the Bounds. Returns -1 if outside, 0 if interests and 1 if fully inside.
	 * @param	mvp : the model-view-projection matrix to test against
	 * @param	checkZ : tells if we will check against the near/far plane</haxe_doc>
		</inFrustumDetails>
		<transform3x3 public="1" set="method" line="126"><f a="m">
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></transform3x3>
		<transform public="1" set="method" line="156"><f a="m">
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></transform>
		<collide public="1" get="inline" set="null" line="189"><f a="b">
	<c path="h3d.col.Bounds"/>
	<x path="Bool"/>
</f></collide>
		<contains public="1" get="inline" set="null" line="193"><f a="p">
	<c path="h3d.col.Point"/>
	<x path="Bool"/>
</f></contains>
		<add public="1" get="inline" set="null" line="197"><f a="b">
	<c path="h3d.col.Bounds"/>
	<x path="Void"/>
</f></add>
		<addPoint public="1" get="inline" set="null" line="206"><f a="p">
	<c path="h3d.col.Point"/>
	<x path="Void"/>
</f></addPoint>
		<addPos public="1" get="inline" set="null" line="215"><f a="x:y:z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></addPos>
		<intersection public="1" set="method" line="224"><f a="a:b">
	<c path="h3d.col.Bounds"/>
	<c path="h3d.col.Bounds"/>
	<x path="Void"/>
</f></intersection>
		<offset public="1" get="inline" set="null" line="239"><f a="dx:dy:dz">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></offset>
		<setMin public="1" get="inline" set="null" line="248"><f a="p">
	<c path="h3d.col.Point"/>
	<x path="Void"/>
</f></setMin>
		<setMax public="1" get="inline" set="null" line="254"><f a="p">
	<c path="h3d.col.Point"/>
	<x path="Void"/>
</f></setMax>
		<load public="1" set="method" line="260"><f a="b">
	<c path="h3d.col.Bounds"/>
	<x path="Void"/>
</f></load>
		<scalePivot public="1" get="inline" set="null" line="269"><f a="v">
	<x path="Float"/>
	<x path="Void"/>
</f></scalePivot>
		<scaleCenter public="1" set="method" line="279"><f a="v">
	<x path="Float"/>
	<x path="Void"/>
</f></scaleCenter>
		<getMin public="1" get="inline" set="null" line="294"><f a=""><c path="h3d.col.Point"/></f></getMin>
		<getCenter public="1" get="inline" set="null" line="298"><f a=""><c path="h3d.col.Point"/></f></getCenter>
		<getSize public="1" get="inline" set="null" line="302"><f a=""><c path="h3d.col.Point"/></f></getSize>
		<getMax public="1" get="inline" set="null" line="306"><f a=""><c path="h3d.col.Point"/></f></getMax>
		<get_xSize get="inline" set="null" line="310"><f a=""><x path="Float"/></f></get_xSize>
		<get_ySize get="inline" set="null" line="311"><f a=""><x path="Float"/></f></get_ySize>
		<get_zSize get="inline" set="null" line="312"><f a=""><x path="Float"/></f></get_zSize>
		<set_xSize get="inline" set="null" line="313"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_xSize>
		<set_ySize get="inline" set="null" line="314"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_ySize>
		<set_zSize get="inline" set="null" line="315"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_zSize>
		<isEmpty public="1" get="inline" set="null" line="317"><f a=""><x path="Bool"/></f></isEmpty>
		<empty public="1" get="inline" set="null" line="321"><f a=""><x path="Void"/></f></empty>
		<all public="1" get="inline" set="null" line="330"><f a=""><x path="Void"/></f></all>
		<clone public="1" get="inline" set="null" line="339"><f a=""><c path="h3d.col.Bounds"/></f></clone>
		<toString public="1" set="method" line="350"><f a=""><c path="String"/></f></toString>
		<toSphere public="1" get="inline" set="null" line="354"><f a=""><c path="h3d.col.Sphere"/></f></toSphere>
		<new public="1" get="inline" set="null" line="17"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.col.OptimizedCollider" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/col/Collider.hx" module="h3d.col.Collider">
		<implements path="h3d.col.Collider"/>
		<implements path="hxd.impl._Serializable.NoSerializeSupport"/>
		<a public="1">
			<c path="h3d.col.Collider"/>
			<meta><m n=":s"/></meta>
		</a>
		<b public="1">
			<c path="h3d.col.Collider"/>
			<meta><m n=":s"/></meta>
		</b>
		<rayIntersection public="1" set="method" line="26"><f a="r:bestMatch">
	<c path="h3d.col.Ray"/>
	<x path="Bool"/>
	<x path="Float"/>
</f></rayIntersection>
		<contains public="1" set="method" line="32"><f a="p">
	<c path="h3d.col.Point"/>
	<x path="Bool"/>
</f></contains>
		<inFrustum public="1" set="method" line="36"><f a="f:?m">
	<c path="h3d.col.Frustum"/>
	<c path="h3d.Matrix"/>
	<x path="Bool"/>
</f></inFrustum>
		<inSphere public="1" set="method" line="40"><f a="s">
	<c path="h3d.col.Sphere"/>
	<x path="Bool"/>
</f></inSphere>
		<new public="1" set="method" line="21"><f a="a:b">
	<c path="h3d.col.Collider"/>
	<c path="h3d.col.Collider"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.col.GroupCollider" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/col/Collider.hx" module="h3d.col.Collider">
		<implements path="h3d.col.Collider"/>
		<colliders public="1"><c path="Array"><c path="h3d.col.Collider"/></c></colliders>
		<rayIntersection public="1" set="method" line="61"><f a="r:bestMatch">
	<c path="h3d.col.Ray"/>
	<x path="Bool"/>
	<x path="Float"/>
</f></rayIntersection>
		<contains public="1" set="method" line="73"><f a="p">
	<c path="h3d.col.Point"/>
	<x path="Bool"/>
</f></contains>
		<inFrustum public="1" set="method" line="80"><f a="f:?m">
	<c path="h3d.col.Frustum"/>
	<c path="h3d.Matrix"/>
	<x path="Bool"/>
</f></inFrustum>
		<inSphere public="1" set="method" line="87"><f a="s">
	<c path="h3d.col.Sphere"/>
	<x path="Bool"/>
</f></inSphere>
		<new public="1" set="method" line="57"><f a="colliders">
	<c path="Array"><c path="h3d.col.Collider"/></c>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.col.FPoint" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/col/FPoint.hx">
		<x public="1"><t path="hxd.impl.Float32"/></x>
		<y public="1"><t path="hxd.impl.Float32"/></y>
		<z public="1"><t path="hxd.impl.Float32"/></z>
		<sub public="1" get="inline" set="null" line="16"><f a="p">
	<c path="h3d.col.FPoint"/>
	<c path="h3d.col.FPoint"/>
</f></sub>
		<add public="1" get="inline" set="null" line="20"><f a="p">
	<c path="h3d.col.FPoint"/>
	<c path="h3d.col.FPoint"/>
</f></add>
		<cross public="1" get="inline" set="null" line="24"><f a="p">
	<c path="h3d.col.FPoint"/>
	<c path="h3d.col.FPoint"/>
</f></cross>
		<dot public="1" get="inline" set="null" line="28"><f a="p">
	<c path="h3d.col.FPoint"/>
	<x path="Float"/>
</f></dot>
		<toString public="1" set="method" line="32"><f a=""><c path="String"/></f></toString>
		<new public="1" get="inline" set="null" line="10">
			<f a="?x:?y:?z" v="0.:0.:0.">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ z : 0., y : 0., x : 0. }</e></m></meta>
		</new>
	</class>
	<class path="h3d.col.Frustum" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/col/Frustum.hx">
		<pleft public="1"><c path="h3d.col.Plane"/></pleft>
		<pright public="1"><c path="h3d.col.Plane"/></pright>
		<ptop public="1"><c path="h3d.col.Plane"/></ptop>
		<pbottom public="1"><c path="h3d.col.Plane"/></pbottom>
		<pnear public="1"><c path="h3d.col.Plane"/></pnear>
		<pfar public="1"><c path="h3d.col.Plane"/></pfar>
		<checkNearFar public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</checkNearFar>
		<clone public="1" set="method" line="24"><f a=""><c path="h3d.col.Frustum"/></f></clone>
		<loadMatrix public="1" set="method" line="36"><f a="mvp">
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></loadMatrix>
		<transform public="1" set="method" line="51"><f a="m">
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></transform>
		<transform3x3 public="1" set="method" line="71"><f a="m">
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></transform3x3>
		<hasPoint public="1" set="method" line="91"><f a="p">
	<c path="h3d.col.Point"/>
	<x path="Bool"/>
</f></hasPoint>
		<hasSphere public="1" set="method" line="103"><f a="s">
	<c path="h3d.col.Sphere"/>
	<x path="Bool"/>
</f></hasSphere>
		<hasBounds public="1" set="method" line="116"><f a="b">
	<c path="h3d.col.Bounds"/>
	<x path="Bool"/>
</f></hasBounds>
		<new public="1" set="method" line="13"><f a="?mvp">
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.col.Ray" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/col/Ray.hx">
		<fromPoints public="1" get="inline" set="null" line="137" static="1"><f a="p1:p2">
	<c path="h3d.col.Point"/>
	<c path="h3d.col.Point"/>
	<c path="h3d.col.Ray"/>
</f></fromPoints>
		<fromValues public="1" get="inline" set="null" line="149" static="1"><f a="x:y:z:dx:dy:dz">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="h3d.col.Ray"/>
</f></fromValues>
		<px public="1"><x path="Float"/></px>
		<py public="1"><x path="Float"/></py>
		<pz public="1"><x path="Float"/></pz>
		<lx public="1"><x path="Float"/></lx>
		<ly public="1"><x path="Float"/></ly>
		<lz public="1"><x path="Float"/></lz>
		<clone public="1" get="inline" set="null" line="17"><f a=""><c path="h3d.col.Ray"/></f></clone>
		<load public="1" get="inline" set="null" line="28"><f a="r">
	<c path="h3d.col.Ray"/>
	<x path="Void"/>
</f></load>
		<normalize set="method" line="37"><f a=""><x path="Void"/></f></normalize>
		<transform public="1" get="inline" set="null" line="46"><f a="m">
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></transform>
		<getPos public="1" get="inline" set="null" line="60"><f a=""><c path="h3d.col.Point"/></f></getPos>
		<getDir public="1" get="inline" set="null" line="64"><f a=""><c path="h3d.col.Point"/></f></getDir>
		<getPoint public="1" get="inline" set="null" line="68"><f a="distance">
	<x path="Float"/>
	<c path="h3d.col.Point"/>
</f></getPoint>
		<toString public="1" set="method" line="72"><f a=""><c path="String"/></f></toString>
		<intersect public="1" get="inline" set="null" line="76"><f a="p">
	<c path="h3d.col.Plane"/>
	<x path="Null"><c path="h3d.col.Point"/></x>
</f></intersect>
		<collideFrustum public="1" get="inline" set="null" line="88"><f a="mvp">
	<c path="h3d.Matrix"/>
	<x path="Bool"/>
</f></collideFrustum>
		<collide public="1" get="inline" set="null" line="113"><f a="b">
	<c path="h3d.col.Bounds"/>
	<x path="Bool"/>
</f></collide>
		<new public="1" get="inline" set="null" line="14"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>h3d.col</e></m>
		</meta>
	</class>
	<class path="h3d.col.ObjectCollider" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/col/ObjectCollider.hx">
		<implements path="hxd.impl._Serializable.NoSerializeSupport"/>
		<implements path="h3d.col.Collider"/>
		<TMP_RAY expr="new Ray()" line="7" static="1">
			<c path="h3d.col.Ray"/>
			<meta><m n=":value"><e>new Ray()</e></m></meta>
		</TMP_RAY>
		<TMP_MAT expr="new Matrix()" line="8" static="1">
			<c path="h3d.Matrix"/>
			<meta><m n=":value"><e>new Matrix()</e></m></meta>
		</TMP_MAT>
		<obj public="1">
			<c path="h3d.scene.Object"/>
			<meta><m n=":s"/></meta>
		</obj>
		<collider public="1">
			<c path="h3d.col.Collider"/>
			<meta><m n=":s"/></meta>
		</collider>
		<rayIntersection public="1" set="method" line="15"><f a="r:bestMatch">
	<c path="h3d.col.Ray"/>
	<x path="Bool"/>
	<x path="Float"/>
</f></rayIntersection>
		<contains public="1" set="method" line="33"><f a="p">
	<c path="h3d.col.Point"/>
	<x path="Bool"/>
</f></contains>
		<inFrustum public="1" set="method" line="41"><f a="f:?m">
	<c path="h3d.col.Frustum"/>
	<c path="h3d.Matrix"/>
	<x path="Bool"/>
</f></inFrustum>
		<inSphere public="1" set="method" line="49"><f a="s">
	<c path="h3d.col.Sphere"/>
	<x path="Bool"/>
</f></inSphere>
		<new public="1" set="method" line="10"><f a="obj:collider">
	<c path="h3d.scene.Object"/>
	<c path="h3d.col.Collider"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.col.Plane" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/col/Plane.hx">
		<fromPoints public="1" get="inline" set="null" line="99" static="1"><f a="p0:p1:p2">
	<c path="h3d.col.Point"/>
	<c path="h3d.col.Point"/>
	<c path="h3d.col.Point"/>
	<c path="h3d.col.Plane"/>
</f></fromPoints>
		<fromNormalPoint public="1" get="inline" set="null" line="106" static="1"><f a="n:p">
	<c path="h3d.col.Point"/>
	<c path="h3d.col.Point"/>
	<c path="h3d.col.Plane"/>
</f></fromNormalPoint>
		<X public="1" get="inline" set="null" line="110" static="1">
			<f a="?v" v="0.0">
				<x path="Float"/>
				<c path="h3d.col.Plane"/>
			</f>
			<meta><m n=":value"><e>{ v : 0.0 }</e></m></meta>
		</X>
		<Y public="1" get="inline" set="null" line="114" static="1">
			<f a="?v" v="0.0">
				<x path="Float"/>
				<c path="h3d.col.Plane"/>
			</f>
			<meta><m n=":value"><e>{ v : 0.0 }</e></m></meta>
		</Y>
		<Z public="1" get="inline" set="null" line="118" static="1">
			<f a="?v" v="0.0">
				<x path="Float"/>
				<c path="h3d.col.Plane"/>
			</f>
			<meta><m n=":value"><e>{ v : 0.0 }</e></m></meta>
		</Z>
		<frustumLeft public="1" get="inline" set="null" line="122" static="1"><f a="mvp">
	<c path="h3d.Matrix"/>
	<c path="h3d.col.Plane"/>
</f></frustumLeft>
		<frustumRight public="1" get="inline" set="null" line="126" static="1"><f a="mvp">
	<c path="h3d.Matrix"/>
	<c path="h3d.col.Plane"/>
</f></frustumRight>
		<frustumBottom public="1" get="inline" set="null" line="130" static="1"><f a="mvp">
	<c path="h3d.Matrix"/>
	<c path="h3d.col.Plane"/>
</f></frustumBottom>
		<frustumTop public="1" get="inline" set="null" line="134" static="1"><f a="mvp">
	<c path="h3d.Matrix"/>
	<c path="h3d.col.Plane"/>
</f></frustumTop>
		<frustumNear public="1" get="inline" set="null" line="138" static="1"><f a="mvp">
	<c path="h3d.Matrix"/>
	<c path="h3d.col.Plane"/>
</f></frustumNear>
		<frustumFar public="1" get="inline" set="null" line="142" static="1"><f a="mvp">
	<c path="h3d.Matrix"/>
	<c path="h3d.col.Plane"/>
</f></frustumFar>
		<nx><x path="Float"/></nx>
		<ny><x path="Float"/></ny>
		<nz><x path="Float"/></nz>
		<d><x path="Float"/></d>
		<getNormal public="1" get="inline" set="null" line="23">
			<f a=""><c path="h3d.col.Point"/></f>
			<haxe_doc>Returns the plan normal</haxe_doc>
		</getNormal>
		<getNormalDistance public="1" get="inline" set="null" line="27"><f a=""><x path="Float"/></f></getNormalDistance>
		<load public="1" get="inline" set="null" line="31"><f a="p">
	<c path="h3d.col.Plane"/>
	<x path="Void"/>
</f></load>
		<transform public="1" set="method" line="38"><f a="m">
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></transform>
		<transform3x3 public="1" set="method" line="45"><f a="m">
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></transform3x3>
		<transformInverseTranspose get="inline" set="null" line="52"><f a="m">
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></transformInverseTranspose>
		<normalize public="1" get="inline" set="null" line="64">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Normalize the plan, so we can use distance().</haxe_doc>
		</normalize>
		<toString public="1" set="method" line="72"><f a=""><c path="String"/></f></toString>
		<distance public="1" get="inline" set="null" line="79">
			<f a="p">
				<c path="h3d.col.Point"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the signed distance between a point an the plane. This requires the plan to be normalized. If the distance is negative it means that we are "under" the plan.</haxe_doc>
		</distance>
		<side public="1" get="inline" set="null" line="83"><f a="p">
	<c path="h3d.col.Point"/>
	<x path="Bool"/>
</f></side>
		<project public="1" get="inline" set="null" line="87"><f a="p">
	<c path="h3d.col.Point"/>
	<c path="h3d.col.Point"/>
</f></project>
		<projectTo public="1" get="inline" set="null" line="92"><f a="p:out">
	<c path="h3d.col.Point"/>
	<c path="h3d.col.Point"/>
	<x path="Void"/>
</f></projectTo>
		<new public="1" get="inline" set="null" line="13"><f a="nx:ny:nz:d">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>h3d.col</e></m>
		</meta>
	</class>
	<class path="h3d.col.Point" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/col/Point.hx">
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<z public="1"><x path="Float"/></z>
		<scale public="1" get="inline" set="null" line="16"><f a="v">
	<x path="Float"/>
	<x path="Void"/>
</f></scale>
		<inFrustum public="1" get="inline" set="null" line="22"><f a="f:?m">
	<c path="h3d.col.Frustum"/>
	<c path="h3d.Matrix"/>
	<x path="Bool"/>
</f></inFrustum>
		<set public="1" get="inline" set="null" line="26"><f a="x:y:z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></set>
		<multiply public="1" get="inline" set="null" line="32"><f a="f">
	<x path="Float"/>
	<c path="h3d.col.Point"/>
</f></multiply>
		<sub public="1" get="inline" set="null" line="36"><f a="p">
	<c path="h3d.col.Point"/>
	<c path="h3d.col.Point"/>
</f></sub>
		<add public="1" get="inline" set="null" line="40"><f a="p">
	<c path="h3d.col.Point"/>
	<c path="h3d.col.Point"/>
</f></add>
		<cross public="1" get="inline" set="null" line="44"><f a="p">
	<c path="h3d.col.Point"/>
	<c path="h3d.col.Point"/>
</f></cross>
		<equals public="1" get="inline" set="null" line="48"><f a="other">
	<c path="h3d.col.Point"/>
	<x path="Bool"/>
</f></equals>
		<lengthSq public="1" get="inline" set="null" line="52"><f a=""><x path="Float"/></f></lengthSq>
		<setLength public="1" get="inline" set="null" line="56"><f a="len">
	<x path="Float"/>
	<x path="Void"/>
</f></setLength>
		<length public="1" get="inline" set="null" line="63"><f a=""><x path="Float"/></f></length>
		<dot public="1" get="inline" set="null" line="67"><f a="p">
	<c path="h3d.col.Point"/>
	<x path="Float"/>
</f></dot>
		<distanceSq public="1" get="inline" set="null" line="71"><f a="p">
	<c path="h3d.col.Point"/>
	<x path="Float"/>
</f></distanceSq>
		<distance public="1" get="inline" set="null" line="78"><f a="p">
	<c path="h3d.col.Point"/>
	<x path="Float"/>
</f></distance>
		<normalize public="1" set="method" line="82"><f a=""><c path="h3d.col.Point"/></f></normalize>
		<normalizeFast public="1" get="inline" set="null" line="91"><f a=""><c path="h3d.col.Point"/></f></normalizeFast>
		<lerp public="1" get="inline" set="null" line="100"><f a="p1:p2:k">
	<c path="h3d.col.Point"/>
	<c path="h3d.col.Point"/>
	<x path="Float"/>
	<x path="Void"/>
</f></lerp>
		<transform public="1" get="inline" set="null" line="109"><f a="m">
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></transform>
		<transform3x3 public="1" get="inline" set="null" line="118"><f a="m">
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></transform3x3>
		<toVector public="1" get="inline" set="null" line="127"><f a=""><c path="h3d.Vector"/></f></toVector>
		<clone public="1" get="inline" set="null" line="131"><f a=""><c path="h3d.col.Point"/></f></clone>
		<load public="1" get="inline" set="null" line="135"><f a="p">
	<c path="h3d.col.Point"/>
	<x path="Void"/>
</f></load>
		<toString public="1" set="method" line="141"><f a=""><c path="String"/></f></toString>
		<new public="1" get="inline" set="null" line="10">
			<f a="?x:?y:?z" v="0.:0.:0.">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ z : 0., y : 0., x : 0. }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.col.TriPlane" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/col/Polygon.hx" module="h3d.col.Polygon">
		<implements path="h3d.col.Collider"/>
		<next public="1" expr="null">
			<c path="h3d.col.TriPlane"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</next>
		<p0x><x path="Float"/></p0x>
		<p0y><x path="Float"/></p0y>
		<p0z><x path="Float"/></p0z>
		<d1x><x path="Float"/></d1x>
		<d1y><x path="Float"/></d1y>
		<d1z><x path="Float"/></d1z>
		<d2x><x path="Float"/></d2x>
		<d2y><x path="Float"/></d2y>
		<d2z><x path="Float"/></d2z>
		<dot00><x path="Float"/></dot00>
		<dot01><x path="Float"/></dot01>
		<dot11><x path="Float"/></dot11>
		<invDenom><x path="Float"/></invDenom>
		<nx><x path="Float"/></nx>
		<ny><x path="Float"/></ny>
		<nz><x path="Float"/></nz>
		<d><x path="Float"/></d>
		<init public="1" get="inline" set="null" line="32"><f a="p0:p1:p2">
	<c path="h3d.col.Point"/>
	<c path="h3d.col.Point"/>
	<c path="h3d.col.Point"/>
	<x path="Void"/>
</f></init>
		<clone public="1" get="inline" set="null" line="57"><f a=""><c path="h3d.col.TriPlane"/></f></clone>
		<load public="1" get="inline" set="null" line="65"><f a="tp">
	<c path="h3d.col.TriPlane"/>
	<x path="Void"/>
</f></load>
		<transform public="1" set="method" line="85"><f a="m">
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></transform>
		<contains public="1" get="inline" set="null" line="95"><f a="p">
	<c path="h3d.col.Point"/>
	<x path="Bool"/>
</f></contains>
		<side public="1" get="inline" set="null" line="99"><f a="p">
	<c path="h3d.col.Point"/>
	<x path="Bool"/>
</f></side>
		<inFrustum public="1" set="method" line="103"><f a="f:?m">
	<c path="h3d.col.Frustum"/>
	<c path="h3d.Matrix"/>
	<x path="Bool"/>
</f></inFrustum>
		<inSphere public="1" set="method" line="108"><f a="s">
	<c path="h3d.col.Sphere"/>
	<x path="Bool"/>
</f></inSphere>
		<rayIntersection public="1" get="inline" set="null" line="113"><f a="r:bestMatch">
	<c path="h3d.col.Ray"/>
	<x path="Bool"/>
	<x path="Float"/>
</f></rayIntersection>
		<isPointInTriangle get="inline" set="null" line="129"><f a="x:y:z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></isPointInTriangle>
		<getPoints public="1" set="method" line="143"><f a=""><c path="Array"><c path="h3d.col.Point"/></c></f></getPoints>
		<new public="1" set="method" line="29"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>h3d.col.Polygon</e></m>
		</meta>
	</class>
	<class path="h3d.col.Polygon" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/col/Polygon.hx">
		<implements path="h3d.col.Collider"/>
		<triPlanes><c path="h3d.col.TriPlane"/></triPlanes>
		<addBuffers public="1" set="method" line="165">
			<f a="vertexes:indexes:?stride" v="::3">
				<x path="haxe.ds.Vector"><t path="hxd.impl.Float32"/></x>
				<x path="haxe.ds.Vector"><t path="hxd.impl.UInt16"/></x>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ stride : 3 }</e></m></meta>
		</addBuffers>
		<isConvex public="1" set="method" line="186"><f a=""><x path="Bool"/></f></isConvex>
		<clone public="1" set="method" line="191"><f a=""><c path="h3d.col.Polygon"/></f></clone>
		<transform public="1" set="method" line="198"><f a="m">
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></transform>
		<getPoints public="1" set="method" line="206"><f a=""><c path="Array"><c path="h3d.col.Point"/></c></f></getPoints>
		<getBounds public="1" set="method" line="216"><f a="?bnds">
	<c path="h3d.col.Bounds"/>
	<c path="h3d.col.Bounds"/>
</f></getBounds>
		<contains public="1" set="method" line="229"><f a="p">
	<c path="h3d.col.Point"/>
	<x path="Bool"/>
</f></contains>
		<rayIntersection public="1" set="method" line="241"><f a="r:bestMatch">
	<c path="h3d.col.Ray"/>
	<x path="Bool"/>
	<x path="Float"/>
</f></rayIntersection>
		<inFrustum public="1" set="method" line="255"><f a="f:?m">
	<c path="h3d.col.Frustum"/>
	<c path="h3d.Matrix"/>
	<x path="Bool"/>
</f></inFrustum>
		<inSphere public="1" set="method" line="260"><f a="s">
	<c path="h3d.col.Sphere"/>
	<x path="Bool"/>
</f></inSphere>
		<new public="1" set="method" line="162"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.col.PolygonBuffer" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/col/PolygonBuffer.hx">
		<implements path="h3d.col.Collider"/>
		<buffer><x path="haxe.ds.Vector"><t path="hxd.impl.Float32"/></x></buffer>
		<indexes><x path="haxe.ds.Vector"><t path="hxd.impl.UInt16"/></x></indexes>
		<startIndex><x path="Int"/></startIndex>
		<triCount><x path="Int"/></triCount>
		<source public="1"><a>
	<geometryName><c path="String"/></geometryName>
	<entry><c path="hxd.fs.FileEntry"/></entry>
</a></source>
		<setData public="1" set="method" line="14">
			<f a="buffer:indexes:?startIndex:?triCount" v="::0:-1">
				<x path="haxe.ds.Vector"><t path="hxd.impl.Float32"/></x>
				<x path="haxe.ds.Vector"><t path="hxd.impl.UInt16"/></x>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ triCount : -1, startIndex : 0 }</e></m></meta>
		</setData>
		<contains public="1" set="method" line="21"><f a="p">
	<c path="h3d.col.Point"/>
	<x path="Bool"/>
</f></contains>
		<inFrustum public="1" set="method" line="44"><f a="f:?m">
	<c path="h3d.col.Frustum"/>
	<c path="h3d.Matrix"/>
	<x path="Bool"/>
</f></inFrustum>
		<inSphere public="1" set="method" line="49"><f a="s">
	<c path="h3d.col.Sphere"/>
	<x path="Bool"/>
</f></inSphere>
		<rayIntersection public="1" set="method" line="55"><f a="r:bestMatch">
	<c path="h3d.col.Ray"/>
	<x path="Bool"/>
	<x path="Float"/>
</f></rayIntersection>
		<new public="1" set="method" line="11"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.col.SkinCollider" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/col/SkinCollider.hx">
		<implements path="h3d.col.Collider"/>
		<implements path="hxd.impl._Serializable.NoSerializeSupport"/>
		<obj>
			<c path="h3d.scene.Skin"/>
			<meta><m n=":s"/></meta>
		</obj>
		<col>
			<c path="h3d.col.PolygonBuffer"/>
			<meta><m n=":s"/></meta>
		</col>
		<transform><c path="h3d.col.PolygonBuffer"/></transform>
		<lastFrame><x path="Int"/></lastFrame>
		<contains public="1" set="method" line="19"><f a="p">
	<c path="h3d.col.Point"/>
	<x path="Bool"/>
</f></contains>
		<inFrustum public="1" set="method" line="24"><f a="p:?m">
	<c path="h3d.col.Frustum"/>
	<c path="h3d.Matrix"/>
	<x path="Bool"/>
</f></inFrustum>
		<inSphere public="1" set="method" line="31"><f a="s">
	<c path="h3d.col.Sphere"/>
	<x path="Bool"/>
</f></inSphere>
		<rayIntersection public="1" set="method" line="36"><f a="r:bestMatch">
	<c path="h3d.col.Ray"/>
	<x path="Bool"/>
	<x path="Float"/>
</f></rayIntersection>
		<applyTransform set="method" line="41"><f a=""><x path="Void"/></f></applyTransform>
		<new public="1" set="method" line="12"><f a="obj:col">
	<c path="h3d.scene.Skin"/>
	<c path="h3d.col.PolygonBuffer"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>h3d.col.PolygonBuffer</e></m>
			<m n=":access"><e>h3d.scene.Skin</e></m>
		</meta>
	</class>
	<class path="h3d.col.Sphere" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/col/Sphere.hx">
		<implements path="h3d.col.Collider"/>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<z public="1"><x path="Float"/></z>
		<r public="1"><x path="Float"/></r>
		<load public="1" get="inline" set="null" line="14">
			<f a="?sx:?sy:?sz:?sr" v="0.:0.:0.:0.">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ sr : 0., sz : 0., sy : 0., sx : 0. }</e></m></meta>
		</load>
		<getCenter public="1" get="inline" set="null" line="21"><f a=""><c path="h3d.col.Point"/></f></getCenter>
		<contains public="1" get="inline" set="null" line="25"><f a="p">
	<c path="h3d.col.Point"/>
	<x path="Bool"/>
</f></contains>
		<rayIntersection public="1" set="method" line="32"><f a="r:bestMatch">
	<c path="h3d.col.Ray"/>
	<x path="Bool"/>
	<x path="Float"/>
</f></rayIntersection>
		<inFrustum public="1" get="inline" set="null" line="50"><f a="f:?m">
	<c path="h3d.col.Frustum"/>
	<c path="h3d.Matrix"/>
	<x path="Bool"/>
</f></inFrustum>
		<inFrustumMatrix set="method" line="55"><f a="f:m">
	<c path="h3d.col.Frustum"/>
	<c path="h3d.Matrix"/>
	<x path="Bool"/>
</f></inFrustumMatrix>
		<inSphere public="1" get="inline" set="null" line="72"><f a="s">
	<c path="h3d.col.Sphere"/>
	<x path="Bool"/>
</f></inSphere>
		<toString public="1" set="method" line="76"><f a=""><c path="String"/></f></toString>
		<new public="1" get="inline" set="null" line="10">
			<f a="?x:?y:?z:?r" v="0.:0.:0.:0.">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ r : 0., z : 0., y : 0., x : 0. }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="h3d.impl.IndexBuffer" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/impl/Driver.hx" module="h3d.impl.Driver"><a/></typedef>
	<typedef path="h3d.impl.VertexBuffer" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/impl/Driver.hx" module="h3d.impl.Driver"><a/></typedef>
	<typedef path="h3d.impl.Texture" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/impl/Driver.hx" module="h3d.impl.Driver"><a/></typedef>
	<typedef path="h3d.impl.DepthBuffer" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/impl/Driver.hx" module="h3d.impl.Driver"><a/></typedef>
	<typedef path="h3d.impl.Query" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/impl/Driver.hx" module="h3d.impl.Driver"><a/></typedef>
	<enum path="h3d.impl.Feature" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/impl/Driver.hx" module="h3d.impl.Driver">
		<StandardDerivatives/>
		<FloatTextures/>
		<AllocDepthBuffer/>
		<HardwareAccelerated/>
		<MultipleRenderTargets/>
		<Queries/>
		<SRGBTextures/>
		<ShaderModel3/>
		<BottomLeftCoords/>
		<Wireframe/>
		<InstancedRendering/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="h3d.impl.QueryKind" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/impl/Driver.hx" module="h3d.impl.Driver">
		<TimeStamp><haxe_doc>The result will give the GPU Timestamp (in nanoseconds, 1e-9 seconds) at the time the endQuery is performed</haxe_doc></TimeStamp>
		<Samples><haxe_doc>The result will give the number of samples that passes the depth buffer between beginQuery/endQuery range</haxe_doc></Samples>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<enum path="h3d.impl.RenderFlag" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/impl/Driver.hx" module="h3d.impl.Driver">
		<CameraHandness><haxe_doc>0 = LeftHanded (default), 1 = RightHanded. Affects the meaning of triangle culling value.</haxe_doc></CameraHandness>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="h3d.impl.InputNames" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/impl/Driver.hx" module="h3d.impl.Driver">
		<UID expr="0" line="127" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</UID>
		<CACHE expr="new Map&lt;String,InputNames&gt;()" line="128" static="1">
			<x path="haxe.ds.Map">
				<c path="String"/>
				<c path="h3d.impl.InputNames"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new Map<String,InputNames>()]]></e></m></meta>
		</CACHE>
		<get public="1" set="method" line="129" static="1"><f a="names">
	<c path="Array"><c path="String"/></c>
	<x path="Null"><c path="h3d.impl.InputNames"/></x>
</f></get>
		<id public="1" set="null"><x path="Int"/></id>
		<names public="1" set="null"><c path="Array"><c path="String"/></c></names>
		<new set="method" line="123"><f a="names">
	<c path="Array"><c path="String"/></c>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.impl.Driver" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/impl/Driver.hx">
		<logEnable public="1"><x path="Bool"/></logEnable>
		<hasFeature public="1" set="method" line="144"><f a="f">
	<e path="h3d.impl.Feature"/>
	<x path="Bool"/>
</f></hasFeature>
		<setRenderFlag public="1" set="method" line="148"><f a="r:value">
	<e path="h3d.impl.RenderFlag"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setRenderFlag>
		<isSupportedFormat public="1" set="method" line="151"><f a="fmt">
	<t path="h3d.mat.TextureFormat"/>
	<x path="Bool"/>
</f></isSupportedFormat>
		<isDisposed public="1" set="method" line="155"><f a=""><x path="Bool"/></f></isDisposed>
		<dispose public="1" set="method" line="159"><f a=""><x path="Void"/></f></dispose>
		<begin public="1" set="method" line="162"><f a="frame">
	<x path="Int"/>
	<x path="Void"/>
</f></begin>
		<log public="1" get="inline" set="null" line="165"><f a="str">
	<c path="String"/>
	<x path="Void"/>
</f></log>
		<generateMipMaps public="1" set="method" line="171"><f a="texture">
	<c path="h3d.mat.Texture"/>
	<x path="Void"/>
</f></generateMipMaps>
		<getNativeShaderCode public="1" set="method" line="175"><f a="shader">
	<c path="hxsl.RuntimeShader"/>
	<c path="String"/>
</f></getNativeShaderCode>
		<logImpl set="method" line="179"><f a="str">
	<c path="String"/>
	<x path="Void"/>
</f></logImpl>
		<clear public="1" set="method" line="182"><f a="?color:?depth:?stencil">
	<c path="h3d.Vector"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></clear>
		<captureRenderBuffer public="1" set="method" line="185"><f a="pixels">
	<c path="hxd.Pixels"/>
	<x path="Void"/>
</f></captureRenderBuffer>
		<capturePixels public="1" set="method" line="188"><f a="tex:layer:mipLevel:?region">
	<c path="h3d.mat.Texture"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="h2d.col.IBounds"/>
	<c path="hxd.Pixels"/>
</f></capturePixels>
		<getDriverName public="1" set="method" line="193"><f a="details">
	<x path="Bool"/>
	<c path="String"/>
</f></getDriverName>
		<init public="1" set="method" line="197">
			<f a="onCreate:?forceSoftware" v=":false">
				<f a="">
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ forceSoftware : false }</e></m></meta>
		</init>
		<resize public="1" set="method" line="200"><f a="width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></resize>
		<selectShader public="1" set="method" line="203"><f a="shader">
	<c path="hxsl.RuntimeShader"/>
	<x path="Bool"/>
</f></selectShader>
		<selectMaterial public="1" set="method" line="207"><f a="pass">
	<c path="h3d.mat.Pass"/>
	<x path="Void"/>
</f></selectMaterial>
		<uploadShaderBuffers public="1" set="method" line="210"><f a="buffers:which">
	<c path="h3d.shader.Buffers"/>
	<x path="h3d.shader.BufferKind"/>
	<x path="Void"/>
</f></uploadShaderBuffers>
		<getShaderInputNames public="1" set="method" line="213"><f a=""><c path="h3d.impl.InputNames"/></f></getShaderInputNames>
		<selectBuffer public="1" set="method" line="217"><f a="buffer">
	<c path="h3d.Buffer"/>
	<x path="Void"/>
</f></selectBuffer>
		<selectMultiBuffers public="1" set="method" line="220"><f a="buffers">
	<c path="h3d.BufferOffset"/>
	<x path="Void"/>
</f></selectMultiBuffers>
		<draw public="1" set="method" line="223"><f a="ibuf:startIndex:ntriangles">
	<t path="h3d.impl.IndexBuffer"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></draw>
		<drawInstanced public="1" set="method" line="226"><f a="ibuf:commands">
	<t path="h3d.impl.IndexBuffer"/>
	<c path="h3d.impl.InstanceBuffer"/>
	<x path="Void"/>
</f></drawInstanced>
		<setRenderZone public="1" set="method" line="229"><f a="x:y:width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setRenderZone>
		<setRenderTarget public="1" set="method" line="232">
			<f a="tex:?layer:?mipLevel" v=":0:0">
				<x path="Null"><c path="h3d.mat.Texture"/></x>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ mipLevel : 0, layer : 0 }</e></m></meta>
		</setRenderTarget>
		<setRenderTargets public="1" set="method" line="235"><f a="textures">
	<c path="Array"><c path="h3d.mat.Texture"/></c>
	<x path="Void"/>
</f></setRenderTargets>
		<allocDepthBuffer public="1" set="method" line="238"><f a="b">
	<c path="h3d.mat.DepthBuffer"/>
	<t path="h3d.impl.DepthBuffer"/>
</f></allocDepthBuffer>
		<disposeDepthBuffer public="1" set="method" line="242"><f a="b">
	<c path="h3d.mat.DepthBuffer"/>
	<x path="Void"/>
</f></disposeDepthBuffer>
		<getDefaultDepthBuffer public="1" set="method" line="245"><f a=""><c path="h3d.mat.DepthBuffer"/></f></getDefaultDepthBuffer>
		<present public="1" set="method" line="249"><f a=""><x path="Void"/></f></present>
		<end public="1" set="method" line="252"><f a=""><x path="Void"/></f></end>
		<setDebug public="1" set="method" line="255"><f a="b">
	<x path="Bool"/>
	<x path="Void"/>
</f></setDebug>
		<allocTexture public="1" set="method" line="258"><f a="t">
	<c path="h3d.mat.Texture"/>
	<t path="h3d.impl.Texture"/>
</f></allocTexture>
		<allocIndexes public="1" set="method" line="262"><f a="count:is32">
	<x path="Int"/>
	<x path="Bool"/>
	<t path="h3d.impl.IndexBuffer"/>
</f></allocIndexes>
		<allocVertexes public="1" set="method" line="266"><f a="m">
	<c path="h3d.impl.ManagedBuffer"/>
	<t path="h3d.impl.VertexBuffer"/>
</f></allocVertexes>
		<allocInstanceBuffer public="1" set="method" line="270"><f a="b:bytes">
	<c path="h3d.impl.InstanceBuffer"/>
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></allocInstanceBuffer>
		<disposeTexture public="1" set="method" line="273"><f a="t">
	<c path="h3d.mat.Texture"/>
	<x path="Void"/>
</f></disposeTexture>
		<disposeIndexes public="1" set="method" line="276"><f a="i">
	<t path="h3d.impl.IndexBuffer"/>
	<x path="Void"/>
</f></disposeIndexes>
		<disposeVertexes public="1" set="method" line="279"><f a="v">
	<t path="h3d.impl.VertexBuffer"/>
	<x path="Void"/>
</f></disposeVertexes>
		<disposeInstanceBuffer public="1" set="method" line="282"><f a="b">
	<c path="h3d.impl.InstanceBuffer"/>
	<x path="Void"/>
</f></disposeInstanceBuffer>
		<uploadIndexBuffer public="1" set="method" line="285"><f a="i:startIndice:indiceCount:buf:bufPos">
	<t path="h3d.impl.IndexBuffer"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="hxd.IndexBuffer"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uploadIndexBuffer>
		<uploadIndexBytes public="1" set="method" line="288"><f a="i:startIndice:indiceCount:buf:bufPos">
	<t path="h3d.impl.IndexBuffer"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uploadIndexBytes>
		<uploadVertexBuffer public="1" set="method" line="291"><f a="v:startVertex:vertexCount:buf:bufPos">
	<t path="h3d.impl.VertexBuffer"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="hxd.FloatBuffer"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uploadVertexBuffer>
		<uploadVertexBytes public="1" set="method" line="294"><f a="v:startVertex:vertexCount:buf:bufPos">
	<t path="h3d.impl.VertexBuffer"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uploadVertexBytes>
		<uploadTextureBitmap public="1" set="method" line="297"><f a="t:bmp:mipLevel:side">
	<c path="h3d.mat.Texture"/>
	<c path="hxd.BitmapData"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uploadTextureBitmap>
		<uploadTexturePixels public="1" set="method" line="300"><f a="t:pixels:mipLevel:side">
	<c path="h3d.mat.Texture"/>
	<c path="hxd.Pixels"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uploadTexturePixels>
		<readVertexBytes public="1" set="method" line="303"><f a="v:startVertex:vertexCount:buf:bufPos">
	<t path="h3d.impl.VertexBuffer"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Void"/>
</f></readVertexBytes>
		<readIndexBytes public="1" set="method" line="307"><f a="v:startVertex:vertexCount:buf:bufPos">
	<t path="h3d.impl.IndexBuffer"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Void"/>
</f></readIndexBytes>
		<copyTexture public="1" set="method" line="314">
			<f a="from:to">
				<c path="h3d.mat.Texture"/>
				<c path="h3d.mat.Texture"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns true if we could copy the texture, false otherwise (not supported by driver or mismatch in size/format)</haxe_doc>
		</copyTexture>
		<allocQuery public="1" set="method" line="320"><f a="queryKind">
	<e path="h3d.impl.QueryKind"/>
	<t path="h3d.impl.Query"/>
</f></allocQuery>
		<deleteQuery public="1" set="method" line="324"><f a="q">
	<t path="h3d.impl.Query"/>
	<x path="Void"/>
</f></deleteQuery>
		<beginQuery public="1" set="method" line="327"><f a="q">
	<t path="h3d.impl.Query"/>
	<x path="Void"/>
</f></beginQuery>
		<endQuery public="1" set="method" line="330"><f a="q">
	<t path="h3d.impl.Query"/>
	<x path="Void"/>
</f></endQuery>
		<queryResultAvailable public="1" set="method" line="333"><f a="q">
	<t path="h3d.impl.Query"/>
	<x path="Bool"/>
</f></queryResultAvailable>
		<queryResult public="1" set="method" line="337"><f a="q">
	<t path="h3d.impl.Query"/>
	<x path="Float"/>
</f></queryResult>
	</class>
	<class path="h3d.impl.InstanceBuffer" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/impl/InstanceBuffer.hx">
		<data><d/></data>
		<driver><c path="h3d.impl.Driver"/></driver>
		<indexCount public="1" set="null" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</indexCount>
		<triCount public="1" set="null" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</triCount>
		<commandCount public="1" set="null"><x path="Int"/></commandCount>
		<setCommand public="1" set="method" line="15"><f a="commandCount:indexCount">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setCommand>
		<setBuffer public="1" set="method" line="29">
			<f a="commandCount:bytes">
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Bytes are structures of 5 i32 with the following values:
		- indexCount : number of indexes per instance
		- instanceCount : number of indexed draws
		- startIndexLocation : offset in indexes
		- baseVertexLocation : offset in buffer
		- startInstanceLocation : offset in per instance buffer</haxe_doc>
		</setBuffer>
		<dispose public="1" set="method" line="45"><f a=""><x path="Void"/></f></dispose>
		<new public="1" set="method" line="12"><f a=""><x path="Void"/></f></new>
		<meta><m n=":allow"><e>h3d.impl.Driver</e></m></meta>
	</class>
	<class path="h3d.impl.LogDriver" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/impl/LogDriver.hx">
		<extends path="h3d.impl.Driver"/>
		<debug public="1" set="method" line="359" static="1"><f a="f">
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></debug>
		<d><c path="h3d.impl.Driver"/></d>
		<loggedShaders expr="new Map&lt;Int,Bool&gt;()">
			<x path="haxe.ds.Map">
				<x path="Int"/>
				<x path="Bool"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new Map<Int,Bool>()]]></e></m></meta>
		</loggedShaders>
		<currentShader><c path="hxsl.RuntimeShader"/></currentShader>
		<logLines public="1" expr="null">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>null</e></m></meta>
		</logLines>
		<logImpl set="method" line="17" override="1"><f a="str">
	<c path="String"/>
	<x path="Void"/>
</f></logImpl>
		<hasFeature public="1" set="method" line="24" override="1"><f a="f">
	<e path="h3d.impl.Feature"/>
	<x path="Bool"/>
</f></hasFeature>
		<isSupportedFormat public="1" set="method" line="28" override="1"><f a="fmt">
	<t path="h3d.mat.TextureFormat"/>
	<x path="Bool"/>
</f></isSupportedFormat>
		<isDisposed public="1" set="method" line="32" override="1"><f a=""><x path="Bool"/></f></isDisposed>
		<dispose public="1" set="method" line="36" override="1"><f a=""><x path="Void"/></f></dispose>
		<begin public="1" set="method" line="41" override="1"><f a="frame">
	<x path="Int"/>
	<x path="Void"/>
</f></begin>
		<clear public="1" set="method" line="46" override="1"><f a="?color:?depth:?stencil">
	<c path="h3d.Vector"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></clear>
		<captureRenderBuffer public="1" set="method" line="51" override="1"><f a="pixels">
	<c path="hxd.Pixels"/>
	<x path="Void"/>
</f></captureRenderBuffer>
		<getDriverName public="1" set="method" line="56" override="1"><f a="details">
	<x path="Bool"/>
	<c path="String"/>
</f></getDriverName>
		<init public="1" set="method" line="60" override="1">
			<f a="onCreate:?forceSoftware" v=":false">
				<f a="">
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ forceSoftware : false }</e></m></meta>
		</init>
		<resize public="1" set="method" line="68" override="1"><f a="width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></resize>
		<selectShader public="1" set="method" line="73" override="1"><f a="shader">
	<c path="hxsl.RuntimeShader"/>
	<x path="Bool"/>
</f></selectShader>
		<getNativeShaderCode public="1" set="method" line="168" override="1"><f a="shader">
	<c path="hxsl.RuntimeShader"/>
	<c path="String"/>
</f></getNativeShaderCode>
		<selectMaterial public="1" set="method" line="172" override="1"><f a="pass">
	<c path="h3d.mat.Pass"/>
	<x path="Void"/>
</f></selectMaterial>
		<sizeOf set="method" line="177"><f a="t">
	<e path="hxsl.Type"/>
	<x path="Int"/>
</f></sizeOf>
		<uploadShaderBuffers public="1" set="method" line="190" override="1"><f a="buffers:which">
	<c path="h3d.shader.Buffers"/>
	<x path="h3d.shader.BufferKind"/>
	<x path="Void"/>
</f></uploadShaderBuffers>
		<textureInfos set="method" line="236"><f a="buf:tid">
	<x path="haxe.ds.Vector"><c path="h3d.mat.Texture"/></x>
	<x path="Int"/>
	<c path="String"/>
</f></textureInfos>
		<getShaderInputNames public="1" set="method" line="250" override="1"><f a=""><c path="h3d.impl.InputNames"/></f></getShaderInputNames>
		<selectBuffer public="1" set="method" line="254" override="1"><f a="buffer">
	<c path="h3d.Buffer"/>
	<x path="Void"/>
</f></selectBuffer>
		<selectMultiBuffers public="1" set="method" line="259" override="1"><f a="buffers">
	<c path="h3d.BufferOffset"/>
	<x path="Void"/>
</f></selectMultiBuffers>
		<draw public="1" set="method" line="264" override="1"><f a="ibuf:startIndex:ntriangles">
	<t path="h3d.impl.IndexBuffer"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></draw>
		<setRenderZone public="1" set="method" line="269" override="1"><f a="x:y:width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setRenderZone>
		<setRenderTarget public="1" set="method" line="274" override="1">
			<f a="tex:?face:?mipMap" v=":0:0">
				<x path="Null"><c path="h3d.mat.Texture"/></x>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ mipMap : 0, face : 0 }</e></m></meta>
		</setRenderTarget>
		<setRenderTargets public="1" set="method" line="279" override="1"><f a="textures">
	<c path="Array"><c path="h3d.mat.Texture"/></c>
	<x path="Void"/>
</f></setRenderTargets>
		<end public="1" set="method" line="284" override="1"><f a=""><x path="Void"/></f></end>
		<present public="1" set="method" line="289" override="1"><f a=""><x path="Void"/></f></present>
		<setDebug public="1" set="method" line="294" override="1"><f a="b">
	<x path="Bool"/>
	<x path="Void"/>
</f></setDebug>
		<allocTexture public="1" set="method" line="299" override="1"><f a="t">
	<c path="h3d.mat.Texture"/>
	<t path="h3d.impl.Texture"/>
</f></allocTexture>
		<allocIndexes public="1" set="method" line="304" override="1"><f a="count:is32">
	<x path="Int"/>
	<x path="Bool"/>
	<t path="h3d.impl.IndexBuffer"/>
</f></allocIndexes>
		<allocVertexes public="1" set="method" line="309" override="1"><f a="m">
	<c path="h3d.impl.ManagedBuffer"/>
	<t path="h3d.impl.VertexBuffer"/>
</f></allocVertexes>
		<disposeTexture public="1" set="method" line="314" override="1"><f a="t">
	<c path="h3d.mat.Texture"/>
	<x path="Void"/>
</f></disposeTexture>
		<disposeIndexes public="1" set="method" line="319" override="1"><f a="i">
	<t path="h3d.impl.IndexBuffer"/>
	<x path="Void"/>
</f></disposeIndexes>
		<disposeVertexes public="1" set="method" line="324" override="1"><f a="v">
	<t path="h3d.impl.VertexBuffer"/>
	<x path="Void"/>
</f></disposeVertexes>
		<uploadIndexBuffer public="1" set="method" line="329" override="1"><f a="i:startIndice:indiceCount:buf:bufPos">
	<t path="h3d.impl.IndexBuffer"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="hxd.IndexBuffer"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uploadIndexBuffer>
		<uploadIndexBytes public="1" set="method" line="334" override="1"><f a="i:startIndice:indiceCount:buf:bufPos">
	<t path="h3d.impl.IndexBuffer"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uploadIndexBytes>
		<uploadVertexBuffer public="1" set="method" line="339" override="1"><f a="v:startVertex:vertexCount:buf:bufPos">
	<t path="h3d.impl.VertexBuffer"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="hxd.FloatBuffer"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uploadVertexBuffer>
		<uploadVertexBytes public="1" set="method" line="344" override="1"><f a="v:startVertex:vertexCount:buf:bufPos">
	<t path="h3d.impl.VertexBuffer"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uploadVertexBytes>
		<uploadTextureBitmap public="1" set="method" line="349" override="1"><f a="t:bmp:mipLevel:side">
	<c path="h3d.mat.Texture"/>
	<c path="hxd.BitmapData"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uploadTextureBitmap>
		<uploadTexturePixels public="1" set="method" line="354" override="1"><f a="t:pixels:mipLevel:side">
	<c path="h3d.mat.Texture"/>
	<c path="hxd.Pixels"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uploadTexturePixels>
		<new public="1" set="method" line="11"><f a="driver">
	<c path="h3d.impl.Driver"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.impl._ManagedBuffer.FreeCell" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/impl/ManagedBuffer.hx" private="1" module="h3d.impl.ManagedBuffer">
		<pos><x path="Int"/></pos>
		<count><x path="Int"/></count>
		<next><c path="h3d.impl._ManagedBuffer.FreeCell"/></next>
		<new set="method" line="8"><f a="pos:count:next">
	<x path="Int"/>
	<x path="Int"/>
	<c path="h3d.impl._ManagedBuffer.FreeCell"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>h3d</e></m>
		</meta>
	</class>
	<class path="h3d.impl.ManagedBuffer" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/impl/ManagedBuffer.hx">
		<mem><c path="h3d.impl.MemoryManager"/></mem>
		<stride public="1" set="null"><x path="Int"/></stride>
		<size public="1" set="null"><x path="Int"/></size>
		<flags public="1" set="null"><x path="haxe.EnumFlags"><e path="h3d.BufferFlag"/></x></flags>
		<vbuf><t path="h3d.impl.VertexBuffer"/></vbuf>
		<freeList><c path="h3d.impl._ManagedBuffer.FreeCell"/></freeList>
		<next><c path="h3d.impl.ManagedBuffer"/></next>
		<uploadVertexBuffer public="1" set="method" line="44">
			<f a="start:vertices:buf:?bufPos" v=":::0">
				<x path="Int"/>
				<x path="Int"/>
				<x path="hxd.FloatBuffer"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ bufPos : 0 }</e></m></meta>
		</uploadVertexBuffer>
		<uploadVertexBytes public="1" set="method" line="48">
			<f a="start:vertices:data:?dataPos" v=":::0">
				<x path="Int"/>
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ dataPos : 0 }</e></m></meta>
		</uploadVertexBytes>
		<readVertexBytes public="1" set="method" line="52">
			<f a="start:vertices:data:?dataPos" v=":::0">
				<x path="Int"/>
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ dataPos : 0 }</e></m></meta>
		</readVertexBytes>
		<alloc public="1" set="method" line="56"><f a="vertices:align">
	<x path="Int"/>
	<x path="Int"/>
	<c path="h3d.Buffer"/>
</f></alloc>
		<getFreeVertices public="1" set="method" line="72"><f a=""><x path="Int"/></f></getFreeVertices>
		<allocPosition set="method" line="82"><f a="nvert:align">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></allocPosition>
		<allocBuffer set="method" line="107"><f a="b">
	<c path="h3d.Buffer"/>
	<x path="Bool"/>
</f></allocBuffer>
		<freeBuffer set="method" line="123">
			<f a="b">
				<c path="h3d.Buffer"/>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>h3d.Buffer.dispose</e></m></meta>
		</freeBuffer>
		<dispose public="1" set="method" line="174"><f a=""><x path="Void"/></f></dispose>
		<isDisposed public="1" get="inline" set="null" line="178"><f a=""><x path="Bool"/></f></isDisposed>
		<new public="1" set="method" line="30"><f a="stride:size:?flags">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><e path="h3d.BufferFlag"/></c>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>h3d.impl.MemoryManager</e></m>
		</meta>
	</class>
	<class path="h3d.impl.MemoryManager" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/impl/MemoryManager.hx">
		<MAX_MEMORY get="inline" set="null" expr="4096 * (1024. * 1024.)" line="5" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>4096 * (1024. * 1024.)</e></m></meta>
		</MAX_MEMORY>
		<MAX_BUFFERS get="inline" set="null" expr="1 &lt;&lt; 16" line="6" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e><![CDATA[1 << 16]]></e></m></meta>
		</MAX_BUFFERS>
		<SIZE get="inline" set="null" expr="65533" line="7" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>65533</e></m></meta>
		</SIZE>
		<ALL_FLAGS expr="Type.allEnums(Buffer.BufferFlag)" line="8" static="1">
			<c path="Array"><e path="h3d.BufferFlag"/></c>
			<meta><m n=":value"><e>Type.allEnums(Buffer.BufferFlag)</e></m></meta>
		</ALL_FLAGS>
		<driver>
			<c path="h3d.impl.Driver"/>
			<meta><m n=":allow"><e>h3d</e></m></meta>
		</driver>
		<buffers><c path="Array"><c path="h3d.impl.ManagedBuffer"/></c></buffers>
		<indexes><c path="Array"><c path="h3d.Indexes"/></c></indexes>
		<textures><c path="Array"><c path="h3d.mat.Texture"/></c></textures>
		<depths><c path="Array"><c path="h3d.mat.DepthBuffer"/></c></depths>
		<triIndexes public="1" set="null"><c path="h3d.Indexes"/></triIndexes>
		<quadIndexes public="1" set="null"><c path="h3d.Indexes"/></quadIndexes>
		<usedMemory public="1" set="null" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</usedMemory>
		<texMemory public="1" set="null" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</texMemory>
		<bufferCount public="1" set="null" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</bufferCount>
		<init public="1" set="method" line="27"><f a=""><x path="Void"/></f></init>
		<initIndexes set="method" line="35"><f a=""><x path="Void"/></f></initIndexes>
		<garbage public="1" set="dynamic" line="59">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Call user-defined garbage function that will cleanup some unused allocated objects.
		Might be called several times if we need to allocate a lot of memory</haxe_doc>
		</garbage>
		<cleanManagedBuffers public="1" set="method" line="67">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Clean empty (unused) buffers</haxe_doc>
		</cleanManagedBuffers>
		<allocManaged set="method" line="85">
			<f a="m">
				<c path="h3d.impl.ManagedBuffer"/>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>h3d.impl.ManagedBuffer</e></m></meta>
		</allocManaged>
		<freeManaged set="method" line="110">
			<f a="m">
				<c path="h3d.impl.ManagedBuffer"/>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>h3d.impl.ManagedBuffer</e></m></meta>
		</freeManaged>
		<allocBuffer set="method" line="131">
			<f a="b:stride">
				<c path="h3d.Buffer"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":allow"><e>h3d.Buffer</e></m>
				<m n=":access"><e>h3d.Buffer</e></m>
			</meta>
		</allocBuffer>
		<deleteIndexes set="method" line="211">
			<f a="i">
				<c path="h3d.Indexes"/>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>h3d.Indexes</e></m></meta>
		</deleteIndexes>
		<allocIndexes set="method" line="219">
			<f a="i">
				<c path="h3d.Indexes"/>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>h3d.Indexes</e></m></meta>
		</allocIndexes>
		<bpp set="method" line="228"><f a="t">
	<c path="h3d.mat.Texture"/>
	<x path="Int"/>
</f></bpp>
		<cleanTextures public="1" set="method" line="232">
			<f a="?force" v="true">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ force : true }</e></m></meta>
		</cleanTextures>
		<sortByLRU set="method" line="244"><f a="t1:t2">
	<c path="h3d.mat.Texture"/>
	<c path="h3d.mat.Texture"/>
	<x path="Int"/>
</f></sortByLRU>
		<deleteTexture set="method" line="249">
			<f a="t">
				<c path="h3d.mat.Texture"/>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>h3d.mat.Texture.dispose</e></m></meta>
		</deleteTexture>
		<allocTexture set="method" line="256">
			<f a="t">
				<c path="h3d.mat.Texture"/>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>h3d.mat.Texture.alloc</e></m></meta>
		</allocTexture>
		<allocDepth set="method" line="270">
			<f a="b">
				<c path="h3d.mat.DepthBuffer"/>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>h3d.mat.DepthBuffer.alloc</e></m></meta>
		</allocDepth>
		<deleteDepth set="method" line="284">
			<f a="b">
				<c path="h3d.mat.DepthBuffer"/>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>h3d.mat.DepthBuffer.dispose</e></m></meta>
		</deleteDepth>
		<onContextLost public="1" set="method" line="292"><f a=""><x path="Void"/></f></onContextLost>
		<dispose public="1" set="method" line="297"><f a=""><x path="Void"/></f></dispose>
		<freeMemorySize set="method" line="325"><f a=""><x path="Int"/></f></freeMemorySize>
		<stats public="1" set="method" line="341"><f a=""><a>
	<totalMemory><x path="Float"/></totalMemory>
	<textureMemory><x path="Float"/></textureMemory>
	<textureCount><x path="Int"/></textureCount>
	<managedMemory><x path="Int"/></managedMemory>
	<freeManagedMemory><x path="Int"/></freeManagedMemory>
	<bufferCount><x path="Int"/></bufferCount>
</a></f></stats>
		<allocStats public="1" set="method" line="370">
			<f a=""><c path="Array"><a>
	<tex><x path="Bool"/></tex>
	<stacks><c path="Array"><a>
	<stack><c path="String"/></stack>
	<size><x path="Int"/></size>
	<count><x path="Int"/></count>
</a></c></stacks>
	<size><x path="Int"/></size>
	<position><c path="String"/></position>
	<count><x path="Int"/></count>
</a></c></f>
			<meta><m n=":access"><e>h3d.Buffer</e></m></meta>
			<haxe_doc>* Return statistics for currently allocated buffers and textures. Requires -D track-alloc compilation flag</haxe_doc>
		</allocStats>
		<new public="1" set="method" line="23"><f a="driver">
	<c path="h3d.impl.Driver"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.impl.NullDriver" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/impl/NullDriver.hx">
		<extends path="h3d.impl.Driver"/>
		<cur><c path="hxsl.RuntimeShader"/></cur>
		<hasFeature public="1" set="method" line="11" override="1"><f a="f">
	<e path="h3d.impl.Feature"/>
	<x path="Bool"/>
</f></hasFeature>
		<isSupportedFormat public="1" set="method" line="15" override="1"><f a="fmt">
	<t path="h3d.mat.TextureFormat"/>
	<x path="Bool"/>
</f></isSupportedFormat>
		<logImpl set="method" line="19" override="1"><f a="str">
	<c path="String"/>
	<x path="Void"/>
</f></logImpl>
		<isDisposed public="1" set="method" line="27" override="1"><f a=""><x path="Bool"/></f></isDisposed>
		<getDriverName public="1" set="method" line="31" override="1"><f a="details">
	<x path="Bool"/>
	<c path="String"/>
</f></getDriverName>
		<init public="1" set="method" line="35" override="1">
			<f a="onCreate:?forceSoftware" v=":false">
				<f a="">
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ forceSoftware : false }</e></m></meta>
		</init>
		<selectShader public="1" set="method" line="39" override="1"><f a="shader">
	<c path="hxsl.RuntimeShader"/>
	<x path="Bool"/>
</f></selectShader>
		<getShaderInputNames public="1" set="method" line="45" override="1"><f a=""><c path="h3d.impl.InputNames"/></f></getShaderInputNames>
		<allocTexture public="1" set="method" line="53" override="1"><f a="t">
	<c path="h3d.mat.Texture"/>
	<t path="h3d.impl.Texture"/>
</f></allocTexture>
		<allocIndexes public="1" set="method" line="57" override="1"><f a="count:is32">
	<x path="Int"/>
	<x path="Bool"/>
	<t path="h3d.impl.IndexBuffer"/>
</f></allocIndexes>
		<allocVertexes public="1" set="method" line="61" override="1"><f a="m">
	<c path="h3d.impl.ManagedBuffer"/>
	<t path="h3d.impl.VertexBuffer"/>
</f></allocVertexes>
		<new public="1" set="method" line="8"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="h3d.impl.Step" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/impl/RendererFX.hx" module="h3d.impl.RendererFX">
		<BeforeLighting/>
		<BeforeTonemappingFX/>
		<BeforeTonemapping/>
		<AfterTonemapping/>
		<AfterUI/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="h3d.impl.RendererFX" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/impl/RendererFX.hx" interface="1">
		<enabled public="1"><x path="Bool"/></enabled>
		<apply public="1" set="method"><f a="r:step">
	<c path="h3d.scene.Renderer"/>
	<e path="h3d.impl.Step"/>
	<x path="Void"/>
</f></apply>
		<dispose public="1" set="method"><f a=""><x path="Void"/></f></dispose>
	</class>
	<class path="h3d.impl.TextureCache" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/impl/TextureCache.hx">
		<cache><c path="Array"><c path="h3d.mat.Texture"/></c></cache>
		<position expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</position>
		<defaultDepthBuffer><c path="h3d.mat.DepthBuffer"/></defaultDepthBuffer>
		<ctx><c path="h3d.impl.RenderContext"/></ctx>
		<defaultFormat public="1"><e path="hxd.PixelFormat"/></defaultFormat>
		<get public="1" get="inline" set="null" line="19">
			<f a="?index" v="0">
				<x path="Int"/>
				<c path="h3d.mat.Texture"/>
			</f>
			<meta><m n=":value"><e>{ index : 0 }</e></m></meta>
		</get>
		<getNamed public="1" set="method" line="23"><f a="name">
	<c path="String"/>
	<c path="h3d.mat.Texture"/>
</f></getNamed>
		<set public="1" set="method" line="30"><f a="t:index">
	<c path="h3d.mat.Texture"/>
	<x path="Int"/>
	<x path="Void"/>
</f></set>
		<begin public="1" set="method" line="34"><f a=""><x path="Void"/></f></begin>
		<lookupTarget set="method" line="43"><f a="name:width:height:format:isCube">
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<t path="h3d.mat.TextureFormat"/>
	<x path="Bool"/>
	<c path="h3d.mat.Texture"/>
</f></lookupTarget>
		<allocTarget public="1" set="method" line="70">
			<f a="name:width:height:?defaultDepth:?format:?isCube" v=":::true::false">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<e path="hxd.PixelFormat"/>
				<x path="Bool"/>
				<c path="h3d.mat.Texture"/>
			</f>
			<meta><m n=":value"><e>{ isCube : false, defaultDepth : true }</e></m></meta>
		</allocTarget>
		<allocTargetScale public="1" set="method" line="81">
			<f a="name:scale:?defaultDepth:?format" v="::true:">
				<c path="String"/>
				<x path="Float"/>
				<x path="Bool"/>
				<e path="hxd.PixelFormat"/>
				<c path="h3d.mat.Texture"/>
			</f>
			<meta><m n=":value"><e>{ defaultDepth : true }</e></m></meta>
		</allocTargetScale>
		<allocTileTarget public="1" set="method" line="86">
			<f a="name:tile:?defaultDepth:?format" v="::false:">
				<c path="String"/>
				<c path="h2d.Tile"/>
				<x path="Bool"/>
				<e path="hxd.PixelFormat"/>
				<c path="h3d.mat.Texture"/>
			</f>
			<meta><m n=":value"><e>{ defaultDepth : false }</e></m></meta>
		</allocTileTarget>
		<dispose public="1" set="method" line="90"><f a=""><x path="Void"/></f></dispose>
		<new public="1" set="method" line="11"><f a="ctx">
	<c path="h3d.impl.RenderContext"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.impl.AnyProps" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/impl/AnyProps.hx">
		<props public="1" set="accessor"><x path="Any"/></props>
		<set_props set="method" line="7"><f a="p">
	<x path="Any"/>
	<x path="Any"/>
</f></set_props>
		<setDefaultProps public="1" set="method" line="13"><f a="kind">
	<c path="String"/>
	<x path="Void"/>
</f></setDefaultProps>
		<getDefaultProps public="1" set="method" line="17"><f a="?kind">
	<c path="String"/>
	<x path="Any"/>
</f></getDefaultProps>
		<refreshProps public="1" set="method" line="21"><f a=""><x path="Void"/></f></refreshProps>
	</class>
	<class path="h3d.mat.BaseMaterial" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/mat/BaseMaterial.hx">
		<extends path="hxd.impl.AnyProps"/>
		<implements path="hxd.impl._Serializable.NoSerializeSupport"/>
		<passes>
			<c path="h3d.mat.Pass"/>
			<meta><m n=":s"/></meta>
		</passes>
		<name public="1">
			<c path="String"/>
			<meta><m n=":s"/></meta>
		</name>
		<mainPass public="1" get="accessor" set="null"><c path="h3d.mat.Pass"/></mainPass>
		<addPass public="1" params="T" set="method" line="16"><f a="p">
	<c path="addPass.T"/>
	<c path="addPass.T"/>
</f></addPass>
		<removePass public="1" set="method" line="30"><f a="p">
	<c path="h3d.mat.Pass"/>
	<x path="Bool"/>
</f></removePass>
		<get_mainPass get="inline" set="null" line="47"><f a=""><c path="h3d.mat.Pass"/></f></get_mainPass>
		<getPasses public="1" set="method" line="51"><f a=""><c path="Array"><c path="h3d.mat.Pass"/></c></f></getPasses>
		<getPass public="1" set="method" line="61"><f a="name">
	<c path="String"/>
	<c path="h3d.mat.Pass"/>
</f></getPass>
		<allocPass public="1" set="method" line="71">
			<f a="name:?inheritMain" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="h3d.mat.Pass"/>
			</f>
			<meta><m n=":value"><e>{ inheritMain : true }</e></m></meta>
		</allocPass>
		<clone public="1" set="method" line="79"><f a="?m">
	<c path="h3d.mat.BaseMaterial"/>
	<c path="h3d.mat.BaseMaterial"/>
</f></clone>
		<new set="method" line="11"><f a="?shader">
	<c path="hxsl.Shader"/>
	<x path="Void"/>
</f></new>
	</class>
	<typedef path="h3d.mat.BlendMode" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/mat/BlendMode.hx"><e path="h2d.BlendMode"/></typedef>
	<enum path="h3d.mat.Face" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/mat/Data.hx" module="h3d.mat.Data">
		<None/>
		<Back/>
		<Front/>
		<Both/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="h3d.mat.Blend" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/mat/Data.hx" module="h3d.mat.Data">
		<One/>
		<Zero/>
		<SrcAlpha/>
		<SrcColor/>
		<DstAlpha/>
		<DstColor/>
		<OneMinusSrcAlpha/>
		<OneMinusSrcColor/>
		<OneMinusDstAlpha/>
		<OneMinusDstColor/>
		<ConstantColor/>
		<ConstantAlpha/>
		<OneMinusConstantColor/>
		<OneMinusConstantAlpha/>
		<SrcAlphaSaturate/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="h3d.mat.Compare" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/mat/Data.hx" module="h3d.mat.Data">
		<Always/>
		<Never/>
		<Equal/>
		<NotEqual/>
		<Greater/>
		<GreaterEqual/>
		<Less/>
		<LessEqual/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="h3d.mat.StencilOp" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/mat/Data.hx" module="h3d.mat.Data">
		<Keep/>
		<Zero/>
		<Replace/>
		<Increment/>
		<IncrementWrap/>
		<Decrement/>
		<DecrementWrap/>
		<Invert/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="h3d.mat.MipMap" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/mat/Data.hx" module="h3d.mat.Data">
		<None/>
		<Nearest/>
		<Linear/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="h3d.mat.Filter" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/mat/Data.hx" module="h3d.mat.Data">
		<Nearest/>
		<Linear/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="h3d.mat.Wrap" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/mat/Data.hx" module="h3d.mat.Data">
		<Clamp/>
		<Repeat/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="h3d.mat.Operation" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/mat/Data.hx" module="h3d.mat.Data">
		<Add/>
		<Sub/>
		<ReverseSub/>
		<Min/>
		<Max/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="h3d.mat.TextureFlags" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/mat/Data.hx" module="h3d.mat.Data">
		<Target><haxe_doc>Allocate a texture that will be used as render target.</haxe_doc></Target>
		<Cube><haxe_doc>Allocate a cube texture. Might be restricted to power of two textures only.</haxe_doc></Cube>
		<MipMapped><haxe_doc>Activates Mip Mapping for this texture. Might not be available for target textures.</haxe_doc></MipMapped>
		<ManualMipMapGen><haxe_doc>By default, textures created with MipMapped will have their mipmaps generated when you upload the mipmap level 0. This flag disables this and manually upload mipmaps instead.</haxe_doc></ManualMipMapGen>
		<IsNPOT><haxe_doc>This is a not power of two texture. Automatically set when having width or height being not power of two.</haxe_doc></IsNPOT>
		<NoAlloc><haxe_doc>Don't initialy allocate the texture memory.</haxe_doc></NoAlloc>
		<Dynamic><haxe_doc>Inform that we will often perform upload operations on this texture</haxe_doc></Dynamic>
		<AlphaPremultiplied><haxe_doc>Assumes that the color value of the texture is premultiplied by the alpha component.</haxe_doc></AlphaPremultiplied>
		<WasCleared><haxe_doc>Tells if the target texture has been cleared (reserved for internal engine usage).</haxe_doc></WasCleared>
		<Loading><haxe_doc>The texture is being currently loaded. Set onLoaded to get event when loading is complete.</haxe_doc></Loading>
		<Serialize><haxe_doc>Allow texture data serialization when found in a scene (for user generated textures)</haxe_doc></Serialize>
		<IsArray><haxe_doc>Tells if it's a texture array</haxe_doc></IsArray>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<typedef path="h3d.mat.TextureFormat" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/mat/Data.hx" module="h3d.mat.Data"><e path="hxd.PixelFormat"/></typedef>
	<class path="h3d.mat.Defaults" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/mat/Defaults.hx">
		<defaultKillAlphaThreshold public="1" expr="0.5" line="5" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.5</e></m></meta>
		</defaultKillAlphaThreshold>
		<loadingTextureColor public="1" expr="0xFFFF00FF" line="6" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xFFFF00FF</e></m></meta>
		</loadingTextureColor>
		<shadowShader public="1" get="accessor" set="accessor" static="1">
			<c path="hxsl.Shader"/>
			<meta><m n=":isVar"/></meta>
		</shadowShader>
		<get_shadowShader set="method" line="11" static="1"><f a=""><c path="hxsl.Shader"/></f></get_shadowShader>
		<set_shadowShader set="method" line="20" static="1"><f a="s">
	<c path="hxsl.Shader"/>
	<c path="hxsl.Shader"/>
</f></set_shadowShader>
		<makeVolumeDecal public="1" set="dynamic" line="24" static="1"><f a="bounds">
	<c path="h3d.col.Bounds"/>
	<c path="hxsl.Shader"/>
</f></makeVolumeDecal>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="h3d.mat.DepthFormat" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/mat/DepthBuffer.hx" module="h3d.mat.DepthBuffer">
		<Depth16/>
		<Depth24/>
		<Depth24Stencil8/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="h3d.mat.DepthBuffer" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/mat/DepthBuffer.hx">
		<getDefault public="1" set="method" line="55" static="1">
			<f a=""><c path="h3d.mat.DepthBuffer"/></f>
			<haxe_doc>This will return the default depth buffer, which is automatically resized to the screen size.</haxe_doc>
		</getDefault>
		<b>
			<t path="h3d.impl.DepthBuffer"/>
			<meta><m n=":allow"><e>h3d.impl.MemoryManager</e></m></meta>
		</b>
		<width public="1" set="null"><x path="Int"/></width>
		<height public="1" set="null"><x path="Int"/></height>
		<format public="1" set="null"><e path="h3d.mat.DepthFormat"/></format>
		<hasStencil public="1" set="method" line="30"><f a=""><x path="Bool"/></f></hasStencil>
		<alloc set="method" line="37"><f a=""><x path="Void"/></f></alloc>
		<dispose public="1" set="method" line="41"><f a=""><x path="Void"/></f></dispose>
		<isDisposed public="1" set="method" line="48"><f a=""><x path="Bool"/></f></isDisposed>
		<new public="1" set="method" line="23">
			<f a="width:height:?format">
				<x path="Int"/>
				<x path="Int"/>
				<e path="h3d.mat.DepthFormat"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new depth buffer, it can be attached to one or several render target Texture by setting their `depthBuffer` property.</haxe_doc>
		</new>
		<haxe_doc>Depth buffer are used to store per pixel depth information when rendering a scene (also called Z-buffer)</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="h3d.mat._Material.DefaultKind" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/mat/Material.hx" private="1" module="h3d.mat.Material">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="h3d.mat._Material.DefaultKind_Impl_" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/mat/Material.hx" private="1" module="h3d.mat.Material" extern="1">
	<Opaque public="1" get="inline" set="null" expr="cast &quot;Opaque&quot;" line="4" static="1">
		<x path="h3d.mat._Material.DefaultKind"/>
		<meta>
			<m n=":value"><e>cast "Opaque"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Opaque>
	<Alpha public="1" get="inline" set="null" expr="cast &quot;Alpha&quot;" line="5" static="1">
		<x path="h3d.mat._Material.DefaultKind"/>
		<meta>
			<m n=":value"><e>cast "Alpha"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Alpha>
	<AlphaKill public="1" get="inline" set="null" expr="cast &quot;AlphaKill&quot;" line="6" static="1">
		<x path="h3d.mat._Material.DefaultKind"/>
		<meta>
			<m n=":value"><e>cast "AlphaKill"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</AlphaKill>
	<Add public="1" get="inline" set="null" expr="cast &quot;Add&quot;" line="7" static="1">
		<x path="h3d.mat._Material.DefaultKind"/>
		<meta>
			<m n=":value"><e>cast "Add"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Add>
	<SoftAdd public="1" get="inline" set="null" expr="cast &quot;SoftAdd&quot;" line="8" static="1">
		<x path="h3d.mat._Material.DefaultKind"/>
		<meta>
			<m n=":value"><e>cast "SoftAdd"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SoftAdd>
	<Hidden public="1" get="inline" set="null" expr="cast &quot;Hidden&quot;" line="9" static="1">
		<x path="h3d.mat._Material.DefaultKind"/>
		<meta>
			<m n=":value"><e>cast "Hidden"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Hidden>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="h3d.mat._Material.DefaultKind_Impl_" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/mat/Material.hx" private="1" module="h3d.mat.Material" extern="1">
		<Opaque public="1" get="inline" set="null" expr="cast &quot;Opaque&quot;" line="4" static="1">
			<x path="h3d.mat._Material.DefaultKind"/>
			<meta>
				<m n=":value"><e>cast "Opaque"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Opaque>
		<Alpha public="1" get="inline" set="null" expr="cast &quot;Alpha&quot;" line="5" static="1">
			<x path="h3d.mat._Material.DefaultKind"/>
			<meta>
				<m n=":value"><e>cast "Alpha"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Alpha>
		<AlphaKill public="1" get="inline" set="null" expr="cast &quot;AlphaKill&quot;" line="6" static="1">
			<x path="h3d.mat._Material.DefaultKind"/>
			<meta>
				<m n=":value"><e>cast "AlphaKill"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</AlphaKill>
		<Add public="1" get="inline" set="null" expr="cast &quot;Add&quot;" line="7" static="1">
			<x path="h3d.mat._Material.DefaultKind"/>
			<meta>
				<m n=":value"><e>cast "Add"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Add>
		<SoftAdd public="1" get="inline" set="null" expr="cast &quot;SoftAdd&quot;" line="8" static="1">
			<x path="h3d.mat._Material.DefaultKind"/>
			<meta>
				<m n=":value"><e>cast "SoftAdd"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SoftAdd>
		<Hidden public="1" get="inline" set="null" expr="cast &quot;Hidden&quot;" line="9" static="1">
			<x path="h3d.mat._Material.DefaultKind"/>
			<meta>
				<m n=":value"><e>cast "Hidden"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Hidden>
		<meta><m n=":enum"/></meta>
	</class>
	<typedef path="h3d.mat._Material.DefaultProps" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/mat/Material.hx" private="1" module="h3d.mat.Material"><a>
	<shadows><x path="Bool"/></shadows>
	<light><x path="Bool"/></light>
	<kind><x path="h3d.mat._Material.DefaultKind"/></kind>
	<culling><x path="Bool"/></culling>
</a></typedef>
	<class path="h3d.mat.Material" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/mat/Material.hx">
		<extends path="h3d.mat.BaseMaterial"/>
		<create public="1" set="method" line="339" static="1"><f a="?tex">
	<c path="h3d.mat.Texture"/>
	<c path="h3d.mat.Material"/>
</f></create>
		<mshader><c path="h3d.shader.BaseMesh"/></mshader>
		<normalShader><c path="h3d.shader.NormalMap"/></normalShader>
		<model public="1"><c path="hxd.res.Resource"/></model>
		<shadows public="1" get="accessor" set="accessor"><x path="Bool"/></shadows>
		<castShadows public="1" set="accessor"><x path="Bool"/></castShadows>
		<receiveShadows public="1" set="accessor"><x path="Bool"/></receiveShadows>
		<staticShadows public="1" set="accessor"><x path="Bool"/></staticShadows>
		<textureShader public="1" set="null"><c path="h3d.shader.Texture"/></textureShader>
		<specularShader public="1" set="null"><c path="h3d.shader.SpecularTexture"/></specularShader>
		<texture public="1" get="accessor" set="accessor"><c path="h3d.mat.Texture"/></texture>
		<specularTexture public="1" get="accessor" set="accessor"><c path="h3d.mat.Texture"/></specularTexture>
		<normalMap public="1" get="accessor" set="accessor"><c path="h3d.mat.Texture"/></normalMap>
		<color public="1" get="accessor" set="accessor"><c path="h3d.Vector"/></color>
		<specularAmount public="1" get="accessor" set="accessor"><x path="Float"/></specularAmount>
		<specularPower public="1" get="accessor" set="accessor"><x path="Float"/></specularPower>
		<blendMode public="1" set="accessor"><t path="h3d.mat.BlendMode"/></blendMode>
		<get_specularPower get="inline" set="null" line="49"><f a=""><x path="Float"/></f></get_specularPower>
		<set_specularPower get="inline" set="null" line="53"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_specularPower>
		<get_specularAmount get="inline" set="null" line="57"><f a=""><x path="Float"/></f></get_specularAmount>
		<set_specularAmount get="inline" set="null" line="61"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_specularAmount>
		<get_color get="inline" set="null" line="65"><f a=""><t path="hxsl.Vec"/></f></get_color>
		<set_color get="inline" set="null" line="69"><f a="v">
	<t path="hxsl.Vec"/>
	<t path="hxsl.Vec"/>
</f></set_color>
		<get_shadows get="inline" set="null" line="73"><f a=""><x path="Bool"/></f></get_shadows>
		<set_shadows get="inline" set="null" line="77"><f a="v">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_shadows>
		<set_castShadows set="method" line="83"><f a="v">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_castShadows>
		<set_receiveShadows set="method" line="95"><f a="v">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_receiveShadows>
		<set_staticShadows set="method" line="108"><f a="v">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_staticShadows>
		<clone public="1" set="method" line="114" override="1"><f a="?m">
	<c path="h3d.mat.BaseMaterial"/>
	<c path="h3d.mat.BaseMaterial"/>
</f></clone>
		<set_blendMode set="method" line="132"><f a="v">
	<t path="h3d.mat.BlendMode"/>
	<t path="h3d.mat.BlendMode"/>
</f></set_blendMode>
		<get_specularTexture set="method" line="150"><f a=""><x path="Null"><c path="h3d.mat.Texture"/></x></f></get_specularTexture>
		<get_texture set="method" line="154"><f a=""><x path="Null"><c path="h3d.mat.Texture"/></x></f></get_texture>
		<set_texture set="method" line="158"><f a="t">
	<t path="hxsl.Sampler2D"/>
	<t path="hxsl.Sampler2D"/>
</f></set_texture>
		<get_normalMap set="method" line="174"><f a=""><x path="Null"><c path="h3d.mat.Texture"/></x></f></get_normalMap>
		<set_normalMap set="method" line="178"><f a="t">
	<t path="hxsl.Sampler2D"/>
	<t path="hxsl.Sampler2D"/>
</f></set_normalMap>
		<set_specularTexture set="method" line="197"><f a="t">
	<t path="hxsl.Sampler2D"/>
	<t path="hxsl.Sampler2D"/>
</f></set_specularTexture>
		<getDefaultModelProps public="1" set="method" line="219"><f a=""><x path="Any"/></f></getDefaultModelProps>
		<getDefaultProps public="1" set="method" line="237" override="1"><f a="?type">
	<c path="String"/>
	<x path="Any"/>
</f></getDefaultProps>
		<refreshProps public="1" set="method" line="265" override="1"><f a=""><x path="Void"/></f></refreshProps>
		<new set="method" line="42"><f a="?texture">
	<c path="h3d.mat.Texture"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.mat.MaterialDatabase" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/mat/MaterialDatabase.hx">
		<db expr="new Map()">
			<t path="Map">
				<c path="String"/>
				<a><v><d/></v></a>
			</t>
			<meta><m n=":value"><e>new Map()</e></m></meta>
		</db>
		<getFilePath set="method" line="10"><f a="model">
	<c path="hxd.res.Resource"/>
	<c path="String"/>
</f></getFilePath>
		<getModelData public="1" set="method" line="14"><f a="model">
	<c path="hxd.res.Resource"/>
	<a/>
</f></getModelData>
		<saveData set="method" line="26"><f a="model:data">
	<c path="hxd.res.Resource"/>
	<d/>
	<x path="Void"/>
</f></saveData>
		<loadMatProps public="1" set="method" line="41"><f a="material:setup">
	<c path="h3d.mat.Material"/>
	<c path="h3d.mat.MaterialSetup"/>
	<x path="Any"/>
</f></loadMatProps>
		<saveMatProps public="1" set="method" line="51"><f a="material:setup">
	<c path="h3d.mat.Material"/>
	<c path="h3d.mat.MaterialSetup"/>
	<x path="Void"/>
</f></saveMatProps>
		<new public="1" set="method" line="7"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.mat.MaterialSetup" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/mat/MaterialSetup.hx">
		<current public="1" expr="new MaterialSetup(&quot;Default&quot;)" line="47" static="1">
			<c path="h3d.mat.MaterialSetup"/>
			<meta><m n=":value"><e>new MaterialSetup("Default")</e></m></meta>
		</current>
		<name public="1" set="null"><c path="String"/></name>
		<database><c path="h3d.mat.MaterialDatabase"/></database>
		<emptyMat><c path="h3d.mat.Material"/></emptyMat>
		<createRenderer public="1" set="method" line="15"><f a=""><c path="h3d.scene.Renderer"/></f></createRenderer>
		<createLightSystem public="1" set="method" line="19"><f a=""><c path="h3d.scene.LightSystem"/></f></createLightSystem>
		<createMaterial public="1" set="method" line="23"><f a=""><c path="h3d.mat.Material"/></f></createMaterial>
		<getDefaults public="1" set="method" line="27"><f a="?kind">
	<c path="String"/>
	<x path="Any"/>
</f></getDefaults>
		<loadMaterialProps public="1" set="method" line="32"><f a="material">
	<c path="h3d.mat.Material"/>
	<x path="Any"/>
</f></loadMaterialProps>
		<saveMaterialProps public="1" set="method" line="36"><f a="material">
	<c path="h3d.mat.Material"/>
	<x path="Void"/>
</f></saveMaterialProps>
		<customMeshInit public="1" set="method" line="44"><f a="mesh">
	<c path="h3d.scene.Mesh"/>
	<x path="Void"/>
</f></customMeshInit>
		<new public="1" set="method" line="9"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.mat.Pass" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/mat/Pass.hx">
		<implements path="hxd.impl._Serializable.NoSerializeSupport"/>
		<getEnableLights public="1" get="inline" set="null" line="19" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></getEnableLights>
		<enableLights_bits public="1" get="inline" set="null" expr="1" line="108" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</enableLights_bits>
		<enableLights_offset public="1" get="inline" set="null" expr="0" line="114" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</enableLights_offset>
		<enableLights_mask public="1" get="inline" set="null" expr="1" line="120" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</enableLights_mask>
		<getDynamicParameters public="1" get="inline" set="null" line="24" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></getDynamicParameters>
		<dynamicParameters_bits public="1" get="inline" set="null" expr="1" line="108" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</dynamicParameters_bits>
		<dynamicParameters_offset public="1" get="inline" set="null" expr="1" line="114" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</dynamicParameters_offset>
		<dynamicParameters_mask public="1" get="inline" set="null" expr="2" line="120" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</dynamicParameters_mask>
		<getIsStatic public="1" get="inline" set="null" line="30" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></getIsStatic>
		<isStatic_bits public="1" get="inline" set="null" expr="1" line="108" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</isStatic_bits>
		<isStatic_offset public="1" get="inline" set="null" expr="2" line="114" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</isStatic_offset>
		<isStatic_mask public="1" get="inline" set="null" expr="4" line="120" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</isStatic_mask>
		<getBatchMode public="1" get="inline" set="null" line="32" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></getBatchMode>
		<batchMode_bits public="1" get="inline" set="null" expr="1" line="108" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</batchMode_bits>
		<batchMode_offset public="1" get="inline" set="null" expr="3" line="114" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</batchMode_offset>
		<batchMode_mask public="1" get="inline" set="null" expr="8" line="120" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>8</e></m></meta>
		</batchMode_mask>
		<getCulling public="1" get="inline" set="null" line="34" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></getCulling>
		<culling_bits public="1" get="inline" set="null" expr="2" line="108" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</culling_bits>
		<culling_offset public="1" get="inline" set="null" expr="0" line="114" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</culling_offset>
		<culling_mask public="1" get="inline" set="null" expr="3" line="120" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</culling_mask>
		<getDepthWrite public="1" get="inline" set="null" line="35" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></getDepthWrite>
		<depthWrite_bits public="1" get="inline" set="null" expr="1" line="108" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</depthWrite_bits>
		<depthWrite_offset public="1" get="inline" set="null" expr="2" line="114" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</depthWrite_offset>
		<depthWrite_mask public="1" get="inline" set="null" expr="4" line="120" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</depthWrite_mask>
		<getDepthTest public="1" get="inline" set="null" line="36" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></getDepthTest>
		<depthTest_bits public="1" get="inline" set="null" expr="3" line="108" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</depthTest_bits>
		<depthTest_offset public="1" get="inline" set="null" expr="3" line="114" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</depthTest_offset>
		<depthTest_mask public="1" get="inline" set="null" expr="56" line="120" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>56</e></m></meta>
		</depthTest_mask>
		<getBlendSrc public="1" get="inline" set="null" line="37" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></getBlendSrc>
		<blendSrc_bits public="1" get="inline" set="null" expr="4" line="108" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</blendSrc_bits>
		<blendSrc_offset public="1" get="inline" set="null" expr="6" line="114" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>6</e></m></meta>
		</blendSrc_offset>
		<blendSrc_mask public="1" get="inline" set="null" expr="960" line="120" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>960</e></m></meta>
		</blendSrc_mask>
		<getBlendDst public="1" get="inline" set="null" line="38" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></getBlendDst>
		<blendDst_bits public="1" get="inline" set="null" expr="4" line="108" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</blendDst_bits>
		<blendDst_offset public="1" get="inline" set="null" expr="10" line="114" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>10</e></m></meta>
		</blendDst_offset>
		<blendDst_mask public="1" get="inline" set="null" expr="15360" line="120" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>15360</e></m></meta>
		</blendDst_mask>
		<getBlendAlphaSrc public="1" get="inline" set="null" line="39" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></getBlendAlphaSrc>
		<blendAlphaSrc_bits public="1" get="inline" set="null" expr="4" line="108" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</blendAlphaSrc_bits>
		<blendAlphaSrc_offset public="1" get="inline" set="null" expr="14" line="114" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>14</e></m></meta>
		</blendAlphaSrc_offset>
		<blendAlphaSrc_mask public="1" get="inline" set="null" expr="245760" line="120" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>245760</e></m></meta>
		</blendAlphaSrc_mask>
		<getBlendAlphaDst public="1" get="inline" set="null" line="40" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></getBlendAlphaDst>
		<blendAlphaDst_bits public="1" get="inline" set="null" expr="4" line="108" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</blendAlphaDst_bits>
		<blendAlphaDst_offset public="1" get="inline" set="null" expr="18" line="114" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>18</e></m></meta>
		</blendAlphaDst_offset>
		<blendAlphaDst_mask public="1" get="inline" set="null" expr="3932160" line="120" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3932160</e></m></meta>
		</blendAlphaDst_mask>
		<getBlendOp public="1" get="inline" set="null" line="41" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></getBlendOp>
		<blendOp_bits public="1" get="inline" set="null" expr="3" line="108" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</blendOp_bits>
		<blendOp_offset public="1" get="inline" set="null" expr="22" line="114" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>22</e></m></meta>
		</blendOp_offset>
		<blendOp_mask public="1" get="inline" set="null" expr="29360128" line="120" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>29360128</e></m></meta>
		</blendOp_mask>
		<getBlendAlphaOp public="1" get="inline" set="null" line="42" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></getBlendAlphaOp>
		<blendAlphaOp_bits public="1" get="inline" set="null" expr="3" line="108" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</blendAlphaOp_bits>
		<blendAlphaOp_offset public="1" get="inline" set="null" expr="25" line="114" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>25</e></m></meta>
		</blendAlphaOp_offset>
		<blendAlphaOp_mask public="1" get="inline" set="null" expr="234881024" line="120" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>234881024</e></m></meta>
		</blendAlphaOp_mask>
		<getWireframe public="1" get="inline" set="null" line="43" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></getWireframe>
		<wireframe_bits public="1" get="inline" set="null" expr="1" line="108" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</wireframe_bits>
		<wireframe_offset public="1" get="inline" set="null" expr="28" line="114" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>28</e></m></meta>
		</wireframe_offset>
		<wireframe_mask public="1" get="inline" set="null" expr="268435456" line="120" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>268435456</e></m></meta>
		</wireframe_mask>
		<getReserved public="1" get="inline" set="null" line="50" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></getReserved>
		<reserved_bits public="1" get="inline" set="null" expr="1" line="108" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</reserved_bits>
		<reserved_offset public="1" get="inline" set="null" expr="29" line="114" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>29</e></m></meta>
		</reserved_offset>
		<reserved_mask public="1" get="inline" set="null" expr="536870912" line="120" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>536870912</e></m></meta>
		</reserved_mask>
		<name public="1" set="null">
			<c path="String"/>
			<meta><m n=":s"/></meta>
		</name>
		<flags><x path="Int"/></flags>
		<passId><x path="Int"/></passId>
		<bits expr="0">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":s"/>
			</meta>
		</bits>
		<parentPass>
			<c path="h3d.mat.Pass"/>
			<meta><m n=":s"/></meta>
		</parentPass>
		<parentShaders><c path="hxsl.ShaderList"/></parentShaders>
		<shaders><c path="hxsl.ShaderList"/></shaders>
		<nextPass>
			<c path="h3d.mat.Pass"/>
			<meta><m n=":s"/></meta>
		</nextPass>
		<enableLights public="1" set="accessor">
			<x path="Bool"/>
			<meta><m n=":bits"><e>flags</e></m></meta>
		</enableLights>
		<dynamicParameters public="1" set="accessor">
			<x path="Bool"/>
			<meta><m n=":bits"><e>flags</e></m></meta>
			<haxe_doc>Inform the pass system that the parameters will be modified in object draw() command,
		so they will be manually uploaded by calling RenderContext.uploadParams.</haxe_doc>
		</dynamicParameters>
		<isStatic public="1" set="accessor">
			<x path="Bool"/>
			<meta><m n=":bits"><e>flags</e></m></meta>
			<haxe_doc>Mark the pass as static, this will allow some renderers or shadows to filter it
		when rendering static/dynamic parts.</haxe_doc>
		</isStatic>
		<batchMode set="accessor">
			<x path="Bool"/>
			<meta><m n=":bits"><e>flags</e></m></meta>
		</batchMode>
		<culling public="1" set="accessor">
			<e path="h3d.mat.Face"/>
			<meta><m n=":bits"><e>bits</e></m></meta>
		</culling>
		<depthWrite public="1" set="accessor">
			<x path="Bool"/>
			<meta><m n=":bits"><e>bits</e></m></meta>
		</depthWrite>
		<depthTest public="1" set="accessor">
			<e path="h3d.mat.Compare"/>
			<meta><m n=":bits"><e>bits</e></m></meta>
		</depthTest>
		<blendSrc public="1" set="accessor">
			<e path="h3d.mat.Blend"/>
			<meta><m n=":bits"><e>bits</e></m></meta>
		</blendSrc>
		<blendDst public="1" set="accessor">
			<e path="h3d.mat.Blend"/>
			<meta><m n=":bits"><e>bits</e></m></meta>
		</blendDst>
		<blendAlphaSrc public="1" set="accessor">
			<e path="h3d.mat.Blend"/>
			<meta><m n=":bits"><e>bits</e></m></meta>
		</blendAlphaSrc>
		<blendAlphaDst public="1" set="accessor">
			<e path="h3d.mat.Blend"/>
			<meta><m n=":bits"><e>bits</e></m></meta>
		</blendAlphaDst>
		<blendOp public="1" set="accessor">
			<e path="h3d.mat.Operation"/>
			<meta><m n=":bits"><e>bits</e></m></meta>
		</blendOp>
		<blendAlphaOp public="1" set="accessor">
			<e path="h3d.mat.Operation"/>
			<meta><m n=":bits"><e>bits</e></m></meta>
		</blendAlphaOp>
		<wireframe public="1" set="accessor">
			<x path="Bool"/>
			<meta><m n=":bits"><e>bits</e></m></meta>
		</wireframe>
		<colorMask public="1"><x path="Int"/></colorMask>
		<layer public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</layer>
		<stencil public="1">
			<c path="h3d.mat.Stencil"/>
			<meta><m n=":s"/></meta>
		</stencil>
		<reserved set="accessor">
			<x path="Bool"/>
			<meta>
				<m n=":bits"><e>bits</e></m>
				<m n=":noCompletion"/>
			</meta>
		</reserved>
		<load public="1" set="method" line="63"><f a="p">
	<c path="h3d.mat.Pass"/>
	<x path="Void"/>
</f></load>
		<setPassName public="1" set="method" line="85"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></setPassName>
		<blend public="1" get="inline" set="null" line="90"><f a="src:dst">
	<e path="h3d.mat.Blend"/>
	<e path="h3d.mat.Blend"/>
	<x path="Void"/>
</f></blend>
		<setBlendMode public="1" set="method" line="97"><f a="b">
	<t path="h3d.mat.BlendMode"/>
	<x path="Void"/>
</f></setBlendMode>
		<depth public="1" set="method" line="163"><f a="write:test">
	<x path="Bool"/>
	<e path="h3d.mat.Compare"/>
	<x path="Void"/>
</f></depth>
		<setColorMask public="1" set="method" line="168"><f a="r:g:b:a">
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></setColorMask>
		<setColorChannel public="1" set="method" line="172"><f a="c">
	<e path="hxsl.Channel"/>
	<x path="Void"/>
</f></setColorChannel>
		<addShader public="1" params="T" set="method" line="182"><f a="s">
	<c path="addShader.T"/>
	<c path="addShader.T"/>
</f></addShader>
		<addShaderAtIndex params="T" set="method" line="192">
			<f a="s:index">
				<c path="addShaderAtIndex.T"/>
				<x path="Int"/>
				<c path="addShaderAtIndex.T"/>
			</f>
			<haxe_doc>Can be used for internal usage</haxe_doc>
		</addShaderAtIndex>
		<getShaderIndex set="method" line="207"><f a="s">
	<c path="hxsl.Shader"/>
	<x path="Int"/>
</f></getShaderIndex>
		<removeShader public="1" set="method" line="218"><f a="s">
	<c path="hxsl.Shader"/>
	<x path="Bool"/>
</f></removeShader>
		<getShader public="1" params="T" set="method" line="234"><f a="t">
	<x path="Class"><c path="getShader.T"/></x>
	<c path="getShader.T"/>
</f></getShader>
		<getShaderByName public="1" set="method" line="245"><f a="name">
	<c path="String"/>
	<c path="hxsl.Shader"/>
</f></getShaderByName>
		<getShaders public="1" get="inline" set="null" line="255"><f a=""><c path="hxsl._ShaderList.ShaderIterator"/></f></getShaders>
		<getShadersRec set="method" line="259"><f a=""><c path="hxsl.ShaderList"/></f></getShadersRec>
		<clone public="1" set="method" line="276"><f a=""><c path="h3d.mat.Pass"/></f></clone>
		<getDebugShaderCode public="1" set="method" line="285">
			<f a="scene:?toHxsl" v=":true">
				<c path="h3d.scene.Scene"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ toHxsl : true }</e></m></meta>
		</getDebugShaderCode>
		<set_enableLights set="method" line="19"><f a="v">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_enableLights>
		<set_dynamicParameters set="method" line="24"><f a="v">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_dynamicParameters>
		<set_isStatic set="method" line="30"><f a="v">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_isStatic>
		<set_batchMode set="method" line="32"><f a="v">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_batchMode>
		<set_culling set="method" line="34"><f a="v">
	<e path="h3d.mat.Face"/>
	<e path="h3d.mat.Face"/>
</f></set_culling>
		<set_depthWrite set="method" line="35"><f a="v">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_depthWrite>
		<set_depthTest set="method" line="36"><f a="v">
	<e path="h3d.mat.Compare"/>
	<e path="h3d.mat.Compare"/>
</f></set_depthTest>
		<set_blendSrc set="method" line="37"><f a="v">
	<e path="h3d.mat.Blend"/>
	<e path="h3d.mat.Blend"/>
</f></set_blendSrc>
		<set_blendDst set="method" line="38"><f a="v">
	<e path="h3d.mat.Blend"/>
	<e path="h3d.mat.Blend"/>
</f></set_blendDst>
		<set_blendAlphaSrc set="method" line="39"><f a="v">
	<e path="h3d.mat.Blend"/>
	<e path="h3d.mat.Blend"/>
</f></set_blendAlphaSrc>
		<set_blendAlphaDst set="method" line="40"><f a="v">
	<e path="h3d.mat.Blend"/>
	<e path="h3d.mat.Blend"/>
</f></set_blendAlphaDst>
		<set_blendOp set="method" line="41"><f a="v">
	<e path="h3d.mat.Operation"/>
	<e path="h3d.mat.Operation"/>
</f></set_blendOp>
		<set_blendAlphaOp set="method" line="42"><f a="v">
	<e path="h3d.mat.Operation"/>
	<e path="h3d.mat.Operation"/>
</f></set_blendAlphaOp>
		<set_wireframe set="method" line="43"><f a="v">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_wireframe>
		<set_reserved set="method" line="50"><f a="v">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_reserved>
		<loadFlags set="method" line="6"><f a="bits">
	<x path="Int"/>
	<x path="Void"/>
</f></loadFlags>
		<loadBits set="method" line="6"><f a="bits">
	<x path="Int"/>
	<x path="Void"/>
</f></loadBits>
		<new public="1" set="method" line="52"><f a="name:?shaders:?parent">
	<c path="String"/>
	<c path="hxsl.ShaderList"/>
	<c path="h3d.mat.Pass"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>h3d.mat.BaseMaterial</e></m>
			<m n=":build"><e>hxd.impl.BitsBuilder.build()</e></m>
		</meta>
	</class>
	<class path="h3d.mat.Stencil" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/mat/Stencil.hx">
		<implements path="hxd.impl._Serializable.NoSerializeSupport"/>
		<getReadMask public="1" get="inline" set="null" line="13" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></getReadMask>
		<readMask_bits public="1" get="inline" set="null" expr="8" line="108" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>8</e></m></meta>
		</readMask_bits>
		<readMask_offset public="1" get="inline" set="null" expr="0" line="114" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</readMask_offset>
		<readMask_mask public="1" get="inline" set="null" expr="255" line="120" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>255</e></m></meta>
		</readMask_mask>
		<getWriteMask public="1" get="inline" set="null" line="14" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></getWriteMask>
		<writeMask_bits public="1" get="inline" set="null" expr="8" line="108" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>8</e></m></meta>
		</writeMask_bits>
		<writeMask_offset public="1" get="inline" set="null" expr="8" line="114" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>8</e></m></meta>
		</writeMask_offset>
		<writeMask_mask public="1" get="inline" set="null" expr="65280" line="120" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>65280</e></m></meta>
		</writeMask_mask>
		<getReference public="1" get="inline" set="null" line="15" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></getReference>
		<reference_bits public="1" get="inline" set="null" expr="8" line="108" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>8</e></m></meta>
		</reference_bits>
		<reference_offset public="1" get="inline" set="null" expr="16" line="114" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>16</e></m></meta>
		</reference_offset>
		<reference_mask public="1" get="inline" set="null" expr="16711680" line="120" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>16711680</e></m></meta>
		</reference_mask>
		<getFrontTest public="1" get="inline" set="null" line="17" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></getFrontTest>
		<frontTest_bits public="1" get="inline" set="null" expr="3" line="108" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</frontTest_bits>
		<frontTest_offset public="1" get="inline" set="null" expr="0" line="114" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</frontTest_offset>
		<frontTest_mask public="1" get="inline" set="null" expr="7" line="120" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>7</e></m></meta>
		</frontTest_mask>
		<getFrontPass public="1" get="inline" set="null" line="18" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></getFrontPass>
		<frontPass_bits public="1" get="inline" set="null" expr="3" line="108" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</frontPass_bits>
		<frontPass_offset public="1" get="inline" set="null" expr="3" line="114" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</frontPass_offset>
		<frontPass_mask public="1" get="inline" set="null" expr="56" line="120" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>56</e></m></meta>
		</frontPass_mask>
		<getFrontSTfail public="1" get="inline" set="null" line="19" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></getFrontSTfail>
		<frontSTfail_bits public="1" get="inline" set="null" expr="3" line="108" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</frontSTfail_bits>
		<frontSTfail_offset public="1" get="inline" set="null" expr="6" line="114" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>6</e></m></meta>
		</frontSTfail_offset>
		<frontSTfail_mask public="1" get="inline" set="null" expr="448" line="120" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>448</e></m></meta>
		</frontSTfail_mask>
		<getFrontDPfail public="1" get="inline" set="null" line="20" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></getFrontDPfail>
		<frontDPfail_bits public="1" get="inline" set="null" expr="3" line="108" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</frontDPfail_bits>
		<frontDPfail_offset public="1" get="inline" set="null" expr="9" line="114" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>9</e></m></meta>
		</frontDPfail_offset>
		<frontDPfail_mask public="1" get="inline" set="null" expr="3584" line="120" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3584</e></m></meta>
		</frontDPfail_mask>
		<getBackTest public="1" get="inline" set="null" line="22" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></getBackTest>
		<backTest_bits public="1" get="inline" set="null" expr="3" line="108" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</backTest_bits>
		<backTest_offset public="1" get="inline" set="null" expr="12" line="114" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>12</e></m></meta>
		</backTest_offset>
		<backTest_mask public="1" get="inline" set="null" expr="28672" line="120" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>28672</e></m></meta>
		</backTest_mask>
		<getBackPass public="1" get="inline" set="null" line="23" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></getBackPass>
		<backPass_bits public="1" get="inline" set="null" expr="3" line="108" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</backPass_bits>
		<backPass_offset public="1" get="inline" set="null" expr="15" line="114" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>15</e></m></meta>
		</backPass_offset>
		<backPass_mask public="1" get="inline" set="null" expr="229376" line="120" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>229376</e></m></meta>
		</backPass_mask>
		<getBackSTfail public="1" get="inline" set="null" line="24" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></getBackSTfail>
		<backSTfail_bits public="1" get="inline" set="null" expr="3" line="108" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</backSTfail_bits>
		<backSTfail_offset public="1" get="inline" set="null" expr="18" line="114" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>18</e></m></meta>
		</backSTfail_offset>
		<backSTfail_mask public="1" get="inline" set="null" expr="1835008" line="120" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1835008</e></m></meta>
		</backSTfail_mask>
		<getBackDPfail public="1" get="inline" set="null" line="25" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></getBackDPfail>
		<backDPfail_bits public="1" get="inline" set="null" expr="3" line="108" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</backDPfail_bits>
		<backDPfail_offset public="1" get="inline" set="null" expr="21" line="114" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>21</e></m></meta>
		</backDPfail_offset>
		<backDPfail_mask public="1" get="inline" set="null" expr="14680064" line="120" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>14680064</e></m></meta>
		</backDPfail_mask>
		<maskBits expr="0">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":s"/>
			</meta>
		</maskBits>
		<opBits expr="0">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":s"/>
			</meta>
		</opBits>
		<readMask public="1" set="accessor">
			<x path="Int"/>
			<meta><m n=":bits">
	<e>maskBits</e>
	<e>8</e>
</m></meta>
		</readMask>
		<writeMask public="1" set="accessor">
			<x path="Int"/>
			<meta><m n=":bits">
	<e>maskBits</e>
	<e>8</e>
</m></meta>
		</writeMask>
		<reference public="1" set="accessor">
			<x path="Int"/>
			<meta><m n=":bits">
	<e>maskBits</e>
	<e>8</e>
</m></meta>
		</reference>
		<frontTest public="1" set="accessor">
			<e path="h3d.mat.Compare"/>
			<meta><m n=":bits"><e>opBits</e></m></meta>
		</frontTest>
		<frontPass public="1" set="accessor">
			<e path="h3d.mat.StencilOp"/>
			<meta><m n=":bits"><e>opBits</e></m></meta>
		</frontPass>
		<frontSTfail public="1" set="accessor">
			<e path="h3d.mat.StencilOp"/>
			<meta><m n=":bits"><e>opBits</e></m></meta>
		</frontSTfail>
		<frontDPfail public="1" set="accessor">
			<e path="h3d.mat.StencilOp"/>
			<meta><m n=":bits"><e>opBits</e></m></meta>
		</frontDPfail>
		<backTest public="1" set="accessor">
			<e path="h3d.mat.Compare"/>
			<meta><m n=":bits"><e>opBits</e></m></meta>
		</backTest>
		<backPass public="1" set="accessor">
			<e path="h3d.mat.StencilOp"/>
			<meta><m n=":bits"><e>opBits</e></m></meta>
		</backPass>
		<backSTfail public="1" set="accessor">
			<e path="h3d.mat.StencilOp"/>
			<meta><m n=":bits"><e>opBits</e></m></meta>
		</backSTfail>
		<backDPfail public="1" set="accessor">
			<e path="h3d.mat.StencilOp"/>
			<meta><m n=":bits"><e>opBits</e></m></meta>
		</backDPfail>
		<setFront public="1" set="method" line="32"><f a="stfail:dpfail:pass">
	<e path="h3d.mat.StencilOp"/>
	<e path="h3d.mat.StencilOp"/>
	<e path="h3d.mat.StencilOp"/>
	<x path="Void"/>
</f></setFront>
		<setBack public="1" set="method" line="38"><f a="stfail:dpfail:pass">
	<e path="h3d.mat.StencilOp"/>
	<e path="h3d.mat.StencilOp"/>
	<e path="h3d.mat.StencilOp"/>
	<x path="Void"/>
</f></setBack>
		<setOp public="1" set="method" line="44"><f a="stfail:dpfail:pass">
	<e path="h3d.mat.StencilOp"/>
	<e path="h3d.mat.StencilOp"/>
	<e path="h3d.mat.StencilOp"/>
	<x path="Void"/>
</f></setOp>
		<setFunc public="1" set="method" line="49">
			<f a="f:?reference:?readMask:?writeMask" v=":0:0xFF:0xFF">
				<e path="h3d.mat.Compare"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ writeMask : 0xFF, readMask : 0xFF, reference : 0 }</e></m></meta>
		</setFunc>
		<clone public="1" set="method" line="56"><f a=""><c path="h3d.mat.Stencil"/></f></clone>
		<load public="1" set="method" line="63"><f a="s">
	<c path="h3d.mat.Stencil"/>
	<x path="Void"/>
</f></load>
		<set_readMask set="method" line="13"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></set_readMask>
		<set_writeMask set="method" line="14"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></set_writeMask>
		<set_reference set="method" line="15"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></set_reference>
		<set_frontTest set="method" line="17"><f a="v">
	<e path="h3d.mat.Compare"/>
	<e path="h3d.mat.Compare"/>
</f></set_frontTest>
		<set_frontPass set="method" line="18"><f a="v">
	<e path="h3d.mat.StencilOp"/>
	<e path="h3d.mat.StencilOp"/>
</f></set_frontPass>
		<set_frontSTfail set="method" line="19"><f a="v">
	<e path="h3d.mat.StencilOp"/>
	<e path="h3d.mat.StencilOp"/>
</f></set_frontSTfail>
		<set_frontDPfail set="method" line="20"><f a="v">
	<e path="h3d.mat.StencilOp"/>
	<e path="h3d.mat.StencilOp"/>
</f></set_frontDPfail>
		<set_backTest set="method" line="22"><f a="v">
	<e path="h3d.mat.Compare"/>
	<e path="h3d.mat.Compare"/>
</f></set_backTest>
		<set_backPass set="method" line="23"><f a="v">
	<e path="h3d.mat.StencilOp"/>
	<e path="h3d.mat.StencilOp"/>
</f></set_backPass>
		<set_backSTfail set="method" line="24"><f a="v">
	<e path="h3d.mat.StencilOp"/>
	<e path="h3d.mat.StencilOp"/>
</f></set_backSTfail>
		<set_backDPfail set="method" line="25"><f a="v">
	<e path="h3d.mat.StencilOp"/>
	<e path="h3d.mat.StencilOp"/>
</f></set_backDPfail>
		<loadOpBits set="method" line="6"><f a="bits">
	<x path="Int"/>
	<x path="Void"/>
</f></loadOpBits>
		<loadMaskBits set="method" line="6"><f a="bits">
	<x path="Int"/>
	<x path="Void"/>
</f></loadMaskBits>
		<new public="1" set="method" line="27"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>h3d.mat.Material</e></m>
			<m n=":build"><e>hxd.impl.BitsBuilder.build()</e></m>
		</meta>
	</class>
	<enum path="hxd.PixelFormat" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/PixelFormat.hx">
		<ARGB/>
		<BGRA/>
		<RGBA/>
		<RGBA16F/>
		<RGBA32F/>
		<R8/>
		<R16F/>
		<R32F/>
		<RG8/>
		<RG16F/>
		<RG32F/>
		<RGB8/>
		<RGB16F/>
		<RGB32F/>
		<SRGB/>
		<SRGB_ALPHA/>
		<RGB10A2/>
		<RG11B10UF/>
		<S3TC a="v"><x path="Int"/></S3TC>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<class path="h3d.mat.Texture" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/mat/Texture.hx">
		<UID expr="0" line="7" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</UID>
		<PREVENT_AUTO_DISPOSE final="1" set="null" expr="0x7FFFFFFF" line="8" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x7FFFFFFF</e></m></meta>
		</PREVENT_AUTO_DISPOSE>
		<nativeFormat public="1" set="null" expr="RGBA" line="19" static="1">
			<t path="h3d.mat.TextureFormat"/>
			<meta><m n=":value"><e>RGBA</e></m></meta>
			<haxe_doc>The default texture color format</haxe_doc>
		</nativeFormat>
		<fromBitmap public="1" set="method" line="397" static="1"><f a="bmp">
	<c path="hxd.BitmapData"/>
	<c path="h3d.mat.Texture"/>
</f></fromBitmap>
		<fromPixels public="1" set="method" line="403" static="1"><f a="pixels">
	<c path="hxd.Pixels"/>
	<c path="h3d.mat.Texture"/>
</f></fromPixels>
		<fromColor public="1" set="method" line="412" static="1">
			<f a="color:?alpha" v=":1.">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Null"><c path="h3d.mat.Texture"/></x>
			</f>
			<meta><m n=":value"><e>{ alpha : 1. }</e></m></meta>
			<haxe_doc>Creates a 1x1 texture using the RGB color passed as parameter.</haxe_doc>
		</fromColor>
		<genDisc public="1" set="method" line="429" static="1">
			<f a="size:color:?alpha" v="::1.">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<c path="h3d.mat.Texture"/>
			</f>
			<meta><m n=":value"><e>{ alpha : 1. }</e></m></meta>
		</genDisc>
		<genTexture set="method" line="433" static="1"><f a="mode:size:color:alpha">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<c path="h3d.mat.Texture"/>
</f></genTexture>
		<drawGenTexture set="method" line="454" static="1"><f a="t:color:mode">
	<c path="h3d.mat.Texture"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></drawGenTexture>
		<defaultCubeTexture public="1" set="method" line="469" static="1">
			<f a=""><c path="h3d.mat.Texture"/></f>
			<haxe_doc>Returns a default dummy 1x1 black cube texture</haxe_doc>
		</defaultCubeTexture>
		<genChecker public="1" set="method" line="484" static="1">
			<f a="size">
				<x path="Int"/>
				<c path="h3d.mat.Texture"/>
			</f>
			<haxe_doc>Returns a checker texture of size x size, than can be repeated</haxe_doc>
		</genChecker>
		<checkerTextureKeys expr="new Map&lt;Int,{ }&gt;()" line="500" static="1">
			<x path="haxe.ds.Map">
				<x path="Int"/>
				<a/>
			</x>
			<meta><m n=":value"><e><![CDATA[new Map<Int,{ }>()]]></e></m></meta>
		</checkerTextureKeys>
		<noiseTextureKeys expr="new Map&lt;Int,{ }&gt;()" line="501" static="1">
			<x path="haxe.ds.Map">
				<x path="Int"/>
				<a/>
			</x>
			<meta><m n=":value"><e><![CDATA[new Map<Int,{ }>()]]></e></m></meta>
		</noiseTextureKeys>
		<genTextureKeys expr="new Map&lt;String,{ }&gt;()" line="502" static="1">
			<x path="haxe.ds.Map">
				<c path="String"/>
				<a/>
			</x>
			<meta><m n=":value"><e><![CDATA[new Map<String,{ }>()]]></e></m></meta>
		</genTextureKeys>
		<genNoise public="1" set="method" line="504" static="1"><f a="size">
	<x path="Int"/>
	<c path="h3d.mat.Texture"/>
</f></genNoise>
		<allocNoise set="method" line="520" static="1"><f a="t:size">
	<c path="h3d.mat.Texture"/>
	<x path="Int"/>
	<x path="Void"/>
</f></allocNoise>
		<allocChecker set="method" line="531" static="1"><f a="t:size">
	<c path="h3d.mat.Texture"/>
	<x path="Int"/>
	<x path="Void"/>
</f></allocChecker>
		<t><t path="h3d.impl.Texture"/></t>
		<mem><c path="h3d.impl.MemoryManager"/></mem>
		<id public="1" set="null"><x path="Int"/></id>
		<name public="1" set="null"><c path="String"/></name>
		<width public="1" set="null"><x path="Int"/></width>
		<height public="1" set="null"><x path="Int"/></height>
		<flags public="1" set="null"><x path="haxe.EnumFlags"><e path="h3d.mat.TextureFlags"/></x></flags>
		<format public="1" set="null"><t path="h3d.mat.TextureFormat"/></format>
		<lastFrame get="accessor" set="accessor"><x path="Int"/></lastFrame>
		<bits><x path="Int"/></bits>
		<waitLoads><c path="Array"><f a=""><x path="Void"/></f></c></waitLoads>
		<mipMap public="1" set="accessor"><e path="h3d.mat.MipMap"/></mipMap>
		<filter public="1" set="accessor"><e path="h3d.mat.Filter"/></filter>
		<wrap public="1" set="accessor"><e path="h3d.mat.Wrap"/></wrap>
		<layerCount public="1" get="accessor" set="null"><x path="Int"/></layerCount>
		<realloc public="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>If this callback is set, the texture can be re-allocated when the 3D context has been lost or when
		it's been free because of lack of memory.</haxe_doc>
		</realloc>
		<depthBuffer public="1">
			<c path="h3d.mat.DepthBuffer"/>
			<haxe_doc>When the texture is used as render target, tells which depth buffer will be used.
		If set to null, depth testing is disabled.</haxe_doc>
		</depthBuffer>
		<_lastFrame><x path="Int"/></_lastFrame>
		<set_lastFrame set="method" line="56"><f a="lf">
	<x path="Int"/>
	<x path="Int"/>
</f></set_lastFrame>
		<get_lastFrame set="method" line="64"><f a=""><x path="Int"/></f></get_lastFrame>
		<get_layerCount set="method" line="104"><f a=""><x path="Int"/></f></get_layerCount>
		<alloc public="1" set="method" line="108"><f a=""><x path="Void"/></f></alloc>
		<isSRGB public="1" set="method" line="113"><f a=""><x path="Bool"/></f></isSRGB>
		<checkAlloc set="method" line="117"><f a=""><x path="Void"/></f></checkAlloc>
		<clone public="1" set="method" line="124"><f a=""><c path="h3d.mat.Texture"/></f></clone>
		<preventAutoDispose public="1" set="method" line="149">
			<f a=""><x path="Void"/></f>
			<haxe_doc>In case of out of GPU memory, textures that hasn't been used for a long time will be disposed.
		Calling this will make this texture not considered for auto disposal.</haxe_doc>
		</preventAutoDispose>
		<waitLoad public="1" set="method" line="158">
			<f a="f">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<haxe_doc>Some textures might take some time to load. You can check flags.has(Loading)
		or add a waitLoad callback which will get called either immediately if the texture is already loaded
		or when loading is complete.</haxe_doc>
		</waitLoad>
		<toString set="method" line="167"><f a=""><c path="String"/></f></toString>
		<setName public="1" set="method" line="178"><f a="n">
	<c path="String"/>
	<x path="Void"/>
</f></setName>
		<set_mipMap set="method" line="182"><f a="m">
	<e path="h3d.mat.MipMap"/>
	<e path="h3d.mat.MipMap"/>
</f></set_mipMap>
		<set_filter set="method" line="187"><f a="f">
	<e path="h3d.mat.Filter"/>
	<e path="h3d.mat.Filter"/>
</f></set_filter>
		<set_wrap set="method" line="192"><f a="w">
	<e path="h3d.mat.Wrap"/>
	<e path="h3d.mat.Wrap"/>
</f></set_wrap>
		<isDisposed public="1" get="inline" set="null" line="197"><f a=""><x path="Bool"/></f></isDisposed>
		<resize public="1" set="method" line="201"><f a="width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></resize>
		<clearF public="1" set="method" line="219">
			<f a="?r:?g:?b:?a:?layer" v="0.:0.:0.:0.:-1">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ layer : -1, a : 0., b : 0., g : 0., r : 0. }</e></m></meta>
		</clearF>
		<clear public="1" set="method" line="237">
			<f a="color:?alpha:?layer" v=":1.:-1">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ layer : -1, alpha : 1. }</e></m></meta>
		</clear>
		<checkSize get="inline" set="null" line="283"><f a="width:height:mip">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></checkSize>
		<checkMipMapGen set="method" line="288"><f a="mipLevel:layer">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></checkMipMapGen>
		<uploadBitmap public="1" set="method" line="293">
			<f a="bmp:?mipLevel:?layer" v=":0:0">
				<c path="hxd.BitmapData"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ layer : 0, mipLevel : 0 }</e></m></meta>
		</uploadBitmap>
		<uploadPixels public="1" set="method" line="301">
			<f a="pixels:?mipLevel:?layer" v=":0:0">
				<c path="hxd.Pixels"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ layer : 0, mipLevel : 0 }</e></m></meta>
		</uploadPixels>
		<dispose public="1" set="method" line="309"><f a=""><x path="Void"/></f></dispose>
		<swapTexture public="1" set="method" line="318">
			<f a="t">
				<c path="h3d.mat.Texture"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Swap two textures, this is an immediate operation.
		BEWARE : if the texture is a cached image (hxd.res.Image), the swap will affect the cache!</haxe_doc>
		</swapTexture>
		<capturePixels public="1" set="method" line="332">
			<f a="?face:?mipLevel:?region" v="0:0:">
				<x path="Int"/>
				<x path="Int"/>
				<c path="h2d.col.IBounds"/>
				<c path="hxd.Pixels"/>
			</f>
			<meta><m n=":value"><e>{ mipLevel : 0, face : 0 }</e></m></meta>
			<haxe_doc>Downloads the current texture data from the GPU.
		Beware, this is a very slow operation that shouldn't be done during rendering.</haxe_doc>
		</capturePixels>
		<new public="1" set="method" line="69"><f a="w:h:?flags:?format">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><e path="h3d.mat.TextureFlags"/></c>
	<t path="h3d.mat.TextureFormat"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>h3d</e></m>
		</meta>
	</class>
	<class path="h3d.mat.TextureArray" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/mat/TextureArray.hx">
		<extends path="h3d.mat.Texture"/>
		<layers><x path="Int"/></layers>
		<get_layerCount set="method" line="15" override="1"><f a=""><x path="Int"/></f></get_layerCount>
		<clone public="1" set="method" line="19" override="1"><f a=""><c path="h3d.mat.TextureArray"/></f></clone>
		<toString set="method" line="28" override="1"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="8"><f a="w:h:layers:?flags:?format">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><e path="h3d.mat.TextureFlags"/></c>
	<t path="h3d.mat.TextureFormat"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="h3d.pass.Base" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/pass/Base.hx">
		<ctx><c path="h3d.scene.RenderContext"/></ctx>
		<name public="1" set="null"><c path="String"/></name>
		<compileShader public="1" set="method" line="12"><f a="p">
	<c path="h3d.mat.Pass"/>
	<c path="hxsl.RuntimeShader"/>
</f></compileShader>
		<setContext public="1" set="method" line="17"><f a="ctx">
	<c path="h3d.scene.RenderContext"/>
	<x path="Void"/>
</f></setContext>
		<dispose public="1" set="method" line="21"><f a=""><x path="Void"/></f></dispose>
		<draw public="1" set="method" line="24"><f a="passes:?sort">
	<c path="h3d.pass.PassList"/>
	<f a="">
		<c path="h3d.pass.PassList"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></draw>
		<new public="1" set="method" line="8"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="h3d.pass.ScreenFx" params="T" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/pass/ScreenFx.hx">
		<run public="1" set="method" line="86" static="1"><f a="shader:output:?layer">
	<c path="h3d.shader.ScreenShader"/>
	<c path="h3d.mat.Texture"/>
	<x path="Int"/>
	<x path="Void"/>
</f></run>
		<shader public="1"><c path="h3d.pass.ScreenFx.T"/></shader>
		<pass public="1"><c path="h3d.mat.Pass"/></pass>
		<primitive public="1"><c path="h3d.prim.Primitive"/></primitive>
		<manager><c path="h3d.pass.ShaderManager"/></manager>
		<_engine><c path="h3d.Engine"/></_engine>
		<engine get="accessor" set="null"><c path="h3d.Engine"/></engine>
		<shaders><c path="hxsl.ShaderList"/></shaders>
		<buffers><c path="h3d.shader.Buffers"/></buffers>
		<get_engine set="method" line="23"><f a=""><c path="h3d.Engine"/></f></get_engine>
		<copy set="method" line="28"><f a="src:dst">
	<c path="h3d.mat.Texture"/>
	<c path="h3d.mat.Texture"/>
	<x path="Void"/>
</f></copy>
		<setGlobals public="1" set="method" line="32"><f a="ctx">
	<c path="h3d.scene.RenderContext"/>
	<x path="Void"/>
</f></setGlobals>
		<addShader public="1" params="T" set="method" line="37"><f a="s">
	<c path="addShader.T"/>
	<c path="addShader.T"/>
</f></addShader>
		<removeShader public="1" set="method" line="42"><f a="s">
	<c path="hxsl.Shader"/>
	<x path="Bool"/>
</f></removeShader>
		<getShader public="1" params="T" set="method" line="56"><f a="cl">
	<x path="Class"><c path="getShader.T"/></x>
	<c path="getShader.T"/>
</f></getShader>
		<render public="1" set="method" line="64"><f a=""><x path="Void"/></f></render>
		<dispose public="1" set="method" line="83"><f a=""><x path="Void"/></f></dispose>
		<new public="1" set="method" line="14"><f a="shader:?output">
	<c path="h3d.pass.ScreenFx.T"/>
	<c path="Array"><e path="hxsl.Output"/></c>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.pass.Blur" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/pass/Blur.hx">
		<extends path="h3d.pass.ScreenFx"><c path="h3d.shader.Blur"/></extends>
		<cubeDir expr="[h3d.Matrix.L([0, 0, -1, 0, 0, -1, 0, 0, 1, 0, 0, 0]), h3d.Matrix.L([0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, 0]), h3d.Matrix.L([1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0]), h3d.Matrix.L([1, 0, 0, 0, 0, 0, -1, 0, 0, -1, 0, 0]), h3d.Matrix.L([1, 0, 0, 0, 0, -1, 0, 0, 0, 1, 0, 0]), h3d.Matrix.L([-1, 0, 0, 0, 0, -1, 0, 0, 0, 0, -1, 0])]">
			<c path="Array"><c path="h3d.Matrix"/></c>
			<meta><m n=":value"><e>[h3d.Matrix.L([0, 0, -1, 0, 0, -1, 0, 0, 1, 0, 0, 0]), h3d.Matrix.L([0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, 0]), h3d.Matrix.L([1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0]), h3d.Matrix.L([1, 0, 0, 0, 0, 0, -1, 0, 0, -1, 0, 0]), h3d.Matrix.L([1, 0, 0, 0, 0, -1, 0, 0, 0, 1, 0, 0]), h3d.Matrix.L([-1, 0, 0, 0, 0, -1, 0, 0, 0, 0, -1, 0])]</e></m></meta>
		</cubeDir>
		<radius public="1" set="accessor">
			<x path="Float"/>
			<haxe_doc>How far in pixels the blur will go.</haxe_doc>
		</radius>
		<gain public="1" set="accessor">
			<x path="Float"/>
			<haxe_doc>How much the blur increases or decreases the color amount (default = 1)</haxe_doc>
		</gain>
		<linear public="1" set="accessor">
			<x path="Float"/>
			<haxe_doc>Set linear blur instead of gaussian (default = 0).</haxe_doc>
		</linear>
		<quality public="1" set="accessor">
			<x path="Float"/>
			<haxe_doc>Adjust how much quality/speed tradeoff we want (default = 1)</haxe_doc>
		</quality>
		<values><c path="Array"><x path="Float"/></c></values>
		<offsets><c path="Array"><x path="Float"/></c></offsets>
		<set_radius set="method" line="44"><f a="r">
	<x path="Float"/>
	<x path="Float"/>
</f></set_radius>
		<set_quality set="method" line="51"><f a="q">
	<x path="Float"/>
	<x path="Float"/>
</f></set_quality>
		<set_gain set="method" line="58"><f a="s">
	<x path="Float"/>
	<x path="Float"/>
</f></set_gain>
		<set_linear set="method" line="65"><f a="b">
	<x path="Float"/>
	<x path="Float"/>
</f></set_linear>
		<gauss set="method" line="72"><f a="x:s">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></gauss>
		<calcValues set="method" line="79"><f a=""><x path="Void"/></f></calcValues>
		<getKernelSize public="1" set="method" line="121"><f a=""><x path="Int"/></f></getKernelSize>
		<apply public="1" set="method" line="126"><f a="ctx:src:?output">
	<c path="h3d.impl.RenderContext"/>
	<c path="h3d.mat.Texture"/>
	<c path="h3d.mat.Texture"/>
	<x path="Void"/>
</f></apply>
		<new public="1" set="method" line="36">
			<f a="?radius:?gain:?linear:?quality" v="1.:1.:0.:1.">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ quality : 1., linear : 0., gain : 1., radius : 1. }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n="ignore"><e>"shader"</e></m>
		</meta>
	</class>
	<class path="h3d.shader.ScreenShader" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/shader/ScreenShader.hx">
		<extends path="hxsl.Shader"/>
		<SRC expr="&quot;HXSLF2gzZC5zaGFkZXIuU2NyZWVuU2hhZGVyBwEFaW5wdXQNAQICCHBvc2l0aW9uBQoBAQADAnV2BQoBAQABAAAEBWZsaXBZAwIAAAUGb3V0cHV0DQICBghwb3NpdGlvbgUMBAUABwVjb2xvcgUMBAUABAAACApwaXhlbENvbG9yBQwEAAAJDGNhbGN1bGF0ZWRVVgUKBAAACghfX2luaXRfXw4GAAALBnZlcnRleA4GAAACAgoAAAUCBgQCBwUMAggFDAUMBgQCCQUKAgMFCgUKAAALAAAFAQYEAgYFDAkDKg4ECgICBQoAAAMGAQoCAgUKBAADAgQDAwEDAAAAAAAAAAADAQMAAAAAAADwPwMFDAUMAA&quot;" line="5" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"HXSLF2gzZC5zaGFkZXIuU2NyZWVuU2hhZGVyBwEFaW5wdXQNAQICCHBvc2l0aW9uBQoBAQADAnV2BQoBAQABAAAEBWZsaXBZAwIAAAUGb3V0cHV0DQICBghwb3NpdGlvbgUMBAUABwVjb2xvcgUMBAUABAAACApwaXhlbENvbG9yBQwEAAAJDGNhbGN1bGF0ZWRVVgUKBAAACghfX2luaXRfXw4GAAALBnZlcnRleA4GAAACAgoAAAUCBgQCBwUMAggFDAUMBgQCCQUKAgMFCgUKAAALAAAFAQYEAgYFDAkDKg4ECgICBQoAAAMGAQoCAgUKBAADAgQDAwEDAAAAAAAAAAADAQMAAAAAAADwPwMFDAUMAA"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<flipY public="1" get="accessor" set="accessor"><x path="Float"/></flipY>
		<flipY__ expr="0">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":noCompletion"/>
			</meta>
		</flipY__>
		<get_flipY get="inline" set="null" line="5">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_flipY>
		<set_flipY get="inline" set="null" line="5">
			<f a="_v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_flipY>
		<updateConstants public="1" set="method" line="5" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="5" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="3"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":src"><e>{
	@input var input:{ var position : Vec2; var uv : Vec2};
	@param var flipY:Float;
	var output:{ var position : Vec4; var color : Vec4};
	var pixelColor:Vec4;
	var calculatedUV:Vec2;
	function __init__() {
		output.color = pixelColor;
		calculatedUV = input.uv;
	};
	function vertex() {
		output.position = vec4(input.position.x, input.position.y * flipY, 0, 1);
	};
}</e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="h3d.pass._Border.BorderShader" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/pass/Border.hx" private="1" module="h3d.pass.Border">
		<extends path="h3d.shader.ScreenShader"/>
		<SRC expr="&quot;HXSLHWgzZC5wYXNzLl9Cb3JkZXIuQm9yZGVyU2hhZGVyCQEFaW5wdXQNAQICCHBvc2l0aW9uBQoBAQADAnV2BQoBAQABAAAEBWZsaXBZAwIAAAUGb3V0cHV0DQICBghwb3NpdGlvbgUMBAUABwVjb2xvcgUMBAUABAAACApwaXhlbENvbG9yBQwEAAAJDGNhbGN1bGF0ZWRVVgUKBAAACgVjb2xvcgUMAgAACwhfX2luaXRfXw4GAAAMBnZlcnRleA4GAAANCGZyYWdtZW50DgYAAAMCCwAABQIGBAIHBQwCCAUMBQwGBAIJBQoCAwUKBQoAAAwAAAUBBgQCBgUMCQMqDgQKAgIFCgAAAwYBCgICBQoEAAMCBAMDAQMAAAAAAAAAAAMBAwAAAAAAAPA/AwUMBQwAAQ0AAAUBBgQCCAUMAgoFDAUMAA&quot;" line="4" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"HXSLHWgzZC5wYXNzLl9Cb3JkZXIuQm9yZGVyU2hhZGVyCQEFaW5wdXQNAQICCHBvc2l0aW9uBQoBAQADAnV2BQoBAQABAAAEBWZsaXBZAwIAAAUGb3V0cHV0DQICBghwb3NpdGlvbgUMBAUABwVjb2xvcgUMBAUABAAACApwaXhlbENvbG9yBQwEAAAJDGNhbGN1bGF0ZWRVVgUKBAAACgVjb2xvcgUMAgAACwhfX2luaXRfXw4GAAAMBnZlcnRleA4GAAANCGZyYWdtZW50DgYAAAMCCwAABQIGBAIHBQwCCAUMBQwGBAIJBQoCAwUKBQoAAAwAAAUBBgQCBgUMCQMqDgQKAgIFCgAAAwYBCgICBQoEAAMCBAMDAQMAAAAAAAAAAAMBAwAAAAAAAPA/AwUMBQwAAQ0AAAUBBgQCCAUMAgoFDAUMAA"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<color public="1" get="accessor" set="accessor"><t path="hxsl.Vec"/></color>
		<color__ expr="new hxsl.Types.Vec()">
			<t path="hxsl.Vec"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Vec()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</color__>
		<get_color get="inline" set="null" line="4">
			<f a=""><t path="hxsl.Vec"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_color>
		<set_color get="inline" set="null" line="4">
			<f a="_v">
				<t path="hxsl.Vec"/>
				<t path="hxsl.Vec"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_color>
		<updateConstants public="1" set="method" line="4" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="4" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="4" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="4" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="3"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":src"><e>{
	@param var color:Vec4;
	function fragment() {
		pixelColor = color;
	};
}</e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="h3d.pass.Border" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/pass/Border.hx">
		<extends path="h3d.pass.ScreenFx"><c path="h3d.pass._Border.BorderShader"/></extends>
		<dispose public="1" set="method" line="49" override="1"><f a=""><x path="Void"/></f></dispose>
		<new public="1" set="method" line="17">
			<f a="width:height:?size" v="::1">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ size : 1 }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.pass._Copy.ArrayCopyShader" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/pass/Copy.hx" private="1" module="h3d.pass.Copy">
		<extends path="h3d.shader.ScreenShader"/>
		<SRC expr="&quot;HXSLHmgzZC5wYXNzLl9Db3B5LkFycmF5Q29weVNoYWRlcgoBBWlucHV0DQECAghwb3NpdGlvbgUKAQEAAwJ1dgUKAQEAAQAABAVmbGlwWQMCAAAFBm91dHB1dA0CAgYIcG9zaXRpb24FDAQFAAcFY29sb3IFDAQFAAQAAAgKcGl4ZWxDb2xvcgUMBAAACQxjYWxjdWxhdGVkVVYFCgQAAAoHdGV4dHVyZQsCAAALBWxheWVyAQIAAAwIX19pbml0X18OBgAADQZ2ZXJ0ZXgOBgAADghmcmFnbWVudA4GAAADAgwAAAUCBgQCBwUMAggFDAUMBgQCCQUKAgMFCgUKAAANAAAFAQYEAgYFDAkDKg4ECgICBQoAAAMGAQoCAgUKBAADAgQDAwEDAAAAAAAAAAADAQMAAAAAAADwPwMFDAUMAAEOAAAFAQYEAggFDAkDIQ4CAgoLCQMpDgICCQUKCQMmDgECCwEDBQsFDAUMAA&quot;" line="17" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"HXSLHmgzZC5wYXNzLl9Db3B5LkFycmF5Q29weVNoYWRlcgoBBWlucHV0DQECAghwb3NpdGlvbgUKAQEAAwJ1dgUKAQEAAQAABAVmbGlwWQMCAAAFBm91dHB1dA0CAgYIcG9zaXRpb24FDAQFAAcFY29sb3IFDAQFAAQAAAgKcGl4ZWxDb2xvcgUMBAAACQxjYWxjdWxhdGVkVVYFCgQAAAoHdGV4dHVyZQsCAAALBWxheWVyAQIAAAwIX19pbml0X18OBgAADQZ2ZXJ0ZXgOBgAADghmcmFnbWVudA4GAAADAgwAAAUCBgQCBwUMAggFDAUMBgQCCQUKAgMFCgUKAAANAAAFAQYEAgYFDAkDKg4ECgICBQoAAAMGAQoCAgUKBAADAgQDAwEDAAAAAAAAAAADAQMAAAAAAADwPwMFDAUMAAEOAAAFAQYEAggFDAkDIQ4CAgoLCQMpDgICCQUKCQMmDgECCwEDBQsFDAUMAA"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<texture public="1" get="accessor" set="accessor"><t path="hxsl.Sampler2DArray"/></texture>
		<texture__>
			<t path="hxsl.Sampler2DArray"/>
			<meta><m n=":noCompletion"/></meta>
		</texture__>
		<get_texture get="inline" set="null" line="17">
			<f a=""><t path="hxsl.Sampler2DArray"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_texture>
		<set_texture get="inline" set="null" line="17">
			<f a="_v">
				<t path="hxsl.Sampler2DArray"/>
				<t path="hxsl.Sampler2DArray"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_texture>
		<layer public="1" get="accessor" set="accessor"><x path="Int"/></layer>
		<layer__ expr="0">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":noCompletion"/>
			</meta>
		</layer__>
		<get_layer get="inline" set="null" line="17">
			<f a=""><x path="Int"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_layer>
		<set_layer get="inline" set="null" line="17">
			<f a="_v">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_layer>
		<updateConstants public="1" set="method" line="17" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="17" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="17" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="17" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="15"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":src"><e>{
	@param var texture:Sampler2DArray;
	@param var layer:Int;
	function fragment() {
		pixelColor = texture.get(vec3(calculatedUV, layer));
	};
}</e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="h3d.pass.ArrayCopy" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/pass/Copy.hx" module="h3d.pass.Copy">
		<extends path="h3d.pass.ScreenFx"><c path="h3d.pass._Copy.ArrayCopyShader"/></extends>
		<run public="1" set="method" line="58" static="1"><f a="from:fromLayer:to:?blend:?pass:?layer">
	<c path="h3d.mat.TextureArray"/>
	<x path="Int"/>
	<c path="h3d.mat.Texture"/>
	<t path="h3d.mat.BlendMode"/>
	<c path="h3d.mat.Pass"/>
	<x path="Int"/>
	<x path="Void"/>
</f></run>
		<apply public="1" set="method" line="32"><f a="from:fromLayer:to:?blend:?customPass:?layer">
	<c path="h3d.mat.TextureArray"/>
	<x path="Int"/>
	<c path="h3d.mat.Texture"/>
	<t path="h3d.mat.BlendMode"/>
	<c path="h3d.mat.Pass"/>
	<x path="Int"/>
	<x path="Void"/>
</f></apply>
		<new public="1" set="method" line="28"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="h3d.pass._Copy.CopyShader" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/pass/Copy.hx" private="1" module="h3d.pass.Copy">
		<extends path="h3d.shader.ScreenShader"/>
		<SRC expr="&quot;HXSLGWgzZC5wYXNzLl9Db3B5LkNvcHlTaGFkZXIJAQVpbnB1dA0BAgIIcG9zaXRpb24FCgEBAAMCdXYFCgEBAAEAAAQFZmxpcFkDAgAABQZvdXRwdXQNAgIGCHBvc2l0aW9uBQwEBQAHBWNvbG9yBQwEBQAEAAAICnBpeGVsQ29sb3IFDAQAAAkMY2FsY3VsYXRlZFVWBQoEAAAKB3RleHR1cmUKAgAACwhfX2luaXRfXw4GAAAMBnZlcnRleA4GAAANCGZyYWdtZW50DgYAAAMCCwAABQIGBAIHBQwCCAUMBQwGBAIJBQoCAwUKBQoAAAwAAAUBBgQCBgUMCQMqDgQKAgIFCgAAAwYBCgICBQoEAAMCBAMDAQMAAAAAAAAAAAMBAwAAAAAAAPA/AwUMBQwAAQ0AAAUBBgQCCAUMCQMhDgICCgoCCQUKBQwFDAA&quot;" line="73" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"HXSLGWgzZC5wYXNzLl9Db3B5LkNvcHlTaGFkZXIJAQVpbnB1dA0BAgIIcG9zaXRpb24FCgEBAAMCdXYFCgEBAAEAAAQFZmxpcFkDAgAABQZvdXRwdXQNAgIGCHBvc2l0aW9uBQwEBQAHBWNvbG9yBQwEBQAEAAAICnBpeGVsQ29sb3IFDAQAAAkMY2FsY3VsYXRlZFVWBQoEAAAKB3RleHR1cmUKAgAACwhfX2luaXRfXw4GAAAMBnZlcnRleA4GAAANCGZyYWdtZW50DgYAAAMCCwAABQIGBAIHBQwCCAUMBQwGBAIJBQoCAwUKBQoAAAwAAAUBBgQCBgUMCQMqDgQKAgIFCgAAAwYBCgICBQoEAAMCBAMDAQMAAAAAAAAAAAMBAwAAAAAAAPA/AwUMBQwAAQ0AAAUBBgQCCAUMCQMhDgICCgoCCQUKBQwFDAA"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<texture public="1" get="accessor" set="accessor"><t path="hxsl.Sampler2D"/></texture>
		<texture__>
			<t path="hxsl.Sampler2D"/>
			<meta><m n=":noCompletion"/></meta>
		</texture__>
		<get_texture get="inline" set="null" line="73">
			<f a=""><t path="hxsl.Sampler2D"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_texture>
		<set_texture get="inline" set="null" line="73">
			<f a="_v">
				<t path="hxsl.Sampler2D"/>
				<t path="hxsl.Sampler2D"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_texture>
		<updateConstants public="1" set="method" line="73" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="73" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="73" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="73" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="71"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":src"><e>{
	@param var texture:Sampler2D;
	function fragment() {
		pixelColor = texture.get(calculatedUV);
	};
}</e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="h3d.pass.Copy" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/pass/Copy.hx">
		<extends path="h3d.pass.ScreenFx"><c path="h3d.pass._Copy.CopyShader"/></extends>
		<run public="1" set="method" line="111" static="1"><f a="from:to:?blend:?pass:?layer">
	<c path="h3d.mat.Texture"/>
	<c path="h3d.mat.Texture"/>
	<t path="h3d.mat.BlendMode"/>
	<c path="h3d.mat.Pass"/>
	<x path="Int"/>
	<x path="Void"/>
</f></run>
		<apply public="1" set="method" line="87"><f a="from:to:?blend:?customPass:?layer">
	<t path="hxsl.Sampler2D"/>
	<c path="h3d.mat.Texture"/>
	<t path="h3d.mat.BlendMode"/>
	<c path="h3d.mat.Pass"/>
	<x path="Int"/>
	<x path="Void"/>
</f></apply>
		<new public="1" set="method" line="83"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.pass._CubeCopy.CubeCopyShader" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/pass/CubeCopy.hx" private="1" module="h3d.pass.CubeCopy">
		<extends path="h3d.shader.ScreenShader"/>
		<SRC expr="&quot;HXSLIWgzZC5wYXNzLl9DdWJlQ29weS5DdWJlQ29weVNoYWRlcgoBBWlucHV0DQECAghwb3NpdGlvbgUKAQEAAwJ1dgUKAQEAAQAABAVmbGlwWQMCAAAFBm91dHB1dA0CAgYIcG9zaXRpb24FDAQFAAcFY29sb3IFDAQFAAQAAAgKcGl4ZWxDb2xvcgUMBAAACQxjYWxjdWxhdGVkVVYFCgQAAAoHdGV4dHVyZQwCAAALA21hdAYCAAAMCF9faW5pdF9fDgYAAA0GdmVydGV4DgYAAA4IZnJhZ21lbnQOBgAAAwIMAAAFAgYEAgcFDAIIBQwFDAYEAgkFCgIDBQoFCgAADQAABQEGBAIGBQwJAyoOBAoCAgUKAAADBgEKAgIFCgQAAwIEAwMBAwAAAAAAAAAAAwEDAAAAAAAA8D8DBQwFDAABDgAABQIIDwJ1dgUKBAAABgMGAQIJBQoBAwAAAAAAAABAAwUKAQMAAAAAAADwPwMFCgAGBAIIBQwJAyEOAgIKDAkDHw4BBgEJAykOAgIPBQoBAwAAAAAAAPA/AwULAgsGBQsFCwUMBQwA&quot;" line="5" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"HXSLIWgzZC5wYXNzLl9DdWJlQ29weS5DdWJlQ29weVNoYWRlcgoBBWlucHV0DQECAghwb3NpdGlvbgUKAQEAAwJ1dgUKAQEAAQAABAVmbGlwWQMCAAAFBm91dHB1dA0CAgYIcG9zaXRpb24FDAQFAAcFY29sb3IFDAQFAAQAAAgKcGl4ZWxDb2xvcgUMBAAACQxjYWxjdWxhdGVkVVYFCgQAAAoHdGV4dHVyZQwCAAALA21hdAYCAAAMCF9faW5pdF9fDgYAAA0GdmVydGV4DgYAAA4IZnJhZ21lbnQOBgAAAwIMAAAFAgYEAgcFDAIIBQwFDAYEAgkFCgIDBQoFCgAADQAABQEGBAIGBQwJAyoOBAoCAgUKAAADBgEKAgIFCgQAAwIEAwMBAwAAAAAAAAAAAwEDAAAAAAAA8D8DBQwFDAABDgAABQIIDwJ1dgUKBAAABgMGAQIJBQoBAwAAAAAAAABAAwUKAQMAAAAAAADwPwMFCgAGBAIIBQwJAyEOAgIKDAkDHw4BBgEJAykOAgIPBQoBAwAAAAAAAPA/AwULAgsGBQsFCwUMBQwA"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<texture public="1" get="accessor" set="accessor"><t path="hxsl.SamplerCube"/></texture>
		<texture__>
			<t path="hxsl.SamplerCube"/>
			<meta><m n=":noCompletion"/></meta>
		</texture__>
		<get_texture get="inline" set="null" line="5">
			<f a=""><t path="hxsl.SamplerCube"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_texture>
		<set_texture get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.SamplerCube"/>
				<t path="hxsl.SamplerCube"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_texture>
		<mat public="1" get="accessor" set="accessor"><t path="hxsl.Matrix"/></mat>
		<mat__ expr="new hxsl.Types.Matrix()">
			<t path="hxsl.Matrix"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Matrix()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</mat__>
		<get_mat get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Matrix"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_mat>
		<set_mat get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Matrix"/>
				<t path="hxsl.Matrix"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_mat>
		<updateConstants public="1" set="method" line="5" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="5" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="3"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":src"><e>{
	@param var texture:SamplerCube;
	@param var mat:Mat3;
	function fragment() {
		var uv = calculatedUV * 2.0 - 1.0;
		pixelColor = texture.get(normalize(vec3(uv, 1) * mat));
	};
}</e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="h3d.pass.CubeCopy" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/pass/CubeCopy.hx">
		<extends path="h3d.pass.ScreenFx"><c path="h3d.pass._CubeCopy.CubeCopyShader"/></extends>
		<run public="1" set="method" line="55" static="1"><f a="from:to:?blend:?pass">
	<c path="h3d.mat.Texture"/>
	<c path="h3d.mat.Texture"/>
	<t path="h3d.mat.BlendMode"/>
	<c path="h3d.mat.Pass"/>
	<x path="Void"/>
</f></run>
		<cubeDir expr="[h3d.Matrix.L([0, 0, -1, 0, 0, -1, 0, 0, 1, 0, 0, 0]), h3d.Matrix.L([0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, 0]), h3d.Matrix.L([1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0]), h3d.Matrix.L([1, 0, 0, 0, 0, 0, -1, 0, 0, -1, 0, 0]), h3d.Matrix.L([1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 1, 0]), h3d.Matrix.L([-1, 0, 0, 0, 0, -1, 0, 0, 0, 0, -1, 0])]">
			<c path="Array"><c path="h3d.Matrix"/></c>
			<meta><m n=":value"><e>[h3d.Matrix.L([0, 0, -1, 0, 0, -1, 0, 0, 1, 0, 0, 0]), h3d.Matrix.L([0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, 0]), h3d.Matrix.L([1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0]), h3d.Matrix.L([1, 0, 0, 0, 0, 0, -1, 0, 0, -1, 0, 0]), h3d.Matrix.L([1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 1, 0]), h3d.Matrix.L([-1, 0, 0, 0, 0, -1, 0, 0, 0, 0, -1, 0])]</e></m></meta>
		</cubeDir>
		<apply public="1" set="method" line="28"><f a="from:to:?blend:?customPass">
	<t path="hxsl.SamplerCube"/>
	<c path="h3d.mat.Texture"/>
	<t path="h3d.mat.BlendMode"/>
	<c path="h3d.mat.Pass"/>
	<x path="Void"/>
</f></apply>
		<new public="1" set="method" line="24"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.pass.Default" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/pass/Default.hx">
		<extends path="h3d.pass.Base"/>
		<manager><c path="h3d.pass.ShaderManager"/></manager>
		<globals get="accessor" set="null"><c path="hxsl.Globals"/></globals>
		<defaultSort expr="new SortByMaterial().sort">
			<f a="passes">
				<c path="h3d.pass.PassList"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>new SortByMaterial().sort</e></m></meta>
		</defaultSort>
		<get_globals get="inline" set="null" line="11"><f a=""><c path="hxsl.Globals"/></f></get_globals>
		<cameraView get="accessor" set="accessor">
			<c path="h3d.Matrix"/>
			<meta><m n="global"><e>"camera.view"</e></m></meta>
		</cameraView>
		<cameraNear get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="global"><e>"camera.zNear"</e></m></meta>
		</cameraNear>
		<cameraFar get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="global"><e>"camera.zFar"</e></m></meta>
		</cameraFar>
		<cameraProj get="accessor" set="accessor">
			<c path="h3d.Matrix"/>
			<meta><m n="global"><e>"camera.proj"</e></m></meta>
		</cameraProj>
		<cameraPos get="accessor" set="accessor">
			<c path="h3d.Vector"/>
			<meta><m n="global"><e>"camera.position"</e></m></meta>
		</cameraPos>
		<cameraProjDiag get="accessor" set="accessor">
			<c path="h3d.Vector"/>
			<meta><m n="global"><e>"camera.projDiag"</e></m></meta>
		</cameraProjDiag>
		<cameraProjFlip get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="global"><e>"camera.projFlip"</e></m></meta>
		</cameraProjFlip>
		<cameraViewProj get="accessor" set="accessor">
			<c path="h3d.Matrix"/>
			<meta><m n="global"><e>"camera.viewProj"</e></m></meta>
		</cameraViewProj>
		<cameraInverseViewProj get="accessor" set="accessor">
			<c path="h3d.Matrix"/>
			<meta><m n="global"><e>"camera.inverseViewProj"</e></m></meta>
		</cameraInverseViewProj>
		<globalTime get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="global"><e>"global.time"</e></m></meta>
		</globalTime>
		<pixelSize get="accessor" set="accessor">
			<c path="h3d.Vector"/>
			<meta><m n="global"><e>"global.pixelSize"</e></m></meta>
		</pixelSize>
		<globalModelView get="accessor" set="accessor">
			<c path="h3d.Matrix"/>
			<meta><m n="global"><e>"global.modelView"</e></m></meta>
		</globalModelView>
		<globalModelViewInverse get="accessor" set="accessor">
			<c path="h3d.Matrix"/>
			<meta><m n="global"><e>"global.modelViewInverse"</e></m></meta>
		</globalModelViewInverse>
		<getOutputs set="method" line="33"><f a=""><c path="Array"><e path="hxsl.Output"/></c></f></getOutputs>
		<compileShader public="1" set="method" line="37" override="1"><f a="p">
	<c path="h3d.mat.Pass"/>
	<c path="hxsl.RuntimeShader"/>
</f></compileShader>
		<processShaders set="method" line="44"><f a="p:shaders">
	<c path="h3d.pass.PassObject"/>
	<c path="hxsl.ShaderList"/>
	<c path="hxsl.ShaderList"/>
</f></processShaders>
		<setupShaders set="method" line="54">
			<f a="passes">
				<c path="h3d.pass.PassList"/>
				<x path="Void"/>
			</f>
			<meta><m n=":access"><e>h3d.scene</e></m></meta>
		</setupShaders>
		<log get="inline" set="null" line="78"><f a="str">
	<c path="String"/>
	<x path="Void"/>
</f></log>
		<drawObject set="method" line="82"><f a="p">
	<c path="h3d.pass.PassObject"/>
	<x path="Void"/>
</f></drawObject>
		<draw public="1" set="method" line="89" override="1">
			<f a="passes:?sort">
				<c path="h3d.pass.PassList"/>
				<f a="">
					<c path="h3d.pass.PassList"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":access"><e>h3d.scene</e></m></meta>
		</draw>
		<cameraView_id>
			<x path="hxsl.GlobalSlot"><c path="h3d.Matrix"/></x>
			<meta><m n=":noCompletion"/></meta>
		</cameraView_id>
		<get_cameraView get="inline" set="null" line="13"><f a=""><c path="h3d.Matrix"/></f></get_cameraView>
		<set_cameraView get="inline" set="null" line="13"><f a="v">
	<c path="h3d.Matrix"/>
	<c path="h3d.Matrix"/>
</f></set_cameraView>
		<cameraNear_id>
			<x path="hxsl.GlobalSlot"><x path="Float"/></x>
			<meta><m n=":noCompletion"/></meta>
		</cameraNear_id>
		<get_cameraNear get="inline" set="null" line="14"><f a=""><x path="Float"/></f></get_cameraNear>
		<set_cameraNear get="inline" set="null" line="14"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_cameraNear>
		<cameraFar_id>
			<x path="hxsl.GlobalSlot"><x path="Float"/></x>
			<meta><m n=":noCompletion"/></meta>
		</cameraFar_id>
		<get_cameraFar get="inline" set="null" line="15"><f a=""><x path="Float"/></f></get_cameraFar>
		<set_cameraFar get="inline" set="null" line="15"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_cameraFar>
		<cameraProj_id>
			<x path="hxsl.GlobalSlot"><c path="h3d.Matrix"/></x>
			<meta><m n=":noCompletion"/></meta>
		</cameraProj_id>
		<get_cameraProj get="inline" set="null" line="16"><f a=""><c path="h3d.Matrix"/></f></get_cameraProj>
		<set_cameraProj get="inline" set="null" line="16"><f a="v">
	<c path="h3d.Matrix"/>
	<c path="h3d.Matrix"/>
</f></set_cameraProj>
		<cameraPos_id>
			<x path="hxsl.GlobalSlot"><c path="h3d.Vector"/></x>
			<meta><m n=":noCompletion"/></meta>
		</cameraPos_id>
		<get_cameraPos get="inline" set="null" line="17"><f a=""><c path="h3d.Vector"/></f></get_cameraPos>
		<set_cameraPos get="inline" set="null" line="17"><f a="v">
	<c path="h3d.Vector"/>
	<c path="h3d.Vector"/>
</f></set_cameraPos>
		<cameraProjDiag_id>
			<x path="hxsl.GlobalSlot"><c path="h3d.Vector"/></x>
			<meta><m n=":noCompletion"/></meta>
		</cameraProjDiag_id>
		<get_cameraProjDiag get="inline" set="null" line="18"><f a=""><c path="h3d.Vector"/></f></get_cameraProjDiag>
		<set_cameraProjDiag get="inline" set="null" line="18"><f a="v">
	<c path="h3d.Vector"/>
	<c path="h3d.Vector"/>
</f></set_cameraProjDiag>
		<cameraProjFlip_id>
			<x path="hxsl.GlobalSlot"><x path="Float"/></x>
			<meta><m n=":noCompletion"/></meta>
		</cameraProjFlip_id>
		<get_cameraProjFlip get="inline" set="null" line="19"><f a=""><x path="Float"/></f></get_cameraProjFlip>
		<set_cameraProjFlip get="inline" set="null" line="19"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_cameraProjFlip>
		<cameraViewProj_id>
			<x path="hxsl.GlobalSlot"><c path="h3d.Matrix"/></x>
			<meta><m n=":noCompletion"/></meta>
		</cameraViewProj_id>
		<get_cameraViewProj get="inline" set="null" line="20"><f a=""><c path="h3d.Matrix"/></f></get_cameraViewProj>
		<set_cameraViewProj get="inline" set="null" line="20"><f a="v">
	<c path="h3d.Matrix"/>
	<c path="h3d.Matrix"/>
</f></set_cameraViewProj>
		<cameraInverseViewProj_id>
			<x path="hxsl.GlobalSlot"><c path="h3d.Matrix"/></x>
			<meta><m n=":noCompletion"/></meta>
		</cameraInverseViewProj_id>
		<get_cameraInverseViewProj get="inline" set="null" line="21"><f a=""><c path="h3d.Matrix"/></f></get_cameraInverseViewProj>
		<set_cameraInverseViewProj get="inline" set="null" line="21"><f a="v">
	<c path="h3d.Matrix"/>
	<c path="h3d.Matrix"/>
</f></set_cameraInverseViewProj>
		<globalTime_id>
			<x path="hxsl.GlobalSlot"><x path="Float"/></x>
			<meta><m n=":noCompletion"/></meta>
		</globalTime_id>
		<get_globalTime get="inline" set="null" line="22"><f a=""><x path="Float"/></f></get_globalTime>
		<set_globalTime get="inline" set="null" line="22"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_globalTime>
		<pixelSize_id>
			<x path="hxsl.GlobalSlot"><c path="h3d.Vector"/></x>
			<meta><m n=":noCompletion"/></meta>
		</pixelSize_id>
		<get_pixelSize get="inline" set="null" line="23"><f a=""><c path="h3d.Vector"/></f></get_pixelSize>
		<set_pixelSize get="inline" set="null" line="23"><f a="v">
	<c path="h3d.Vector"/>
	<c path="h3d.Vector"/>
</f></set_pixelSize>
		<globalModelView_id>
			<x path="hxsl.GlobalSlot"><c path="h3d.Matrix"/></x>
			<meta><m n=":noCompletion"/></meta>
		</globalModelView_id>
		<get_globalModelView get="inline" set="null" line="24"><f a=""><c path="h3d.Matrix"/></f></get_globalModelView>
		<set_globalModelView get="inline" set="null" line="24"><f a="v">
	<c path="h3d.Matrix"/>
	<c path="h3d.Matrix"/>
</f></set_globalModelView>
		<globalModelViewInverse_id>
			<x path="hxsl.GlobalSlot"><c path="h3d.Matrix"/></x>
			<meta><m n=":noCompletion"/></meta>
		</globalModelViewInverse_id>
		<get_globalModelViewInverse get="inline" set="null" line="25"><f a=""><c path="h3d.Matrix"/></f></get_globalModelViewInverse>
		<set_globalModelViewInverse get="inline" set="null" line="25"><f a="v">
	<c path="h3d.Matrix"/>
	<c path="h3d.Matrix"/>
</f></set_globalModelViewInverse>
		<initGlobals set="method" line="3"><f a=""><x path="Void"/></f></initGlobals>
		<setGlobals set="method" line="3"><f a=""><x path="Void"/></f></setGlobals>
		<new public="1" set="method" line="27"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>hxsl.Macros.buildGlobals()</e></m>
			<m n=":access"><e>h3d.mat.Pass</e></m>
		</meta>
	</class>
	<class path="h3d.pass.Shadows" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/pass/Shadows.hx">
		<extends path="h3d.pass.Default"/>
		<lightCamera><c path="h3d.Camera"/></lightCamera>
		<format><e path="hxd.PixelFormat"/></format>
		<staticTexture><c path="h3d.mat.Texture"/></staticTexture>
		<light><c path="h3d.scene.Light"/></light>
		<enabled public="1" set="accessor" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</enabled>
		<mode public="1" set="accessor" expr="None">
			<e path="h3d.pass.RenderMode"/>
			<meta><m n=":value"><e>None</e></m></meta>
		</mode>
		<size public="1" set="accessor" expr="1024">
			<x path="Int"/>
			<meta><m n=":value"><e>1024</e></m></meta>
		</size>
		<shader public="1" set="null"><c path="hxsl.Shader"/></shader>
		<blur public="1"><c path="h3d.pass.Blur"/></blur>
		<samplingKind public="1" expr="None">
			<e path="h3d.pass.ShadowSamplingKind"/>
			<meta><m n=":value"><e>None</e></m></meta>
		</samplingKind>
		<power public="1" expr="30.0">
			<x path="Float"/>
			<meta><m n=":value"><e>30.0</e></m></meta>
		</power>
		<bias public="1" expr="0.01">
			<x path="Float"/>
			<meta><m n=":value"><e>0.01</e></m></meta>
		</bias>
		<pcfQuality public="1" expr="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</pcfQuality>
		<pcfScale public="1" expr="1.0">
			<x path="Float"/>
			<meta><m n=":value"><e>1.0</e></m></meta>
		</pcfScale>
		<set_mode set="method" line="44"><f a="m">
	<e path="h3d.pass.RenderMode"/>
	<e path="h3d.pass.RenderMode"/>
</f></set_mode>
		<set_enabled set="method" line="49"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_enabled>
		<set_size set="method" line="53"><f a="s">
	<x path="Int"/>
	<x path="Int"/>
</f></set_size>
		<dispose public="1" set="method" line="61" override="1"><f a=""><x path="Void"/></f></dispose>
		<getShadowProj public="1" set="method" line="68"><f a=""><c path="h3d.Matrix"/></f></getShadowProj>
		<getShadowTex public="1" set="method" line="72"><f a=""><t path="hxsl.ChannelTextureType"/></f></getShadowTex>
		<isUsingWorldDist set="method" line="76"><f a=""><x path="Bool"/></f></isUsingWorldDist>
		<getOutputs set="method" line="80" override="1"><f a=""><c path="Array"><e path="hxsl.Output"/></c></f></getOutputs>
		<loadStaticData public="1" set="method" line="89"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<x path="Bool"/>
</f></loadStaticData>
		<saveStaticData public="1" set="method" line="93"><f a=""><c path="haxe.io.Bytes"/></f></saveStaticData>
		<computeStatic public="1" set="method" line="97"><f a="passes">
	<c path="h3d.pass.PassList"/>
	<x path="Void"/>
</f></computeStatic>
		<createDefaultShadowMap set="method" line="101"><f a=""><x path="Null"><c path="h3d.mat.Texture"/></x></f></createDefaultShadowMap>
		<syncShader set="method" line="107"><f a="texture">
	<c path="h3d.mat.Texture"/>
	<x path="Void"/>
</f></syncShader>
		<filterPasses set="method" line="110"><f a="passes">
	<c path="h3d.pass.PassList"/>
	<x path="Bool"/>
</f></filterPasses>
		<cullPasses get="inline" set="null" line="144"><f a="passes:f">
	<c path="h3d.pass.PassList"/>
	<f a="">
		<c path="h3d.col.Collider"/>
		<x path="Bool"/>
	</f>
	<x path="Void"/>
</f></cullPasses>
		<new public="1" set="method" line="34"><f a="light">
	<c path="h3d.scene.Light"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="h3d.pass.DirShadowMap" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/pass/DirShadowMap.hx">
		<extends path="h3d.pass.Shadows"/>
		<customDepth><x path="Bool"/></customDepth>
		<depth><c path="h3d.mat.DepthBuffer"/></depth>
		<dshader><c path="h3d.shader.DirShadow"/></dshader>
		<border><c path="h3d.pass.Border"/></border>
		<mergePass expr="new h3d.pass.ScreenFx(new h3d.shader.MinMaxShader())">
			<c path="h3d.pass.ScreenFx"><c path="h3d.shader.MinMaxShader"/></c>
			<meta><m n=":value"><e>new h3d.pass.ScreenFx(new h3d.shader.MinMaxShader())</e></m></meta>
		</mergePass>
		<set_mode set="method" line="21" override="1"><f a="m">
	<e path="h3d.pass.RenderMode"/>
	<e path="h3d.pass.RenderMode"/>
</f></set_mode>
		<set_enabled set="method" line="26" override="1"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_enabled>
		<set_size set="method" line="31" override="1"><f a="s">
	<x path="Int"/>
	<x path="Int"/>
</f></set_size>
		<dispose public="1" set="method" line="39" override="1"><f a=""><x path="Void"/></f></dispose>
		<getShadowTex public="1" set="method" line="45" override="1"><f a=""><t path="hxsl.ChannelTextureType"/></f></getShadowTex>
		<calcShadowBounds public="1" set="dynamic" line="49"><f a="camera">
	<c path="h3d.Camera"/>
	<x path="Void"/>
</f></calcShadowBounds>
		<setGlobals set="method" line="108" override="1"><f a=""><x path="Void"/></f></setGlobals>
		<syncShader set="method" line="118" override="1"><f a="texture">
	<t path="hxsl.ChannelTextureType"/>
	<x path="Void"/>
</f></syncShader>
		<saveStaticData public="1" set="method" line="136" override="1"><f a=""><c path="haxe.io.Bytes"/></f></saveStaticData>
		<loadStaticData public="1" set="method" line="161" override="1"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<x path="Bool"/>
</f></loadStaticData>
		<draw public="1" set="method" line="192" override="1"><f a="passes:?sort">
	<c path="h3d.pass.PassList"/>
	<f a="">
		<c path="h3d.pass.PassList"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></draw>
		<computeStatic public="1" set="method" line="247" override="1"><f a="passes">
	<c path="h3d.pass.PassList"/>
	<x path="Void"/>
</f></computeStatic>
		<new public="1" set="method" line="11"><f a="light">
	<c path="h3d.scene.Light"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="h3d.pass.DefaultShadowMap" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/pass/DefaultShadowMap.hx">
		<extends path="h3d.pass.DirShadowMap"/>
		<shadowMapId><x path="Int"/></shadowMapId>
		<shadowProjId><x path="Int"/></shadowProjId>
		<shadowColorId><x path="Int"/></shadowColorId>
		<shadowPowerId><x path="Int"/></shadowPowerId>
		<shadowBiasId><x path="Int"/></shadowBiasId>
		<color public="1"><c path="h3d.Vector"/></color>
		<draw public="1" set="method" line="27" override="1"><f a="passes:?sort">
	<c path="h3d.pass.PassList"/>
	<f a="">
		<c path="h3d.pass.PassList"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></draw>
		<new public="1" set="method" line="13">
			<f a="?size:?format" v="1024:">
				<x path="Int"/>
				<e path="hxd.PixelFormat"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ size : 1024 }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.pass._HardwarePick.FixedColor" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/pass/HardwarePick.hx" private="1" module="h3d.pass.HardwarePick">
		<extends path="hxsl.Shader"/>
		<SRC expr="&quot;HXSLIWgzZC5wYXNzLl9IYXJkd2FyZVBpY2suRml4ZWRDb2xvcgUBB2NvbG9ySUQFDAIAAAIIdmlld3BvcnQFDAIAAAMGb3V0cHV0DQECBAhwb3NpdGlvbgUMBAMABQdjb2xvcklEBQwEAwAEAAAGBnZlcnRleA4GAAAHCGZyYWdtZW50DgYAAAIABgAABQEGBAIEBQwGAQQGAAIEBQwGAQkDKg4DCgICBQwRAAUKAQMAAAAAAAAAAAMBAwAAAAAAAAAAAwUMCgIEBQwMAAMFDAUMBQwJAyoOAwoCAgUMOQAFCgEDAAAAAAAA8D8DAQMAAAAAAADwPwMFDAUMBQwAAQcAAAUBBgQCBQUMAgEFDAUMAA&quot;" line="5" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"HXSLIWgzZC5wYXNzLl9IYXJkd2FyZVBpY2suRml4ZWRDb2xvcgUBB2NvbG9ySUQFDAIAAAIIdmlld3BvcnQFDAIAAAMGb3V0cHV0DQECBAhwb3NpdGlvbgUMBAMABQdjb2xvcklEBQwEAwAEAAAGBnZlcnRleA4GAAAHCGZyYWdtZW50DgYAAAIABgAABQEGBAIEBQwGAQQGAAIEBQwGAQkDKg4DCgICBQwRAAUKAQMAAAAAAAAAAAMBAwAAAAAAAAAAAwUMCgIEBQwMAAMFDAUMBQwJAyoOAwoCAgUMOQAFCgEDAAAAAAAA8D8DAQMAAAAAAADwPwMFDAUMBQwAAQcAAAUBBgQCBQUMAgEFDAUMAA"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<colorID public="1" get="accessor" set="accessor"><t path="hxsl.Vec"/></colorID>
		<colorID__ expr="new hxsl.Types.Vec()">
			<t path="hxsl.Vec"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Vec()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</colorID__>
		<get_colorID get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Vec"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_colorID>
		<set_colorID get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Vec"/>
				<t path="hxsl.Vec"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_colorID>
		<viewport public="1" get="accessor" set="accessor"><t path="hxsl.Vec"/></viewport>
		<viewport__ expr="new hxsl.Types.Vec()">
			<t path="hxsl.Vec"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Vec()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</viewport__>
		<get_viewport get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Vec"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_viewport>
		<set_viewport get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Vec"/>
				<t path="hxsl.Vec"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_viewport>
		<updateConstants public="1" set="method" line="5" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="5" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="3"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":src"><e>{
	@param var colorID:Vec4;
	@param var viewport:Vec4;
	var output:{ var position : Vec4; var colorID : Vec4};
	function vertex() {
		output.position = (output.position + vec4(viewport.xy, 0., 0.) * output.position.w) * vec4(viewport.zw, 1., 1.);
	};
	function fragment() {
		output.colorID = colorID;
	};
}</e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="h3d.pass.HardwarePick" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/pass/HardwarePick.hx">
		<extends path="h3d.pass.Default"/>
		<pickX public="1"><x path="Float"/></pickX>
		<pickY public="1"><x path="Float"/></pickY>
		<fixedColor expr="new FixedColor()">
			<c path="h3d.pass._HardwarePick.FixedColor"/>
			<meta><m n=":value"><e>new FixedColor()</e></m></meta>
		</fixedColor>
		<colorID><x path="Int"/></colorID>
		<texOut><c path="h3d.mat.Texture"/></texOut>
		<material><c path="h3d.mat.Pass"/></material>
		<pickedIndex public="1" expr="-1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</pickedIndex>
		<dispose public="1" set="method" line="45" override="1"><f a=""><x path="Void"/></f></dispose>
		<getOutputs set="method" line="53" override="1"><f a=""><c path="Array"><e path="hxsl.Output"/></c></f></getOutputs>
		<drawObject set="method" line="57" override="1"><f a="p">
	<c path="h3d.pass.PassObject"/>
	<x path="Void"/>
</f></drawObject>
		<nextID get="inline" set="null" line="62"><f a=""><x path="Void"/></f></nextID>
		<draw public="1" set="method" line="66" override="1"><f a="passes:?sort">
	<c path="h3d.pass.PassList"/>
	<f a="">
		<c path="h3d.pass.PassList"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></draw>
		<new public="1" set="method" line="33"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.pass.PassListIterator" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/pass/PassList.hx" module="h3d.pass.PassList">
		<o><c path="h3d.pass.PassObject"/></o>
		<hasNext public="1" get="inline" set="null" line="8"><f a=""><x path="Bool"/></f></hasNext>
		<next public="1" get="inline" set="null" line="11"><f a=""><c path="h3d.pass.PassObject"/></f></next>
		<new public="1" get="inline" set="null" line="5"><f a="o">
	<c path="h3d.pass.PassObject"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.pass.PassList" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/pass/PassList.hx">
		<current><c path="h3d.pass.PassObject"/></current>
		<discarded><c path="h3d.pass.PassObject"/></discarded>
		<lastDisc><c path="h3d.pass.PassObject"/></lastDisc>
		<init public="1" get="inline" set="null" line="32">
			<f a="pass">
				<c path="h3d.pass.PassObject"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Set the passes and empty the discarded list</haxe_doc>
		</init>
		<reset public="1" get="inline" set="null" line="40">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Put back discarded passes into the pass list</haxe_doc>
		</reset>
		<save public="1" get="inline" set="null" line="51">
			<f a=""><c path="h3d.pass.PassObject"/></f>
			<haxe_doc>Save the discarded list, allow to perfom some filters, then call "load" to restore passes</haxe_doc>
		</save>
		<load public="1" get="inline" set="null" line="58">
			<f a="p">
				<c path="h3d.pass.PassObject"/>
				<x path="Void"/>
			</f>
			<haxe_doc>load state that was save() before</haxe_doc>
		</load>
		<isEmpty public="1" get="inline" set="null" line="72"><f a=""><x path="Bool"/></f></isEmpty>
		<clear public="1" set="method" line="79">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Put all passes into discarded list</haxe_doc>
		</clear>
		<sort public="1" get="inline" set="null" line="92"><f a="f">
	<f a=":">
		<c path="h3d.pass.PassObject"/>
		<c path="h3d.pass.PassObject"/>
		<x path="Int"/>
	</f>
	<x path="Void"/>
</f></sort>
		<filter public="1" get="inline" set="null" line="99">
			<f a="f">
				<f a="">
					<c path="h3d.pass.PassObject"/>
					<x path="Bool"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>Filter current passes, add results to discarded list</haxe_doc>
		</filter>
		<iterator public="1" get="inline" set="null" line="132"><f a=""><c path="h3d.pass.PassListIterator"/></f></iterator>
		<getFiltered public="1" get="inline" set="null" line="139">
			<f a=""><c path="h3d.pass.PassListIterator"/></f>
			<haxe_doc>Iterate on all discarded elements, if any</haxe_doc>
		</getFiltered>
		<new public="1" set="method" line="25"><f a="?current">
	<c path="h3d.pass.PassObject"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>h3d.pass.PassObject</e></m>
		</meta>
	</class>
	<class path="h3d.pass.PassObject" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/pass/PassObject.hx">
		<next public="1">
			<c path="h3d.pass.PassObject"/>
			<meta><m n=":noCompletion"/></meta>
		</next>
		<nextAlloc><c path="h3d.pass.PassObject"/></nextAlloc>
		<pass public="1"><c path="h3d.mat.Pass"/></pass>
		<obj public="1"><c path="h3d.scene.Object"/></obj>
		<index public="1"><x path="Int"/></index>
		<shaders public="1"><c path="hxsl.ShaderList"/></shaders>
		<shader public="1"><c path="hxsl.RuntimeShader"/></shader>
		<depth public="1"><x path="Float"/></depth>
		<texture public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</texture>
		<new set="method" line="16"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.pass.ShaderManager" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/pass/ShaderManager.hx">
		<STRICT public="1" expr="true" line="5" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</STRICT>
		<globals public="1"><c path="hxsl.Globals"/></globals>
		<shaderCache><c path="hxsl.Cache"/></shaderCache>
		<currentOutput><c path="hxsl.ShaderList"/></currentOutput>
		<setOutput public="1" set="method" line="21"><f a="?output">
	<c path="Array"><e path="hxsl.Output"/></c>
	<x path="Void"/>
</f></setOutput>
		<fillRec set="method" line="27">
			<f a="v:type:out:pos">
				<d/>
				<e path="hxsl.Type"/>
				<t path="h3d.shader.ShaderBufferData"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":noDebug"/></meta>
		</fillRec>
		<shaderInfo set="method" line="154"><f a="shaders:path">
	<c path="hxsl.ShaderList"/>
	<c path="String"/>
	<c path="String"/>
</f></shaderInfo>
		<getPtr get="inline" set="null" line="166"><f a="data">
	<t path="h3d.shader.ShaderBufferData"/>
	<t path="h3d.shader.ShaderBufferData"/>
</f></getPtr>
		<getParamValue public="1" get="inline" set="null" line="174">
			<f a="p:shaders:?opt" v="::false">
				<c path="hxsl.AllocParam"/>
				<c path="hxsl.ShaderList"/>
				<x path="Bool"/>
				<d/>
			</f>
			<meta><m n=":value"><e>{ opt : false }</e></m></meta>
		</getParamValue>
		<fillGlobals public="1" set="method" line="190"><f a="buf:s">
	<c path="h3d.shader.Buffers"/>
	<c path="hxsl.RuntimeShader"/>
	<x path="Void"/>
</f></fillGlobals>
		<fillParams public="1" set="method" line="212"><f a="buf:s:shaders">
	<c path="h3d.shader.Buffers"/>
	<c path="hxsl.RuntimeShader"/>
	<c path="hxsl.ShaderList"/>
	<x path="Void"/>
</f></fillParams>
		<compileShaders public="1" set="method" line="261">
			<f a="shaders:?batchMode" v=":false">
				<c path="hxsl.ShaderList"/>
				<x path="Bool"/>
				<c path="hxsl.RuntimeShader"/>
			</f>
			<meta><m n=":value"><e>{ batchMode : false }</e></m></meta>
		</compileShaders>
		<new public="1" set="method" line="11"><f a="?output">
	<c path="Array"><e path="hxsl.Output"/></c>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="h3d.pass.RenderMode" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/pass/Shadows.hx" module="h3d.pass.Shadows">
		<None/>
		<Static/>
		<Dynamic/>
		<Mixed/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="h3d.pass.ShadowSamplingKind" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/pass/Shadows.hx" module="h3d.pass.Shadows">
		<None/>
		<PCF/>
		<ESM/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="h3d.pass.SortByMaterial" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/pass/SortByMaterial.hx">
		<shaderCount expr="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</shaderCount>
		<textureCount expr="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</textureCount>
		<shaderIdMap><c path="Array"><x path="Int"/></c></shaderIdMap>
		<textureIdMap><c path="Array"><x path="Int"/></c></textureIdMap>
		<sort public="1" set="method" line="15"><f a="passes">
	<c path="h3d.pass.PassList"/>
	<x path="Void"/>
</f></sort>
		<new public="1" set="method" line="10"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.prim.BigPrimitive" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/prim/BigPrimitive.hx">
		<extends path="h3d.prim.Primitive"/>
		<PREV_BUFFER static="1"><x path="hxd.FloatBuffer"/></PREV_BUFFER>
		<PREV_INDEX static="1"><x path="hxd.IndexBuffer"/></PREV_INDEX>
		<isRaw><x path="Bool"/></isRaw>
		<stride><x path="Int"/></stride>
		<buffers><c path="Array"><c path="h3d.Buffer"/></c></buffers>
		<allIndexes><c path="Array"><c path="h3d.Indexes"/></c></allIndexes>
		<tmpBuf><x path="hxd.FloatBuffer"/></tmpBuf>
		<tmpIdx><x path="hxd.IndexBuffer"/></tmpIdx>
		<bounds><c path="h3d.col.Bounds"/></bounds>
		<bufPos expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</bufPos>
		<idxPos expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</idxPos>
		<startIndex expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</startIndex>
		<flushing><x path="Bool"/></flushing>
		<hasTangents public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</hasTangents>
		<isStatic public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</isStatic>
		<begin public="1" set="method" line="46">
			<f a="vcount:icount">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Call begin() before starting to add vertexes/indexes to the primitive.
		The count value is the number of vertexes you will add, it will automatically flush() if it doesn't fit into the current buffer.</haxe_doc>
		</begin>
		<addPoint public="1" get="inline" set="null" line="81">
			<f a="x:y:z">
				<t path="hxd.impl.Float32"/>
				<t path="hxd.impl.Float32"/>
				<t path="hxd.impl.Float32"/>
				<x path="Void"/>
			</f>
			<haxe_doc>This is similar to addVertexValue for X Y and Z, but will also update the bounds if you wish to have them calculated.</haxe_doc>
		</addPoint>
		<addBounds public="1" get="inline" set="null" line="88"><f a="x:y:z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></addBounds>
		<addVertexValue public="1" get="inline" set="null" line="92"><f a="v">
	<t path="hxd.impl.Float32"/>
	<x path="Void"/>
</f></addVertexValue>
		<addIndex public="1" get="inline" set="null" line="96"><f a="i">
	<x path="Int"/>
	<x path="Void"/>
</f></addIndex>
		<triCount public="1" set="method" line="100" override="1"><f a=""><x path="Int"/></f></triCount>
		<vertexCount public="1" set="method" line="108" override="1"><f a=""><x path="Int"/></f></vertexCount>
		<flush public="1" set="method" line="120">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Flush the current buffer.
		It is required to call begin() after a flush()</haxe_doc>
		</flush>
		<render public="1" set="method" line="147" override="1"><f a="engine">
	<c path="h3d.Engine"/>
	<x path="Void"/>
</f></render>
		<getBounds public="1" set="method" line="153" override="1"><f a=""><c path="h3d.col.Bounds"/></f></getBounds>
		<dispose public="1" set="method" line="157" override="1"><f a=""><x path="Void"/></f></dispose>
		<clear public="1" set="method" line="161"><f a=""><x path="Void"/></f></clear>
		<add public="1" set="method" line="183">
			<f a="buf:idx:?dx:?dy:?dz:?rotation:?scale:?stride" v="::0.:0.:0.:0.:1.:-1">
				<x path="hxd.FloatBuffer"/>
				<x path="hxd.IndexBuffer"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ stride : -1, scale : 1., rotation : 0., dz : 0., dy : 0., dx : 0. }</e></m></meta>
			<haxe_doc>Adds a complete object to the primitive, with custom position,scale,rotation.
		See addSub for complete documentation.</haxe_doc>
		</add>
		<addSub public="1" set="method" line="195">
			<f a="buf:idx:startVert:startTri:nvert:triCount:?dx:?dy:?dz:?rotation:?scale:?stride:?deltaU:?deltaV:?color:?mat" v="::::::0.:0.:0.:0.:1.:-1:0.:0.:1.:null">
				<x path="hxd.FloatBuffer"/>
				<x path="hxd.IndexBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="h3d.Matrix"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ mat : null, color : 1., deltaV : 0., deltaU : 0., stride : -1, scale : 1., rotation : 0., dz : 0., dy : 0., dx : 0. }</e></m>
				<m n=":noDebug"/>
			</meta>
			<haxe_doc>Adds a buffer to the primitive, with custom position,scale,rotation.
		The buffer can have more stride than the BigPrimitive, but not less.
		It is assumed that the buffer contains [X,Y,Z,NX,NY,NZ,U,V,R,G,B] (depending on his stride) so the different offsets are applied to the corresponding components.
		If hasTangent=true, we have [TX,TY,TZ] just after normal.
		However if the stride is 5, we assume [X,Y,Z,U,V]
		If mat is not null, it overrides dx, dy, dz, rotation, scale</haxe_doc>
		</addSub>
		<new public="1" set="method" line="30">
			<f a="stride:?isRaw" v=":false">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ isRaw : false }</e></m></meta>
		</new>
		<haxe_doc>Vertex buffers are limited to 65K vertexes because of the 16-bits limitation of the index buffers.
	BigPrimitive allows you to easily create large buffers by spliting the buffers.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.prim.MeshPrimitive" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/prim/MeshPrimitive.hx">
		<extends path="h3d.prim.Primitive"/>
		<bufferCache><t path="Map">
	<x path="Int"/>
	<c path="h3d.BufferOffset"/>
</t></bufferCache>
		<layouts><t path="Map">
	<x path="Int"/>
	<c path="h3d.BufferOffset"/>
</t></layouts>
		<allocBuffer set="method" line="8"><f a="engine:name">
	<c path="h3d.Engine"/>
	<c path="String"/>
	<x path="Null"><c path="h3d.BufferOffset"/></x>
</f></allocBuffer>
		<hasBuffer public="1" set="method" line="12"><f a="name">
	<c path="String"/>
	<x path="Bool"/>
</f></hasBuffer>
		<addBuffer set="method" line="18">
			<f a="name:buf:?offset" v="::0">
				<c path="String"/>
				<c path="h3d.Buffer"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ offset : 0 }</e></m></meta>
		</addBuffer>
		<dispose public="1" set="method" line="28" override="1"><f a=""><x path="Void"/></f></dispose>
		<getBuffers set="method" line="37"><f a="engine">
	<c path="h3d.Engine"/>
	<x path="Null"><c path="h3d.BufferOffset"/></x>
</f></getBuffers>
		<render public="1" set="method" line="67" override="1"><f a="engine">
	<c path="h3d.Engine"/>
	<x path="Void"/>
</f></render>
		<new public="1" set="method" line="3">
			<f a=""><x path="Void"/></f>
			<meta><m n=":compilerGenerated"/></meta>
		</new>
	</class>
	<class path="h3d.prim.HMDModel" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/prim/HMDModel.hx">
		<extends path="h3d.prim.MeshPrimitive"/>
		<data><c path="hxd.fmt.hmd.Geometry"/></data>
		<dataPosition><x path="Int"/></dataPosition>
		<indexCount><x path="Int"/></indexCount>
		<indexesTriPos><c path="Array"><x path="Int"/></c></indexesTriPos>
		<lib><c path="hxd.fmt.hmd.Library"/></lib>
		<curMaterial><x path="Int"/></curMaterial>
		<collider><c path="h3d.col.Collider"/></collider>
		<normalsRecomputed><c path="String"/></normalsRecomputed>
		<bufferAliases expr="new Map()">
			<t path="Map">
				<c path="String"/>
				<a>
					<realName><c path="String"/></realName>
					<offset><x path="Int"/></offset>
				</a>
			</t>
			<meta><m n=":value"><e>new Map()</e></m></meta>
		</bufferAliases>
		<triCount public="1" set="method" line="21" override="1"><f a=""><x path="Int"/></f></triCount>
		<vertexCount public="1" set="method" line="25" override="1"><f a=""><x path="Int"/></f></vertexCount>
		<getBounds public="1" set="method" line="29" override="1"><f a=""><c path="h3d.col.Bounds"/></f></getBounds>
		<selectMaterial public="1" set="method" line="33" override="1"><f a="i">
	<x path="Int"/>
	<x path="Void"/>
</f></selectMaterial>
		<getDataBuffers public="1" set="method" line="37"><f a="fmt:?defaults:?material">
	<c path="Array"><c path="hxd.fmt.hmd.GeometryFormat"/></c>
	<c path="Array"><c path="h3d.Vector"/></c>
	<x path="Int"/>
	<c path="hxd.fmt.hmd.GeometryBuffer"/>
</f></getDataBuffers>
		<loadSkin public="1" set="method" line="41"><f a="skin">
	<c path="h3d.anim.Skin"/>
	<x path="Void"/>
</f></loadSkin>
		<addAlias public="1" set="method" line="45">
			<f a="name:realName:?offset" v="::0">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ offset : 0 }</e></m></meta>
		</addAlias>
		<alloc public="1" set="method" line="49" override="1"><f a="engine">
	<c path="h3d.Engine"/>
	<x path="Void"/>
</f></alloc>
		<recomputeNormals public="1" set="method" line="95"><f a="?name">
	<c path="String"/>
	<x path="Void"/>
</f></recomputeNormals>
		<render public="1" set="method" line="143" override="1"><f a="engine">
	<c path="h3d.Engine"/>
	<x path="Void"/>
</f></render>
		<initCollider set="method" line="154"><f a="poly">
	<c path="h3d.col.PolygonBuffer"/>
	<x path="Void"/>
</f></initCollider>
		<getCollider public="1" set="method" line="163" override="1"><f a=""><c path="h3d.col.Collider"/></f></getCollider>
		<new public="1" set="method" line="15"><f a="data:dataPos:lib">
	<c path="hxd.fmt.hmd.Geometry"/>
	<x path="Int"/>
	<c path="hxd.fmt.hmd.Library"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.prim.Plane2D" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/prim/Plane2D.hx">
		<extends path="h3d.prim.Primitive"/>
		<get public="1" set="method" line="46" static="1"><f a=""><x path="Null"><d/></x></f></get>
		<triCount public="1" set="method" line="8" override="1"><f a=""><x path="Int"/></f></triCount>
		<vertexCount public="1" set="method" line="12" override="1"><f a=""><x path="Int"/></f></vertexCount>
		<alloc public="1" set="method" line="16" override="1"><f a="engine">
	<c path="h3d.Engine"/>
	<x path="Void"/>
</f></alloc>
		<render public="1" set="method" line="41" override="1"><f a="engine">
	<c path="h3d.Engine"/>
	<x path="Void"/>
</f></render>
		<new public="1" set="method" line="5"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.prim.Polygon" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/prim/Polygon.hx">
		<extends path="h3d.prim.MeshPrimitive"/>
		<points public="1"><c path="Array"><c path="h3d.col.Point"/></c></points>
		<normals public="1"><c path="Array"><c path="h3d.col.Point"/></c></normals>
		<tangents public="1"><c path="Array"><c path="h3d.col.Point"/></c></tangents>
		<uvs public="1"><c path="Array"><c path="h3d.prim.UV"/></c></uvs>
		<idx public="1"><x path="hxd.IndexBuffer"/></idx>
		<colors public="1"><c path="Array"><c path="h3d.col.Point"/></c></colors>
		<scaled expr="1.">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>1.</e></m>
				<m n=":s"/>
			</meta>
		</scaled>
		<translatedX expr="0.">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0.</e></m>
				<m n=":s"/>
			</meta>
		</translatedX>
		<translatedY expr="0.">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0.</e></m>
				<m n=":s"/>
			</meta>
		</translatedY>
		<translatedZ expr="0.">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0.</e></m>
				<m n=":s"/>
			</meta>
		</translatedZ>
		<getBounds public="1" set="method" line="22" override="1"><f a=""><c path="h3d.col.Bounds"/></f></getBounds>
		<alloc public="1" set="method" line="29" override="1"><f a="engine">
	<c path="h3d.Engine"/>
	<x path="Void"/>
</f></alloc>
		<unindex public="1" set="method" line="99"><f a=""><x path="Void"/></f></unindex>
		<translate public="1" set="method" line="134"><f a="dx:dy:dz">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></translate>
		<scale public="1" set="method" line="145"><f a="s">
	<x path="Float"/>
	<x path="Void"/>
</f></scale>
		<addNormals public="1" set="method" line="154"><f a=""><x path="Void"/></f></addNormals>
		<addTangents public="1" set="method" line="186"><f a=""><x path="Void"/></f></addTangents>
		<addUVs public="1" set="method" line="233"><f a=""><x path="Void"/></f></addUVs>
		<uvScale public="1" set="method" line="239"><f a="su:sv">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></uvScale>
		<triCount public="1" set="method" line="251" override="1"><f a=""><x path="Int"/></f></triCount>
		<vertexCount public="1" set="method" line="258" override="1"><f a=""><x path="Int"/></f></vertexCount>
		<getCollider public="1" set="method" line="262" override="1"><f a=""><c path="h3d.col.Collider"/></f></getCollider>
		<render public="1" set="method" line="278" override="1"><f a="engine">
	<c path="h3d.Engine"/>
	<x path="Void"/>
</f></render>
		<new public="1" set="method" line="17"><f a="points:?idx">
	<c path="Array"><c path="h3d.col.Point"/></c>
	<x path="hxd.IndexBuffer"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.prim.RawPrimitive" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/prim/RawPrimitive.hx">
		<extends path="h3d.prim.Primitive"/>
		<vcount><x path="Int"/></vcount>
		<tcount><x path="Int"/></tcount>
		<bounds><c path="h3d.col.Bounds"/></bounds>
		<onContextLost public="1"><f a=""><a>
	<vbuf><x path="hxd.FloatBuffer"/></vbuf>
	<stride><x path="Int"/></stride>
	<quads>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
	</quads>
	<ibuf>
		<x path="Null"><x path="hxd.IndexBuffer"/></x>
		<meta><m n=":optional"/></meta>
	</ibuf>
</a></f></onContextLost>
		<alloc public="1" set="method" line="17" override="1"><f a="engine">
	<c path="h3d.Engine"/>
	<x path="Void"/>
</f></alloc>
		<getBounds public="1" set="method" line="34" override="1"><f a=""><c path="h3d.col.Bounds"/></f></getBounds>
		<triCount public="1" set="method" line="39" override="1"><f a=""><x path="Int"/></f></triCount>
		<vertexCount public="1" set="method" line="43" override="1"><f a=""><x path="Int"/></f></vertexCount>
		<new public="1" set="method" line="10">
			<f a="inf:?persist" v=":false">
				<a>
					<vbuf><x path="hxd.FloatBuffer"/></vbuf>
					<stride><x path="Int"/></stride>
					<quads>
						<x path="Null"><x path="Bool"/></x>
						<meta><m n=":optional"/></meta>
					</quads>
					<ibuf>
						<x path="Null"><x path="hxd.IndexBuffer"/></x>
						<meta><m n=":optional"/></meta>
					</ibuf>
					<bounds>
						<x path="Null"><c path="h3d.col.Bounds"/></x>
						<meta><m n=":optional"/></meta>
					</bounds>
				</a>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ persist : false }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.prim.UV" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/prim/UV.hx">
		<u public="1"><x path="Float"/></u>
		<v public="1"><x path="Float"/></v>
		<clone public="1" set="method" line="13"><f a=""><c path="h3d.prim.UV"/></f></clone>
		<toString set="method" line="17"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="8"><f a="u:v">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.scene.Graphics" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/scene/Graphics.hx">
		<extends path="h3d.scene.Mesh"/>
		<bprim><c path="h3d.prim.BigPrimitive"/></bprim>
		<curX expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</curX>
		<curY expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</curY>
		<curZ expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</curZ>
		<curR expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</curR>
		<curG><x path="Float"/></curG>
		<curB><x path="Float"/></curB>
		<curA><x path="Float"/></curA>
		<lineSize expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</lineSize>
		<lineShader><c path="h3d.shader.LineShader"/></lineShader>
		<tmpPoints><c path="Array"><c path="h3d.scene._Graphics.GPoint"/></c></tmpPoints>
		<is3D public="1" set="accessor">
			<x path="Bool"/>
			<haxe_doc>Setting is3D to true will switch from a screen space line (constant size whatever the distance) to a world space line</haxe_doc>
		</is3D>
		<onRemove set="method" line="58" override="1"><f a=""><x path="Void"/></f></onRemove>
		<set_is3D set="method" line="63"><f a="v">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_is3D>
		<flushLine set="method" line="76"><f a=""><x path="Void"/></f></flushLine>
		<flush set="method" line="185"><f a=""><x path="Void"/></f></flush>
		<sync set="method" line="194" override="1"><f a="ctx">
	<c path="h3d.scene.RenderContext"/>
	<x path="Void"/>
</f></sync>
		<draw set="method" line="200" override="1"><f a="ctx">
	<c path="h3d.scene.RenderContext"/>
	<x path="Void"/>
</f></draw>
		<clear public="1" set="method" line="206"><f a=""><x path="Void"/></f></clear>
		<lineStyle public="1" set="method" line="211">
			<f a="?size:?color:?alpha" v="0.:0:1.">
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ alpha : 1., color : 0, size : 0. }</e></m></meta>
		</lineStyle>
		<setColor public="1" set="method" line="220">
			<f a="color:?alpha" v=":1.">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ alpha : 1. }</e></m></meta>
		</setColor>
		<drawLine public="1" get="inline" set="null" line="227"><f a="p1:p2">
	<c path="h3d.col.Point"/>
	<c path="h3d.col.Point"/>
	<x path="Void"/>
</f></drawLine>
		<moveTo public="1" set="method" line="232"><f a="x:y:z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></moveTo>
		<addVertex get="inline" set="null" line="243"><f a="x:y:z:r:g:b:a">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></addVertex>
		<lineTo public="1" set="method" line="247"><f a="x:y:z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></lineTo>
		<new public="1" set="method" line="42"><f a="?parent">
	<c path="h3d.scene.Object"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.scene.Box" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/scene/Box.hx">
		<extends path="h3d.scene.Graphics"/>
		<color public="1"><x path="Int"/></color>
		<bounds public="1"><c path="h3d.col.Bounds"/></bounds>
		<thickness public="1" expr="1.0">
			<x path="Float"/>
			<meta><m n=":value"><e>1.0</e></m></meta>
		</thickness>
		<prevXMin expr="1e9">
			<x path="Float"/>
			<meta><m n=":value"><e>1e9</e></m></meta>
		</prevXMin>
		<prevYMin expr="1e9">
			<x path="Float"/>
			<meta><m n=":value"><e>1e9</e></m></meta>
		</prevYMin>
		<prevZMin expr="1e9">
			<x path="Float"/>
			<meta><m n=":value"><e>1e9</e></m></meta>
		</prevZMin>
		<prevXMax expr="-1e9">
			<x path="Float"/>
			<meta><m n=":value"><e>-1e9</e></m></meta>
		</prevXMax>
		<prevYMax expr="-1e9">
			<x path="Float"/>
			<meta><m n=":value"><e>-1e9</e></m></meta>
		</prevYMax>
		<prevZMax expr="-1e9">
			<x path="Float"/>
			<meta><m n=":value"><e>-1e9</e></m></meta>
		</prevZMax>
		<clone public="1" set="method" line="22" override="1"><f a="?o">
	<c path="h3d.scene.Object"/>
	<c path="h3d.scene.Object"/>
</f></clone>
		<getLocalCollider public="1" set="method" line="35" override="1"><f a=""><c path="h3d.col.Collider"/></f></getLocalCollider>
		<sync set="method" line="39" override="1"><f a="ctx">
	<c path="h3d.scene.RenderContext"/>
	<x path="Void"/>
</f></sync>
		<new public="1" set="method" line="15">
			<f a="?color:?bounds:?depth:?parent" v="0xFFFF0000::true:">
				<x path="Int"/>
				<c path="h3d.col.Bounds"/>
				<x path="Bool"/>
				<c path="h3d.scene.Object"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ depth : true, color : 0xFFFF0000 }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.scene._Graphics.GPoint" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/scene/Graphics.hx" private="1" module="h3d.scene.Graphics">
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<z public="1"><x path="Float"/></z>
		<r public="1"><x path="Float"/></r>
		<g public="1"><x path="Float"/></g>
		<b public="1"><x path="Float"/></b>
		<a public="1"><x path="Float"/></a>
		<new public="1" set="method" line="12"><f a="x:y:z:r:g:b:a">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.scene.Interactive" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/scene/Interactive.hx">
		<extends path="h3d.scene.Object"/>
		<implements path="hxd.Interactive"/>
		<shape public="1">
			<c path="h3d.col.Collider"/>
			<meta><m n=":s"/></meta>
		</shape>
		<preciseShape public="1">
			<x path="Null"><c path="h3d.col.Collider"/></x>
			<meta><m n=":s"/></meta>
			<haxe_doc>If several interactive conflicts, the preciseShape (if defined) can be used to distinguish between the two.</haxe_doc>
		</preciseShape>
		<priority public="1">
			<x path="Int"/>
			<meta><m n=":s"/></meta>
			<haxe_doc>In case of conflicting shapes, usually the one in front of the camera is prioritized, unless you set an higher priority.</haxe_doc>
		</priority>
		<cursor public="1" set="accessor"><x path="Null"><e path="hxd.Cursor"/></x></cursor>
		<cancelEvents public="1" expr="false">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n=":s"/>
			</meta>
			<haxe_doc>Set the default `cancel` mode (see `hxd.Event`), default to false.</haxe_doc>
		</cancelEvents>
		<propagateEvents public="1" expr="false">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n=":s"/>
			</meta>
			<haxe_doc>Set the default `propagate` mode (see `hxd.Event`), default to false.</haxe_doc>
		</propagateEvents>
		<enableRightButton public="1">
			<x path="Bool"/>
			<meta><m n=":s"/></meta>
		</enableRightButton>
		<bestMatch public="1">
			<x path="Bool"/>
			<meta><m n=":s"/></meta>
			<haxe_doc>Is it required to find the best hit point in a complex mesh or any hit possible point will be enough (default = false, faster).</haxe_doc>
		</bestMatch>
		<scene><c path="h3d.scene.Scene"/></scene>
		<mouseDownButton expr="-1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</mouseDownButton>
		<hitPoint expr="new h3d.Vector()">
			<c path="h3d.Vector"/>
			<meta>
				<m n=":value"><e>new h3d.Vector()</e></m>
				<m n=":allow"><e>h3d.scene.Scene</e></m>
			</meta>
		</hitPoint>
		<onAdd set="method" line="45" override="1"><f a=""><x path="Void"/></f></onAdd>
		<onRemove set="method" line="51" override="1"><f a=""><x path="Void"/></f></onRemove>
		<preventClick public="1" set="method" line="62">
			<f a=""><x path="Void"/></f>
			<haxe_doc>This can be called during or after a push event in order to prevent the release from triggering a click.</haxe_doc>
		</preventClick>
		<getInteractiveScene public="1" set="method" line="66">
			<f a=""><c path="hxd.InteractiveScene"/></f>
			<meta><m n=":noCompletion"/></meta>
		</getInteractiveScene>
		<handleEvent public="1" set="method" line="70">
			<f a="e">
				<c path="hxd.Event"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</handleEvent>
		<set_cursor set="method" line="116"><f a="c">
	<x path="Null"><e path="hxd.Cursor"/></x>
	<x path="Null"><e path="hxd.Cursor"/></x>
</f></set_cursor>
		<focus public="1" set="method" line="123"><f a=""><x path="Void"/></f></focus>
		<blur public="1" set="method" line="129"><f a=""><x path="Void"/></f></blur>
		<isOver public="1" set="method" line="133"><f a=""><x path="Bool"/></f></isOver>
		<hasFocus public="1" set="method" line="137"><f a=""><x path="Bool"/></f></hasFocus>
		<onOver public="1" set="dynamic" line="146">
			<f a="e">
				<c path="hxd.Event"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sent when mouse enters Interactive hitbox area.
		`event.propagate` and `event.cancel` are ignored during `onOver`.
		Propagation can be set with `onMove` event, as well as cancelling `onMove` will prevent `onOver`.</haxe_doc>
		</onOver>
		<onOut public="1" set="dynamic" line="152">
			<f a="e">
				<c path="hxd.Event"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sent when mouse exits Interactive hitbox area.
		`event.propagate` and `event.cancel` are ignored during `onOut`.</haxe_doc>
		</onOut>
		<onPush public="1" set="dynamic" line="156">
			<f a="e">
				<c path="hxd.Event"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sent when Interactive is pressed by user.</haxe_doc>
		</onPush>
		<onRelease public="1" set="dynamic" line="167">
			<f a="e">
				<c path="hxd.Event"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sent on multiple conditions.
		A. Always sent if user releases mouse while it is inside Interactive hitbox area.
			This happends regardless if that Interactive was pressed prior or not.
		B. Sent before `onReleaseOutside` if this Interactive was pressed, but released outside it's bounds.
		For first case `event.kind` will be `ERelease`, for second case - `EReleaseOutside`.
		See `onClick` and `onReleaseOutside` functions for separate events that trigger only when user interacts with this particular Interactive.</haxe_doc>
		</onRelease>
		<onReleaseOutside public="1" set="dynamic" line="174">
			<f a="e">
				<c path="hxd.Event"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sent when user presses Interactive, moves mouse outside and releases it.
		This event fired only on Interactive that user pressed, but released mouse after moving it outside of Interactive hitbox area.</haxe_doc>
		</onReleaseOutside>
		<onClick public="1" set="dynamic" line="181">
			<f a="e">
				<c path="hxd.Event"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sent when Interactive is clicked by user.
		This event fired only on Interactive that user pressed and released when mouse is inside Interactive hitbox area.</haxe_doc>
		</onClick>
		<onMove public="1" set="dynamic" line="184"><f a="e">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></onMove>
		<onWheel public="1" set="dynamic" line="187"><f a="e">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></onWheel>
		<onFocus public="1" set="dynamic" line="190"><f a="e">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></onFocus>
		<onFocusLost public="1" set="dynamic" line="193"><f a="e">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></onFocusLost>
		<onKeyUp public="1" set="dynamic" line="196"><f a="e">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></onKeyUp>
		<onKeyDown public="1" set="dynamic" line="199"><f a="e">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></onKeyDown>
		<onCheck public="1" set="dynamic" line="202"><f a="e">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></onCheck>
		<onTextInput public="1" set="dynamic" line="205"><f a="e">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></onTextInput>
		<new public="1" set="method" line="39"><f a="shape:?parent">
	<c path="h3d.col.Collider"/>
	<c path="h3d.scene.Object"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="h3d.scene.Light" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/scene/Light.hx">
		<extends path="h3d.scene.Object"/>
		<shader><c path="hxsl.Shader"/></shader>
		<objectDistance><x path="Float"/></objectDistance>
		<next public="1">
			<c path="h3d.scene.Light"/>
			<meta><m n=":noCompletion"/></meta>
		</next>
		<cullingDistance expr="-1">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>-1</e></m>
				<m n=":s"/>
			</meta>
		</cullingDistance>
		<priority public="1" expr="0">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":s"/>
			</meta>
		</priority>
		<color public="1" get="accessor" set="accessor"><c path="h3d.Vector"/></color>
		<enableSpecular public="1" get="accessor" set="accessor"><x path="Bool"/></enableSpecular>
		<get_color set="method" line="20"><f a=""><c path="h3d.Vector"/></f></get_color>
		<set_color set="method" line="24"><f a="v">
	<c path="h3d.Vector"/>
	<c path="h3d.Vector"/>
</f></set_color>
		<get_enableSpecular set="method" line="28"><f a=""><x path="Bool"/></f></get_enableSpecular>
		<set_enableSpecular set="method" line="32"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_enableSpecular>
		<emit set="method" line="37" override="1"><f a="ctx">
	<c path="h3d.scene.RenderContext"/>
	<x path="Void"/>
</f></emit>
		<getShadowDirection set="method" line="41"><f a=""><c path="h3d.Vector"/></f></getShadowDirection>
		<new set="method" line="14"><f a="shader:?parent">
	<c path="hxsl.Shader"/>
	<c path="h3d.scene.Object"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="h3d.scene.LightSystem" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/scene/LightSystem.hx">
		<drawPasses public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</drawPasses>
		<ambientLight public="1" set="null"><c path="h3d.Vector"/></ambientLight>
		<shadowLight public="1"><c path="h3d.scene.Light"/></shadowLight>
		<lightCount><x path="Int"/></lightCount>
		<ctx><c path="h3d.scene.RenderContext"/></ctx>
		<initGlobals public="1" set="method" line="16"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></initGlobals>
		<cullLights set="method" line="19"><f a=""><x path="Void"/></f></cullLights>
		<initLights public="1" set="method" line="45"><f a="ctx">
	<c path="h3d.scene.RenderContext"/>
	<x path="Void"/>
</f></initLights>
		<computeLight public="1" set="method" line="62"><f a="obj:shaders">
	<c path="h3d.scene.Object"/>
	<c path="hxsl.ShaderList"/>
	<c path="hxsl.ShaderList"/>
</f></computeLight>
		<new public="1" set="method" line="12"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="h3d.scene.MultiMaterial" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/scene/MultiMaterial.hx">
		<extends path="h3d.scene.Mesh"/>
		<materials public="1"><c path="Array"><c path="h3d.mat.Material"/></c></materials>
		<getMeshMaterials public="1" set="method" line="12" override="1"><f a=""><c path="Array"><c path="h3d.mat.Material"/></c></f></getMeshMaterials>
		<clone public="1" set="method" line="16" override="1"><f a="?o">
	<c path="h3d.scene.Object"/>
	<c path="h3d.scene.MultiMaterial"/>
</f></clone>
		<emit set="method" line="26" override="1"><f a="ctx">
	<c path="h3d.scene.RenderContext"/>
	<x path="Void"/>
</f></emit>
		<getMaterialByName public="1" set="method" line="34" override="1"><f a="name">
	<c path="String"/>
	<c path="h3d.mat.Material"/>
</f></getMaterialByName>
		<getMaterials public="1" set="method" line="41" override="1"><f a="?a">
	<c path="Array"><c path="h3d.mat.Material"/></c>
	<x path="Null"><c path="Array"><c path="h3d.mat.Material"/></c></x>
</f></getMaterials>
		<draw set="method" line="51" override="1"><f a="ctx">
	<c path="h3d.scene.RenderContext"/>
	<x path="Void"/>
</f></draw>
		<new public="1" set="method" line="7"><f a="prim:?mats:?parent">
	<c path="h3d.prim.Primitive"/>
	<c path="Array"><x path="Null"><c path="h3d.mat.Material"/></x></c>
	<c path="h3d.scene.Object"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="h3d.scene.ObjectFlags" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/scene/Object.hx" module="h3d.scene.Object">
		<this><x path="Int"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="h3d.scene._Object.ObjectFlags_Impl_" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/scene/Object.hx" private="1" module="h3d.scene.Object">
	<FPosChanged public="1" get="inline" set="null" expr="cast 0x01" line="4" static="1">
		<x path="h3d.scene.ObjectFlags"/>
		<meta>
			<m n=":value"><e>cast 0x01</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FPosChanged>
	<FVisible public="1" get="inline" set="null" expr="cast 0x02" line="5" static="1">
		<x path="h3d.scene.ObjectFlags"/>
		<meta>
			<m n=":value"><e>cast 0x02</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FVisible>
	<FCulled public="1" get="inline" set="null" expr="cast 0x04" line="6" static="1">
		<x path="h3d.scene.ObjectFlags"/>
		<meta>
			<m n=":value"><e>cast 0x04</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FCulled>
	<FFollowPositionOnly public="1" get="inline" set="null" expr="cast 0x08" line="7" static="1">
		<x path="h3d.scene.ObjectFlags"/>
		<meta>
			<m n=":value"><e>cast 0x08</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FFollowPositionOnly>
	<FLightCameraCenter public="1" get="inline" set="null" expr="cast 0x10" line="8" static="1">
		<x path="h3d.scene.ObjectFlags"/>
		<meta>
			<m n=":value"><e>cast 0x10</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FLightCameraCenter>
	<FAllocated public="1" get="inline" set="null" expr="cast 0x20" line="9" static="1">
		<x path="h3d.scene.ObjectFlags"/>
		<meta>
			<m n=":value"><e>cast 0x20</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FAllocated>
	<FAlwaysSync public="1" get="inline" set="null" expr="cast 0x40" line="10" static="1">
		<x path="h3d.scene.ObjectFlags"/>
		<meta>
			<m n=":value"><e>cast 0x40</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FAlwaysSync>
	<FInheritCulled public="1" get="inline" set="null" expr="cast 0x80" line="11" static="1">
		<x path="h3d.scene.ObjectFlags"/>
		<meta>
			<m n=":value"><e>cast 0x80</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FInheritCulled>
	<FNoSerialize public="1" get="inline" set="null" expr="cast 0x100" line="12" static="1">
		<x path="h3d.scene.ObjectFlags"/>
		<meta>
			<m n=":value"><e>cast 0x100</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FNoSerialize>
	<FIgnoreBounds public="1" get="inline" set="null" expr="cast 0x200" line="13" static="1">
		<x path="h3d.scene.ObjectFlags"/>
		<meta>
			<m n=":value"><e>cast 0x200</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FIgnoreBounds>
	<FIgnoreCollide public="1" get="inline" set="null" expr="cast 0x400" line="14" static="1">
		<x path="h3d.scene.ObjectFlags"/>
		<meta>
			<m n=":value"><e>cast 0x400</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FIgnoreCollide>
	<FIgnoreParentTransform public="1" get="inline" set="null" expr="cast 0x800" line="15" static="1">
		<x path="h3d.scene.ObjectFlags"/>
		<meta>
			<m n=":value"><e>cast 0x800</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FIgnoreParentTransform>
	<FCullingColliderInherited public="1" get="inline" set="null" expr="cast 0x1000" line="16" static="1">
		<x path="h3d.scene.ObjectFlags"/>
		<meta>
			<m n=":value"><e>cast 0x1000</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FCullingColliderInherited>
	<_new public="1" get="inline" set="null" line="17" static="1">
		<f a="value">
			<x path="Int"/>
			<x path="h3d.scene.ObjectFlags"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<toInt public="1" get="inline" set="null" line="20" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toInt>
	<has public="1" get="inline" set="null" line="21" static="1">
		<f a="this:f">
			<x path="Int"/>
			<x path="h3d.scene.ObjectFlags"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</has>
	<set public="1" get="inline" set="null" line="22" static="1">
		<f a="this:f:b">
			<x path="Int"/>
			<x path="h3d.scene.ObjectFlags"/>
			<x path="Bool"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="h3d.scene._Object.ObjectFlags_Impl_" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/scene/Object.hx" private="1" module="h3d.scene.Object">
		<FPosChanged public="1" get="inline" set="null" expr="cast 0x01" line="4" static="1">
			<x path="h3d.scene.ObjectFlags"/>
			<meta>
				<m n=":value"><e>cast 0x01</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FPosChanged>
		<FVisible public="1" get="inline" set="null" expr="cast 0x02" line="5" static="1">
			<x path="h3d.scene.ObjectFlags"/>
			<meta>
				<m n=":value"><e>cast 0x02</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FVisible>
		<FCulled public="1" get="inline" set="null" expr="cast 0x04" line="6" static="1">
			<x path="h3d.scene.ObjectFlags"/>
			<meta>
				<m n=":value"><e>cast 0x04</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FCulled>
		<FFollowPositionOnly public="1" get="inline" set="null" expr="cast 0x08" line="7" static="1">
			<x path="h3d.scene.ObjectFlags"/>
			<meta>
				<m n=":value"><e>cast 0x08</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FFollowPositionOnly>
		<FLightCameraCenter public="1" get="inline" set="null" expr="cast 0x10" line="8" static="1">
			<x path="h3d.scene.ObjectFlags"/>
			<meta>
				<m n=":value"><e>cast 0x10</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FLightCameraCenter>
		<FAllocated public="1" get="inline" set="null" expr="cast 0x20" line="9" static="1">
			<x path="h3d.scene.ObjectFlags"/>
			<meta>
				<m n=":value"><e>cast 0x20</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FAllocated>
		<FAlwaysSync public="1" get="inline" set="null" expr="cast 0x40" line="10" static="1">
			<x path="h3d.scene.ObjectFlags"/>
			<meta>
				<m n=":value"><e>cast 0x40</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FAlwaysSync>
		<FInheritCulled public="1" get="inline" set="null" expr="cast 0x80" line="11" static="1">
			<x path="h3d.scene.ObjectFlags"/>
			<meta>
				<m n=":value"><e>cast 0x80</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FInheritCulled>
		<FNoSerialize public="1" get="inline" set="null" expr="cast 0x100" line="12" static="1">
			<x path="h3d.scene.ObjectFlags"/>
			<meta>
				<m n=":value"><e>cast 0x100</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FNoSerialize>
		<FIgnoreBounds public="1" get="inline" set="null" expr="cast 0x200" line="13" static="1">
			<x path="h3d.scene.ObjectFlags"/>
			<meta>
				<m n=":value"><e>cast 0x200</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FIgnoreBounds>
		<FIgnoreCollide public="1" get="inline" set="null" expr="cast 0x400" line="14" static="1">
			<x path="h3d.scene.ObjectFlags"/>
			<meta>
				<m n=":value"><e>cast 0x400</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FIgnoreCollide>
		<FIgnoreParentTransform public="1" get="inline" set="null" expr="cast 0x800" line="15" static="1">
			<x path="h3d.scene.ObjectFlags"/>
			<meta>
				<m n=":value"><e>cast 0x800</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FIgnoreParentTransform>
		<FCullingColliderInherited public="1" get="inline" set="null" expr="cast 0x1000" line="16" static="1">
			<x path="h3d.scene.ObjectFlags"/>
			<meta>
				<m n=":value"><e>cast 0x1000</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FCullingColliderInherited>
		<_new public="1" get="inline" set="null" line="17" static="1">
			<f a="value">
				<x path="Int"/>
				<x path="h3d.scene.ObjectFlags"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<toInt public="1" get="inline" set="null" line="20" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toInt>
		<has public="1" get="inline" set="null" line="21" static="1">
			<f a="this:f">
				<x path="Int"/>
				<x path="h3d.scene.ObjectFlags"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</has>
		<set public="1" get="inline" set="null" line="22" static="1">
			<f a="this:f:b">
				<x path="Int"/>
				<x path="h3d.scene.ObjectFlags"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="h3d.scene._RenderContext.SharedGlobal" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/scene/RenderContext.hx" private="1" module="h3d.scene.RenderContext">
		<gid public="1"><x path="Int"/></gid>
		<value public="1"><d/></value>
		<new public="1" set="method" line="6"><f a="gid:value">
	<x path="Int"/>
	<unknown/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.scene.RenderContext" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/scene/RenderContext.hx">
		<extends path="h3d.impl.RenderContext"/>
		<camera public="1"><c path="h3d.Camera"/></camera>
		<scene public="1"><c path="h3d.scene.Scene"/></scene>
		<drawPass public="1"><c path="h3d.pass.PassObject"/></drawPass>
		<pbrLightPass public="1"><c path="h3d.mat.Pass"/></pbrLightPass>
		<computingStatic public="1"><x path="Bool"/></computingStatic>
		<sharedGlobals><c path="Array"><c path="h3d.scene._RenderContext.SharedGlobal"/></c></sharedGlobals>
		<lightSystem public="1"><c path="h3d.scene.LightSystem"/></lightSystem>
		<extraShaders public="1"><c path="hxsl.ShaderList"/></extraShaders>
		<visibleFlag public="1"><x path="Bool"/></visibleFlag>
		<shaderBuffers public="1"><c path="h3d.shader.Buffers"/></shaderBuffers>
		<cullingCollider public="1"><c path="h3d.col.Collider"/></cullingCollider>
		<allocPool><c path="h3d.pass.PassObject"/></allocPool>
		<allocFirst><c path="h3d.pass.PassObject"/></allocFirst>
		<cachedShaderList><c path="Array"><c path="hxsl.ShaderList"/></c></cachedShaderList>
		<cachedPassObjects><c path="Array"><c path="h3d.scene.PassObjects"/></c></cachedPassObjects>
		<cachedPos><x path="Int"/></cachedPos>
		<passes><c path="h3d.pass.PassObject"/></passes>
		<lights><c path="h3d.scene.Light"/></lights>
		<currentManager><c path="h3d.pass.ShaderManager"/></currentManager>
		<emit public="1" get="inline" set="null" line="43">
			<f a="mat:obj:?index" v="::0">
				<c path="h3d.mat.Material"/>
				<c path="h3d.scene.Object"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ index : 0 }</e></m>
				<m n=":access"><e>h3d.mat.Pass</e></m>
			</meta>
		</emit>
		<start public="1" set="method" line="51"><f a=""><x path="Void"/></f></start>
		<nextPass public="1" get="inline" set="null" line="63"><f a=""><x path="Void"/></f></nextPass>
		<getGlobal public="1" set="method" line="68"><f a="name">
	<c path="String"/>
	<d/>
</f></getGlobal>
		<setGlobal public="1" get="inline" set="null" line="76"><f a="name:value">
	<c path="String"/>
	<d/>
	<x path="Void"/>
</f></setGlobal>
		<setGlobalID public="1" set="method" line="80"><f a="gid:value">
	<x path="Int"/>
	<d/>
	<x path="Void"/>
</f></setGlobalID>
		<emitPass public="1" set="method" line="89"><f a="pass:obj">
	<c path="h3d.mat.Pass"/>
	<c path="h3d.scene.Object"/>
	<c path="h3d.pass.PassObject"/>
</f></emitPass>
		<allocShaderList public="1" set="method" line="104"><f a="s:?next">
	<c path="hxsl.Shader"/>
	<c path="hxsl.ShaderList"/>
	<c path="hxsl.ShaderList"/>
</f></allocShaderList>
		<emitLight public="1" set="method" line="115"><f a="l">
	<c path="h3d.scene.Light"/>
	<x path="Void"/>
</f></emitLight>
		<uploadParams public="1" set="method" line="120"><f a=""><x path="Void"/></f></uploadParams>
		<done public="1" set="method" line="126"><f a=""><x path="Void"/></f></done>
		<new public="1" set="method" line="36"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.scene.PassObjects" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/scene/Renderer.hx" module="h3d.scene.Renderer">
		<name public="1"><c path="String"/></name>
		<passes public="1"><c path="h3d.pass.PassList"/></passes>
		<rendered public="1"><x path="Bool"/></rendered>
		<new public="1" set="method" line="7"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="h3d.scene._Renderer.SMap" params="T" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/scene/Renderer.hx" private="1" module="h3d.scene.Renderer"><t path="Map">
	<c path="String"/>
	<c path="h3d.scene._Renderer.SMap.T"/>
</t></typedef>
	<enum path="h3d.scene.RenderMode" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/scene/Renderer.hx" module="h3d.scene.Renderer">
		<Default/>
		<LightProbe/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="h3d.scene.Renderer" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/scene/Renderer.hx">
		<extends path="hxd.impl.AnyProps"/>
		<defaultPass><c path="h3d.pass.Base"/></defaultPass>
		<passObjects><t path="h3d.scene._Renderer.SMap"><c path="h3d.scene.PassObjects"/></t></passObjects>
		<allPasses><c path="Array"><c path="h3d.pass.Base"/></c></allPasses>
		<emptyPasses expr="new h3d.pass.PassList()">
			<c path="h3d.pass.PassList"/>
			<meta><m n=":value"><e>new h3d.pass.PassList()</e></m></meta>
		</emptyPasses>
		<ctx><c path="h3d.scene.RenderContext"/></ctx>
		<hasSetTarget expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</hasSetTarget>
		<frontToBack><f a="">
	<c path="h3d.pass.PassList"/>
	<x path="Void"/>
</f></frontToBack>
		<backToFront><f a="">
	<c path="h3d.pass.PassList"/>
	<x path="Void"/>
</f></backToFront>
		<effects public="1" expr="[]">
			<c path="Array"><c path="h3d.impl.RendererFX"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</effects>
		<renderMode public="1" expr="Default">
			<e path="h3d.scene.RenderMode"/>
			<meta><m n=":value"><e>Default</e></m></meta>
		</renderMode>
		<dispose public="1" set="method" line="45"><f a=""><x path="Void"/></f></dispose>
		<mark set="method" line="53"><f a="id">
	<c path="String"/>
	<x path="Void"/>
</f></mark>
		<getPass public="1" params="T" set="method" line="56"><f a="c">
	<x path="Class"><c path="getPass.T"/></x>
	<c path="getPass.T"/>
</f></getPass>
		<getPassByName public="1" set="method" line="63"><f a="name">
	<c path="String"/>
	<c path="h3d.pass.Base"/>
</f></getPassByName>
		<debugCompileShader public="1" set="method" line="70"><f a="pass">
	<c path="h3d.mat.Pass"/>
	<c path="hxsl.RuntimeShader"/>
</f></debugCompileShader>
		<hasFeature set="method" line="77"><f a="f">
	<e path="h3d.impl.Feature"/>
	<x path="Bool"/>
</f></hasFeature>
		<getDefaultLight params="T" set="method" line="81"><f a="l">
	<c path="getDefaultLight.T"/>
	<c path="getDefaultLight.T"/>
</f></getDefaultLight>
		<getLightSystem set="method" line="85"><f a=""><c path="h3d.scene.LightSystem"/></f></getLightSystem>
		<time set="method" line="89"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></time>
		<depthSort set="method" line="93">
			<f a="frontToBack:passes">
				<x path="Bool"/>
				<c path="h3d.pass.PassList"/>
				<x path="Void"/>
			</f>
			<meta><m n=":access"><e>h3d.scene.Object</e></m></meta>
		</depthSort>
		<clear get="inline" set="null" line="106"><f a="?color:?depth:?stencil">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></clear>
		<allocTarget get="inline" set="null" line="110">
			<f a="name:?depth:?size:?format" v=":true:1.:">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Float"/>
				<e path="hxd.PixelFormat"/>
				<c path="h3d.mat.Texture"/>
			</f>
			<meta><m n=":value"><e>{ size : 1., depth : true }</e></m></meta>
		</allocTarget>
		<copy set="method" line="114"><f a="from:to:?blend">
	<c path="h3d.mat.Texture"/>
	<c path="h3d.mat.Texture"/>
	<t path="h3d.mat.BlendMode"/>
	<x path="Void"/>
</f></copy>
		<setTarget set="method" line="118"><f a="tex">
	<c path="h3d.mat.Texture"/>
	<x path="Void"/>
</f></setTarget>
		<setTargets params="T" set="method" line="124"><f a="textures">
	<c path="Array"><c path="setTargets.T"/></c>
	<x path="Void"/>
</f></setTargets>
		<resetTarget set="method" line="130"><f a=""><x path="Void"/></f></resetTarget>
		<has set="method" line="137"><f a="name">
	<c path="String"/>
	<x path="Bool"/>
</f></has>
		<get set="method" line="141"><f a="name">
	<c path="String"/>
	<c path="h3d.pass.PassList"/>
</f></get>
		<draw set="method" line="148"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></draw>
		<render set="method" line="152"><f a=""><x path="Void"/></f></render>
		<computeStatic set="method" line="156"><f a=""><x path="Void"/></f></computeStatic>
		<start public="1" set="method" line="160"><f a=""><x path="Void"/></f></start>
		<process public="1" set="method" line="163"><f a="passes">
	<c path="Array"><c path="h3d.scene.PassObjects"/></c>
	<x path="Void"/>
</f></process>
		<new public="1" set="method" line="36"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>hrt.prefab.rfx.RendererFX</e></m>
			<m n=":allow"><e>h3d.pass.Shadows</e></m>
		</meta>
	</class>
	<class path="h3d.scene.Scene" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/scene/Scene.hx">
		<extends path="h3d.scene.Object"/>
		<implements path="hxd.InteractiveScene"/>
		<implements path="h3d.IDrawable"/>
		<camera public="1">
			<c path="h3d.Camera"/>
			<haxe_doc>The scene current camera.</haxe_doc>
		</camera>
		<lightSystem public="1">
			<c path="h3d.scene.LightSystem"/>
			<haxe_doc>The scene light system. Can be customized.</haxe_doc>
		</lightSystem>
		<renderer public="1" set="accessor">
			<c path="h3d.scene.Renderer"/>
			<haxe_doc>The scene renderer. Can be customized.</haxe_doc>
		</renderer>
		<ctx><c path="h3d.scene.RenderContext"/></ctx>
		<interactives><c path="Array"><c path="h3d.scene.Interactive"/></c></interactives>
		<events>
			<c path="hxd.SceneEvents"/>
			<meta><m n=":allow"><e>h3d.scene.Interactive</e></m></meta>
		</events>
		<hitInteractives><c path="Array"><c path="h3d.scene.Interactive"/></c></hitInteractives>
		<eventListeners><c path="Array"><f a="">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></c></eventListeners>
		<window><c path="hxd.Window"/></window>
		<setEvents public="1" set="method" line="53">
			<f a="events">
				<c path="hxd.SceneEvents"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</setEvents>
		<addEventListener public="1" set="method" line="60">
			<f a="f">
				<f a="">
					<c path="hxd.Event"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>Add an event listener that will capture all events not caught by an h2d.Interactive</haxe_doc>
		</addEventListener>
		<removeEventListener public="1" set="method" line="67">
			<f a="f">
				<f a="">
					<c path="hxd.Event"/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
			</f>
			<haxe_doc>Remove a previously added event listener, return false it was not part of our event listeners.</haxe_doc>
		</removeEventListener>
		<dispatchListeners public="1" set="method" line="77">
			<f a="event">
				<c path="hxd.Event"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":dox"><e>hide</e></m>
				<m n=":noCompletion"/>
			</meta>
		</dispatchListeners>
		<set_renderer set="method" line="84"><f a="r">
	<c path="h3d.scene.Renderer"/>
	<c path="h3d.scene.Renderer"/>
</f></set_renderer>
		<sortHitPointByCameraDistance set="method" line="90"><f a="i1:i2">
	<c path="h3d.scene.Interactive"/>
	<c path="h3d.scene.Interactive"/>
	<x path="Int"/>
</f></sortHitPointByCameraDistance>
		<dispatchEvent public="1" set="method" line="99">
			<f a="event:to">
				<c path="hxd.Event"/>
				<c path="hxd.Interactive"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":dox"><e>hide</e></m>
				<m n=":noCompletion"/>
			</meta>
		</dispatchEvent>
		<isInteractiveVisible public="1" set="method" line="106">
			<f a="i">
				<c path="hxd.Interactive"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":dox"><e>hide</e></m>
				<m n=":noCompletion"/>
			</meta>
		</isInteractiveVisible>
		<handleEvent public="1" set="method" line="116">
			<f a="event:last">
				<c path="hxd.Event"/>
				<c path="hxd.Interactive"/>
				<x path="Null"><c path="h3d.scene.Interactive"/></x>
			</f>
			<meta>
				<m n=":dox"><e>hide</e></m>
				<m n=":noCompletion"/>
			</meta>
		</handleEvent>
		<clone public="1" set="method" line="232" override="1"><f a="?o">
	<c path="h3d.scene.Object"/>
	<c path="h3d.scene.Scene"/>
</f></clone>
		<dispose public="1" set="method" line="242">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Free the GPU memory for this Scene and its children</haxe_doc>
		</dispose>
		<addEventTarget set="method" line="257">
			<f a="i">
				<c path="h3d.scene.Interactive"/>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>h3d</e></m></meta>
		</addEventTarget>
		<removeEventTarget set="method" line="263">
			<f a="i">
				<c path="h3d.scene.Interactive"/>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>h3d</e></m></meta>
		</removeEventTarget>
		<setElapsedTime public="1" set="method" line="274">
			<f a="elapsedTime">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Before render() or sync() are called, allow to set how much time has elapsed (in seconds) since the last frame in order to update scene animations.
		This is managed automatically by hxd.App</haxe_doc>
		</setElapsedTime>
		<hardwarePass><c path="h3d.pass.HardwarePick"/></hardwarePass>
		<hardwarePick public="1" set="method" line="287">
			<f a="pixelX:pixelY">
				<x path="Float"/>
				<x path="Float"/>
				<c path="h3d.scene.Object"/>
			</f>
			<haxe_doc>Use GPU rendering to pick a model at the given pixel position.
		hardwarePick() will check all scene visible meshes bounds against a ray cast with current camera, then draw them into a 1x1 pixel texture with a specific shader.
		The texture will then be read and the color will identify the object that was rendered at this pixel.
		This is a very precise way of doing scene picking since it performs exactly the same transformations (skinning, custom shaders, etc.) but might be more costly than using CPU colliders.
		Please note that when done during/after rendering, this might clear the screen on some platforms so it should always be done before rendering.</haxe_doc>
		</hardwarePick>
		<syncOnly public="1" set="method" line="339">
			<f a="et">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Synchronize the scene without rendering, updating all objects and animations by the given amount of time, in seconds.</haxe_doc>
		</syncOnly>
		<computeStatic public="1" set="method" line="361">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Perform a rendering with `RendererContext.computingStatic=true`, allowing the computation of static shadow maps, etc.</haxe_doc>
		</computeStatic>
		<render public="1" set="method" line="375">
			<f a="engine">
				<c path="h3d.Engine"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":access"><e>h3d.mat.Pass</e></m>
				<m n=":access"><e>h3d.scene.RenderContext</e></m>
			</meta>
			<haxe_doc>Render the scene on screen. Internal usage only.</haxe_doc>
		</render>
		<serializeScene public="1" set="method" line="458">
			<f a=""><c path="haxe.io.Bytes"/></f>
			<haxe_doc>Serialize the scene content as HSD bytes (see hxd.fmt.hsd package). Requires -lib hxbit</haxe_doc>
		</serializeScene>
		<new public="1" set="method" line="37">
			<f a="?createRenderer:?createLightSystem" v="true:true">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ createLightSystem : true, createRenderer : true }</e></m></meta>
			<haxe_doc>Create a new scene. A default 3D scene is already available in `hxd.App.s3d`</haxe_doc>
		</new>
		<haxe_doc>h3d.scene.Scene is the root class for a 3D scene. All root objects are added to it before being drawn on screen.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.scene.Joint" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/scene/Skin.hx" module="h3d.scene.Skin">
		<extends path="h3d.scene.Object"/>
		<skin public="1">
			<c path="h3d.scene.Skin"/>
			<meta><m n=":s"/></meta>
		</skin>
		<index public="1">
			<x path="Int"/>
			<meta><m n=":s"/></meta>
		</index>
		<getObjectByName public="1" set="method" line="16" override="1"><f a="name">
	<c path="String"/>
	<c path="h3d.scene.Joint"/>
</f></getObjectByName>
		<syncPos set="method" line="36" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":access"><e>h3d.scene.Skin</e></m></meta>
		</syncPos>
		<new public="1" set="method" line="7"><f a="skin:j">
	<c path="h3d.scene.Skin"/>
	<c path="h3d.anim.Joint"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.scene.Skin" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/scene/Skin.hx">
		<extends path="h3d.scene.MultiMaterial"/>
		<skinData><c path="h3d.anim.Skin"/></skinData>
		<currentRelPose><c path="Array"><c path="h3d.Matrix"/></c></currentRelPose>
		<currentAbsPose><c path="Array"><c path="h3d.Matrix"/></c></currentAbsPose>
		<currentPalette><c path="Array"><c path="h3d.Matrix"/></c></currentPalette>
		<splitPalette><c path="Array"><c path="Array"><c path="h3d.Matrix"/></c></c></splitPalette>
		<jointsUpdated><x path="Bool"/></jointsUpdated>
		<jointsAbsPosInv><c path="h3d.Matrix"/></jointsAbsPosInv>
		<paletteChanged><x path="Bool"/></paletteChanged>
		<skinShader><c path="h3d.shader.SkinBase"/></skinShader>
		<jointsGraphics><c path="h3d.scene.Graphics"/></jointsGraphics>
		<showJoints public="1"><x path="Bool"/></showJoints>
		<clone public="1" set="method" line="88" override="1"><f a="?o">
	<c path="h3d.scene.Object"/>
	<c path="h3d.scene.Skin"/>
</f></clone>
		<getBoundsRec set="method" line="96" override="1"><f a="b">
	<c path="h3d.col.Bounds"/>
	<c path="h3d.col.Bounds"/>
</f></getBoundsRec>
		<getObjectByName public="1" set="method" line="117" override="1"><f a="name">
	<c path="String"/>
	<c path="h3d.scene.Object"/>
</f></getObjectByName>
		<getLocalCollider public="1" set="method" line="132" override="1"><f a=""><c path="h3d.col.Collider"/></f></getLocalCollider>
		<getGlobalCollider public="1" set="method" line="137" override="1"><f a=""><c path="h3d.col.SkinCollider"/></f></getGlobalCollider>
		<calcAbsPos set="method" line="143" override="1"><f a=""><x path="Void"/></f></calcAbsPos>
		<getSkinData public="1" set="method" line="149"><f a=""><c path="h3d.anim.Skin"/></f></getSkinData>
		<setSkinData public="1" set="method" line="153">
			<f a="s:?shaderInit" v=":true">
				<c path="h3d.anim.Skin"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ shaderInit : true }</e></m></meta>
		</setSkinData>
		<sync set="method" line="199" override="1"><f a="ctx">
	<c path="h3d.scene.RenderContext"/>
	<x path="Void"/>
</f></sync>
		<syncJoints set="method" line="206">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noDebug"/></meta>
		</syncJoints>
		<emit set="method" line="226" override="1"><f a="ctx">
	<c path="h3d.scene.RenderContext"/>
	<x path="Void"/>
</f></emit>
		<draw set="method" line="262" override="1"><f a="ctx">
	<c path="h3d.scene.RenderContext"/>
	<x path="Void"/>
</f></draw>
		<new public="1" set="method" line="82"><f a="s:?mat:?parent">
	<c path="h3d.anim.Skin"/>
	<c path="Array"><x path="Null"><c path="h3d.mat.Material"/></x></c>
	<c path="h3d.scene.Object"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.scene.fwd.LightSystem" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/scene/fwd/LightSystem.hx">
		<extends path="h3d.scene.LightSystem"/>
		<maxLightsPerObject public="1" expr="6">
			<x path="Int"/>
			<meta><m n=":value"><e>6</e></m></meta>
		</maxLightsPerObject>
		<globals><c path="hxsl.Globals"/></globals>
		<ambientShader><c path="hxsl.Shader"/></ambientShader>
		<perPixelLighting public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</perPixelLighting>
		<additiveLighting public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>In the additive lighting model (by default), the lights are added after the ambient.
		In the new non additive ligthning model, the lights will be modulated against the ambient, so an ambient of 1 will reduce lights intensities to 0.</haxe_doc>
		</additiveLighting>
		<get_additiveLighting set="method" line="23"><f a=""><x path="Bool"/></f></get_additiveLighting>
		<set_additiveLighting set="method" line="27"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_additiveLighting>
		<initLights public="1" set="method" line="31" override="1"><f a="ctx">
	<c path="h3d.scene.RenderContext"/>
	<x path="Void"/>
</f></initLights>
		<initGlobals public="1" set="method" line="37" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></initGlobals>
		<sortLight set="method" line="42"><f a="l1:l2">
	<c path="h3d.scene.Light"/>
	<c path="h3d.scene.Light"/>
	<x path="Int"/>
</f></sortLight>
		<computeLight public="1" set="method" line="48" override="1"><f a="obj:shaders">
	<c path="h3d.scene.Object"/>
	<c path="hxsl.ShaderList"/>
	<c path="hxsl.ShaderList"/>
</f></computeLight>
		<new public="1" set="method" line="16"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="h3d.scene.fwd._Renderer.SMap" params="T" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/scene/fwd/Renderer.hx" private="1" module="h3d.scene.fwd.Renderer"><t path="Map">
	<c path="String"/>
	<c path="h3d.scene.fwd._Renderer.SMap.T"/>
</t></typedef>
	<class path="h3d.scene.fwd.DepthPass" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/scene/fwd/Renderer.hx" module="h3d.scene.fwd.Renderer">
		<extends path="h3d.pass.Default"/>
		<depthMapId><x path="Int"/></depthMapId>
		<enableSky public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</enableSky>
		<getOutputs set="method" line="15" override="1"><f a=""><c path="Array"><e path="hxsl.Output"/></c></f></getOutputs>
		<draw public="1" set="method" line="19" override="1"><f a="passes:?sort">
	<c path="h3d.pass.PassList"/>
	<f a="">
		<c path="h3d.pass.PassList"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></draw>
		<new public="1" set="method" line="10"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.scene.fwd.NormalPass" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/scene/fwd/Renderer.hx" module="h3d.scene.fwd.Renderer">
		<extends path="h3d.pass.Default"/>
		<normalMapId><x path="Int"/></normalMapId>
		<getOutputs set="method" line="39" override="1"><f a=""><c path="Array"><e path="hxsl.Output"/></c></f></getOutputs>
		<draw public="1" set="method" line="43" override="1"><f a="passes:?sort">
	<c path="h3d.pass.PassList"/>
	<f a="">
		<c path="h3d.pass.PassList"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></draw>
		<new public="1" set="method" line="34"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.scene.fwd.Renderer" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/scene/fwd/Renderer.hx">
		<extends path="h3d.scene.Renderer"/>
		<def get="accessor" set="null"><c path="h3d.pass.Base"/></def>
		<depth public="1" expr="new DepthPass()">
			<c path="h3d.pass.Base"/>
			<meta><m n=":value"><e>new DepthPass()</e></m></meta>
		</depth>
		<normal public="1" expr="new NormalPass()">
			<c path="h3d.pass.Base"/>
			<meta><m n=":value"><e>new NormalPass()</e></m></meta>
		</normal>
		<shadow public="1" expr="new h3d.pass.DefaultShadowMap(1024)">
			<c path="h3d.pass.DefaultShadowMap"/>
			<meta><m n=":value"><e>new h3d.pass.DefaultShadowMap(1024)</e></m></meta>
		</shadow>
		<get_def get="inline" set="null" line="67"><f a=""><c path="h3d.pass.Base"/></f></get_def>
		<renderPass set="method" line="70"><f a="p:passes:?sort">
	<c path="h3d.pass.Base"/>
	<c path="h3d.pass.PassList"/>
	<f a="">
		<c path="h3d.pass.PassList"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></renderPass>
		<getPassByName public="1" set="method" line="74" override="1"><f a="name">
	<c path="String"/>
	<c path="h3d.pass.Base"/>
</f></getPassByName>
		<render set="method" line="80" override="1"><f a=""><x path="Void"/></f></render>
		<new public="1" set="method" line="61"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.shader.AmbientLight" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/shader/AmbientLight.hx">
		<extends path="hxsl.Shader"/>
		<SRC expr="&quot;HXSLF2gzZC5zaGFkZXIuQW1iaWVudExpZ2h0CgEGZ2xvYmFsDQECAgxhbWJpZW50TGlnaHQFCwABAAMQcGVyUGl4ZWxMaWdodGluZwIAAQEAAAAAAAAAAAQKcGl4ZWxDb2xvcgUMBAAABQ9saWdodFBpeGVsQ29sb3IFCwQAAAYKbGlnaHRDb2xvcgULBAAABwhhZGRpdGl2ZQICAAEAAAAAAAgIX19pbml0X18OBgAACRBfX2luaXRfX2ZyYWdtZW50DgYAAAoJY2FsY0xpZ2h0DgYAAAsGdmVydGV4DgYAAAwIZnJhZ21lbnQOBgAABQIIAAAFAQYEAgYFCwsCBwICAgULCQMpDgEBAwAAAAAAAAAAAwULBQsFCwACCQAABQEGBAIFBQsLAgcCAgIFCwkDKQ4BAQMAAAAAAAAAAAMFCwULBQsAAwoBDQpsaWdodENvbG9yBQsEAAAFCwUBDQsCBwICDQULBAYAAgIFCwYBCQMWDgIEBgMBAwAAAAAAAPA/AwICBQsFCwULAQMAAAAAAAAAAAMFCwINBQsFCwULBQsFCwAAAAsAAAUBCwcCAgMCAgaBCgIEBQySAAULCQIKDgECBgULBQsFCwAAAAEMAAAFAQsCAwIGgQoCBAUMkgAFCwkCCg4BAgUFCwULBQsAAAA&quot;" line="5" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"HXSLF2gzZC5zaGFkZXIuQW1iaWVudExpZ2h0CgEGZ2xvYmFsDQECAgxhbWJpZW50TGlnaHQFCwABAAMQcGVyUGl4ZWxMaWdodGluZwIAAQEAAAAAAAAAAAQKcGl4ZWxDb2xvcgUMBAAABQ9saWdodFBpeGVsQ29sb3IFCwQAAAYKbGlnaHRDb2xvcgULBAAABwhhZGRpdGl2ZQICAAEAAAAAAAgIX19pbml0X18OBgAACRBfX2luaXRfX2ZyYWdtZW50DgYAAAoJY2FsY0xpZ2h0DgYAAAsGdmVydGV4DgYAAAwIZnJhZ21lbnQOBgAABQIIAAAFAQYEAgYFCwsCBwICAgULCQMpDgEBAwAAAAAAAAAAAwULBQsFCwACCQAABQEGBAIFBQsLAgcCAgIFCwkDKQ4BAQMAAAAAAAAAAAMFCwULBQsAAwoBDQpsaWdodENvbG9yBQsEAAAFCwUBDQsCBwICDQULBAYAAgIFCwYBCQMWDgIEBgMBAwAAAAAAAPA/AwICBQsFCwULAQMAAAAAAAAAAAMFCwINBQsFCwULBQsFCwAAAAsAAAUBCwcCAgMCAgaBCgIEBQySAAULCQIKDgECBgULBQsFCwAAAAEMAAAFAQsCAwIGgQoCBAUMkgAFCwkCCg4BAgUFCwULBQsAAAA"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<additive public="1" get="accessor" set="accessor"><x path="Bool"/></additive>
		<additive__>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</additive__>
		<get_additive get="inline" set="null" line="5">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_additive>
		<set_additive get="inline" set="null" line="5">
			<f a="_v">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_additive>
		<updateConstants public="1" set="method" line="5" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="5" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="3"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":src"><e>{
	@global var global:{ var ambientLight : Vec3; @const};
	var pixelColor:Vec4;
	var lightPixelColor:Vec3;
	var lightColor:Vec3;
	@const var additive:Bool;
	function __init__() {
		lightColor = additive ? global.ambientLight : vec3(0.);
	};
	function __init__fragment() {
		lightPixelColor = additive ? global.ambientLight : vec3(0.);
	};
	function calcLight(lightColor:Vec3):Vec3 {
		return additive ? lightColor : (global.ambientLight + (1 - global.ambientLight).max(0.) * lightColor);
	};
	function vertex() {
		if (!global.perPixelLighting) pixelColor.rgb *= calcLight(lightColor);
	};
	function fragment() {
		if (global.perPixelLighting) pixelColor.rgb *= calcLight(lightPixelColor);
	};
}</e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="h3d.shader.Base2d" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/shader/Base2d.hx">
		<extends path="hxsl.Shader"/>
		<SRC expr="&quot;HXSLEWgzZC5zaGFkZXIuQmFzZTJkGgEFaW5wdXQNAQMCCHBvc2l0aW9uBQoBAQADAnV2BQoBAQAEBWNvbG9yBQwBAQABAAAFBm91dHB1dA0CAgYIcG9zaXRpb24FDAQFAAcFY29sb3IFDAQFAAQAAAgEdGltZQMAAAAJBnpWYWx1ZQMCAAAKB3RleHR1cmUKAgAACw5zcHJpdGVQb3NpdGlvbgUMBAAADBBhYnNvbHV0ZVBvc2l0aW9uBQwEAAANCnBpeGVsQ29sb3IFDAQAAA4MdGV4dHVyZUNvbG9yBQwEAAAPDGNhbGN1bGF0ZWRVVgUKAwAAEAppc1JlbGF0aXZlAgIAAQAAAAAAEQVjb2xvcgUMAgAAEg9hYnNvbHV0ZU1hdHJpeEEFCwIAABMPYWJzb2x1dGVNYXRyaXhCBQsCAAAUDWZpbHRlck1hdHJpeEEFCwIAABUNZmlsdGVyTWF0cml4QgULAgAAFghoYXNVVlBvcwICAAEAAAAAABcFdXZQb3MFDAIAABgJa2lsbEFscGhhAgIAAQAAAAAAGQpwaXhlbEFsaWduAgIAAQAAAAAAGhBoYWxmUGl4ZWxJbnZlcnNlBQoCAAAbCHZpZXdwb3J0BQwCAAAcDm91dHB1dFBvc2l0aW9uBQwEAAAdCF9faW5pdF9fDgYAAB4GdmVydGV4DgYAAB8IZnJhZ21lbnQOBgAAAwIdAAAFBgYEAgsFDAkDKg4DAgIFCgIJAwEDAAAAAAAA8D8DBQwFDAsCEAIFAwYECgIMBQwAAAMJAx0OAgkDKQ4CCgILBQwRAAUKAQMAAAAAAADwPwMFCwISBQsDAwYECgIMBQwEAAMJAx0OAgkDKQ4CCgILBQwRAAUKAQMAAAAAAADwPwMFCwITBQsDAwYECgIMBQw5AAUKCgILBQw5AAUKBQoABgQCDAUMAgsFDAUMAAYEAg8FCgsCFgIGAAYBAgMFCgoCFwUMOQAFCgUKCgIXBQwRAAUKBQoCAwUKBQoFCgYEAg0FDAsCEAIGAQIRBQwCBAUMBQwCBAUMBQwFDAYEAg4FDAkDIQ4CAgoKAg8FCgUMBQwGgQINBQwCDgUMBQwAAB4AAAUFCCADdG1wBQsEAAAJAykOAgoCDAUMEQAFCgEDAAAAAAAA8D8DBQsABgQCHAUMCQMqDgMJAx0OAgIgBQsCFAULAwkDHQ4CAiAFCwIVBQsDCgIMBQw5AAUKBQwFDAYECgIcBQwRAAUKBgEEBgAKAhwFDBEABQoKAhsFDBEABQoFCgUKCgIbBQw5AAUKBQoFCgsCGQIGgwoCHAUMEQAFCgIaBQoFCgAABgQCBgUMAhwFDAUMAAEfAAAFAgsGDgIYAgYJCgINBQwMAAMBA/yp8dJNYlA/AwICDAAAAAYEAgcFDAINBQwFDAA&quot;" line="5" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"HXSLEWgzZC5zaGFkZXIuQmFzZTJkGgEFaW5wdXQNAQMCCHBvc2l0aW9uBQoBAQADAnV2BQoBAQAEBWNvbG9yBQwBAQABAAAFBm91dHB1dA0CAgYIcG9zaXRpb24FDAQFAAcFY29sb3IFDAQFAAQAAAgEdGltZQMAAAAJBnpWYWx1ZQMCAAAKB3RleHR1cmUKAgAACw5zcHJpdGVQb3NpdGlvbgUMBAAADBBhYnNvbHV0ZVBvc2l0aW9uBQwEAAANCnBpeGVsQ29sb3IFDAQAAA4MdGV4dHVyZUNvbG9yBQwEAAAPDGNhbGN1bGF0ZWRVVgUKAwAAEAppc1JlbGF0aXZlAgIAAQAAAAAAEQVjb2xvcgUMAgAAEg9hYnNvbHV0ZU1hdHJpeEEFCwIAABMPYWJzb2x1dGVNYXRyaXhCBQsCAAAUDWZpbHRlck1hdHJpeEEFCwIAABUNZmlsdGVyTWF0cml4QgULAgAAFghoYXNVVlBvcwICAAEAAAAAABcFdXZQb3MFDAIAABgJa2lsbEFscGhhAgIAAQAAAAAAGQpwaXhlbEFsaWduAgIAAQAAAAAAGhBoYWxmUGl4ZWxJbnZlcnNlBQoCAAAbCHZpZXdwb3J0BQwCAAAcDm91dHB1dFBvc2l0aW9uBQwEAAAdCF9faW5pdF9fDgYAAB4GdmVydGV4DgYAAB8IZnJhZ21lbnQOBgAAAwIdAAAFBgYEAgsFDAkDKg4DAgIFCgIJAwEDAAAAAAAA8D8DBQwFDAsCEAIFAwYECgIMBQwAAAMJAx0OAgkDKQ4CCgILBQwRAAUKAQMAAAAAAADwPwMFCwISBQsDAwYECgIMBQwEAAMJAx0OAgkDKQ4CCgILBQwRAAUKAQMAAAAAAADwPwMFCwITBQsDAwYECgIMBQw5AAUKCgILBQw5AAUKBQoABgQCDAUMAgsFDAUMAAYEAg8FCgsCFgIGAAYBAgMFCgoCFwUMOQAFCgUKCgIXBQwRAAUKBQoCAwUKBQoFCgYEAg0FDAsCEAIGAQIRBQwCBAUMBQwCBAUMBQwFDAYEAg4FDAkDIQ4CAgoKAg8FCgUMBQwGgQINBQwCDgUMBQwAAB4AAAUFCCADdG1wBQsEAAAJAykOAgoCDAUMEQAFCgEDAAAAAAAA8D8DBQsABgQCHAUMCQMqDgMJAx0OAgIgBQsCFAULAwkDHQ4CAiAFCwIVBQsDCgIMBQw5AAUKBQwFDAYECgIcBQwRAAUKBgEEBgAKAhwFDBEABQoKAhsFDBEABQoFCgUKCgIbBQw5AAUKBQoFCgsCGQIGgwoCHAUMEQAFCgIaBQoFCgAABgQCBgUMAhwFDAUMAAEfAAAFAgsGDgIYAgYJCgINBQwMAAMBA/yp8dJNYlA/AwICDAAAAAYEAgcFDAINBQwFDAA"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<zValue public="1" get="accessor" set="accessor"><x path="Float"/></zValue>
		<zValue__ expr="0">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":noCompletion"/>
			</meta>
		</zValue__>
		<get_zValue get="inline" set="null" line="5">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_zValue>
		<set_zValue get="inline" set="null" line="5">
			<f a="_v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_zValue>
		<texture public="1" get="accessor" set="accessor"><t path="hxsl.Sampler2D"/></texture>
		<texture__>
			<t path="hxsl.Sampler2D"/>
			<meta><m n=":noCompletion"/></meta>
		</texture__>
		<get_texture get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Sampler2D"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_texture>
		<set_texture get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Sampler2D"/>
				<t path="hxsl.Sampler2D"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_texture>
		<isRelative public="1" get="accessor" set="accessor"><x path="Bool"/></isRelative>
		<isRelative__>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</isRelative__>
		<get_isRelative get="inline" set="null" line="5">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_isRelative>
		<set_isRelative get="inline" set="null" line="5">
			<f a="_v">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_isRelative>
		<color public="1" get="accessor" set="accessor"><t path="hxsl.Vec"/></color>
		<color__ expr="new hxsl.Types.Vec()">
			<t path="hxsl.Vec"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Vec()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</color__>
		<get_color get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Vec"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_color>
		<set_color get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Vec"/>
				<t path="hxsl.Vec"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_color>
		<absoluteMatrixA public="1" get="accessor" set="accessor"><t path="hxsl.Vec"/></absoluteMatrixA>
		<absoluteMatrixA__ expr="new hxsl.Types.Vec()">
			<t path="hxsl.Vec"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Vec()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</absoluteMatrixA__>
		<get_absoluteMatrixA get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Vec"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_absoluteMatrixA>
		<set_absoluteMatrixA get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Vec"/>
				<t path="hxsl.Vec"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_absoluteMatrixA>
		<absoluteMatrixB public="1" get="accessor" set="accessor"><t path="hxsl.Vec"/></absoluteMatrixB>
		<absoluteMatrixB__ expr="new hxsl.Types.Vec()">
			<t path="hxsl.Vec"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Vec()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</absoluteMatrixB__>
		<get_absoluteMatrixB get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Vec"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_absoluteMatrixB>
		<set_absoluteMatrixB get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Vec"/>
				<t path="hxsl.Vec"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_absoluteMatrixB>
		<filterMatrixA public="1" get="accessor" set="accessor"><t path="hxsl.Vec"/></filterMatrixA>
		<filterMatrixA__ expr="new hxsl.Types.Vec()">
			<t path="hxsl.Vec"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Vec()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</filterMatrixA__>
		<get_filterMatrixA get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Vec"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_filterMatrixA>
		<set_filterMatrixA get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Vec"/>
				<t path="hxsl.Vec"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_filterMatrixA>
		<filterMatrixB public="1" get="accessor" set="accessor"><t path="hxsl.Vec"/></filterMatrixB>
		<filterMatrixB__ expr="new hxsl.Types.Vec()">
			<t path="hxsl.Vec"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Vec()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</filterMatrixB__>
		<get_filterMatrixB get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Vec"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_filterMatrixB>
		<set_filterMatrixB get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Vec"/>
				<t path="hxsl.Vec"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_filterMatrixB>
		<hasUVPos public="1" get="accessor" set="accessor"><x path="Bool"/></hasUVPos>
		<hasUVPos__>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</hasUVPos__>
		<get_hasUVPos get="inline" set="null" line="5">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_hasUVPos>
		<set_hasUVPos get="inline" set="null" line="5">
			<f a="_v">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_hasUVPos>
		<uvPos public="1" get="accessor" set="accessor"><t path="hxsl.Vec"/></uvPos>
		<uvPos__ expr="new hxsl.Types.Vec()">
			<t path="hxsl.Vec"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Vec()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</uvPos__>
		<get_uvPos get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Vec"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_uvPos>
		<set_uvPos get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Vec"/>
				<t path="hxsl.Vec"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_uvPos>
		<killAlpha public="1" get="accessor" set="accessor"><x path="Bool"/></killAlpha>
		<killAlpha__>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</killAlpha__>
		<get_killAlpha get="inline" set="null" line="5">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_killAlpha>
		<set_killAlpha get="inline" set="null" line="5">
			<f a="_v">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_killAlpha>
		<pixelAlign public="1" get="accessor" set="accessor"><x path="Bool"/></pixelAlign>
		<pixelAlign__>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</pixelAlign__>
		<get_pixelAlign get="inline" set="null" line="5">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_pixelAlign>
		<set_pixelAlign get="inline" set="null" line="5">
			<f a="_v">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_pixelAlign>
		<halfPixelInverse public="1" get="accessor" set="accessor"><t path="hxsl.Vec"/></halfPixelInverse>
		<halfPixelInverse__ expr="new hxsl.Types.Vec()">
			<t path="hxsl.Vec"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Vec()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</halfPixelInverse__>
		<get_halfPixelInverse get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Vec"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_halfPixelInverse>
		<set_halfPixelInverse get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Vec"/>
				<t path="hxsl.Vec"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_halfPixelInverse>
		<viewport public="1" get="accessor" set="accessor"><t path="hxsl.Vec"/></viewport>
		<viewport__ expr="new hxsl.Types.Vec()">
			<t path="hxsl.Vec"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Vec()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</viewport__>
		<get_viewport get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Vec"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_viewport>
		<set_viewport get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Vec"/>
				<t path="hxsl.Vec"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_viewport>
		<updateConstants public="1" set="method" line="5" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="5" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="3"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":src"><e><![CDATA[{
	@input var input:{ var position : Vec2; var uv : Vec2; var color : Vec4};
	var output:{ var position : Vec4; var color : Vec4};
	@global var time:Float;
	@param var zValue:Float;
	@param var texture:Sampler2D;
	var spritePosition:Vec4;
	var absolutePosition:Vec4;
	var pixelColor:Vec4;
	var textureColor:Vec4;
	@var var calculatedUV:Vec2;
	@const var isRelative:Bool;
	@param var color:Vec4;
	@param var absoluteMatrixA:Vec3;
	@param var absoluteMatrixB:Vec3;
	@param var filterMatrixA:Vec3;
	@param var filterMatrixB:Vec3;
	@const var hasUVPos:Bool;
	@param var uvPos:Vec4;
	@const var killAlpha:Bool;
	@const var pixelAlign:Bool;
	@param var halfPixelInverse:Vec2;
	@param var viewport:Vec4;
	var outputPosition:Vec4;
	function __init__() {
		spritePosition = vec4(input.position, zValue, 1);
		if (isRelative) {
			absolutePosition.x = vec3(spritePosition.xy, 1).dot(absoluteMatrixA);
			absolutePosition.y = vec3(spritePosition.xy, 1).dot(absoluteMatrixB);
			absolutePosition.zw = spritePosition.zw;
		} else absolutePosition = spritePosition;
		calculatedUV = hasUVPos ? input.uv * uvPos.zw + uvPos.xy : input.uv;
		pixelColor = isRelative ? color * input.color : input.color;
		textureColor = texture.get(calculatedUV);
		pixelColor *= textureColor;
	};
	function vertex() {
		var tmp = vec3(absolutePosition.xy, 1);
		outputPosition = vec4(tmp.dot(filterMatrixA), tmp.dot(filterMatrixB), absolutePosition.zw);
		outputPosition.xy = (outputPosition.xy + viewport.xy) * viewport.zw;
		if (pixelAlign) outputPosition.xy -= halfPixelInverse;
		output.position = outputPosition;
	};
	function fragment() {
		if (killAlpha && pixelColor.a < 0.001) discard;
		output.color = pixelColor;
	};
}]]></e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="h3d.shader.BaseMesh" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/shader/BaseMesh.hx">
		<extends path="hxsl.Shader"/>
		<SRC expr="&quot;HXSLE2gzZC5zaGFkZXIuQmFzZU1lc2gXAQZjYW1lcmENAQoCBHZpZXcHAAEAAwRwcm9qBwABAAQIcG9zaXRpb24FCwABAAUIcHJvakZsaXADAAEABghwcm9qRGlhZwULAAEABwh2aWV3UHJvagcAAQAID2ludmVyc2VWaWV3UHJvagcAAQAJBXpOZWFyAwABAAoEekZhcgMAAQALA2RpcgULAwEAAAAADAZnbG9iYWwNAgQNBHRpbWUDAAwADglwaXhlbFNpemUFCgAMAA8JbW9kZWxWaWV3BwAMAQMQEG1vZGVsVmlld0ludmVyc2UHAAwBAwAAABEFaW5wdXQNAwISCHBvc2l0aW9uBQsBEQATBm5vcm1hbAULAREAAQAAFAZvdXRwdXQNBAUVCHBvc2l0aW9uBQwEFAAWBWNvbG9yBQwEFAAXBWRlcHRoAwQUABgGbm9ybWFsBQsEFAAZCXdvcmxkRGlzdAMEFAAEAAAaEHJlbGF0aXZlUG9zaXRpb24FCwQAABsTdHJhbnNmb3JtZWRQb3NpdGlvbgULBAAAHBhwaXhlbFRyYW5zZm9ybWVkUG9zaXRpb24FCwQAAB0RdHJhbnNmb3JtZWROb3JtYWwFCwQAAB4RcHJvamVjdGVkUG9zaXRpb24FDAQAAB8KcGl4ZWxDb2xvcgUMBAAAIAVkZXB0aAMEAAAhCHNjcmVlblVWBQoEAAAiCXNwZWNQb3dlcgMEAAAjCXNwZWNDb2xvcgULBAAAJAl3b3JsZERpc3QDBAAAJQVjb2xvcgUMAgAAJg1zcGVjdWxhclBvd2VyAwIAAQcAAAAAAAAAAAAAAAAAAFlAJw5zcGVjdWxhckFtb3VudAMCAAEHAAAAAAAAAAAAAAAAAAAkQCgNc3BlY3VsYXJDb2xvcgULAgAAKQhfX2luaXRfXw4GAAAqEF9faW5pdF9fZnJhZ21lbnQOBgAAKwZ2ZXJ0ZXgOBgAALAhmcmFnbWVudA4GAAAEAikAAAULBgQCGgULAhIFCwULBgQCGwULBgECGgULCQM0DgECDwcIBQsFCwYEAh4FDAYBCQMqDgICGwULAQMAAAAAAADwPwMFDAIHBwUMBQwGBAIdBQsJAx8OAQQGAQITBQsJAzIOAQIPBwYFCwULBQsFCwYEAgsFCwkDHw4BBAYDAgQFCwIbBQsFCwULBQsFCwYEAh8FDAIlBQwFDAYEAiIDAiYDAwYEAiMFCwYBAigFCwInAwULBQsGBAIhBQoJAzoOAQYCCgIeBQwRAAUKCgIeBQwMAAMFCgUKBQoGBAIgAwYCCgIeBQwIAAMKAh4FDAwAAwMDBgQCJAMGAgkDGw4BBgMCGwULAgQFCwULAwIKAwMDAAIqAAAFBQYEAh0FCwkDHw4BAh0FCwULBQsGBAIhBQoJAzoOAQYCCgIeBQwRAAUKCgIeBQwMAAMFCgUKBQoGBAIgAwYCCgIeBQwIAAMKAh4FDAwAAwMDBgQCIgMCJgMDBgQCIwULBgECKAULAicDBQsFCwAAKwAABQIGBAIVBQwGAQIeBQwJAyoOBAEDAAAAAAAA8D8DAgUDAQMAAAAAAADwPwMBAwAAAAAAAPA/AwUMBQwFDAYEAhwFCwIbBQsFCwABLAAABQQGBAIWBQwCHwUMBQwGBAIXAwIgAwMGBAIYBQsCHQULBQsGBAIZAwIkAwMA&quot;" line="5" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"HXSLE2gzZC5zaGFkZXIuQmFzZU1lc2gXAQZjYW1lcmENAQoCBHZpZXcHAAEAAwRwcm9qBwABAAQIcG9zaXRpb24FCwABAAUIcHJvakZsaXADAAEABghwcm9qRGlhZwULAAEABwh2aWV3UHJvagcAAQAID2ludmVyc2VWaWV3UHJvagcAAQAJBXpOZWFyAwABAAoEekZhcgMAAQALA2RpcgULAwEAAAAADAZnbG9iYWwNAgQNBHRpbWUDAAwADglwaXhlbFNpemUFCgAMAA8JbW9kZWxWaWV3BwAMAQMQEG1vZGVsVmlld0ludmVyc2UHAAwBAwAAABEFaW5wdXQNAwISCHBvc2l0aW9uBQsBEQATBm5vcm1hbAULAREAAQAAFAZvdXRwdXQNBAUVCHBvc2l0aW9uBQwEFAAWBWNvbG9yBQwEFAAXBWRlcHRoAwQUABgGbm9ybWFsBQsEFAAZCXdvcmxkRGlzdAMEFAAEAAAaEHJlbGF0aXZlUG9zaXRpb24FCwQAABsTdHJhbnNmb3JtZWRQb3NpdGlvbgULBAAAHBhwaXhlbFRyYW5zZm9ybWVkUG9zaXRpb24FCwQAAB0RdHJhbnNmb3JtZWROb3JtYWwFCwQAAB4RcHJvamVjdGVkUG9zaXRpb24FDAQAAB8KcGl4ZWxDb2xvcgUMBAAAIAVkZXB0aAMEAAAhCHNjcmVlblVWBQoEAAAiCXNwZWNQb3dlcgMEAAAjCXNwZWNDb2xvcgULBAAAJAl3b3JsZERpc3QDBAAAJQVjb2xvcgUMAgAAJg1zcGVjdWxhclBvd2VyAwIAAQcAAAAAAAAAAAAAAAAAAFlAJw5zcGVjdWxhckFtb3VudAMCAAEHAAAAAAAAAAAAAAAAAAAkQCgNc3BlY3VsYXJDb2xvcgULAgAAKQhfX2luaXRfXw4GAAAqEF9faW5pdF9fZnJhZ21lbnQOBgAAKwZ2ZXJ0ZXgOBgAALAhmcmFnbWVudA4GAAAEAikAAAULBgQCGgULAhIFCwULBgQCGwULBgECGgULCQM0DgECDwcIBQsFCwYEAh4FDAYBCQMqDgICGwULAQMAAAAAAADwPwMFDAIHBwUMBQwGBAIdBQsJAx8OAQQGAQITBQsJAzIOAQIPBwYFCwULBQsFCwYEAgsFCwkDHw4BBAYDAgQFCwIbBQsFCwULBQsFCwYEAh8FDAIlBQwFDAYEAiIDAiYDAwYEAiMFCwYBAigFCwInAwULBQsGBAIhBQoJAzoOAQYCCgIeBQwRAAUKCgIeBQwMAAMFCgUKBQoGBAIgAwYCCgIeBQwIAAMKAh4FDAwAAwMDBgQCJAMGAgkDGw4BBgMCGwULAgQFCwULAwIKAwMDAAIqAAAFBQYEAh0FCwkDHw4BAh0FCwULBQsGBAIhBQoJAzoOAQYCCgIeBQwRAAUKCgIeBQwMAAMFCgUKBQoGBAIgAwYCCgIeBQwIAAMKAh4FDAwAAwMDBgQCIgMCJgMDBgQCIwULBgECKAULAicDBQsFCwAAKwAABQIGBAIVBQwGAQIeBQwJAyoOBAEDAAAAAAAA8D8DAgUDAQMAAAAAAADwPwMBAwAAAAAAAPA/AwUMBQwFDAYEAhwFCwIbBQsFCwABLAAABQQGBAIWBQwCHwUMBQwGBAIXAwIgAwMGBAIYBQsCHQULBQsGBAIZAwIkAwMA"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<color public="1" get="accessor" set="accessor"><t path="hxsl.Vec"/></color>
		<color__ expr="new hxsl.Types.Vec()">
			<t path="hxsl.Vec"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Vec()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</color__>
		<get_color get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Vec"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_color>
		<set_color get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Vec"/>
				<t path="hxsl.Vec"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_color>
		<specularPower public="1" get="accessor" set="accessor"><x path="Float"/></specularPower>
		<specularPower__ expr="0">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":noCompletion"/>
			</meta>
		</specularPower__>
		<get_specularPower get="inline" set="null" line="5">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_specularPower>
		<set_specularPower get="inline" set="null" line="5">
			<f a="_v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_specularPower>
		<specularAmount public="1" get="accessor" set="accessor"><x path="Float"/></specularAmount>
		<specularAmount__ expr="0">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":noCompletion"/>
			</meta>
		</specularAmount__>
		<get_specularAmount get="inline" set="null" line="5">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_specularAmount>
		<set_specularAmount get="inline" set="null" line="5">
			<f a="_v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_specularAmount>
		<specularColor public="1" get="accessor" set="accessor"><t path="hxsl.Vec"/></specularColor>
		<specularColor__ expr="new hxsl.Types.Vec()">
			<t path="hxsl.Vec"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Vec()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</specularColor__>
		<get_specularColor get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Vec"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_specularColor>
		<set_specularColor get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Vec"/>
				<t path="hxsl.Vec"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_specularColor>
		<updateConstants public="1" set="method" line="5" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="5" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="95"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":src"><e>{
	@global var camera:{ var view : Mat4; var proj : Mat4; var position : Vec3; var projFlip : Float; var projDiag : Vec3; var viewProj : Mat4; var inverseViewProj : Mat4; var zNear : Float; var zFar : Float; @var};
	@global var global:{ var time : Float; var pixelSize : Vec2; @perObject; @perObject};
	@input var input:{ var position : Vec3; var normal : Vec3};
	var output:{ var position : Vec4; var color : Vec4; var depth : Float; var normal : Vec3; var worldDist : Float};
	var relativePosition:Vec3;
	var transformedPosition:Vec3;
	var pixelTransformedPosition:Vec3;
	var transformedNormal:Vec3;
	var projectedPosition:Vec4;
	var pixelColor:Vec4;
	var depth:Float;
	var screenUV:Vec2;
	var specPower:Float;
	var specColor:Vec3;
	var worldDist:Float;
	@param var color:Vec4;
	@range(0, 100) @param var specularPower:Float;
	@range(0, 10) @param var specularAmount:Float;
	@param var specularColor:Vec3;
	function __init__() {
		relativePosition = input.position;
		transformedPosition = relativePosition * global.modelView.mat3x4();
		projectedPosition = vec4(transformedPosition, 1) * camera.viewProj;
		transformedNormal = (input.normal * global.modelView.mat3()).normalize();
		camera.dir = (camera.position - transformedPosition).normalize();
		pixelColor = color;
		specPower = specularPower;
		specColor = specularColor * specularAmount;
		screenUV = screenToUv(projectedPosition.xy / projectedPosition.w);
		depth = projectedPosition.z / projectedPosition.w;
		worldDist = length(transformedPosition - camera.position) / camera.zFar;
	};
	function __init__fragment() {
		transformedNormal = transformedNormal.normalize();
		screenUV = screenToUv(projectedPosition.xy / projectedPosition.w);
		depth = projectedPosition.z / projectedPosition.w;
		specPower = specularPower;
		specColor = specularColor * specularAmount;
	};
	function vertex() {
		output.position = projectedPosition * vec4(1, camera.projFlip, 1, 1);
		pixelTransformedPosition = transformedPosition;
	};
	function fragment() {
		output.color = pixelColor;
		output.depth = depth;
		output.normal = transformedNormal;
		output.worldDist = worldDist;
	};
}</e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="h3d.shader.Blur" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/shader/Blur.hx">
		<extends path="h3d.shader.ScreenShader"/>
		<SRC expr="&quot;HXSLD2gzZC5zaGFkZXIuQmx1choBBWlucHV0DQECAghwb3NpdGlvbgUKAQEAAwJ1dgUKAQEAAQAABAVmbGlwWQMCAAAFBm91dHB1dA0CAgYIcG9zaXRpb24FDAQFAAcFY29sb3IFDAQFAAQAAAgKcGl4ZWxDb2xvcgUMBAAACQxjYWxjdWxhdGVkVVYFCgQAAAoVY2FtZXJhSW52ZXJzZVZpZXdQcm9qBwIAAAsHdGV4dHVyZQoCAAAMDGRlcHRoVGV4dHVyZQoCAAANB1F1YWxpdHkBAgABAAAAAAAOB2lzRGVwdGgCAgABAAAAAAAPBnZhbHVlcw8DDQIAABAHb2Zmc2V0cw8DDQIAABEFcGl4ZWwFCgIAABINaGFzRml4ZWRDb2xvcgICAAEAAAAAABMQc21vb3RoRml4ZWRDb2xvcgICAAEAAAAAABQKZml4ZWRDb2xvcgUMAgAAFRBpc0RlcHRoRGVwZW5kYW50AgIAAQAAAAAAFgloYXNOb3JtYWwCAgABAAAAAAAXDW5vcm1hbFRleHR1cmUKAgAAGAZpc0N1YmUCAgABAAAAAAAZC2N1YmVUZXh0dXJlDAIAABoHY3ViZURpcgYCAAAbCF9faW5pdF9fDgYAABwGdmVydGV4DgYAAB0IZnJhZ21lbnQOBgAAHgtnZXRQb3NpdGlvbg4GAAAEAhsAAAUCBgQCBwUMAggFDAUMBgQCCQUKAgMFCgUKAAAcAAAFAQYEAgYFDAkDKg4ECgICBQoAAAMGAQoCAgUKBAADAgQDAwEDAAAAAAAAAAADAQMAAAAAAADwPwMFDAUMAAEdAAAFAgsCFQIFBggfBHBjdXIFCwQAAAkCHg4BAgMFCgULAAggBGNjdXIFDAQAAAkDIQ4CAgsKAgMFCgUMAAghBWNvbG9yBQwEAAAJAyoOBAEDAAAAAAAAAAADAQMAAAAAAAAAAAMBAwAAAAAAAAAAAwEDAAAAAAAAAAADBQwACCIEbmN1cgULBAAACQM5DgEJAyEOAgIXCgIDBQoFDAULABUGdW5yb2xsAA4jAWkBBAAABhUGAAcDAg0BAQECAQAAAAEBAg0BDwEAAAUICCQCdXYFCgQAAAYAAgMFCgYBAhEFChECEA8DDQsGCQIjAQECAAAAAAECBwMCIwEBAiMBAQMFCgUKAAglAWMFDAQAAAkDIQ4CAgsKAiQFCgUMAAgmAXAFCwQAAAkCHg4BAiQFCgULAAgnAWQDBAAACQMdDgIEBgMCJgULAh8FCwULBQsGAwImBQsCHwULBQsDAAgoAW4FCwQAAAkDOQ4BCQMhDgICFwoCJAUKBQwFCwAGBAIlBQwJAxgOAwIgBQwCJQUMCQMdDgICIgULAigFCwMFDAUMBgQCJQUMCQMYDgMCJQUMAiAFDAkDFQ4CBAYBCQMWDgIEBgMCJwMBA/yp8dJNYlA/AwMDAQMAAAAAAAAAAAMDAQMAAAAAAGr4QAMDAwEDAAAAAAAA8D8DAwUMBQwGgAIhBQwGAQIlBQwRAg8PAw0LBgkCIwEBAgAAAAABAgcDAiMBAQIjAQEDBQwFDAAAAAYEAggFDAIhBQwFDAALAg4CBQMIKQN2YWwDBAAAAQMAAAAAAAAAAAMAFQZ1bnJvbGwADioBaQEEAAAGFQYABwMCDQEBAQIBAAAAAQECDQEPAQAABQELAhgCBoACKQMGAQkDNw4BCQMhDgICGQwGAQkDKQ4CBgMGAQQGAAIDBQoGAQYBAhEFChECEA8DDQsGCQIqAQECAAAAAAECBwMCKgEBAioBAQMFCgkDJg4BAioBAwUKBQoFCgEDAAAAAAAAAEADBQoBAwAAAAAAAPA/AwUKAQMAAAAAAADwPwMFCwIaBgULBQwDEQIPDwMNCwYJAioBAQIAAAAAAQIHAwIqAQECKgEBAwMDBoACKQMGAQkDNw4BCQMhDgICCwoGAAIDBQoGAQYBAhEFChECEA8DDQsGCQIqAQECAAAAAAECBwMCKgEBAioBAQMFCgkDJg4BAioBAwUKBQoFDAMRAg8PAw0LBgkCKgEBAgAAAAABAgcDAioBAQIqAQEDAwMAAAAABgQCCAUMCQM2DgEJAxUOAgIpAwEDyxpQyv//7z8DAwUMBQwABQMIKwVjb2xvcgUMBAAACQMqDgQBAwAAAAAAAAAAAwEDAAAAAAAAAAADAQMAAAAAAAAAAAMBAwAAAAAAAAAAAwUMABUGdW5yb2xsAA4sAWkBBAAABhUGAAcDAg0BAQECAQAAAAEBAg0BDwEAAAUBCwIYAgaAAisFDAYBCQMhDgICGQwGAQkDKQ4CBgMGAQQGAAIDBQoGAQYBAhEFChECEA8DDQsGCQIsAQECAAAAAAECBwMCLAEBAiwBAQMFCgkDJg4BAiwBAwUKBQoFCgEDAAAAAAAAAEADBQoBAwAAAAAAAPA/AwUKAQMAAAAAAADwPwMFCwIaBgULBQwRAg8PAw0LBgkCLAEBAgAAAAABAgcDAiwBAQIsAQEDBQwFDAaAAisFDAYBCQMhDgICCwoGAAIDBQoGAQYBAhEFChECEA8DDQsGCQIsAQECAAAAAAECBwMCLAEBAiwBAQMFCgkDJg4BAiwBAwUKBQoFDBECDw8DDQsGCQIsAQECAAAAAAECBwMCLAEBAiwBAQMFDAUMAAAAAAYEAggFDAIrBQwFDAAAAAsCEgIFAgsCEwIGgQoCCAUMDAADCgIUBQwMAAMDBgQKAggFDAwAAwYBCgIUBQwMAAMJAyYOAQYHCgIIBQwMAAMBAwAAAAAAAAAAAwIDAwMABgQKAggFDJIABQsGAQoCFAUMkgAFCwoCCAUMDAADBQsFCwAAAAADHgEtAnV2BQoEAAAFCwUECC4FZGVwdGgDBAAACQM3DgEJAyEOAgIMCgItBQoFDAMACC8EdGVtcAUMBAAABgEJAyoOAwkDOw4BAi0FCgUKAi4DAQMAAAAAAADwPwMFDAIKBwUMAAgwCG9yaWdpbldTBQsEAAAGAgoCLwUMkgAFCwoCLwUMDAADBQsADQIwBQsAAA&quot;" line="5" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"HXSLD2gzZC5zaGFkZXIuQmx1choBBWlucHV0DQECAghwb3NpdGlvbgUKAQEAAwJ1dgUKAQEAAQAABAVmbGlwWQMCAAAFBm91dHB1dA0CAgYIcG9zaXRpb24FDAQFAAcFY29sb3IFDAQFAAQAAAgKcGl4ZWxDb2xvcgUMBAAACQxjYWxjdWxhdGVkVVYFCgQAAAoVY2FtZXJhSW52ZXJzZVZpZXdQcm9qBwIAAAsHdGV4dHVyZQoCAAAMDGRlcHRoVGV4dHVyZQoCAAANB1F1YWxpdHkBAgABAAAAAAAOB2lzRGVwdGgCAgABAAAAAAAPBnZhbHVlcw8DDQIAABAHb2Zmc2V0cw8DDQIAABEFcGl4ZWwFCgIAABINaGFzRml4ZWRDb2xvcgICAAEAAAAAABMQc21vb3RoRml4ZWRDb2xvcgICAAEAAAAAABQKZml4ZWRDb2xvcgUMAgAAFRBpc0RlcHRoRGVwZW5kYW50AgIAAQAAAAAAFgloYXNOb3JtYWwCAgABAAAAAAAXDW5vcm1hbFRleHR1cmUKAgAAGAZpc0N1YmUCAgABAAAAAAAZC2N1YmVUZXh0dXJlDAIAABoHY3ViZURpcgYCAAAbCF9faW5pdF9fDgYAABwGdmVydGV4DgYAAB0IZnJhZ21lbnQOBgAAHgtnZXRQb3NpdGlvbg4GAAAEAhsAAAUCBgQCBwUMAggFDAUMBgQCCQUKAgMFCgUKAAAcAAAFAQYEAgYFDAkDKg4ECgICBQoAAAMGAQoCAgUKBAADAgQDAwEDAAAAAAAAAAADAQMAAAAAAADwPwMFDAUMAAEdAAAFAgsCFQIFBggfBHBjdXIFCwQAAAkCHg4BAgMFCgULAAggBGNjdXIFDAQAAAkDIQ4CAgsKAgMFCgUMAAghBWNvbG9yBQwEAAAJAyoOBAEDAAAAAAAAAAADAQMAAAAAAAAAAAMBAwAAAAAAAAAAAwEDAAAAAAAAAAADBQwACCIEbmN1cgULBAAACQM5DgEJAyEOAgIXCgIDBQoFDAULABUGdW5yb2xsAA4jAWkBBAAABhUGAAcDAg0BAQECAQAAAAEBAg0BDwEAAAUICCQCdXYFCgQAAAYAAgMFCgYBAhEFChECEA8DDQsGCQIjAQECAAAAAAECBwMCIwEBAiMBAQMFCgUKAAglAWMFDAQAAAkDIQ4CAgsKAiQFCgUMAAgmAXAFCwQAAAkCHg4BAiQFCgULAAgnAWQDBAAACQMdDgIEBgMCJgULAh8FCwULBQsGAwImBQsCHwULBQsDAAgoAW4FCwQAAAkDOQ4BCQMhDgICFwoCJAUKBQwFCwAGBAIlBQwJAxgOAwIgBQwCJQUMCQMdDgICIgULAigFCwMFDAUMBgQCJQUMCQMYDgMCJQUMAiAFDAkDFQ4CBAYBCQMWDgIEBgMCJwMBA/yp8dJNYlA/AwMDAQMAAAAAAAAAAAMDAQMAAAAAAGr4QAMDAwEDAAAAAAAA8D8DAwUMBQwGgAIhBQwGAQIlBQwRAg8PAw0LBgkCIwEBAgAAAAABAgcDAiMBAQIjAQEDBQwFDAAAAAYEAggFDAIhBQwFDAALAg4CBQMIKQN2YWwDBAAAAQMAAAAAAAAAAAMAFQZ1bnJvbGwADioBaQEEAAAGFQYABwMCDQEBAQIBAAAAAQECDQEPAQAABQELAhgCBoACKQMGAQkDNw4BCQMhDgICGQwGAQkDKQ4CBgMGAQQGAAIDBQoGAQYBAhEFChECEA8DDQsGCQIqAQECAAAAAAECBwMCKgEBAioBAQMFCgkDJg4BAioBAwUKBQoFCgEDAAAAAAAAAEADBQoBAwAAAAAAAPA/AwUKAQMAAAAAAADwPwMFCwIaBgULBQwDEQIPDwMNCwYJAioBAQIAAAAAAQIHAwIqAQECKgEBAwMDBoACKQMGAQkDNw4BCQMhDgICCwoGAAIDBQoGAQYBAhEFChECEA8DDQsGCQIqAQECAAAAAAECBwMCKgEBAioBAQMFCgkDJg4BAioBAwUKBQoFDAMRAg8PAw0LBgkCKgEBAgAAAAABAgcDAioBAQIqAQEDAwMAAAAABgQCCAUMCQM2DgEJAxUOAgIpAwEDyxpQyv//7z8DAwUMBQwABQMIKwVjb2xvcgUMBAAACQMqDgQBAwAAAAAAAAAAAwEDAAAAAAAAAAADAQMAAAAAAAAAAAMBAwAAAAAAAAAAAwUMABUGdW5yb2xsAA4sAWkBBAAABhUGAAcDAg0BAQECAQAAAAEBAg0BDwEAAAUBCwIYAgaAAisFDAYBCQMhDgICGQwGAQkDKQ4CBgMGAQQGAAIDBQoGAQYBAhEFChECEA8DDQsGCQIsAQECAAAAAAECBwMCLAEBAiwBAQMFCgkDJg4BAiwBAwUKBQoFCgEDAAAAAAAAAEADBQoBAwAAAAAAAPA/AwUKAQMAAAAAAADwPwMFCwIaBgULBQwRAg8PAw0LBgkCLAEBAgAAAAABAgcDAiwBAQIsAQEDBQwFDAaAAisFDAYBCQMhDgICCwoGAAIDBQoGAQYBAhEFChECEA8DDQsGCQIsAQECAAAAAAECBwMCLAEBAiwBAQMFCgkDJg4BAiwBAwUKBQoFDBECDw8DDQsGCQIsAQECAAAAAAECBwMCLAEBAiwBAQMFDAUMAAAAAAYEAggFDAIrBQwFDAAAAAsCEgIFAgsCEwIGgQoCCAUMDAADCgIUBQwMAAMDBgQKAggFDAwAAwYBCgIUBQwMAAMJAyYOAQYHCgIIBQwMAAMBAwAAAAAAAAAAAwIDAwMABgQKAggFDJIABQsGAQoCFAUMkgAFCwoCCAUMDAADBQsFCwAAAAADHgEtAnV2BQoEAAAFCwUECC4FZGVwdGgDBAAACQM3DgEJAyEOAgIMCgItBQoFDAMACC8EdGVtcAUMBAAABgEJAyoOAwkDOw4BAi0FCgUKAi4DAQMAAAAAAADwPwMFDAIKBwUMAAgwCG9yaWdpbldTBQsEAAAGAgoCLwUMkgAFCwoCLwUMDAADBQsADQIwBQsAAA"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<cameraInverseViewProj public="1" get="accessor" set="accessor"><t path="hxsl.Matrix"/></cameraInverseViewProj>
		<cameraInverseViewProj__ expr="new hxsl.Types.Matrix()">
			<t path="hxsl.Matrix"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Matrix()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</cameraInverseViewProj__>
		<get_cameraInverseViewProj get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Matrix"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_cameraInverseViewProj>
		<set_cameraInverseViewProj get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Matrix"/>
				<t path="hxsl.Matrix"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_cameraInverseViewProj>
		<texture public="1" get="accessor" set="accessor"><t path="hxsl.Sampler2D"/></texture>
		<texture__>
			<t path="hxsl.Sampler2D"/>
			<meta><m n=":noCompletion"/></meta>
		</texture__>
		<get_texture get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Sampler2D"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_texture>
		<set_texture get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Sampler2D"/>
				<t path="hxsl.Sampler2D"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_texture>
		<depthTexture public="1" get="accessor" set="accessor"><t path="hxsl.Sampler2D"/></depthTexture>
		<depthTexture__>
			<t path="hxsl.Sampler2D"/>
			<meta><m n=":noCompletion"/></meta>
		</depthTexture__>
		<get_depthTexture get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Sampler2D"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_depthTexture>
		<set_depthTexture get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Sampler2D"/>
				<t path="hxsl.Sampler2D"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_depthTexture>
		<Quality public="1" get="accessor" set="accessor"><x path="Int"/></Quality>
		<Quality__ expr="0">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":noCompletion"/>
			</meta>
		</Quality__>
		<get_Quality get="inline" set="null" line="5">
			<f a=""><x path="Int"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_Quality>
		<set_Quality get="inline" set="null" line="5">
			<f a="_v">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_Quality>
		<isDepth public="1" get="accessor" set="accessor"><x path="Bool"/></isDepth>
		<isDepth__>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</isDepth__>
		<get_isDepth get="inline" set="null" line="5">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_isDepth>
		<set_isDepth get="inline" set="null" line="5">
			<f a="_v">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_isDepth>
		<values public="1" get="accessor" set="accessor"><c path="Array"><x path="Float"/></c></values>
		<values__ expr="new Array()">
			<c path="Array"><x path="Float"/></c>
			<meta>
				<m n=":value"><e>new Array()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</values__>
		<get_values get="inline" set="null" line="5">
			<f a=""><c path="Array"><x path="Float"/></c></f>
			<meta><m n=":noCompletion"/></meta>
		</get_values>
		<set_values get="inline" set="null" line="5">
			<f a="_v">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_values>
		<offsets public="1" get="accessor" set="accessor"><c path="Array"><x path="Float"/></c></offsets>
		<offsets__ expr="new Array()">
			<c path="Array"><x path="Float"/></c>
			<meta>
				<m n=":value"><e>new Array()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</offsets__>
		<get_offsets get="inline" set="null" line="5">
			<f a=""><c path="Array"><x path="Float"/></c></f>
			<meta><m n=":noCompletion"/></meta>
		</get_offsets>
		<set_offsets get="inline" set="null" line="5">
			<f a="_v">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_offsets>
		<pixel public="1" get="accessor" set="accessor"><t path="hxsl.Vec"/></pixel>
		<pixel__ expr="new hxsl.Types.Vec()">
			<t path="hxsl.Vec"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Vec()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</pixel__>
		<get_pixel get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Vec"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_pixel>
		<set_pixel get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Vec"/>
				<t path="hxsl.Vec"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_pixel>
		<hasFixedColor public="1" get="accessor" set="accessor"><x path="Bool"/></hasFixedColor>
		<hasFixedColor__>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</hasFixedColor__>
		<get_hasFixedColor get="inline" set="null" line="5">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_hasFixedColor>
		<set_hasFixedColor get="inline" set="null" line="5">
			<f a="_v">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_hasFixedColor>
		<smoothFixedColor public="1" get="accessor" set="accessor"><x path="Bool"/></smoothFixedColor>
		<smoothFixedColor__>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</smoothFixedColor__>
		<get_smoothFixedColor get="inline" set="null" line="5">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_smoothFixedColor>
		<set_smoothFixedColor get="inline" set="null" line="5">
			<f a="_v">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_smoothFixedColor>
		<fixedColor public="1" get="accessor" set="accessor"><t path="hxsl.Vec"/></fixedColor>
		<fixedColor__ expr="new hxsl.Types.Vec()">
			<t path="hxsl.Vec"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Vec()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</fixedColor__>
		<get_fixedColor get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Vec"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_fixedColor>
		<set_fixedColor get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Vec"/>
				<t path="hxsl.Vec"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_fixedColor>
		<isDepthDependant public="1" get="accessor" set="accessor"><x path="Bool"/></isDepthDependant>
		<isDepthDependant__>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</isDepthDependant__>
		<get_isDepthDependant get="inline" set="null" line="5">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_isDepthDependant>
		<set_isDepthDependant get="inline" set="null" line="5">
			<f a="_v">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_isDepthDependant>
		<hasNormal public="1" get="accessor" set="accessor"><x path="Bool"/></hasNormal>
		<hasNormal__>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</hasNormal__>
		<get_hasNormal get="inline" set="null" line="5">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_hasNormal>
		<set_hasNormal get="inline" set="null" line="5">
			<f a="_v">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_hasNormal>
		<normalTexture public="1" get="accessor" set="accessor"><t path="hxsl.Sampler2D"/></normalTexture>
		<normalTexture__>
			<t path="hxsl.Sampler2D"/>
			<meta><m n=":noCompletion"/></meta>
		</normalTexture__>
		<get_normalTexture get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Sampler2D"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_normalTexture>
		<set_normalTexture get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Sampler2D"/>
				<t path="hxsl.Sampler2D"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_normalTexture>
		<isCube public="1" get="accessor" set="accessor"><x path="Bool"/></isCube>
		<isCube__>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</isCube__>
		<get_isCube get="inline" set="null" line="5">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_isCube>
		<set_isCube get="inline" set="null" line="5">
			<f a="_v">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_isCube>
		<cubeTexture public="1" get="accessor" set="accessor"><t path="hxsl.SamplerCube"/></cubeTexture>
		<cubeTexture__>
			<t path="hxsl.SamplerCube"/>
			<meta><m n=":noCompletion"/></meta>
		</cubeTexture__>
		<get_cubeTexture get="inline" set="null" line="5">
			<f a=""><t path="hxsl.SamplerCube"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_cubeTexture>
		<set_cubeTexture get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.SamplerCube"/>
				<t path="hxsl.SamplerCube"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_cubeTexture>
		<cubeDir public="1" get="accessor" set="accessor"><t path="hxsl.Matrix"/></cubeDir>
		<cubeDir__ expr="new hxsl.Types.Matrix()">
			<t path="hxsl.Matrix"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Matrix()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</cubeDir__>
		<get_cubeDir get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Matrix"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_cubeDir>
		<set_cubeDir get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Matrix"/>
				<t path="hxsl.Matrix"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_cubeDir>
		<updateConstants public="1" set="method" line="5" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="5" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="3"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":src"><e><![CDATA[{
	@param var cameraInverseViewProj:Mat4;
	@param var texture:Sampler2D;
	@param var depthTexture:Sampler2D;
	@param @const var Quality:Int;
	@param @const var isDepth:Bool;
	@param var values:Array<Float,Quality>;
	@param var offsets:Array<Float,Quality>;
	@param var pixel:Vec2;
	@const var hasFixedColor:Bool;
	@const var smoothFixedColor:Bool;
	@param var fixedColor:Vec4;
	@param @const var isDepthDependant:Bool;
	@param @const var hasNormal:Bool;
	@param var normalTexture:Sampler2D;
	@param @const var isCube:Bool;
	@param var cubeTexture:SamplerCube;
	@param var cubeDir:Mat3;
	function fragment() {
		if (isDepthDependant) {
			var pcur = getPosition(input.uv);
			var ccur = texture.get(input.uv);
			var color = vec4(0, 0, 0, 0);
			var ncur = unpackNormal(normalTexture.get(input.uv));
			@unroll for (i  in  -Quality + 1 ... Quality) {
				var uv = input.uv + pixel * offsets[i < 0 ? -i : i];
				var c = texture.get(uv);
				var p = getPosition(uv);
				var d = (p - pcur).dot(p - pcur);
				var n = unpackNormal(normalTexture.get(uv));
				c = mix(ccur, c, ncur.dot(n));
				c = mix(c, ccur, ((d - 0.001).max(0.) * 100000).min(1.));
				color += c * values[i < 0 ? -i : i];
			};
			pixelColor = color;
		} else if (isDepth) {
			var val = 0.;
			@unroll for (i  in  -Quality + 1 ... Quality) {
				if (isCube) val += unpack(cubeTexture.get(vec3((input.uv + pixel * offsets[i < 0 ? -i : i] * i) * 2.0 - 1.0, 1) * cubeDir)) * values[i < 0 ? -i : i] else val += unpack(texture.get(input.uv + pixel * offsets[i < 0 ? -i : i] * i)) * values[i < 0 ? -i : i];
			};
			pixelColor = pack(val.min(0.9999999));
		} else {
			var color = vec4(0, 0, 0, 0);
			@unroll for (i  in  -Quality + 1 ... Quality) {
				if (isCube) color += cubeTexture.get(vec3((input.uv + pixel * offsets[i < 0 ? -i : i] * i) * 2.0 - 1.0, 1) * cubeDir) * values[i < 0 ? -i : i] else color += texture.get(input.uv + pixel * offsets[i < 0 ? -i : i] * i) * values[i < 0 ? -i : i];
			};
			pixelColor = color;
		};
		if (hasFixedColor) {
			if (smoothFixedColor) pixelColor.a *= fixedColor.a else pixelColor.a = fixedColor.a * float(pixelColor.a > 0);
			pixelColor.rgb = fixedColor.rgb * pixelColor.a;
		};
	};
	function getPosition(uv:Vec2):Vec3 {
		var depth = unpack(depthTexture.get(uv));
		var temp = vec4(uvToScreen(uv), depth, 1) * cameraInverseViewProj;
		var originWS = temp.xyz / temp.w;
		return originWS;
	};
}]]></e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<abstract path="h3d.shader.BufferKind" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/shader/Buffers.hx" module="h3d.shader.Buffers">
		<this><x path="Int"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="h3d.shader._Buffers.BufferKind_Impl_" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/shader/Buffers.hx" private="1" module="h3d.shader.Buffers" extern="1">
	<Globals public="1" get="inline" set="null" expr="cast 0" line="4" static="1">
		<x path="h3d.shader.BufferKind"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Globals>
	<Params public="1" get="inline" set="null" expr="cast 1" line="5" static="1">
		<x path="h3d.shader.BufferKind"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Params>
	<Textures public="1" get="inline" set="null" expr="cast 2" line="6" static="1">
		<x path="h3d.shader.BufferKind"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Textures>
	<Buffers public="1" get="inline" set="null" expr="cast 3" line="7" static="1">
		<x path="h3d.shader.BufferKind"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Buffers>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="h3d.shader._Buffers.BufferKind_Impl_" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/shader/Buffers.hx" private="1" module="h3d.shader.Buffers" extern="1">
		<Globals public="1" get="inline" set="null" expr="cast 0" line="4" static="1">
			<x path="h3d.shader.BufferKind"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Globals>
		<Params public="1" get="inline" set="null" expr="cast 1" line="5" static="1">
			<x path="h3d.shader.BufferKind"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Params>
		<Textures public="1" get="inline" set="null" expr="cast 2" line="6" static="1">
			<x path="h3d.shader.BufferKind"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Textures>
		<Buffers public="1" get="inline" set="null" expr="cast 3" line="7" static="1">
			<x path="h3d.shader.BufferKind"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Buffers>
		<meta><m n=":enum"/></meta>
	</class>
	<typedef path="h3d.shader.ShaderBufferData" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/shader/Buffers.hx" module="h3d.shader.Buffers"><t path="hxd.impl.Float32Array"/></typedef>
	<class path="h3d.shader.ShaderBuffers" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/shader/Buffers.hx" module="h3d.shader.Buffers">
		<globals public="1"><t path="h3d.shader.ShaderBufferData"/></globals>
		<params public="1"><t path="h3d.shader.ShaderBufferData"/></params>
		<tex public="1"><x path="haxe.ds.Vector"><c path="h3d.mat.Texture"/></x></tex>
		<buffers public="1"><x path="haxe.ds.Vector"><c path="h3d.Buffer"/></x></buffers>
		<grow public="1" set="method" line="26"><f a="s">
	<c path="hxsl.RuntimeShaderData"/>
	<x path="Void"/>
</f></grow>
		<new public="1" set="method" line="19"><f a="s">
	<c path="hxsl.RuntimeShaderData"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.shader.Buffers" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/shader/Buffers.hx">
		<vertex public="1"><c path="h3d.shader.ShaderBuffers"/></vertex>
		<fragment public="1"><c path="h3d.shader.ShaderBuffers"/></fragment>
		<grow public="1" get="inline" set="null" line="49"><f a="s">
	<c path="hxsl.RuntimeShader"/>
	<x path="Void"/>
</f></grow>
		<new public="1" set="method" line="44"><f a="s">
	<c path="hxsl.RuntimeShader"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.shader.ColorAdd" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/shader/ColorAdd.hx">
		<extends path="hxsl.Shader"/>
		<SRC expr="&quot;HXSLE2gzZC5zaGFkZXIuQ29sb3JBZGQDAQpwaXhlbENvbG9yBQwEAAACBWNvbG9yBQsCAAADCGZyYWdtZW50DgYAAAEBAwAABQEGgAoCAQUMkgAFCwICBQsFCwA&quot;" line="5" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"HXSLE2gzZC5zaGFkZXIuQ29sb3JBZGQDAQpwaXhlbENvbG9yBQwEAAACBWNvbG9yBQsCAAADCGZyYWdtZW50DgYAAAEBAwAABQEGgAoCAQUMkgAFCwICBQsFCwA"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<color public="1" get="accessor" set="accessor"><t path="hxsl.Vec"/></color>
		<color__ expr="new hxsl.Types.Vec()">
			<t path="hxsl.Vec"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Vec()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</color__>
		<get_color get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Vec"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_color>
		<set_color get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Vec"/>
				<t path="hxsl.Vec"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_color>
		<updateConstants public="1" set="method" line="5" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="5" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="16">
			<f a="?color" v="0">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ color : 0 }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":src"><e>{
	var pixelColor:Vec4;
	@param var color:Vec3;
	function fragment() {
		pixelColor.rgb += color;
	};
}</e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="h3d.shader.ColorKey" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/shader/ColorKey.hx">
		<extends path="hxsl.Shader"/>
		<SRC expr="&quot;HXSLE2gzZC5zaGFkZXIuQ29sb3JLZXkDAQhjb2xvcktleQUMAgAAAgx0ZXh0dXJlQ29sb3IFDAQAAAMIZnJhZ21lbnQOBgAAAQEDAAAFAggEBWNkaWZmBQwEAAAGAwICBQwCAQUMBQwACwYJCQMdDgICBAUMAgQFDAMBA/Fo44i1+OQ+AwIMAAAAAA&quot;" line="5" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"HXSLE2gzZC5zaGFkZXIuQ29sb3JLZXkDAQhjb2xvcktleQUMAgAAAgx0ZXh0dXJlQ29sb3IFDAQAAAMIZnJhZ21lbnQOBgAAAQEDAAAFAggEBWNkaWZmBQwEAAAGAwICBQwCAQUMBQwACwYJCQMdDgICBAUMAgQFDAMBA/Fo44i1+OQ+AwIMAAAAAA"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<colorKey public="1" get="accessor" set="accessor"><t path="hxsl.Vec"/></colorKey>
		<colorKey__ expr="new hxsl.Types.Vec()">
			<t path="hxsl.Vec"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Vec()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</colorKey__>
		<get_colorKey get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Vec"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_colorKey>
		<set_colorKey get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Vec"/>
				<t path="hxsl.Vec"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_colorKey>
		<updateConstants public="1" set="method" line="5" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="5" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="15">
			<f a="?v" v="0">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ v : 0 }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":src"><e><![CDATA[{
	@param var colorKey:Vec4;
	var textureColor:Vec4;
	function fragment() {
		var cdiff = textureColor - colorKey;
		if (cdiff.dot(cdiff) < 0.00001) discard;
	};
}]]></e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="h3d.shader.ColorMatrix" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/shader/ColorMatrix.hx">
		<extends path="hxsl.Shader"/>
		<SRC expr="&quot;HXSLFmgzZC5zaGFkZXIuQ29sb3JNYXRyaXgDAQpwaXhlbENvbG9yBQwEAAACBm1hdHJpeAcCAAADCGZyYWdtZW50DgYAAAEBAwAABQEGBAIBBQwJAyoOAgoEBgEJAyoOAgoCAQUMkgAFCwEDAAAAAAAA8D8DBQwCAgcFDAUMkgAFCwoEBgECAQUMAgIHBQwFDAwAAwUMBQwA&quot;" line="5" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"HXSLFmgzZC5zaGFkZXIuQ29sb3JNYXRyaXgDAQpwaXhlbENvbG9yBQwEAAACBm1hdHJpeAcCAAADCGZyYWdtZW50DgYAAAEBAwAABQEGBAIBBQwJAyoOAgoEBgEJAyoOAgoCAQUMkgAFCwEDAAAAAAAA8D8DBQwCAgcFDAUMkgAFCwoEBgECAQUMAgIHBQwFDAwAAwUMBQwA"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<matrix public="1" get="accessor" set="accessor"><t path="hxsl.Matrix"/></matrix>
		<matrix__ expr="new hxsl.Types.Matrix()">
			<t path="hxsl.Matrix"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Matrix()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</matrix__>
		<get_matrix get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Matrix"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_matrix>
		<set_matrix get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Matrix"/>
				<t path="hxsl.Matrix"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_matrix>
		<updateConstants public="1" set="method" line="5" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="5" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="16"><f a="?m">
	<c path="Array"><x path="Float"/></c>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":src"><e>{
	var pixelColor:Vec4;
	@param var matrix:Mat4;
	function fragment() {
		pixelColor = vec4((vec4(pixelColor.rgb, 1.) * matrix).rgb, (pixelColor * matrix).a);
	};
}</e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="h3d.shader.DirShadow" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/shader/DirShadow.hx">
		<extends path="hxsl.Shader"/>
		<SRC expr="&quot;HXSLFGgzZC5zaGFkZXIuRGlyU2hhZG93EgEGZW5hYmxlAgIAAQAAAAAAAgdVU0VfRVNNAgIAAQAAAAAAAwtzaGFkb3dQb3dlcgMCAAAEB1VTRV9QQ0YCAgABAAAAAAAFCnBjZlF1YWxpdHkBAgABAAAAAAAGCHBjZlNjYWxlAwIAAAcJc2hhZG93UmVzBQoCAAAICXNoYWRvd01hcBEBAgAACQpzaGFkb3dQcm9qCAIAAAoKc2hhZG93QmlhcwMCAAALE3RyYW5zZm9ybWVkUG9zaXRpb24FCwQAAAwGc2hhZG93AwQAAA0JZGlyU2hhZG93AwQAAA4OcG9pc3NvbkRpc2tMb3cPBQwABAIAAA8PcG9pc3NvbkRpc2tIaWdoDwUMAAwCAAAQE3BvaXNzb25EaXNrVmVyeUhpZ2gPBQwAQAIAABEEcmFuZA4GAAASCGZyYWdtZW50DgYAAAIDEQETAXYDBAAAAwUCCBQCZHADBAAACQMdDgIJAyoOAQITAwUMCQMqDgQBA18pyxDH+ilAAwED9P3UeOmOU0ADAQOiRbbz/ZRGQAMBA1CNl24Sq1dAAwUMAwANCQMTDgEGAQkDAg4BAhQDAwEDUPwYc9Fd5UADAwMAAAESAAAFAgsCAQIFAQsCBAIFBwYEAgwDAQMAAAAAAADwPwMDCBUJdGV4ZWxTaXplBQoEAAAGAgEDAAAAAAAA8D8DAgcFCgUKAAgWCXNoYWRvd1BvcwULBAAABgECCwULAgkIBQsACBcIc2hhZG93VXYFCgQAAAkDOg4BCgIWBQsRAAUKBQoACBgEek1heAMEAAAJAzUOAQoCFgULCAADAwAIGQNyb3QDBAAABgEGAQkCEQ4BBgAGAAoCCwULAAADCgILBQsEAAMDCgILBQsIAAMDAwEDH4XrUbgeCUADAwEDAAAAAAAAAEADAwATBAIFAQEDAQECAQAAAAEFAggaDnNhbXBsZVN0cmVuZ3RoAwQAAAYCAQMAAAAAAADwPwMBAwAAAAAAABBAAwMADhsBaQEEAAAGFQECAAAAAAEBAgQAAAABDwEAAAUECBwGb2Zmc2V0BQoEAAAGAQYBChECDg8FDAAEAhsBBQwRAAUKAhUFCgUKAgYDBQoABgQCHAUKCQMoDgIGAwYBCQMDDgECGQMDCgIcBQoAAAMDBgEJAwIOAQIZAwMKAhwFCgQAAwMDBgAGAQkDAw4BAhkDAwoCHAUKBAADAwYBCQMCDgECGQMDCgIcBQoAAAMDAwUKBQoIHQVkZXB0aAMEAAAJA0AOAwIIEQEGAAIXBQoCHAUKBQoBAwAAAAAAAAAAAwMACwYHBgMCGAMCCgMDAh0DAgaDAgwDAhoDAwAAAAAAAQECAgAAAAEFAggeDnNhbXBsZVN0cmVuZ3RoAwQAAAYCAQMAAAAAAADwPwMBAwAAAAAAAChAAwMADh8BaQEEAAAGFQECAAAAAAEBAgwAAAABDwEAAAUECCAGb2Zmc2V0BQoEAAAGAQYBChECDw8FDAAMAh8BBQwRAAUKAhUFCgUKAgYDBQoABgQCIAUKCQMoDgIGAwYBCQMDDgECGQMDCgIgBQoAAAMDBgEJAwIOAQIZAwMKAiAFCgQAAwMDBgAGAQkDAw4BAhkDAwoCIAUKBAADAwYBCQMCDgECGQMDCgIgBQoAAAMDAwUKBQoIIQVkZXB0aAMEAAAJA0AOAwIIEQEGAAIXBQoCIAUKBQoBAwAAAAAAAAAAAwMACwYHBgMCGAMCCgMDAiEDAgaDAgwDAh4DAwAAAAAAAQECAwAAAAEFAggiDnNhbXBsZVN0cmVuZ3RoAwQAAAYCAQMAAAAAAADwPwMBAwAAAAAAAFBAAwMADiMBaQEEAAAGFQECAAAAAAEBAkAAAAABDwEAAAUECCQGb2Zmc2V0BQoEAAAGAQYBChECEA8FDABAAiMBBQwRAAUKAhUFCgUKAgYDBQoABgQCJAUKCQMoDgIGAwYBCQMDDgECGQMDCgIkBQoAAAMDBgEJAwIOAQIZAwMKAiQFCgQAAwMDBgAGAQkDAw4BAhkDAwoCJAUKBAADAwYBCQMCDgECGQMDCgIkBQoAAAMDAwUKBQoIJQVkZXB0aAMEAAAJA0AOAwIIEQEGAAIXBQoCJAUKBQoBAwAAAAAAAAAAAwMACwYHBgMCGAMCCgMDAiUDAgaDAgwDAiIDAwAAAAAAAAAACwICAgUFCCYJc2hhZG93UG9zBQsEAAAGAQILBQsCCQgFCwAIJwVkZXB0aAMEAAAJAz8OAgIIEQEJAzoOAQoCJgULEQAFCgUKAwAIKAR6TWF4AwQAAAkDNQ4BCgImBQsIAAMDAAgpBWRlbHRhAwQAAAYDCQMVDgIEBgACJwMCCgMDAwIoAwMCKAMDAAYEAgwDCQM1DgEJAwkOAQYBAgMDAikDAwMDAwAFBAgqCXNoYWRvd1BvcwULBAAABgECCwULAgkIBQsACCsIc2hhZG93VXYFCgQAAAkDOg4BCgIqBQsRAAUKBQoACCwFZGVwdGgDBAAACQM/DgICCBEBCgIrBQoRAAUKAwAGBAIMAwsGBwYDCgIqBQsIAAMCCgMDAiwDAgEDAAAAAAAAAAADAQMAAAAAAADwPwMDAwAAAAAAAAYEAg0DAgwDAwA&quot;" line="5" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"HXSLFGgzZC5zaGFkZXIuRGlyU2hhZG93EgEGZW5hYmxlAgIAAQAAAAAAAgdVU0VfRVNNAgIAAQAAAAAAAwtzaGFkb3dQb3dlcgMCAAAEB1VTRV9QQ0YCAgABAAAAAAAFCnBjZlF1YWxpdHkBAgABAAAAAAAGCHBjZlNjYWxlAwIAAAcJc2hhZG93UmVzBQoCAAAICXNoYWRvd01hcBEBAgAACQpzaGFkb3dQcm9qCAIAAAoKc2hhZG93QmlhcwMCAAALE3RyYW5zZm9ybWVkUG9zaXRpb24FCwQAAAwGc2hhZG93AwQAAA0JZGlyU2hhZG93AwQAAA4OcG9pc3NvbkRpc2tMb3cPBQwABAIAAA8PcG9pc3NvbkRpc2tIaWdoDwUMAAwCAAAQE3BvaXNzb25EaXNrVmVyeUhpZ2gPBQwAQAIAABEEcmFuZA4GAAASCGZyYWdtZW50DgYAAAIDEQETAXYDBAAAAwUCCBQCZHADBAAACQMdDgIJAyoOAQITAwUMCQMqDgQBA18pyxDH+ilAAwED9P3UeOmOU0ADAQOiRbbz/ZRGQAMBA1CNl24Sq1dAAwUMAwANCQMTDgEGAQkDAg4BAhQDAwEDUPwYc9Fd5UADAwMAAAESAAAFAgsCAQIFAQsCBAIFBwYEAgwDAQMAAAAAAADwPwMDCBUJdGV4ZWxTaXplBQoEAAAGAgEDAAAAAAAA8D8DAgcFCgUKAAgWCXNoYWRvd1BvcwULBAAABgECCwULAgkIBQsACBcIc2hhZG93VXYFCgQAAAkDOg4BCgIWBQsRAAUKBQoACBgEek1heAMEAAAJAzUOAQoCFgULCAADAwAIGQNyb3QDBAAABgEGAQkCEQ4BBgAGAAoCCwULAAADCgILBQsEAAMDCgILBQsIAAMDAwEDH4XrUbgeCUADAwEDAAAAAAAAAEADAwATBAIFAQEDAQECAQAAAAEFAggaDnNhbXBsZVN0cmVuZ3RoAwQAAAYCAQMAAAAAAADwPwMBAwAAAAAAABBAAwMADhsBaQEEAAAGFQECAAAAAAEBAgQAAAABDwEAAAUECBwGb2Zmc2V0BQoEAAAGAQYBChECDg8FDAAEAhsBBQwRAAUKAhUFCgUKAgYDBQoABgQCHAUKCQMoDgIGAwYBCQMDDgECGQMDCgIcBQoAAAMDBgEJAwIOAQIZAwMKAhwFCgQAAwMDBgAGAQkDAw4BAhkDAwoCHAUKBAADAwYBCQMCDgECGQMDCgIcBQoAAAMDAwUKBQoIHQVkZXB0aAMEAAAJA0AOAwIIEQEGAAIXBQoCHAUKBQoBAwAAAAAAAAAAAwMACwYHBgMCGAMCCgMDAh0DAgaDAgwDAhoDAwAAAAAAAQECAgAAAAEFAggeDnNhbXBsZVN0cmVuZ3RoAwQAAAYCAQMAAAAAAADwPwMBAwAAAAAAAChAAwMADh8BaQEEAAAGFQECAAAAAAEBAgwAAAABDwEAAAUECCAGb2Zmc2V0BQoEAAAGAQYBChECDw8FDAAMAh8BBQwRAAUKAhUFCgUKAgYDBQoABgQCIAUKCQMoDgIGAwYBCQMDDgECGQMDCgIgBQoAAAMDBgEJAwIOAQIZAwMKAiAFCgQAAwMDBgAGAQkDAw4BAhkDAwoCIAUKBAADAwYBCQMCDgECGQMDCgIgBQoAAAMDAwUKBQoIIQVkZXB0aAMEAAAJA0AOAwIIEQEGAAIXBQoCIAUKBQoBAwAAAAAAAAAAAwMACwYHBgMCGAMCCgMDAiEDAgaDAgwDAh4DAwAAAAAAAQECAwAAAAEFAggiDnNhbXBsZVN0cmVuZ3RoAwQAAAYCAQMAAAAAAADwPwMBAwAAAAAAAFBAAwMADiMBaQEEAAAGFQECAAAAAAEBAkAAAAABDwEAAAUECCQGb2Zmc2V0BQoEAAAGAQYBChECEA8FDABAAiMBBQwRAAUKAhUFCgUKAgYDBQoABgQCJAUKCQMoDgIGAwYBCQMDDgECGQMDCgIkBQoAAAMDBgEJAwIOAQIZAwMKAiQFCgQAAwMDBgAGAQkDAw4BAhkDAwoCJAUKBAADAwYBCQMCDgECGQMDCgIkBQoAAAMDAwUKBQoIJQVkZXB0aAMEAAAJA0AOAwIIEQEGAAIXBQoCJAUKBQoBAwAAAAAAAAAAAwMACwYHBgMCGAMCCgMDAiUDAgaDAgwDAiIDAwAAAAAAAAAACwICAgUFCCYJc2hhZG93UG9zBQsEAAAGAQILBQsCCQgFCwAIJwVkZXB0aAMEAAAJAz8OAgIIEQEJAzoOAQoCJgULEQAFCgUKAwAIKAR6TWF4AwQAAAkDNQ4BCgImBQsIAAMDAAgpBWRlbHRhAwQAAAYDCQMVDgIEBgACJwMCCgMDAwIoAwMCKAMDAAYEAgwDCQM1DgEJAwkOAQYBAgMDAikDAwMDAwAFBAgqCXNoYWRvd1BvcwULBAAABgECCwULAgkIBQsACCsIc2hhZG93VXYFCgQAAAkDOg4BCgIqBQsRAAUKBQoACCwFZGVwdGgDBAAACQM/DgICCBEBCgIrBQoRAAUKAwAGBAIMAwsGBwYDCgIqBQsIAAMCCgMDAiwDAgEDAAAAAAAAAAADAQMAAAAAAADwPwMDAwAAAAAAAAYEAg0DAgwDAwA"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<enable public="1" get="accessor" set="accessor"><x path="Bool"/></enable>
		<enable__>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</enable__>
		<get_enable get="inline" set="null" line="5">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_enable>
		<set_enable get="inline" set="null" line="5">
			<f a="_v">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_enable>
		<USE_ESM public="1" get="accessor" set="accessor"><x path="Bool"/></USE_ESM>
		<USE_ESM__>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</USE_ESM__>
		<get_USE_ESM get="inline" set="null" line="5">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_USE_ESM>
		<set_USE_ESM get="inline" set="null" line="5">
			<f a="_v">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_USE_ESM>
		<shadowPower public="1" get="accessor" set="accessor"><x path="Float"/></shadowPower>
		<shadowPower__ expr="0">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":noCompletion"/>
			</meta>
		</shadowPower__>
		<get_shadowPower get="inline" set="null" line="5">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_shadowPower>
		<set_shadowPower get="inline" set="null" line="5">
			<f a="_v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_shadowPower>
		<USE_PCF public="1" get="accessor" set="accessor"><x path="Bool"/></USE_PCF>
		<USE_PCF__>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</USE_PCF__>
		<get_USE_PCF get="inline" set="null" line="5">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_USE_PCF>
		<set_USE_PCF get="inline" set="null" line="5">
			<f a="_v">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_USE_PCF>
		<pcfQuality public="1" get="accessor" set="accessor"><x path="Int"/></pcfQuality>
		<pcfQuality__ expr="0">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":noCompletion"/>
			</meta>
		</pcfQuality__>
		<get_pcfQuality get="inline" set="null" line="5">
			<f a=""><x path="Int"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_pcfQuality>
		<set_pcfQuality get="inline" set="null" line="5">
			<f a="_v">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_pcfQuality>
		<pcfScale public="1" get="accessor" set="accessor"><x path="Float"/></pcfScale>
		<pcfScale__ expr="0">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":noCompletion"/>
			</meta>
		</pcfScale__>
		<get_pcfScale get="inline" set="null" line="5">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_pcfScale>
		<set_pcfScale get="inline" set="null" line="5">
			<f a="_v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_pcfScale>
		<shadowRes public="1" get="accessor" set="accessor"><t path="hxsl.Vec"/></shadowRes>
		<shadowRes__ expr="new hxsl.Types.Vec()">
			<t path="hxsl.Vec"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Vec()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</shadowRes__>
		<get_shadowRes get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Vec"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_shadowRes>
		<set_shadowRes get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Vec"/>
				<t path="hxsl.Vec"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_shadowRes>
		<shadowMap public="1" get="accessor" set="accessor"><t path="hxsl.ChannelTextureType"/></shadowMap>
		<shadowMap__>
			<t path="hxsl.ChannelTextureType"/>
			<meta><m n=":noCompletion"/></meta>
		</shadowMap__>
		<get_shadowMap get="inline" set="null" line="5">
			<f a=""><t path="hxsl.ChannelTextureType"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_shadowMap>
		<set_shadowMap get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.ChannelTextureType"/>
				<t path="hxsl.ChannelTextureType"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_shadowMap>
		<shadowMapChannel__ expr="Unknown">
			<e path="hxsl.Channel"/>
			<meta><m n=":value"><e>Unknown</e></m></meta>
		</shadowMapChannel__>
		<shadowMapChannel public="1" get="accessor" set="accessor"><e path="hxsl.Channel"/></shadowMapChannel>
		<get_shadowMapChannel get="inline" set="null" line="215"><f a=""><e path="hxsl.Channel"/></f></get_shadowMapChannel>
		<set_shadowMapChannel get="inline" set="null" line="216"><f a="v">
	<e path="hxsl.Channel"/>
	<e path="hxsl.Channel"/>
</f></set_shadowMapChannel>
		<shadowProj public="1" get="accessor" set="accessor"><t path="hxsl.Matrix"/></shadowProj>
		<shadowProj__ expr="new hxsl.Types.Matrix()">
			<t path="hxsl.Matrix"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Matrix()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</shadowProj__>
		<get_shadowProj get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Matrix"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_shadowProj>
		<set_shadowProj get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Matrix"/>
				<t path="hxsl.Matrix"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_shadowProj>
		<shadowBias public="1" get="accessor" set="accessor"><x path="Float"/></shadowBias>
		<shadowBias__ expr="0">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":noCompletion"/>
			</meta>
		</shadowBias__>
		<get_shadowBias get="inline" set="null" line="5">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_shadowBias>
		<set_shadowBias get="inline" set="null" line="5">
			<f a="_v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_shadowBias>
		<poissonDiskLow public="1" get="accessor" set="accessor"><c path="Array"><t path="hxsl.Vec"/></c></poissonDiskLow>
		<poissonDiskLow__ expr="new Array()">
			<c path="Array"><t path="hxsl.Vec"/></c>
			<meta>
				<m n=":value"><e>new Array()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</poissonDiskLow__>
		<get_poissonDiskLow get="inline" set="null" line="5">
			<f a=""><c path="Array"><t path="hxsl.Vec"/></c></f>
			<meta><m n=":noCompletion"/></meta>
		</get_poissonDiskLow>
		<set_poissonDiskLow get="inline" set="null" line="5">
			<f a="_v">
				<c path="Array"><t path="hxsl.Vec"/></c>
				<c path="Array"><t path="hxsl.Vec"/></c>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_poissonDiskLow>
		<poissonDiskHigh public="1" get="accessor" set="accessor"><c path="Array"><t path="hxsl.Vec"/></c></poissonDiskHigh>
		<poissonDiskHigh__ expr="new Array()">
			<c path="Array"><t path="hxsl.Vec"/></c>
			<meta>
				<m n=":value"><e>new Array()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</poissonDiskHigh__>
		<get_poissonDiskHigh get="inline" set="null" line="5">
			<f a=""><c path="Array"><t path="hxsl.Vec"/></c></f>
			<meta><m n=":noCompletion"/></meta>
		</get_poissonDiskHigh>
		<set_poissonDiskHigh get="inline" set="null" line="5">
			<f a="_v">
				<c path="Array"><t path="hxsl.Vec"/></c>
				<c path="Array"><t path="hxsl.Vec"/></c>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_poissonDiskHigh>
		<poissonDiskVeryHigh public="1" get="accessor" set="accessor"><c path="Array"><t path="hxsl.Vec"/></c></poissonDiskVeryHigh>
		<poissonDiskVeryHigh__ expr="new Array()">
			<c path="Array"><t path="hxsl.Vec"/></c>
			<meta>
				<m n=":value"><e>new Array()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</poissonDiskVeryHigh__>
		<get_poissonDiskVeryHigh get="inline" set="null" line="5">
			<f a=""><c path="Array"><t path="hxsl.Vec"/></c></f>
			<meta><m n=":noCompletion"/></meta>
		</get_poissonDiskVeryHigh>
		<set_poissonDiskVeryHigh get="inline" set="null" line="5">
			<f a="_v">
				<c path="Array"><t path="hxsl.Vec"/></c>
				<c path="Array"><t path="hxsl.Vec"/></c>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_poissonDiskVeryHigh>
		<updateConstants public="1" set="method" line="5" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="5" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="93"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":src"><e><![CDATA[{
	@const var enable:Bool;
	@const var USE_ESM:Bool;
	@param var shadowPower:Float;
	@const var USE_PCF:Bool;
	@const var pcfQuality:Int;
	@param var pcfScale:Float;
	@param var shadowRes:Vec2;
	@param var shadowMap:Channel;
	@param var shadowProj:Mat3x4;
	@param var shadowBias:Float;
	var transformedPosition:Vec3;
	var shadow:Float;
	var dirShadow:Float;
	@param var poissonDiskLow:Array<Vec4,4>;
	@param var poissonDiskHigh:Array<Vec4,12>;
	@param var poissonDiskVeryHigh:Array<Vec4,64>;
	function rand(v:Float):Float {
		var dp = dot(vec4(v), vec4(12.9898, 78.233, 45.164, 94.673));
		return fract(sin(dp) * 43758.5453);
	};
	function fragment() {
		if (enable) {
			if (USE_PCF) {
				shadow = 1.0;
				var texelSize = 1.0 / shadowRes;
				var shadowPos = transformedPosition * shadowProj;
				var shadowUv = screenToUv(shadowPos.xy);
				var zMax = shadowPos.z.saturate();
				var rot = rand(transformedPosition.x + transformedPosition.y + transformedPosition.z) * 3.14 * 2;
				switch (pcfQuality) {
					case 1:
						var sampleStrength = 1.0 / 4.0;
						for (i  in  0 ... 4) {
							var offset = poissonDiskLow[i].xy * texelSize * pcfScale;
							offset = vec2(cos(rot) * offset.x - sin(rot) * offset.y, cos(rot) * offset.y + sin(rot) * offset.x);
							var depth = shadowMap.getLod(shadowUv + offset, 0);
							if (zMax - shadowBias > depth) shadow -= sampleStrength;
						};					
					case 2:
						var sampleStrength = 1.0 / 12.0;
						for (i  in  0 ... 12) {
							var offset = poissonDiskHigh[i].xy * texelSize * pcfScale;
							offset = vec2(cos(rot) * offset.x - sin(rot) * offset.y, cos(rot) * offset.y + sin(rot) * offset.x);
							var depth = shadowMap.getLod(shadowUv + offset, 0);
							if (zMax - shadowBias > depth) shadow -= sampleStrength;
						};					
					case 3:
						var sampleStrength = 1.0 / 64.0;
						for (i  in  0 ... 64) {
							var offset = poissonDiskVeryHigh[i].xy * texelSize * pcfScale;
							offset = vec2(cos(rot) * offset.x - sin(rot) * offset.y, cos(rot) * offset.y + sin(rot) * offset.x);
							var depth = shadowMap.getLod(shadowUv + offset, 0);
							if (zMax - shadowBias > depth) shadow -= sampleStrength;
						};					
				};
			} else if (USE_ESM) {
				var shadowPos = transformedPosition * shadowProj;
				var depth = shadowMap.get(screenToUv(shadowPos.xy));
				var zMax = shadowPos.z.saturate();
				var delta = (depth + shadowBias).min(zMax) - zMax;
				shadow = exp(shadowPower * delta).saturate();
			} else {
				var shadowPos = transformedPosition * shadowProj;
				var shadowUv = screenToUv(shadowPos.xy);
				var depth = shadowMap.get(shadowUv.xy);
				shadow = shadowPos.z - shadowBias > depth ? 0 : 1;
			};
		};
		dirShadow = shadow;
	};
}]]></e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="h3d.shader.GenTexture" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/shader/GenTexture.hx">
		<extends path="h3d.shader.ScreenShader"/>
		<SRC expr="&quot;HXSLFWgzZC5zaGFkZXIuR2VuVGV4dHVyZQoBBWlucHV0DQECAghwb3NpdGlvbgUKAQEAAwJ1dgUKAQEAAQAABAVmbGlwWQMCAAAFBm91dHB1dA0CAgYIcG9zaXRpb24FDAQFAAcFY29sb3IFDAQFAAQAAAgKcGl4ZWxDb2xvcgUMBAAACQxjYWxjdWxhdGVkVVYFCgQAAAoEbW9kZQECAAEAAAAAAAsFY29sb3IFDAIAAAwIX19pbml0X18OBgAADQZ2ZXJ0ZXgOBgAADghmcmFnbWVudA4GAAADAgwAAAUCBgQCBwUMAggFDAUMBgQCCQUKAgMFCgUKAAANAAAFAQYEAgYFDAkDKg4ECgICBQoAAAMGAQoCAgUKBAADAgQDAwEDAAAAAAAAAAADAQMAAAAAAADwPwMFDAUMAAEOAAAFARMEAgoBAQEBAQIAAAAAAQUBBgQCCAUMCwYHCQMbDgEKAgYFDBEABQoDAQMAAAAAAADwPwMCCQMqDgEBAwAAAAAAAAAAAwUMAgsFDAUMBQwAAAAA&quot;" line="5" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"HXSLFWgzZC5zaGFkZXIuR2VuVGV4dHVyZQoBBWlucHV0DQECAghwb3NpdGlvbgUKAQEAAwJ1dgUKAQEAAQAABAVmbGlwWQMCAAAFBm91dHB1dA0CAgYIcG9zaXRpb24FDAQFAAcFY29sb3IFDAQFAAQAAAgKcGl4ZWxDb2xvcgUMBAAACQxjYWxjdWxhdGVkVVYFCgQAAAoEbW9kZQECAAEAAAAAAAsFY29sb3IFDAIAAAwIX19pbml0X18OBgAADQZ2ZXJ0ZXgOBgAADghmcmFnbWVudA4GAAADAgwAAAUCBgQCBwUMAggFDAUMBgQCCQUKAgMFCgUKAAANAAAFAQYEAgYFDAkDKg4ECgICBQoAAAMGAQoCAgUKBAADAgQDAwEDAAAAAAAAAAADAQMAAAAAAADwPwMFDAUMAAEOAAAFARMEAgoBAQEBAQIAAAAAAQUBBgQCCAUMCwYHCQMbDgEKAgYFDBEABQoDAQMAAAAAAADwPwMCCQMqDgEBAwAAAAAAAAAAAwUMAgsFDAUMBQwAAAAA"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<mode public="1" get="accessor" set="accessor"><x path="Int"/></mode>
		<mode__ expr="0">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":noCompletion"/>
			</meta>
		</mode__>
		<get_mode get="inline" set="null" line="5">
			<f a=""><x path="Int"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_mode>
		<set_mode get="inline" set="null" line="5">
			<f a="_v">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_mode>
		<color public="1" get="accessor" set="accessor"><t path="hxsl.Vec"/></color>
		<color__ expr="new hxsl.Types.Vec()">
			<t path="hxsl.Vec"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Vec()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</color__>
		<get_color get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Vec"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_color>
		<set_color get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Vec"/>
				<t path="hxsl.Vec"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_color>
		<updateConstants public="1" set="method" line="5" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="5" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="3"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":src"><e><![CDATA[{
	@const var mode:Int;
	@param var color:Vec4;
	function fragment() {
		switch (mode) {
			case 0:
				pixelColor = output.position.xy.length() > 1 ? vec4(0.) : color;			
		};
	};
}]]></e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="h3d.shader.LineShader" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/shader/LineShader.hx">
		<extends path="hxsl.Shader"/>
		<SRC expr="&quot;HXSLFWgzZC5zaGFkZXIuTGluZVNoYWRlcgwBBmNhbWVyYQ0BAwIEdmlldwcAAQADBHByb2oHAAEABAh2aWV3UHJvagcAAQAAAAAFBmdsb2JhbA0CAgYJcGl4ZWxTaXplBQoABQAHCW1vZGVsVmlldwcABQEDAAAACAVpbnB1dA0DAwkIcG9zaXRpb24FCwEIAAoGbm9ybWFsBQsBCAALAnV2BQoBCAABAAAMBm91dHB1dA0EAQ0IcG9zaXRpb24FDAQMAAQAAA4RdHJhbnNmb3JtZWROb3JtYWwFCwQAAA8TdHJhbnNmb3JtZWRQb3NpdGlvbgULBAAAEBFwcm9qZWN0ZWRQb3NpdGlvbgUMBAAAEQtsZW5ndGhTY2FsZQMCAAASBXdpZHRoAwIAABMEcGRpcgUMBAAAFAhfX2luaXRfXw4GAAAVBnZlcnRleA4GAAACAhQAAAUBBQUIFgNkaXIFCwQAAAYBAgoFCwkDMg4BAgcHBgULAAYEAhMFDAYBCQMqDgIGAQIWBQsJAzIOAQICBwYFCwEDAAAAAAAA8D8DBQwCAwcFDAUMBoEKAhMFDBEABQoGAgEDAAAAAAAA8D8DCQMNDgEGAAYBCgITBQwAAAMKAhMFDAAAAwMGAQoCEwUMBAADCgITBQwEAAMDAwMDBQoGgAIPBQsGAQYBAhYFCwoCCwUKAAADBQsCEQMFCwULBgQCDgULCQMfDgECFgULBQsFCwAAABUAAAUBBoAKAhAFDBEABQoGAQYBBgEGAQQGAQoCEwUMBQAFCgkDKA4CAQMAAAAAAADwPwMBAwAAAAAAAPC/AwUKBQoFCgQGAwoCCwUKBAADAQMAAAAAAADgPwMDAwUKCgIQBQwIAAMFCgIGBQoFCgISAwUKBQoA&quot;" line="5" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"HXSLFWgzZC5zaGFkZXIuTGluZVNoYWRlcgwBBmNhbWVyYQ0BAwIEdmlldwcAAQADBHByb2oHAAEABAh2aWV3UHJvagcAAQAAAAAFBmdsb2JhbA0CAgYJcGl4ZWxTaXplBQoABQAHCW1vZGVsVmlldwcABQEDAAAACAVpbnB1dA0DAwkIcG9zaXRpb24FCwEIAAoGbm9ybWFsBQsBCAALAnV2BQoBCAABAAAMBm91dHB1dA0EAQ0IcG9zaXRpb24FDAQMAAQAAA4RdHJhbnNmb3JtZWROb3JtYWwFCwQAAA8TdHJhbnNmb3JtZWRQb3NpdGlvbgULBAAAEBFwcm9qZWN0ZWRQb3NpdGlvbgUMBAAAEQtsZW5ndGhTY2FsZQMCAAASBXdpZHRoAwIAABMEcGRpcgUMBAAAFAhfX2luaXRfXw4GAAAVBnZlcnRleA4GAAACAhQAAAUBBQUIFgNkaXIFCwQAAAYBAgoFCwkDMg4BAgcHBgULAAYEAhMFDAYBCQMqDgIGAQIWBQsJAzIOAQICBwYFCwEDAAAAAAAA8D8DBQwCAwcFDAUMBoEKAhMFDBEABQoGAgEDAAAAAAAA8D8DCQMNDgEGAAYBCgITBQwAAAMKAhMFDAAAAwMGAQoCEwUMBAADCgITBQwEAAMDAwMDBQoGgAIPBQsGAQYBAhYFCwoCCwUKAAADBQsCEQMFCwULBgQCDgULCQMfDgECFgULBQsFCwAAABUAAAUBBoAKAhAFDBEABQoGAQYBBgEGAQQGAQoCEwUMBQAFCgkDKA4CAQMAAAAAAADwPwMBAwAAAAAAAPC/AwUKBQoFCgQGAwoCCwUKBAADAQMAAAAAAADgPwMDAwUKCgIQBQwIAAMFCgIGBQoFCgISAwUKBQoA"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<lengthScale public="1" get="accessor" set="accessor"><x path="Float"/></lengthScale>
		<lengthScale__ expr="0">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":noCompletion"/>
			</meta>
		</lengthScale__>
		<get_lengthScale get="inline" set="null" line="5">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_lengthScale>
		<set_lengthScale get="inline" set="null" line="5">
			<f a="_v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_lengthScale>
		<width public="1" get="accessor" set="accessor"><x path="Float"/></width>
		<width__ expr="0">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":noCompletion"/>
			</meta>
		</width__>
		<get_width get="inline" set="null" line="5">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_width>
		<set_width get="inline" set="null" line="5">
			<f a="_v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_width>
		<updateConstants public="1" set="method" line="5" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="5" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="53">
			<f a="?width:?lengthScale" v="1.5:1.">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ lengthScale : 1., width : 1.5 }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":src"><e>{
	@global var camera:{ var view : Mat4; var proj : Mat4; var viewProj : Mat4};
	@global var global:{ var pixelSize : Vec2; @perObject};
	@input var input:{ var position : Vec3; var normal : Vec3; var uv : Vec2};
	var output:{ var position : Vec4};
	var transformedNormal:Vec3;
	var transformedPosition:Vec3;
	var projectedPosition:Vec4;
	@param var lengthScale:Float;
	@param var width:Float;
	var pdir:Vec4;
	function __init__() {
		{
			var dir = input.normal * global.modelView.mat3();
			pdir = vec4(dir * mat3(camera.view), 1) * camera.proj;
			pdir.xy *= 1 / sqrt(pdir.x * pdir.x + pdir.y * pdir.y);
			transformedPosition += dir * input.uv.x * lengthScale;
			transformedNormal = dir.normalize();
		};
	};
	function vertex() {
		projectedPosition.xy += (pdir.yx * vec2(1, -1)) * (input.uv.y - 0.5) * projectedPosition.z * global.pixelSize * width;
	};
}</e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="h3d.shader.MinMaxShader" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/shader/MinMaxShader.hx">
		<extends path="h3d.shader.ScreenShader"/>
		<SRC expr="&quot;HXSLF2gzZC5zaGFkZXIuTWluTWF4U2hhZGVyCwEFaW5wdXQNAQICCHBvc2l0aW9uBQoBAQADAnV2BQoBAQABAAAEBWZsaXBZAwIAAAUGb3V0cHV0DQICBghwb3NpdGlvbgUMBAUABwVjb2xvcgUMBAUABAAACApwaXhlbENvbG9yBQwEAAAJDGNhbGN1bGF0ZWRVVgUKBAAACgR0ZXhBCgIAAAsEdGV4QgoCAAAMBWlzTWF4AgIAAQAAAAAADQhfX2luaXRfXw4GAAAOBnZlcnRleA4GAAAPCGZyYWdtZW50DgYAAAMCDQAABQIGBAIHBQwCCAUMBQwGBAIJBQoCAwUKBQoAAA4AAAUBBgQCBgUMCQMqDgQKAgIFCgAAAwYBCgICBQoEAAMCBAMDAQMAAAAAAAAAAAMBAwAAAAAAAPA/AwUMBQwAAQ8AAAUDCBABYQUMBAAACQMhDgICCgoCCQUKBQwACBEBYgUMBAAACQMhDgICCwoCCQUKBQwABgQCCAUMCwIMAgkDFg4CAhAFDAIRBQwFDAkDFQ4CAhAFDAIRBQwFDAUMBQwA&quot;" line="5" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"HXSLF2gzZC5zaGFkZXIuTWluTWF4U2hhZGVyCwEFaW5wdXQNAQICCHBvc2l0aW9uBQoBAQADAnV2BQoBAQABAAAEBWZsaXBZAwIAAAUGb3V0cHV0DQICBghwb3NpdGlvbgUMBAUABwVjb2xvcgUMBAUABAAACApwaXhlbENvbG9yBQwEAAAJDGNhbGN1bGF0ZWRVVgUKBAAACgR0ZXhBCgIAAAsEdGV4QgoCAAAMBWlzTWF4AgIAAQAAAAAADQhfX2luaXRfXw4GAAAOBnZlcnRleA4GAAAPCGZyYWdtZW50DgYAAAMCDQAABQIGBAIHBQwCCAUMBQwGBAIJBQoCAwUKBQoAAA4AAAUBBgQCBgUMCQMqDgQKAgIFCgAAAwYBCgICBQoEAAMCBAMDAQMAAAAAAAAAAAMBAwAAAAAAAPA/AwUMBQwAAQ8AAAUDCBABYQUMBAAACQMhDgICCgoCCQUKBQwACBEBYgUMBAAACQMhDgICCwoCCQUKBQwABgQCCAUMCwIMAgkDFg4CAhAFDAIRBQwFDAkDFQ4CAhAFDAIRBQwFDAUMBQwA"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<texA public="1" get="accessor" set="accessor"><t path="hxsl.Sampler2D"/></texA>
		<texA__>
			<t path="hxsl.Sampler2D"/>
			<meta><m n=":noCompletion"/></meta>
		</texA__>
		<get_texA get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Sampler2D"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_texA>
		<set_texA get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Sampler2D"/>
				<t path="hxsl.Sampler2D"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_texA>
		<texB public="1" get="accessor" set="accessor"><t path="hxsl.Sampler2D"/></texB>
		<texB__>
			<t path="hxsl.Sampler2D"/>
			<meta><m n=":noCompletion"/></meta>
		</texB__>
		<get_texB get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Sampler2D"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_texB>
		<set_texB get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Sampler2D"/>
				<t path="hxsl.Sampler2D"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_texB>
		<isMax public="1" get="accessor" set="accessor"><x path="Bool"/></isMax>
		<isMax__>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</isMax__>
		<get_isMax get="inline" set="null" line="5">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_isMax>
		<set_isMax get="inline" set="null" line="5">
			<f a="_v">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_isMax>
		<updateConstants public="1" set="method" line="5" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="5" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="3"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":src"><e>{
	@param var texA:Sampler2D;
	@param var texB:Sampler2D;
	@const var isMax:Bool;
	function fragment() {
		var a = texA.get(calculatedUV);
		var b = texB.get(calculatedUV);
		pixelColor = isMax ? max(a, b) : min(a, b);
	};
}</e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="h3d.shader.CubeMinMaxShader" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/shader/MinMaxShader.hx" module="h3d.shader.MinMaxShader">
		<extends path="h3d.shader.ScreenShader"/>
		<SRC expr="&quot;HXSLG2gzZC5zaGFkZXIuQ3ViZU1pbk1heFNoYWRlcgwBBWlucHV0DQECAghwb3NpdGlvbgUKAQEAAwJ1dgUKAQEAAQAABAVmbGlwWQMCAAAFBm91dHB1dA0CAgYIcG9zaXRpb24FDAQFAAcFY29sb3IFDAQFAAQAAAgKcGl4ZWxDb2xvcgUMBAAACQxjYWxjdWxhdGVkVVYFCgQAAAoEdGV4QQwCAAALBHRleEIMAgAADAVpc01heAICAAEAAAAAAA0DbWF0BgIAAA4IX19pbml0X18OBgAADwZ2ZXJ0ZXgOBgAAEAhmcmFnbWVudA4GAAADAg4AAAUCBgQCBwUMAggFDAUMBgQCCQUKAgMFCgUKAAAPAAAFAQYEAgYFDAkDKg4ECgICBQoAAAMGAQoCAgUKBAADAgQDAwEDAAAAAAAAAAADAQMAAAAAAADwPwMFDAUMAAEQAAAFBQgRAnV2BQoEAAAGAwYBAgkFCgEDAAAAAAAAAEADBQoBAwAAAAAAAPA/AwUKAAgSA2RpcgULBAAABgEJAykOAgIRBQoBAwAAAAAAAPA/AwULAg0GBQsACBMBYQUMBAAACQMhDgICCgwCEgULBQwACBQBYgUMBAAACQMhDgICCwwCEgULBQwABgQCCAUMCwIMAgkDFg4CAhMFDAIUBQwFDAkDFQ4CAhMFDAIUBQwFDAUMBQwA&quot;" line="21" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"HXSLG2gzZC5zaGFkZXIuQ3ViZU1pbk1heFNoYWRlcgwBBWlucHV0DQECAghwb3NpdGlvbgUKAQEAAwJ1dgUKAQEAAQAABAVmbGlwWQMCAAAFBm91dHB1dA0CAgYIcG9zaXRpb24FDAQFAAcFY29sb3IFDAQFAAQAAAgKcGl4ZWxDb2xvcgUMBAAACQxjYWxjdWxhdGVkVVYFCgQAAAoEdGV4QQwCAAALBHRleEIMAgAADAVpc01heAICAAEAAAAAAA0DbWF0BgIAAA4IX19pbml0X18OBgAADwZ2ZXJ0ZXgOBgAAEAhmcmFnbWVudA4GAAADAg4AAAUCBgQCBwUMAggFDAUMBgQCCQUKAgMFCgUKAAAPAAAFAQYEAgYFDAkDKg4ECgICBQoAAAMGAQoCAgUKBAADAgQDAwEDAAAAAAAAAAADAQMAAAAAAADwPwMFDAUMAAEQAAAFBQgRAnV2BQoEAAAGAwYBAgkFCgEDAAAAAAAAAEADBQoBAwAAAAAAAPA/AwUKAAgSA2RpcgULBAAABgEJAykOAgIRBQoBAwAAAAAAAPA/AwULAg0GBQsACBMBYQUMBAAACQMhDgICCgwCEgULBQwACBQBYgUMBAAACQMhDgICCwwCEgULBQwABgQCCAUMCwIMAgkDFg4CAhMFDAIUBQwFDAkDFQ4CAhMFDAIUBQwFDAUMBQwA"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<texA public="1" get="accessor" set="accessor"><t path="hxsl.SamplerCube"/></texA>
		<texA__>
			<t path="hxsl.SamplerCube"/>
			<meta><m n=":noCompletion"/></meta>
		</texA__>
		<get_texA get="inline" set="null" line="21">
			<f a=""><t path="hxsl.SamplerCube"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_texA>
		<set_texA get="inline" set="null" line="21">
			<f a="_v">
				<t path="hxsl.SamplerCube"/>
				<t path="hxsl.SamplerCube"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_texA>
		<texB public="1" get="accessor" set="accessor"><t path="hxsl.SamplerCube"/></texB>
		<texB__>
			<t path="hxsl.SamplerCube"/>
			<meta><m n=":noCompletion"/></meta>
		</texB__>
		<get_texB get="inline" set="null" line="21">
			<f a=""><t path="hxsl.SamplerCube"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_texB>
		<set_texB get="inline" set="null" line="21">
			<f a="_v">
				<t path="hxsl.SamplerCube"/>
				<t path="hxsl.SamplerCube"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_texB>
		<isMax public="1" get="accessor" set="accessor"><x path="Bool"/></isMax>
		<isMax__>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</isMax__>
		<get_isMax get="inline" set="null" line="21">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_isMax>
		<set_isMax get="inline" set="null" line="21">
			<f a="_v">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_isMax>
		<mat public="1" get="accessor" set="accessor"><t path="hxsl.Matrix"/></mat>
		<mat__ expr="new hxsl.Types.Matrix()">
			<t path="hxsl.Matrix"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Matrix()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</mat__>
		<get_mat get="inline" set="null" line="21">
			<f a=""><t path="hxsl.Matrix"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_mat>
		<set_mat get="inline" set="null" line="21">
			<f a="_v">
				<t path="hxsl.Matrix"/>
				<t path="hxsl.Matrix"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_mat>
		<updateConstants public="1" set="method" line="21" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="21" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="21" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="21" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="19"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":src"><e>{
	@param var texA:SamplerCube;
	@param var texB:SamplerCube;
	@const var isMax:Bool;
	@param var mat:Mat3;
	function fragment() {
		var uv = calculatedUV * 2.0 - 1.0;
		var dir = vec3(uv, 1) * mat;
		var a = texA.get(dir);
		var b = texB.get(dir);
		pixelColor = isMax ? max(a, b) : min(a, b);
	};
}</e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="h3d.shader.NormalMap" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/shader/NormalMap.hx">
		<extends path="hxsl.Shader"/>
		<SRC expr="&quot;HXSLFGgzZC5zaGFkZXIuTm9ybWFsTWFwCgEGY2FtZXJhDQECAghwb3NpdGlvbgULAAEAAwNkaXIFCwMBAAAAAAQGZ2xvYmFsDQIBBQltb2RlbFZpZXcHAAQBAwAAAAYFaW5wdXQNAwIHBm5vcm1hbAULAQYACAd0YW5nZW50BQsBBgABAAAJB3RleHR1cmUKAgAACgxjYWxjdWxhdGVkVVYFCgQAAAsTdHJhbnNmb3JtZWRQb3NpdGlvbgULBAAADBF0cmFuc2Zvcm1lZE5vcm1hbAULBAAADRJ0cmFuc2Zvcm1lZFRhbmdlbnQFDAMAAA4OX19pbml0X192ZXJ0ZXgOBgAADwhmcmFnbWVudA4GAAACAg4AAAUBBgQCDQUMCQMqDgIGAQIIBQsJAzIOAQIFBwYFCwsGBwkDHQ4CAggFCwIIBQsDAQMAAAAAAADgPwMCAQMAAAAAAADwPwMBAwAAAAAAAPC/AwMFDAUMAAEPAAAFBQgQAW4FCwQAAAIMBQsACBECbmYFCwQAAAkDOQ4BCQMhDgICCQoCCgUKBQwFCwAIEgR0YW5YBQsEAAAJAx8OAQoCDQUMkgAFCwULAAgTBHRhblkFCwQAAAYBCQMeDgICEAULAhIFCwULBwMKAg0FDAwAAwMFCwAGBAIMBQsJAx8OAQQGAAYABgEKAhEFCwAAAwISBQsFCwYBCgIRBQsEAAMCEwULBQsFCwYBCgIRBQsIAAMCEAULBQsFCwULBQsFCwA&quot;" line="5" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"HXSLFGgzZC5zaGFkZXIuTm9ybWFsTWFwCgEGY2FtZXJhDQECAghwb3NpdGlvbgULAAEAAwNkaXIFCwMBAAAAAAQGZ2xvYmFsDQIBBQltb2RlbFZpZXcHAAQBAwAAAAYFaW5wdXQNAwIHBm5vcm1hbAULAQYACAd0YW5nZW50BQsBBgABAAAJB3RleHR1cmUKAgAACgxjYWxjdWxhdGVkVVYFCgQAAAsTdHJhbnNmb3JtZWRQb3NpdGlvbgULBAAADBF0cmFuc2Zvcm1lZE5vcm1hbAULBAAADRJ0cmFuc2Zvcm1lZFRhbmdlbnQFDAMAAA4OX19pbml0X192ZXJ0ZXgOBgAADwhmcmFnbWVudA4GAAACAg4AAAUBBgQCDQUMCQMqDgIGAQIIBQsJAzIOAQIFBwYFCwsGBwkDHQ4CAggFCwIIBQsDAQMAAAAAAADgPwMCAQMAAAAAAADwPwMBAwAAAAAAAPC/AwMFDAUMAAEPAAAFBQgQAW4FCwQAAAIMBQsACBECbmYFCwQAAAkDOQ4BCQMhDgICCQoCCgUKBQwFCwAIEgR0YW5YBQsEAAAJAx8OAQoCDQUMkgAFCwULAAgTBHRhblkFCwQAAAYBCQMeDgICEAULAhIFCwULBwMKAg0FDAwAAwMFCwAGBAIMBQsJAx8OAQQGAAYABgEKAhEFCwAAAwISBQsFCwYBCgIRBQsEAAMCEwULBQsFCwYBCgIRBQsIAAMCEAULBQsFCwULBQsFCwA"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<texture public="1" get="accessor" set="accessor"><t path="hxsl.Sampler2D"/></texture>
		<texture__>
			<t path="hxsl.Sampler2D"/>
			<meta><m n=":noCompletion"/></meta>
		</texture__>
		<get_texture get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Sampler2D"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_texture>
		<set_texture get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Sampler2D"/>
				<t path="hxsl.Sampler2D"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_texture>
		<updateConstants public="1" set="method" line="5" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="5" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="43"><f a="?texture">
	<t path="hxsl.Sampler2D"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":src"><e><![CDATA[{
	@global var camera:{ var position : Vec3; @var};
	@global var global:{ @perObject};
	@input var input:{ var normal : Vec3; var tangent : Vec3};
	@param var texture:Sampler2D;
	var calculatedUV:Vec2;
	var transformedPosition:Vec3;
	var transformedNormal:Vec3;
	@var var transformedTangent:Vec4;
	function __init__vertex() {
		transformedTangent = vec4(input.tangent * global.modelView.mat3(), input.tangent.dot(input.tangent) > 0.5 ? 1. : -1.);
	};
	function fragment() {
		var n = transformedNormal;
		var nf = unpackNormal(texture.get(calculatedUV));
		var tanX = transformedTangent.xyz.normalize();
		var tanY = n.cross(tanX) * -transformedTangent.w;
		transformedNormal = (nf.x * tanX + nf.y * tanY + nf.z * n).normalize();
	};
}]]></e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="h3d.shader.Shadow" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/shader/Shadow.hx">
		<extends path="hxsl.Shader"/>
		<SRC expr="&quot;HXSLEWgzZC5zaGFkZXIuU2hhZG93BgEGc2hhZG93DQEFAgNtYXARAQABAAMEcHJvaggAAQAEBWNvbG9yBQsAAQAFBXBvd2VyAwABAAYEYmlhcwMAAQAAAAAHCnBpeGVsQ29sb3IFDAQAAAgTdHJhbnNmb3JtZWRQb3NpdGlvbgULBAAACRhwaXhlbFRyYW5zZm9ybWVkUG9zaXRpb24FCwQAAAoJc2hhZG93UG9zBQsDAAEBCwhmcmFnbWVudA4GAAABAQsAAAUGCAwJc2hhZG93UG9zBQsEAAAGAQIJBQsCAwgFCwAIDQVkZXB0aAMEAAAJAz8OAgICEQEJAzoOAQoCDAULEQAFCgUKAwAIDgR6TWF4AwQAAAkDNQ4BCgIMBQsIAAMDAAgPBWRlbHRhAwQAAAYDCQMVDgIEBgACDQMCBgMDAwIOAwMCDgMDAAgQBXNoYWRlAwQAAAkDNQ4BCQMJDgEGAQIFAwIPAwMDAwAGgQoCBwUMkgAFCwYABgEEBgMBAwAAAAAAAPA/AwIQAwMDCgIEBQuSAAULBQsCEAMFCwULAA&quot;" line="5" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"HXSLEWgzZC5zaGFkZXIuU2hhZG93BgEGc2hhZG93DQEFAgNtYXARAQABAAMEcHJvaggAAQAEBWNvbG9yBQsAAQAFBXBvd2VyAwABAAYEYmlhcwMAAQAAAAAHCnBpeGVsQ29sb3IFDAQAAAgTdHJhbnNmb3JtZWRQb3NpdGlvbgULBAAACRhwaXhlbFRyYW5zZm9ybWVkUG9zaXRpb24FCwQAAAoJc2hhZG93UG9zBQsDAAEBCwhmcmFnbWVudA4GAAABAQsAAAUGCAwJc2hhZG93UG9zBQsEAAAGAQIJBQsCAwgFCwAIDQVkZXB0aAMEAAAJAz8OAgICEQEJAzoOAQoCDAULEQAFCgUKAwAIDgR6TWF4AwQAAAkDNQ4BCgIMBQsIAAMDAAgPBWRlbHRhAwQAAAYDCQMVDgIEBgACDQMCBgMDAwIOAwMCDgMDAAgQBXNoYWRlAwQAAAkDNQ4BCQMJDgEGAQIFAwIPAwMDAwAGgQoCBwUMkgAFCwYABgEEBgMBAwAAAAAAAPA/AwIQAwMDCgIEBQuSAAULBQsCEAMFCwULAA"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<updateConstants public="1" set="method" line="5" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<new public="1" set="method" line="28"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":src"><e>{
	@global var shadow:{ var map : Channel; var proj : Mat3x4; var color : Vec3; var power : Float; var bias : Float};
	var pixelColor:Vec4;
	var transformedPosition:Vec3;
	var pixelTransformedPosition:Vec3;
	@private var shadowPos:Vec3;
	function fragment() {
		var shadowPos = pixelTransformedPosition * shadow.proj;
		var depth = shadow.map.get(screenToUv(shadowPos.xy));
		var zMax = shadowPos.z.saturate();
		var delta = (depth + shadow.bias).min(zMax) - zMax;
		var shade = exp(shadow.power * delta).saturate();
		pixelColor.rgb *= (1 - shade) * shadow.color.rgb + shade;
	};
}</e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="h3d.shader.SignedDistanceField" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/shader/SignedDistanceField.hx">
		<extends path="hxsl.Shader"/>
		<SRC expr="&quot;HXSLHmgzZC5zaGFkZXIuU2lnbmVkRGlzdGFuY2VGaWVsZA4BBWlucHV0DQEDAghwb3NpdGlvbgUKAQEAAwJ1dgUKAQEABAVjb2xvcgUMAQEAAQAABQZvdXRwdXQNAgIGCHBvc2l0aW9uBQwEBQAHBWNvbG9yBQwEBQAEAAAIBHRpbWUDAAAACQ5zcHJpdGVQb3NpdGlvbgUMBAAAChBhYnNvbHV0ZVBvc2l0aW9uBQwEAAALCnBpeGVsQ29sb3IFDAQAAAwMdGV4dHVyZUNvbG9yBQwEAAANDGNhbGN1bGF0ZWRVVgUKAwAADg5vdXRwdXRQb3NpdGlvbgUMBAAADwdjaGFubmVsAQIAAQAAAAAAEAthbHBoYUN1dG9mZgMCAAARCXNtb290aGluZwMCAAASBm1lZGlhbg4GAAATCGZyYWdtZW50DgYAAAIDEgMUAXIDBAAAFQFnAwQAABYBYgMEAAADBQENCQMWDgIJAxUOAgIUAwIVAwMJAxUOAgkDFg4CAhQDAhUDAwIWAwMDAAABEwAABQQIFw10ZXh0dXJlU2FtcGxlBQwEAAACDAUMAAgYCGRpc3RhbmNlAwQAAAAABgQCGAMLBgUCDwEBAgAAAAABAgoCFwUMAAADCwYFAg8BAQIBAAAAAQIKAhcFDAQAAwsGBQIPAQECAgAAAAECCgIXBQwIAAMLBgUCDwEBAgMAAAABAgoCFwUMDAADCQISDgMKAhcFDAAAAwoCFwUMBAADCgIXBQwIAAMDAwMDAwMGBAIMBQwJAyoOBAEDAAAAAAAA8D8DAQMAAAAAAADwPwMBAwAAAAAAAPA/AwkDGg4DBgMCEAMCEQMDBgACEAMCEQMDAhgDAwUMBQwA&quot;" line="5" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"HXSLHmgzZC5zaGFkZXIuU2lnbmVkRGlzdGFuY2VGaWVsZA4BBWlucHV0DQEDAghwb3NpdGlvbgUKAQEAAwJ1dgUKAQEABAVjb2xvcgUMAQEAAQAABQZvdXRwdXQNAgIGCHBvc2l0aW9uBQwEBQAHBWNvbG9yBQwEBQAEAAAIBHRpbWUDAAAACQ5zcHJpdGVQb3NpdGlvbgUMBAAAChBhYnNvbHV0ZVBvc2l0aW9uBQwEAAALCnBpeGVsQ29sb3IFDAQAAAwMdGV4dHVyZUNvbG9yBQwEAAANDGNhbGN1bGF0ZWRVVgUKAwAADg5vdXRwdXRQb3NpdGlvbgUMBAAADwdjaGFubmVsAQIAAQAAAAAAEAthbHBoYUN1dG9mZgMCAAARCXNtb290aGluZwMCAAASBm1lZGlhbg4GAAATCGZyYWdtZW50DgYAAAIDEgMUAXIDBAAAFQFnAwQAABYBYgMEAAADBQENCQMWDgIJAxUOAgIUAwIVAwMJAxUOAgkDFg4CAhQDAhUDAwIWAwMDAAABEwAABQQIFw10ZXh0dXJlU2FtcGxlBQwEAAACDAUMAAgYCGRpc3RhbmNlAwQAAAAABgQCGAMLBgUCDwEBAgAAAAABAgoCFwUMAAADCwYFAg8BAQIBAAAAAQIKAhcFDAQAAwsGBQIPAQECAgAAAAECCgIXBQwIAAMLBgUCDwEBAgMAAAABAgoCFwUMDAADCQISDgMKAhcFDAAAAwoCFwUMBAADCgIXBQwIAAMDAwMDAwMGBAIMBQwJAyoOBAEDAAAAAAAA8D8DAQMAAAAAAADwPwMBAwAAAAAAAPA/AwkDGg4DBgMCEAMCEQMDBgACEAMCEQMDAhgDAwUMBQwA"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<channel public="1" get="accessor" set="accessor"><x path="Int"/></channel>
		<channel__ expr="0">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":noCompletion"/>
			</meta>
		</channel__>
		<get_channel get="inline" set="null" line="5">
			<f a=""><x path="Int"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_channel>
		<set_channel get="inline" set="null" line="5">
			<f a="_v">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_channel>
		<alphaCutoff public="1" get="accessor" set="accessor"><x path="Float"/></alphaCutoff>
		<alphaCutoff__ expr="0.5">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0.5</e></m>
				<m n=":noCompletion"/>
			</meta>
		</alphaCutoff__>
		<get_alphaCutoff get="inline" set="null" line="5">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_alphaCutoff>
		<set_alphaCutoff get="inline" set="null" line="5">
			<f a="_v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_alphaCutoff>
		<smoothing public="1" get="accessor" set="accessor"><x path="Float"/></smoothing>
		<smoothing__ expr="0.041666666666666664">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0.041666666666666664</e></m>
				<m n=":noCompletion"/>
			</meta>
		</smoothing__>
		<get_smoothing get="inline" set="null" line="5">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_smoothing>
		<set_smoothing get="inline" set="null" line="5">
			<f a="_v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_smoothing>
		<updateConstants public="1" set="method" line="5" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="5" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="3"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":src"><e>{
	@:import h3d.shader.Base2d;
	@const var channel:Int = 0;
	@param var alphaCutoff:Float = 0.5;
	@param var smoothing:Float = 0.04166666666666666666666666666667;
	function median(r:Float, g:Float, b:Float):Float {
		return max(min(r, g), min(max(r, g), b));
	};
	function fragment() {
		var textureSample:Vec4 = textureColor;
		var distance:Float;
		distance = if (channel == 0) textureSample.r else if (channel == 1) textureSample.g else if (channel == 2) textureSample.b else if (channel == 3) textureSample.a else median(textureSample.r, textureSample.g, textureSample.b);
		textureColor = vec4(1.0, 1.0, 1.0, smoothstep(alphaCutoff - smoothing, alphaCutoff + smoothing, distance));
	};
}</e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="h3d.shader.SkinBase" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/shader/SkinBase.hx">
		<extends path="hxsl.Shader"/>
		<SRC expr="&quot;HXSLE2gzZC5zaGFkZXIuU2tpbkJhc2UFARByZWxhdGl2ZVBvc2l0aW9uBQsEAAACE3RyYW5zZm9ybWVkUG9zaXRpb24FCwQAAAMRdHJhbnNmb3JtZWROb3JtYWwFCwQAAAQITWF4Qm9uZXMBAgABAAAAAAAFDWJvbmVzTWF0cml4ZXMPCAQCAAEIAA&quot;" line="5" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"HXSLE2gzZC5zaGFkZXIuU2tpbkJhc2UFARByZWxhdGl2ZVBvc2l0aW9uBQsEAAACE3RyYW5zZm9ybWVkUG9zaXRpb24FCwQAAAMRdHJhbnNmb3JtZWROb3JtYWwFCwQAAAQITWF4Qm9uZXMBAgABAAAAAAAFDWJvbmVzTWF0cml4ZXMPCAQCAAEIAA"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<MaxBones public="1" get="accessor" set="accessor"><x path="Int"/></MaxBones>
		<MaxBones__ expr="0">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":noCompletion"/>
			</meta>
		</MaxBones__>
		<get_MaxBones get="inline" set="null" line="5">
			<f a=""><x path="Int"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_MaxBones>
		<set_MaxBones get="inline" set="null" line="5">
			<f a="_v">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_MaxBones>
		<bonesMatrixes public="1" get="accessor" set="accessor"><c path="Array"><t path="hxsl.Matrix"/></c></bonesMatrixes>
		<bonesMatrixes__ expr="new Array()">
			<c path="Array"><t path="hxsl.Matrix"/></c>
			<meta>
				<m n=":value"><e>new Array()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</bonesMatrixes__>
		<get_bonesMatrixes get="inline" set="null" line="5">
			<f a=""><c path="Array"><t path="hxsl.Matrix"/></c></f>
			<meta><m n=":noCompletion"/></meta>
		</get_bonesMatrixes>
		<set_bonesMatrixes get="inline" set="null" line="5">
			<f a="_v">
				<c path="Array"><t path="hxsl.Matrix"/></c>
				<c path="Array"><t path="hxsl.Matrix"/></c>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_bonesMatrixes>
		<updateConstants public="1" set="method" line="5" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="5" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="16"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":src"><e><![CDATA[{
	var relativePosition:Vec3;
	var transformedPosition:Vec3;
	var transformedNormal:Vec3;
	@const var MaxBones:Int;
	@ignore @param var bonesMatrixes:Array<Mat3x4,MaxBones>;
}]]></e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="h3d.shader.Skin" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/shader/Skin.hx">
		<extends path="h3d.shader.SkinBase"/>
		<SRC expr="&quot;HXSLD2gzZC5zaGFkZXIuU2tpbggBEHJlbGF0aXZlUG9zaXRpb24FCwQAAAITdHJhbnNmb3JtZWRQb3NpdGlvbgULBAAAAxF0cmFuc2Zvcm1lZE5vcm1hbAULBAAABAhNYXhCb25lcwECAAEAAAAAAAUNYm9uZXNNYXRyaXhlcw8IBAIAAQgGBWlucHV0DQEEBwhwb3NpdGlvbgULAQYACAZub3JtYWwFCwEGAAkHd2VpZ2h0cwULAQYACgdpbmRleGVzCQQAAAABBgABAAALEnRyYW5zZm9ybWVkVGFuZ2VudAUMBAAADAZ2ZXJ0ZXgOBgAAAQAMAAAFAgYEAgIFCwYABgAGAQQGAQIBBQsRAgUPCAQKAgoJBAAAAAAAAQgFCwULCgIJBQsAAAMFCwYBBAYBAgEFCxECBQ8IBAoCCgkEAAAABAABCAULBQsKAgkFCwQAAwULBQsGAQQGAQIBBQsRAgUPCAQKAgoJBAAAAAgAAQgFCwULCgIJBQsIAAMFCwULBQsGBAIDBQsJAx8OAQYABgAGAQQGAQIIBQsJAzIOARECBQ8IBAoCCgkEAAAAAAABCAYFCwULCgIJBQsAAAMFCwYBBAYBAggFCwkDMg4BEQIFDwgECgIKCQQAAAAEAAEIBgULBQsKAgkFCwQAAwULBQsGAQQGAQIIBQsJAzIOARECBQ8IBAoCCgkEAAAACAABCAYFCwULCgIJBQsIAAMFCwULBQsFCwA&quot;" line="5" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"HXSLD2gzZC5zaGFkZXIuU2tpbggBEHJlbGF0aXZlUG9zaXRpb24FCwQAAAITdHJhbnNmb3JtZWRQb3NpdGlvbgULBAAAAxF0cmFuc2Zvcm1lZE5vcm1hbAULBAAABAhNYXhCb25lcwECAAEAAAAAAAUNYm9uZXNNYXRyaXhlcw8IBAIAAQgGBWlucHV0DQEEBwhwb3NpdGlvbgULAQYACAZub3JtYWwFCwEGAAkHd2VpZ2h0cwULAQYACgdpbmRleGVzCQQAAAABBgABAAALEnRyYW5zZm9ybWVkVGFuZ2VudAUMBAAADAZ2ZXJ0ZXgOBgAAAQAMAAAFAgYEAgIFCwYABgAGAQQGAQIBBQsRAgUPCAQKAgoJBAAAAAAAAQgFCwULCgIJBQsAAAMFCwYBBAYBAgEFCxECBQ8IBAoCCgkEAAAABAABCAULBQsKAgkFCwQAAwULBQsGAQQGAQIBBQsRAgUPCAQKAgoJBAAAAAgAAQgFCwULCgIJBQsIAAMFCwULBQsGBAIDBQsJAx8OAQYABgAGAQQGAQIIBQsJAzIOARECBQ8IBAoCCgkEAAAAAAABCAYFCwULCgIJBQsAAAMFCwYBBAYBAggFCwkDMg4BEQIFDwgECgIKCQQAAAAEAAEIBgULBQsKAgkFCwQAAwULBQsGAQQGAQIIBQsJAzIOARECBQ8IBAoCCgkEAAAACAABCAYFCwULCgIJBQsIAAMFCwULBQsFCwA"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<updateConstants public="1" set="method" line="5" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="5" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="3"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":src"><e>{
	@input var input:{ var position : Vec3; var normal : Vec3; var weights : Vec3; var indexes : Bytes4};
	var transformedTangent:Vec4;
	function vertex() {
		transformedPosition = (relativePosition * bonesMatrixes[input.indexes.x]) * input.weights.x + (relativePosition * bonesMatrixes[input.indexes.y]) * input.weights.y + (relativePosition * bonesMatrixes[input.indexes.z]) * input.weights.z;
		transformedNormal = normalize((input.normal * mat3(bonesMatrixes[input.indexes.x])) * input.weights.x + (input.normal * mat3(bonesMatrixes[input.indexes.y])) * input.weights.y + (input.normal * mat3(bonesMatrixes[input.indexes.z])) * input.weights.z);
	};
}</e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="h3d.shader.SkinTangent" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/shader/SkinTangent.hx">
		<extends path="h3d.shader.SkinBase"/>
		<SRC expr="&quot;HXSLFmgzZC5zaGFkZXIuU2tpblRhbmdlbnQIARByZWxhdGl2ZVBvc2l0aW9uBQsEAAACE3RyYW5zZm9ybWVkUG9zaXRpb24FCwQAAAMRdHJhbnNmb3JtZWROb3JtYWwFCwQAAAQITWF4Qm9uZXMBAgABAAAAAAAFDWJvbmVzTWF0cml4ZXMPCAQCAAEIBgVpbnB1dA0BBQcIcG9zaXRpb24FCwEGAAgGbm9ybWFsBQsBBgAJB3RhbmdlbnQFCwEGAAoHd2VpZ2h0cwULAQYACwdpbmRleGVzCQQAAAABBgABAAAMEnRyYW5zZm9ybWVkVGFuZ2VudAUMBAAADQZ2ZXJ0ZXgOBgAAAQANAAAFAwYEAgIFCwYABgAGAQQGAQIBBQsRAgUPCAQKAgsJBAAAAAAAAQgFCwULCgIKBQsAAAMFCwYBBAYBAgEFCxECBQ8IBAoCCwkEAAAABAABCAULBQsKAgoFCwQAAwULBQsGAQQGAQIBBQsRAgUPCAQKAgsJBAAAAAgAAQgFCwULCgIKBQsIAAMFCwULBQsGBAIDBQsJAx8OAQYABgAGAQQGAQIIBQsJAzIOARECBQ8IBAoCCwkEAAAAAAABCAYFCwULCgIKBQsAAAMFCwYBBAYBAggFCwkDMg4BEQIFDwgECgILCQQAAAAEAAEIBgULBQsKAgoFCwQAAwULBQsGAQQGAQIIBQsJAzIOARECBQ8IBAoCCwkEAAAACAABCAYFCwULCgIKBQsIAAMFCwULBQsFCwYEAgwFDAkDKg4CCQMfDgEGAAYABgEEBgEKAgkFC5IABQsJAzIOARECBQ8IBAoCCwkEAAAAAAABCAYFCwULCgIKBQsAAAMFCwYBBAYBCgIJBQuSAAULCQMyDgERAgUPCAQKAgsJBAAAAAQAAQgGBQsFCwoCCgULBAADBQsFCwYBBAYBCgIJBQuSAAULCQMyDgERAgUPCAQKAgsJBAAAAAgAAQgGBQsFCwoCCgULCAADBQsFCwULCgIMBQwMAAMFDAUMAA&quot;" line="5" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"HXSLFmgzZC5zaGFkZXIuU2tpblRhbmdlbnQIARByZWxhdGl2ZVBvc2l0aW9uBQsEAAACE3RyYW5zZm9ybWVkUG9zaXRpb24FCwQAAAMRdHJhbnNmb3JtZWROb3JtYWwFCwQAAAQITWF4Qm9uZXMBAgABAAAAAAAFDWJvbmVzTWF0cml4ZXMPCAQCAAEIBgVpbnB1dA0BBQcIcG9zaXRpb24FCwEGAAgGbm9ybWFsBQsBBgAJB3RhbmdlbnQFCwEGAAoHd2VpZ2h0cwULAQYACwdpbmRleGVzCQQAAAABBgABAAAMEnRyYW5zZm9ybWVkVGFuZ2VudAUMBAAADQZ2ZXJ0ZXgOBgAAAQANAAAFAwYEAgIFCwYABgAGAQQGAQIBBQsRAgUPCAQKAgsJBAAAAAAAAQgFCwULCgIKBQsAAAMFCwYBBAYBAgEFCxECBQ8IBAoCCwkEAAAABAABCAULBQsKAgoFCwQAAwULBQsGAQQGAQIBBQsRAgUPCAQKAgsJBAAAAAgAAQgFCwULCgIKBQsIAAMFCwULBQsGBAIDBQsJAx8OAQYABgAGAQQGAQIIBQsJAzIOARECBQ8IBAoCCwkEAAAAAAABCAYFCwULCgIKBQsAAAMFCwYBBAYBAggFCwkDMg4BEQIFDwgECgILCQQAAAAEAAEIBgULBQsKAgoFCwQAAwULBQsGAQQGAQIIBQsJAzIOARECBQ8IBAoCCwkEAAAACAABCAYFCwULCgIKBQsIAAMFCwULBQsFCwYEAgwFDAkDKg4CCQMfDgEGAAYABgEEBgEKAgkFC5IABQsJAzIOARECBQ8IBAoCCwkEAAAAAAABCAYFCwULCgIKBQsAAAMFCwYBBAYBCgIJBQuSAAULCQMyDgERAgUPCAQKAgsJBAAAAAQAAQgGBQsFCwoCCgULBAADBQsFCwYBBAYBCgIJBQuSAAULCQMyDgERAgUPCAQKAgsJBAAAAAgAAQgGBQsFCwoCCgULCAADBQsFCwULCgIMBQwMAAMFDAUMAA"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<updateConstants public="1" set="method" line="5" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="5" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="3"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":src"><e>{
	@input var input:{ var position : Vec3; var normal : Vec3; var tangent : Vec3; var weights : Vec3; var indexes : Bytes4};
	var transformedTangent:Vec4;
	function vertex() {
		transformedPosition = (relativePosition * bonesMatrixes[input.indexes.x]) * input.weights.x + (relativePosition * bonesMatrixes[input.indexes.y]) * input.weights.y + (relativePosition * bonesMatrixes[input.indexes.z]) * input.weights.z;
		transformedNormal = normalize((input.normal * mat3(bonesMatrixes[input.indexes.x])) * input.weights.x + (input.normal * mat3(bonesMatrixes[input.indexes.y])) * input.weights.y + (input.normal * mat3(bonesMatrixes[input.indexes.z])) * input.weights.z);
		transformedTangent = vec4(normalize((input.tangent.xyz * mat3(bonesMatrixes[input.indexes.x])) * input.weights.x + (input.tangent.xyz * mat3(bonesMatrixes[input.indexes.y])) * input.weights.y + (input.tangent.xyz * mat3(bonesMatrixes[input.indexes.z])) * input.weights.z), transformedTangent.w);
	};
}</e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="h3d.shader.SpecularTexture" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/shader/SpecularTexture.hx">
		<extends path="hxsl.Shader"/>
		<SRC expr="&quot;HXSLGmgzZC5zaGFkZXIuU3BlY3VsYXJUZXh0dXJlBAEHdGV4dHVyZQoCAAACDGNhbGN1bGF0ZWRVVgUKBAAAAwlzcGVjQ29sb3IFCwQAAAQIZnJhZ21lbnQOBgAAAQEEAAAFAQaBAgMFCwoJAyEOAgIBCgICBQoFDJIABQsFCwA&quot;" line="5" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"HXSLGmgzZC5zaGFkZXIuU3BlY3VsYXJUZXh0dXJlBAEHdGV4dHVyZQoCAAACDGNhbGN1bGF0ZWRVVgUKBAAAAwlzcGVjQ29sb3IFCwQAAAQIZnJhZ21lbnQOBgAAAQEEAAAFAQaBAgMFCwoJAyEOAgIBCgICBQoFDJIABQsFCwA"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<texture public="1" get="accessor" set="accessor"><t path="hxsl.Sampler2D"/></texture>
		<texture__>
			<t path="hxsl.Sampler2D"/>
			<meta><m n=":noCompletion"/></meta>
		</texture__>
		<get_texture get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Sampler2D"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_texture>
		<set_texture get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Sampler2D"/>
				<t path="hxsl.Sampler2D"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_texture>
		<updateConstants public="1" set="method" line="5" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="5" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="15"><f a="?tex">
	<t path="hxsl.Sampler2D"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":src"><e>{
	@param var texture:Sampler2D;
	var calculatedUV:Vec2;
	var specColor:Vec3;
	function fragment() {
		specColor *= texture.get(calculatedUV).rgb;
	};
}</e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="h3d.shader.Texture" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/shader/Texture.hx">
		<extends path="hxsl.Shader"/>
		<SRC expr="&quot;HXSLEmgzZC5zaGFkZXIuVGV4dHVyZQsBBWlucHV0DQEBAgJ1dgUKAQEAAQAAAwhhZGRpdGl2ZQICAAEAAAAAAAQJa2lsbEFscGhhAgIAAQAAAAAABQ1zcGVjdWxhckFscGhhAgIAAQAAAAAABhJraWxsQWxwaGFUaHJlc2hvbGQDAgABBwAAAAAAAAAAAAAAAAAA8D8HB3RleHR1cmUKAgAACAxjYWxjdWxhdGVkVVYFCgQAAAkKcGl4ZWxDb2xvcgUMBAAACglzcGVjQ29sb3IFCwQAAAsGdmVydGV4DgYAAAwIZnJhZ21lbnQOBgAAAgALAAAFAQYEAggFCgICBQoFCgABDAAABQQIDQFjBQwEAAAJAyEOAgIHCgIIBQoFDAALBg4CBAIGCQYDCgINBQwMAAMCBgMDAQMAAAAAAAAAAAMCAgwAAAALAgMCBoACCQUMAg0FDAUMBoECCQUMAg0FDAUMAAsCBQIGgQIKBQsKAg0FDP4ABQsFCwAAAA&quot;" line="5" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"HXSLEmgzZC5zaGFkZXIuVGV4dHVyZQsBBWlucHV0DQEBAgJ1dgUKAQEAAQAAAwhhZGRpdGl2ZQICAAEAAAAAAAQJa2lsbEFscGhhAgIAAQAAAAAABQ1zcGVjdWxhckFscGhhAgIAAQAAAAAABhJraWxsQWxwaGFUaHJlc2hvbGQDAgABBwAAAAAAAAAAAAAAAAAA8D8HB3RleHR1cmUKAgAACAxjYWxjdWxhdGVkVVYFCgQAAAkKcGl4ZWxDb2xvcgUMBAAACglzcGVjQ29sb3IFCwQAAAsGdmVydGV4DgYAAAwIZnJhZ21lbnQOBgAAAgALAAAFAQYEAggFCgICBQoFCgABDAAABQQIDQFjBQwEAAAJAyEOAgIHCgIIBQoFDAALBg4CBAIGCQYDCgINBQwMAAMCBgMDAQMAAAAAAAAAAAMCAgwAAAALAgMCBoACCQUMAg0FDAUMBoECCQUMAg0FDAUMAAsCBQIGgQIKBQsKAg0FDP4ABQsFCwAAAA"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<additive public="1" get="accessor" set="accessor"><x path="Bool"/></additive>
		<additive__>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</additive__>
		<get_additive get="inline" set="null" line="5">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_additive>
		<set_additive get="inline" set="null" line="5">
			<f a="_v">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_additive>
		<killAlpha public="1" get="accessor" set="accessor"><x path="Bool"/></killAlpha>
		<killAlpha__>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</killAlpha__>
		<get_killAlpha get="inline" set="null" line="5">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_killAlpha>
		<set_killAlpha get="inline" set="null" line="5">
			<f a="_v">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_killAlpha>
		<specularAlpha public="1" get="accessor" set="accessor"><x path="Bool"/></specularAlpha>
		<specularAlpha__>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</specularAlpha__>
		<get_specularAlpha get="inline" set="null" line="5">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_specularAlpha>
		<set_specularAlpha get="inline" set="null" line="5">
			<f a="_v">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_specularAlpha>
		<killAlphaThreshold public="1" get="accessor" set="accessor"><x path="Float"/></killAlphaThreshold>
		<killAlphaThreshold__ expr="0">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":noCompletion"/>
			</meta>
		</killAlphaThreshold__>
		<get_killAlphaThreshold get="inline" set="null" line="5">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_killAlphaThreshold>
		<set_killAlphaThreshold get="inline" set="null" line="5">
			<f a="_v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_killAlphaThreshold>
		<texture public="1" get="accessor" set="accessor"><t path="hxsl.Sampler2D"/></texture>
		<texture__>
			<t path="hxsl.Sampler2D"/>
			<meta><m n=":noCompletion"/></meta>
		</texture__>
		<get_texture get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Sampler2D"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_texture>
		<set_texture get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Sampler2D"/>
				<t path="hxsl.Sampler2D"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_texture>
		<updateConstants public="1" set="method" line="5" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="5" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="37"><f a="?tex">
	<t path="hxsl.Sampler2D"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":src"><e><![CDATA[{
	@input var input:{ var uv : Vec2};
	@const var additive:Bool;
	@const var killAlpha:Bool;
	@const var specularAlpha:Bool;
	@range(0, 1) @param var killAlphaThreshold:Float;
	@param var texture:Sampler2D;
	var calculatedUV:Vec2;
	var pixelColor:Vec4;
	var specColor:Vec3;
	function vertex() {
		calculatedUV = input.uv;
	};
	function fragment() {
		var c = texture.get(calculatedUV);
		if (killAlpha && c.a - killAlphaThreshold < 0) discard;
		if (additive) pixelColor += c else pixelColor *= c;
		if (specularAlpha) specColor *= c.aaa;
	};
}]]></e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="h3d.shader.UVDelta" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/shader/UVDelta.hx">
		<extends path="hxsl.Shader"/>
		<SRC expr="&quot;HXSLEmgzZC5zaGFkZXIuVVZEZWx0YQQBB3V2RGVsdGEFCgIAAAIHdXZTY2FsZQUKAgAAAwxjYWxjdWxhdGVkVVYFCgQAAAQGdmVydGV4DgYAAAEABAAABQEGBAIDBQoGAAYBAgMFCgICBQoFCgIBBQoFCgUKAA&quot;" line="5" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"HXSLEmgzZC5zaGFkZXIuVVZEZWx0YQQBB3V2RGVsdGEFCgIAAAIHdXZTY2FsZQUKAgAAAwxjYWxjdWxhdGVkVVYFCgQAAAQGdmVydGV4DgYAAAEABAAABQEGBAIDBQoGAAYBAgMFCgICBQoFCgIBBQoFCgUKAA"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<uvDelta public="1" get="accessor" set="accessor"><t path="hxsl.Vec"/></uvDelta>
		<uvDelta__ expr="new hxsl.Types.Vec()">
			<t path="hxsl.Vec"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Vec()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</uvDelta__>
		<get_uvDelta get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Vec"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_uvDelta>
		<set_uvDelta get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Vec"/>
				<t path="hxsl.Vec"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_uvDelta>
		<uvScale public="1" get="accessor" set="accessor"><t path="hxsl.Vec"/></uvScale>
		<uvScale__ expr="new hxsl.Types.Vec()">
			<t path="hxsl.Vec"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Vec()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</uvScale__>
		<get_uvScale get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Vec"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_uvScale>
		<set_uvScale get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Vec"/>
				<t path="hxsl.Vec"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_uvScale>
		<updateConstants public="1" set="method" line="5" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="5" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="14">
			<f a="?dx:?dy:?sx:?sy" v="0.:0.:1.:1.">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ sy : 1., sx : 1., dy : 0., dx : 0. }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":src"><e>{
	@param var uvDelta:Vec2;
	@param var uvScale:Vec2;
	var calculatedUV:Vec2;
	function vertex() {
		calculatedUV = calculatedUV * uvScale + uvDelta;
	};
}</e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="h3d.shader.VertexColorAlpha" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/shader/VertexColorAlpha.hx">
		<extends path="hxsl.Shader"/>
		<SRC expr="&quot;HXSLG2gzZC5zaGFkZXIuVmVydGV4Q29sb3JBbHBoYQQBBWlucHV0DQEBAgVjb2xvcgUMAQEAAQAAAwpwaXhlbENvbG9yBQwEAAAECGFkZGl0aXZlAgIAAQAAAAAABQhmcmFnbWVudA4GAAABAQUAAAUBCwIEAgaAAgMFDAICBQwFDAaBAgMFDAICBQwFDAAA&quot;" line="5" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"HXSLG2gzZC5zaGFkZXIuVmVydGV4Q29sb3JBbHBoYQQBBWlucHV0DQEBAgVjb2xvcgUMAQEAAQAAAwpwaXhlbENvbG9yBQwEAAAECGFkZGl0aXZlAgIAAQAAAAAABQhmcmFnbWVudA4GAAABAQUAAAUBCwIEAgaAAgMFDAICBQwFDAaBAgMFDAICBQwFDAAA"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<additive public="1" get="accessor" set="accessor"><x path="Bool"/></additive>
		<additive__>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</additive__>
		<get_additive get="inline" set="null" line="5">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_additive>
		<set_additive get="inline" set="null" line="5">
			<f a="_v">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_additive>
		<updateConstants public="1" set="method" line="5" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="5" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="3"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":src"><e>{
	@input var input:{ var color : Vec4};
	var pixelColor:Vec4;
	@const var additive:Bool;
	function fragment() {
		if (additive) pixelColor += input.color else pixelColor *= input.color;
	};
}</e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="h3d.shader.VolumeDecal" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/shader/VolumeDecal.hx">
		<extends path="hxsl.Shader"/>
		<SRC expr="&quot;HXSLFmgzZC5zaGFkZXIuVm9sdW1lRGVjYWwYAQZjYW1lcmENAQoCBHZpZXcHAAEAAwRwcm9qBwABAAQIcG9zaXRpb24FCwABAAUIcHJvakZsaXADAAEABghwcm9qRGlhZwULAAEABwh2aWV3UHJvagcAAQAID2ludmVyc2VWaWV3UHJvagcAAQAJBXpOZWFyAwABAAoEekZhcgMAAQALA2RpcgULAwEAAAAADAZnbG9iYWwNAgQNBHRpbWUDAAwADglwaXhlbFNpemUFCgAMAA8JbW9kZWxWaWV3BwAMAQMQEG1vZGVsVmlld0ludmVyc2UHAAwBAwAAABEFaW5wdXQNAwISCHBvc2l0aW9uBQsBEQATBm5vcm1hbAULAREAAQAAFAZvdXRwdXQNBAUVCHBvc2l0aW9uBQwEFAAWBWNvbG9yBQwEFAAXBWRlcHRoAwQUABgGbm9ybWFsBQsEFAAZCXdvcmxkRGlzdAMEFAAEAAAaEHJlbGF0aXZlUG9zaXRpb24FCwQAABsTdHJhbnNmb3JtZWRQb3NpdGlvbgULBAAAHBhwaXhlbFRyYW5zZm9ybWVkUG9zaXRpb24FCwQAAB0RdHJhbnNmb3JtZWROb3JtYWwFCwQAAB4RcHJvamVjdGVkUG9zaXRpb24FDAQAAB8KcGl4ZWxDb2xvcgUMBAAAIAVkZXB0aAMEAAAhCHNjcmVlblVWBQoEAAAiCXNwZWNQb3dlcgMEAAAjCXNwZWNDb2xvcgULBAAAJAl3b3JsZERpc3QDBAAAJQhkZXB0aE1hcBEBAAAAJgVzY2FsZQUKAgAAJwZub3JtYWwFCwIAACgHdGFuZ2VudAULAgAAKQppc0NlbnRlcmVkAgIAAQAAAAAAKgxjYWxjdWxhdGVkVVYFCgQAACsSdHJhbnNmb3JtZWRUYW5nZW50BQwEAAAsDl9faW5pdF9fdmVydGV4DgYAAC0IZnJhZ21lbnQOBgAAAgIsAAAFAgYEAh0FCwkDHw4BBAYBAicFCwkDMg4BAg8HBgULBQsFCwULBgQCKwUMCQMqDgIJAx8OAQQGAQIoBQsJAzIOAQIPBwYFCwULBQsBAwAAAAAAAPA/AwUMBQwAAS0AAAUJCC4GbWF0cml4BwQAAAYBAggHAhAHBwAILwlzY3JlZW5Qb3MFCgQAAAYCCgIeBQwRAAUKCgIeBQwMAAMFCgAIMANydXYFDAQAAAkDKg4DAi8FCgkDPw4CAiURAQkDOg4BAi8FCgUKAwEDAAAAAAAA8D8DBQwACDEEd3BvcwUMBAAABgECMAUMAi4HBQwACDIEcHBvcwUMBAAABgECMAUMAggHBQwABgQCHAULBgIKAjIFDJIABQsKAjIFDAwAAwULBQsGBAIqBQoGAQImBQoEBgIKAjEFDBEABQoKAjEFDAwAAwUKBQoFCgUKCwIpAgaAAioFCgEDAAAAAAAA4D8DBQoAAAsGCQkDFQ4CCQMVDgIKAioFCgAAAwoCKgUKBAADAwkDFQ4CBgMBAwAAAAAAAPA/AwoCKgUKAAADAwYDAQMAAAAAAADwPwMKAioFCgQAAwMDAwEDAAAAAAAAAAADAgwAAAAA&quot;" line="5" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"HXSLFmgzZC5zaGFkZXIuVm9sdW1lRGVjYWwYAQZjYW1lcmENAQoCBHZpZXcHAAEAAwRwcm9qBwABAAQIcG9zaXRpb24FCwABAAUIcHJvakZsaXADAAEABghwcm9qRGlhZwULAAEABwh2aWV3UHJvagcAAQAID2ludmVyc2VWaWV3UHJvagcAAQAJBXpOZWFyAwABAAoEekZhcgMAAQALA2RpcgULAwEAAAAADAZnbG9iYWwNAgQNBHRpbWUDAAwADglwaXhlbFNpemUFCgAMAA8JbW9kZWxWaWV3BwAMAQMQEG1vZGVsVmlld0ludmVyc2UHAAwBAwAAABEFaW5wdXQNAwISCHBvc2l0aW9uBQsBEQATBm5vcm1hbAULAREAAQAAFAZvdXRwdXQNBAUVCHBvc2l0aW9uBQwEFAAWBWNvbG9yBQwEFAAXBWRlcHRoAwQUABgGbm9ybWFsBQsEFAAZCXdvcmxkRGlzdAMEFAAEAAAaEHJlbGF0aXZlUG9zaXRpb24FCwQAABsTdHJhbnNmb3JtZWRQb3NpdGlvbgULBAAAHBhwaXhlbFRyYW5zZm9ybWVkUG9zaXRpb24FCwQAAB0RdHJhbnNmb3JtZWROb3JtYWwFCwQAAB4RcHJvamVjdGVkUG9zaXRpb24FDAQAAB8KcGl4ZWxDb2xvcgUMBAAAIAVkZXB0aAMEAAAhCHNjcmVlblVWBQoEAAAiCXNwZWNQb3dlcgMEAAAjCXNwZWNDb2xvcgULBAAAJAl3b3JsZERpc3QDBAAAJQhkZXB0aE1hcBEBAAAAJgVzY2FsZQUKAgAAJwZub3JtYWwFCwIAACgHdGFuZ2VudAULAgAAKQppc0NlbnRlcmVkAgIAAQAAAAAAKgxjYWxjdWxhdGVkVVYFCgQAACsSdHJhbnNmb3JtZWRUYW5nZW50BQwEAAAsDl9faW5pdF9fdmVydGV4DgYAAC0IZnJhZ21lbnQOBgAAAgIsAAAFAgYEAh0FCwkDHw4BBAYBAicFCwkDMg4BAg8HBgULBQsFCwULBgQCKwUMCQMqDgIJAx8OAQQGAQIoBQsJAzIOAQIPBwYFCwULBQsBAwAAAAAAAPA/AwUMBQwAAS0AAAUJCC4GbWF0cml4BwQAAAYBAggHAhAHBwAILwlzY3JlZW5Qb3MFCgQAAAYCCgIeBQwRAAUKCgIeBQwMAAMFCgAIMANydXYFDAQAAAkDKg4DAi8FCgkDPw4CAiURAQkDOg4BAi8FCgUKAwEDAAAAAAAA8D8DBQwACDEEd3BvcwUMBAAABgECMAUMAi4HBQwACDIEcHBvcwUMBAAABgECMAUMAggHBQwABgQCHAULBgIKAjIFDJIABQsKAjIFDAwAAwULBQsGBAIqBQoGAQImBQoEBgIKAjEFDBEABQoKAjEFDAwAAwUKBQoFCgUKCwIpAgaAAioFCgEDAAAAAAAA4D8DBQoAAAsGCQkDFQ4CCQMVDgIKAioFCgAAAwoCKgUKBAADAwkDFQ4CBgMBAwAAAAAAAPA/AwoCKgUKAAADAwYDAQMAAAAAAADwPwMKAioFCgQAAwMDAwEDAAAAAAAAAAADAgwAAAAA"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<scale public="1" get="accessor" set="accessor"><t path="hxsl.Vec"/></scale>
		<scale__ expr="new hxsl.Types.Vec()">
			<t path="hxsl.Vec"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Vec()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</scale__>
		<get_scale get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Vec"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_scale>
		<set_scale get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Vec"/>
				<t path="hxsl.Vec"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_scale>
		<normal public="1" get="accessor" set="accessor"><t path="hxsl.Vec"/></normal>
		<normal__ expr="new hxsl.Types.Vec()">
			<t path="hxsl.Vec"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Vec()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</normal__>
		<get_normal get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Vec"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_normal>
		<set_normal get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Vec"/>
				<t path="hxsl.Vec"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_normal>
		<tangent public="1" get="accessor" set="accessor"><t path="hxsl.Vec"/></tangent>
		<tangent__ expr="new hxsl.Types.Vec()">
			<t path="hxsl.Vec"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Vec()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</tangent__>
		<get_tangent get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Vec"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_tangent>
		<set_tangent get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Vec"/>
				<t path="hxsl.Vec"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_tangent>
		<isCentered public="1" get="accessor" set="accessor"><x path="Bool"/></isCentered>
		<isCentered__ expr="true">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>true</e></m>
				<m n=":noCompletion"/>
			</meta>
		</isCentered__>
		<get_isCentered get="inline" set="null" line="5">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_isCentered>
		<set_isCentered get="inline" set="null" line="5">
			<f a="_v">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_isCentered>
		<updateConstants public="1" set="method" line="5" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="5" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="42"><f a="objectWidth:objectHeight">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":src"><e><![CDATA[{
	@:import BaseMesh;
	@global var depthMap:Channel;
	@param var scale:Vec2;
	@param var normal:Vec3;
	@param var tangent:Vec3;
	@const var isCentered:Bool = true;
	var calculatedUV:Vec2;
	var transformedTangent:Vec4;
	function __init__vertex() {
		transformedNormal = (normal * global.modelView.mat3()).normalize();
		transformedTangent = vec4((tangent * global.modelView.mat3()).normalize(), 1.);
	};
	function fragment() {
		var matrix = camera.inverseViewProj * global.modelViewInverse;
		var screenPos = projectedPosition.xy / projectedPosition.w;
		var ruv = vec4(screenPos, depthMap.get(screenToUv(screenPos)), 1);
		var wpos = ruv * matrix;
		var ppos = ruv * camera.inverseViewProj;
		pixelTransformedPosition = ppos.xyz / ppos.w;
		calculatedUV = scale * (wpos.xy / wpos.w);
		if (isCentered) calculatedUV += 0.5;
		if (min(min(calculatedUV.x, calculatedUV.y), min(1 - calculatedUV.x, 1 - calculatedUV.y)) < 0) discard;
	};
}]]></e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<abstract path="haxe.Function" params="" file="E:\HaxeToolkit\haxe\std\haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc>This type unifies with any function type.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.</haxe_doc>
		<meta><m n=":callable"/></meta>
		<impl><class path="haxe._Constraints.Function_Impl_" params="" file="E:\HaxeToolkit\haxe\std\haxe/Constraints.hx" private="1" module="haxe.Constraints"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.FlatEnum" params="" file="E:\HaxeToolkit\haxe\std\haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc>This type unifies with an enum instance if all constructors of the enum
	require no arguments.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.</haxe_doc>
		<impl><class path="haxe._Constraints.FlatEnum_Impl_" params="" file="E:\HaxeToolkit\haxe\std\haxe/Constraints.hx" private="1" module="haxe.Constraints"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.Constructible" params="T" file="E:\HaxeToolkit\haxe\std\haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc><![CDATA[This type unifies with any instance of classes that have a constructor
	which

	  * is `public` and
	  * unifies with the type used for type parameter `T`.

	If a type parameter `A` is assigned to a type parameter `B` which is constrained
	to `Constructible<T>`, A must be explicitly constrained to
	`Constructible<T>` as well.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.]]></haxe_doc>
		<impl><class path="haxe._Constraints.Constructible_Impl_" params="" file="E:\HaxeToolkit\haxe\std\haxe/Constraints.hx" private="1" module="haxe.Constraints"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="haxe.IMap" params="K:V" file="E:\HaxeToolkit\haxe\std\haxe/Constraints.hx" module="haxe.Constraints" interface="1"><meta><m n=":keep"/></meta></class>
	<class path="haxe.EntryPoint" params="" file="E:\HaxeToolkit\haxe\std\haxe/EntryPoint.hx">
		<pending expr="new Array&lt;Void&gt;()" line="40" static="1">
			<c path="Array"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e><![CDATA[new Array<Void>()]]></e></m></meta>
		</pending>
		<threadCount public="1" set="null" expr="0" line="41" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</threadCount>
		<processEvents set="method" line="85" static="1"><f a=""><x path="Float"/></f></processEvents>
		<run public="1" set="method" line="108" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>Start the main loop. Depending on the platform, this can return immediately or will only return when the application exits.</haxe_doc>
		</run>
		<haxe_doc>If `haxe.MainLoop` is kept from DCE, then we will insert an `haxe.EntryPoint.run()` call just at then end of `main()`.
	This class can be redefined by custom frameworks so they can handle their own main loop logic.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<abstract path="haxe.EnumFlags" params="T" file="E:\HaxeToolkit\haxe\std\haxe/EnumFlags.hx">
		<this><x path="Int"/></this>
		<haxe_doc>A typed interface for bit flags. This is not a real object, only a typed
	interface for an actual Int. Each flag can be tested/set with the
	corresponding enum instance. Up to 32 flags can be stored that way.

	Enum constructor indices are preserved from Haxe syntax, so the first
	declared is index 0, the next index 1 etc. The methods are optimized if the
	enum instance is passed directly, e.g. as `has(EnumCtor)`. Otherwise
	`Type.enumIndex()` reflection is used.</haxe_doc>
		<impl><class path="haxe._EnumFlags.EnumFlags_Impl_" params="" file="E:\HaxeToolkit\haxe\std\haxe/EnumFlags.hx" private="1" module="haxe.EnumFlags"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="haxe.EnumTools" params="" file="E:\HaxeToolkit\haxe\std\haxe/EnumTools.hx" extern="1">
		<getName public="1" params="T" get="inline" set="null" line="52" static="1">
			<f a="e">
				<x path="Enum"><c path="getName.T"/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the name of enum `e`, including its path.

		If `e` is inside a package, the package structure is returned dot-
		separated, with another dot separating the enum name:
		
			pack1.pack2.(...).packN.EnumName

		If `e` is a sub-type of a Haxe module, that module is not part of the
		package structure.

		If `e` has no package, the enum name is returned.

		If `e` is `null`, the result is unspecified.

		The enum name does not include any type parameters.</haxe_doc>
		</getName>
		<createByName public="1" params="T" get="inline" set="null" line="65" static="1">
			<f a="e:constr:?params">
				<x path="Enum"><c path="createByName.T"/></x>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createByName.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor `constr` with
		arguments `params`.

		If `e` or `constr` is `null`, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createByName>
		<createByIndex public="1" params="T" get="inline" set="null" line="81" static="1">
			<f a="e:index:?params">
				<x path="Enum"><c path="createByIndex.T"/></x>
				<x path="Int"/>
				<c path="Array"><d/></c>
				<c path="createByIndex.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor number
		`index` with arguments `params`.

		The constructor indices are preserved from Haxe syntax, so the first
		declared is index 0, the next index 1 etc.

		If `e` or `index` is `null`, or if enum `e` has no constructor
		corresponding to index `index`, or if the number of elements in `params`
		does not match the expected number of constructor arguments, or if any
		argument has an invalid type, the result is unspecified.</haxe_doc>
		</createByIndex>
		<createAll public="1" params="T" get="inline" set="null" line="98" static="1">
			<f a="e">
				<x path="Enum"><c path="createAll.T"/></x>
				<c path="Array"><c path="createAll.T"/></c>
			</f>
			<haxe_doc>Returns a list of all constructors of enum `e` that require no
		arguments.

		This may return the empty Array `[]` if all constructors of `e` require
		arguments.

		Otherwise an instance of `e` constructed through each of its non-
		argument constructors is returned, in the order of the constructor
		declaration.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</createAll>
		<getConstructors public="1" params="T" get="inline" set="null" line="110" static="1">
			<f a="e">
				<x path="Enum"><c path="getConstructors.T"/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of the names of all constructors of enum `e`.

		The order of the constructor names in the returned Array is preserved
		from the original syntax.

		If `c` is `null`, the result is unspecified.</haxe_doc>
		</getConstructors>
		<haxe_doc>This class provides advanced methods on enums. It is ideally used with
	`using EnumTools` and then acts as an
	  [extension](https://haxe.org/manual/lf-static-extension.html) to the
	  `enum` types.

	If the first argument to any of the methods is `null`, the result is
	unspecified.</haxe_doc>
	</class>
	<class path="haxe.EnumValueTools" params="" file="E:\HaxeToolkit\haxe\std\haxe/EnumTools.hx" module="haxe.EnumTools" extern="1">
		<equals public="1" params="T" get="inline" set="null" line="133" static="1">
			<f a="a:b">
				<c path="equals.T"/>
				<c path="equals.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Recursively compares two enum instances `a` and `b` by value.

		Unlike `a == b`, this function performs a deep equality check on the
		arguments of the constructors (if there are any).

		If `a` or `b` are `null`, the result is unspecified.</haxe_doc>
		</equals>
		<getName public="1" get="inline" set="null" line="144" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the constructor name of enum instance `e`.

		The result String does not contain any constructor arguments.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</getName>
		<getParameters public="1" get="inline" set="null" line="158" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>Returns a list of the constructor arguments of enum instance `e`.

		If `e` has no arguments, the result is `[]`.

		Otherwise the result are the values that were used as arguments to `e`,
		in the order of their declaration.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</getParameters>
		<getIndex public="1" get="inline" set="null" line="170" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the index of enum instance `e`.

		This corresponds to the original syntactic position of `e`. The index of
		the first declared constructor is 0, the next one is 1 etc.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</getIndex>
		<haxe_doc>This class provides advanced methods on enum values. It is ideally used with
	`using EnumValueTools` and then acts as an
	  [extension](https://haxe.org/manual/lf-static-extension.html) to the
	  `EnumValue` types.

	If the first argument to any of the methods is `null`, the result is
	unspecified.</haxe_doc>
	</class>
	<abstract path="haxe.Int32" params="" file="E:\HaxeToolkit\haxe\std\haxe/Int32.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="Int"/></icast>
			<icast field="toFloat"><x path="Float"/></icast>
		</to>
		<haxe_doc>Int32 provides a 32-bit integer with consistent overflow behavior across
	all platforms.</haxe_doc>
		<impl><class path="haxe._Int32.Int32_Impl_" params="" file="E:\HaxeToolkit\haxe\std\haxe/Int32.hx" private="1" module="haxe.Int32"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.Int64" params="" file="E:\HaxeToolkit\haxe\std\haxe/Int64.hx">
		<from>
			<icast><t path="haxe._Int64.__Int64"/></icast>
			<icast field="ofInt"><x path="Int"/></icast>
		</from>
		<this><t path="haxe._Int64.__Int64"/></this>
		<to><icast><t path="haxe._Int64.__Int64"/></icast></to>
		<haxe_doc>A cross-platform signed 64-bit integer.
	Int64 instances can be created from two 32-bit words using `Int64.make()`.</haxe_doc>
		<impl><class path="haxe._Int64.Int64_Impl_" params="" file="E:\HaxeToolkit\haxe\std\haxe/Int64.hx" private="1" module="haxe.Int64">
	<high public="1" get="accessor" set="null" static="1">
		<x path="haxe.Int32"/>
		<meta><m n=":impl"/></meta>
	</high>
	<low public="1" get="accessor" set="null" static="1">
		<x path="haxe.Int32"/>
		<meta><m n=":impl"/></meta>
	</low>
	<meta><m n=":keep"/></meta>
</class></impl>
	</abstract>
	<typedef path="haxe._Int64.__Int64" params="" file="E:\HaxeToolkit\haxe\std\haxe/Int64.hx" private="1" module="haxe.Int64">
		<c path="haxe._Int64.___Int64"/>
		<haxe_doc>This typedef will fool `@:coreApi` into thinking that we are using
	the same underlying type, even though it might be different on
	specific platforms.</haxe_doc>
	</typedef>
	<class path="haxe._Int64.___Int64" params="" file="E:\HaxeToolkit\haxe\std\haxe/Int64.hx" private="1" module="haxe.Int64">
		<high public="1"><x path="haxe.Int32"/></high>
		<low public="1"><x path="haxe.Int32"/></low>
		<new public="1" get="inline" set="null" line="467"><f a="high:low">
	<x path="haxe.Int32"/>
	<x path="haxe.Int32"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.Log" params="" file="E:\HaxeToolkit\haxe\std\haxe/Log.hx">
		<formatOutput public="1" set="method" line="33" static="1">
			<f a="v:infos">
				<d/>
				<t path="haxe.PosInfos"/>
				<c path="String"/>
			</f>
			<haxe_doc>Format the output of `trace` before printing it.</haxe_doc>
		</formatOutput>
		<trace public="1" set="dynamic" line="62" static="1">
			<f a="v:?infos">
				<d/>
				<t path="haxe.PosInfos"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Outputs `v` in a platform-dependent way.

		The second parameter `infos` is injected by the compiler and contains
		information about the position where the `trace()` call was made.

		This method can be rebound to a custom function:

			var oldTrace = haxe.Log.trace; // store old function
			haxe.Log.trace = function(v, ?infos) {
			  // handle trace
			}
			...
			haxe.Log.trace = oldTrace;

		If it is bound to null, subsequent calls to `trace()` will cause an
		exception.</haxe_doc>
		</trace>
		<haxe_doc>Log primarily provides the `trace()` method, which is invoked upon a call to
	`trace()` in Haxe code.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.MainEvent" params="" file="E:\HaxeToolkit\haxe\std\haxe/MainLoop.hx" module="haxe.MainLoop">
		<f><f a=""><x path="Void"/></f></f>
		<prev><c path="haxe.MainEvent"/></prev>
		<next><c path="haxe.MainEvent"/></next>
		<isBlocking public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>Tells if the event can lock the process from exiting (default:true)</haxe_doc>
		</isBlocking>
		<nextRun public="1" set="null"><x path="Float"/></nextRun>
		<priority public="1" set="null"><x path="Int"/></priority>
		<delay public="1" set="method" line="28">
			<f a="t">
				<x path="Null"><x path="Float"/></x>
				<x path="Void"/>
			</f>
			<haxe_doc>Delay the execution of the event for the given time, in seconds.
		If t is null, the event will be run at tick() time.</haxe_doc>
		</delay>
		<stop public="1" set="method" line="43">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Stop the event from firing anymore.</haxe_doc>
		</stop>
		<new set="method" line="18"><f a="f:p">
	<f a=""><x path="Void"/></f>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.MainLoop" params="" file="E:\HaxeToolkit\haxe\std\haxe/MainLoop.hx">
		<pending static="1"><c path="haxe.MainEvent"/></pending>
		<threadCount public="1" get="null" set="null" static="1"><x path="Int"/></threadCount>
		<hasEvents public="1" set="method" line="66" static="1"><f a=""><x path="Bool"/></f></hasEvents>
		<add public="1" set="method" line="87" static="1">
			<f a="f:?priority" v=":0">
				<f a=""><x path="Void"/></f>
				<x path="Int"/>
				<c path="haxe.MainEvent"/>
			</f>
			<meta><m n=":value"><e>{ priority : 0 }</e></m></meta>
			<haxe_doc>Add a pending event to be run into the main loop.</haxe_doc>
		</add>
		<sortEvents set="method" line="99" static="1"><f a=""><x path="Void"/></f></sortEvents>
		<tick set="method" line="164" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Run the pending events. Return the time for next event.</haxe_doc>
		</tick>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":access"><e>haxe.MainEvent</e></m>
		</meta>
	</class>
	<typedef path="haxe.PosInfos" params="" file="E:\HaxeToolkit\haxe\std\haxe/PosInfos.hx">
		<a>
			<methodName><c path="String"/></methodName>
			<lineNumber><x path="Int"/></lineNumber>
			<fileName><c path="String"/></fileName>
			<customParams>
				<x path="Null"><c path="Array"><d/></c></x>
				<meta><m n=":optional"/></meta>
			</customParams>
			<className><c path="String"/></className>
		</a>
		<haxe_doc>`PosInfos` is a magic type which can be used to generate position information
	into the output for debugging use.

	If a function has a final optional argument of this type, i.e.
	`(..., ?pos:haxe.PosInfos)`, each call to that function which does not assign
	a value to that argument has its position added as call argument.

	This can be used to track positions of calls in e.g. a unit testing
	framework.</haxe_doc>
	</typedef>
	<class path="haxe.Serializer" params="" file="E:\HaxeToolkit\haxe\std\haxe/Serializer.hx">
		<USE_CACHE public="1" expr="false" line="57" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>If the values you are serializing can contain circular references or
		objects repetitions, you should set `USE_CACHE` to true to prevent
		infinite loops.

		This may also reduce the size of serialization Strings at the expense of
		performance.

		This value can be changed for individual instances of `Serializer` by
		setting their `useCache` field.</haxe_doc>
		</USE_CACHE>
		<USE_ENUM_INDEX public="1" expr="false" line="69" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>Use constructor indexes for enums instead of names.

		This may reduce the size of serialization Strings, but makes them less
		suited for long-term storage: If constructors are removed or added from
		the enum, the indices may no longer match.

		This value can be changed for individual instances of `Serializer` by
		setting their `useEnumIndex` field.</haxe_doc>
		</USE_ENUM_INDEX>
		<BASE64 expr="&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789%:&quot;" line="71" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789%:"</e></m></meta>
		</BASE64>
		<BASE64_CODES expr="null" line="72" static="1">
			<x path="haxe.ds.Vector"><x path="Null"><x path="Int"/></x></x>
			<meta><m n=":value"><e>null</e></m></meta>
		</BASE64_CODES>
		<run public="1" set="method" line="582" static="1">
			<f a="v">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>Serializes `v` and returns the String representation.

	This is a convenience function for creating a new instance of
	Serializer, serialize `v` into it and obtain the result through a call
	to `toString()`.</haxe_doc>
		</run>
		<buf><c path="StringBuf"/></buf>
		<cache><c path="Array"><d/></c></cache>
		<shash><c path="haxe.ds.StringMap"><x path="Int"/></c></shash>
		<scount><x path="Int"/></scount>
		<useCache public="1">
			<x path="Bool"/>
			<haxe_doc>The individual cache setting for `this` Serializer instance.

		See `USE_CACHE` for a complete description.</haxe_doc>
		</useCache>
		<useEnumIndex public="1">
			<x path="Bool"/>
			<haxe_doc>The individual enum index setting for `this` Serializer instance.

		See `USE_ENUM_INDEX` for a complete description.</haxe_doc>
		</useEnumIndex>
		<toString public="1" set="method" line="118">
			<f a=""><c path="String"/></f>
			<haxe_doc>Return the String representation of `this` Serializer.

		The exact format specification can be found here:
		https://haxe.org/manual/serialization/format</haxe_doc>
		</toString>
		<serializeString set="method" line="154"><f a="s">
	<c path="String"/>
	<x path="Void"/>
</f></serializeString>
		<serializeRef set="method" line="174"><f a="v">
	<d/>
	<x path="Bool"/>
</f></serializeRef>
		<serializeFields set="method" line="211"><f a="v">
	<a/>
	<x path="Void"/>
</f></serializeFields>
		<serialize public="1" set="method" line="229">
			<f a="v">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>Serializes `v`.

	All haxe-defined values and objects with the exception of functions can
	be serialized. Serialization of external/native objects is not
	guaranteed to work.

	The values of `this.useCache` and `this.useEnumIndex` may affect
	serialization output.</haxe_doc>
		</serialize>
		<new public="1" set="method" line="103">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Serializer instance.

		Subsequent calls to `this.serialize` will append values to the
		internal buffer of this String. Once complete, the contents can be
		retrieved through a call to `this.toString`.

		Each `Serializer` instance maintains its own cache if `this.useCache` is
		`true`.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[The Serializer class can be used to encode values and objects into a `String`,
	from which the `Unserializer` class can recreate the original representation.

	This class can be used in two ways:

	- create a `new Serializer()` instance, call its `serialize()` method with
		any argument and finally retrieve the String representation from
		`toString()`
	- call `Serializer.run()` to obtain the serialized representation of a
		single argument

	Serialization is guaranteed to work for all haxe-defined classes, but may
	or may not work for instances of external/native classes.

	The specification of the serialization format can be found here:
	<https://haxe.org/manual/std-serialization-format.html>]]></haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.Timer" params="" file="E:\HaxeToolkit\haxe\std\haxe/Timer.hx">
		<delay public="1" set="method" line="139" static="1">
			<f a="f:time_ms">
				<f a=""><x path="Void"/></f>
				<x path="Int"/>
				<c path="haxe.Timer"/>
			</f>
			<haxe_doc>Invokes `f` after `time_ms` milliseconds.

		This is a convenience function for creating a new Timer instance with
		`time_ms` as argument, binding its `run()` method to `f` and then stopping
		`this` Timer upon the first invocation.

		If `f` is `null`, the result is unspecified.</haxe_doc>
		</delay>
		<event><c path="haxe.MainEvent"/></event>
		<stop public="1" set="method" line="90">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Stops `this` Timer.

		After calling this method, no additional invocations of `this.run`
		will occur.

		It is not possible to restart `this` Timer once stopped.</haxe_doc>
		</stop>
		<run public="1" set="dynamic" line="128">
			<f a=""><x path="Void"/></f>
			<haxe_doc>This method is invoked repeatedly on `this` Timer.

		It can be overridden in a subclass, or rebound directly to a custom
		function:

		```haxe
		var timer = new haxe.Timer(1000); // 1000ms delay
		timer.run = function() { ... }
		```
		
		Once bound, it can still be rebound to different functions until `this`
		Timer is stopped through a call to `this.stop`.</haxe_doc>
		</run>
		<new public="1" set="method" line="60">
			<f a="time_ms">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new timer that will run every `time_ms` milliseconds.

		After creating the Timer instance, it calls `this.run` repeatedly,
		with delays of `time_ms` milliseconds, until `this.stop` is called.

		The first invocation occurs after `time_ms` milliseconds, not
		immediately.

		The accuracy of this may be platform-dependent.</haxe_doc>
		</new>
		<haxe_doc>The `Timer` class allows you to create asynchronous timers on platforms that
	support events.

	The intended usage is to create an instance of the `Timer` class with a given
	interval, set its `run()` method to a custom function to be invoked and
	eventually call `stop()` to stop the `Timer`.

	Note that a running `Timer` may or may not prevent the program to exit
	automatically when `main()` returns.

	It is also possible to extend this class and override its `run()` method in
	the child class.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe._Unserializer.DefaultResolver" params="" file="E:\HaxeToolkit\haxe\std\haxe/Unserializer.hx" private="1" module="haxe.Unserializer">
		<resolveClass public="1" get="inline" set="null" line="476"><f a="name">
	<c path="String"/>
	<x path="Class"><d/></x>
</f></resolveClass>
		<resolveEnum public="1" get="inline" set="null" line="479"><f a="name">
	<c path="String"/>
	<x path="Enum"><d/></x>
</f></resolveEnum>
		<new public="1" set="method" line="474"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.Unserializer" params="" file="E:\HaxeToolkit\haxe\std\haxe/Unserializer.hx">
		<DEFAULT_RESOLVER public="1" expr="new DefaultResolver()" line="65" static="1">
			<t path="haxe.TypeResolver"/>
			<meta><m n=":value"><e>new DefaultResolver()</e></m></meta>
			<haxe_doc><![CDATA[This value can be set to use custom type resolvers.

		A type resolver finds a `Class` or `Enum` instance from a given `String`.
		By default, the Haxe `Type` Api is used.

		A type resolver must provide two methods:

		1. `resolveClass(name:String):Class<Dynamic>` is called to determine a
				`Class` from a class name
		2. `resolveEnum(name:String):Enum<Dynamic>` is called to determine an
				`Enum` from an enum name

		This value is applied when a new `Unserializer` instance is created.
		Changing it afterwards has no effect on previously created instances.]]></haxe_doc>
		</DEFAULT_RESOLVER>
		<BASE64 expr="&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789%:&quot;" line="67" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789%:"</e></m></meta>
		</BASE64>
		<CODES expr="null" line="70" static="1">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e>null</e></m></meta>
		</CODES>
		<initCodes set="method" line="72" static="1"><f a=""><c path="Array"><x path="Int"/></c></f></initCodes>
		<run public="1" set="method" line="464" static="1">
			<f a="v">
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>Unserializes `v` and returns the according value.

		This is a convenience function for creating a new instance of
		Unserializer with `v` as buffer and calling its `unserialize()` method
		once.</haxe_doc>
		</run>
		<buf><c path="String"/></buf>
		<pos><x path="Int"/></pos>
		<length><x path="Int"/></length>
		<cache><c path="Array"><d/></c></cache>
		<scache><c path="Array"><c path="String"/></c></scache>
		<resolver><t path="haxe.TypeResolver"/></resolver>
		<readDigits set="method" line="144"><f a=""><x path="Int"/></f></readDigits>
		<readFloat set="method" line="169"><f a=""><x path="Float"/></f></readFloat>
		<unserializeObject set="method" line="184"><f a="o">
	<a/>
	<x path="Void"/>
</f></unserializeObject>
		<unserializeEnum params="T" set="method" line="199"><f a="edecl:tag">
	<x path="Enum"><c path="unserializeEnum.T"/></x>
	<c path="String"/>
	<c path="unserializeEnum.T"/>
</f></unserializeEnum>
		<unserialize public="1" set="method" line="231">
			<f a=""><d/></f>
			<haxe_doc>Unserializes the next part of `this` Unserializer instance and returns
		the according value.

		This function may call `this.resolver.resolveClass` to determine a
		Class from a String, and `this.resolver.resolveEnum` to determine an
		Enum from a String.

		If `this` Unserializer instance contains no more or invalid data, an
		exception is thrown.

		This operation may fail on structurally valid data if a type cannot be
		resolved or if a field cannot be set. This can happen when unserializing
		Strings that were serialized on a different Haxe target, in which the
		serialization side has to make sure not to include platform-specific
		data.

		Classes are created from `Type.createEmptyInstance`, which means their
		constructors are not called.</haxe_doc>
		</unserialize>
		<new public="1" set="method" line="99">
			<f a="buf">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new Unserializer instance, with its internal buffer
		initialized to `buf`.

		This does not parse `buf` immediately. It is parsed only when calls to
		`this.unserialize` are made.

		Each Unserializer instance maintains its own cache.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[The `Unserializer` class is the complement to the `Serializer` class. It parses
	a serialization `String` and creates objects from the contained data.

	This class can be used in two ways:

	- create a `new Unserializer()` instance with a given serialization
		String, then call its `unserialize()` method until all values are
		extracted
	- call `Unserializer.run()`  to unserialize a single value from a given
		String

	The specification of the serialization format can be found here:
	<https://haxe.org/manual/serialization/format>]]></haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.crypto.Adler32" params="" file="E:\HaxeToolkit\haxe\std\haxe/crypto/Adler32.hx">
		<read public="1" set="method" line="60" static="1"><f a="i">
	<c path="haxe.io.Input"/>
	<c path="haxe.crypto.Adler32"/>
</f></read>
		<a1><x path="Int"/></a1>
		<a2><x path="Int"/></a2>
		<update public="1" set="method" line="41"><f a="b:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></update>
		<equals public="1" set="method" line="52"><f a="a">
	<c path="haxe.crypto.Adler32"/>
	<x path="Bool"/>
</f></equals>
		<new public="1" set="method" line="32"><f a=""><x path="Void"/></f></new>
		<haxe_doc>Calculates the Adler32 of the given Bytes.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.io.Bytes" params="" file="E:\HaxeToolkit\haxe\std\haxe/io/Bytes.hx">
		<alloc public="1" set="method" line="549" static="1">
			<f a="length">
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>Returns a new `Bytes` instance with the given `length`. The values of the
		bytes are not initialized and may not be zero.</haxe_doc>
		</alloc>
		<ofString public="1" set="method" line="580" static="1">
			<f a="s:?encoding">
				<c path="String"/>
				<e path="haxe.io.Encoding"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>Returns the `Bytes` representation of the given `String`, using the
		specified encoding (UTF-8 by default).</haxe_doc>
		</ofString>
		<length public="1" set="null"><x path="Int"/></length>
		<b><t path="haxe.io.BytesData"/></b>
		<blit public="1" set="method" line="90">
			<f a="pos:src:srcpos:len">
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Copies `len` bytes from `src` into this instance.
		@param pos Zero-based location in `this` instance at which to start writing
			bytes.
		@param src Source `Bytes` instance from which to copy bytes.
		@param srcpos Zero-based location at `src` from which bytes will be copied.
		@param len Number of bytes to be copied.</haxe_doc>
		</blit>
		<fill public="1" set="method" line="132">
			<f a="pos:len:value">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets `len` consecutive bytes starting from index `pos` of `this` instance
		to `value`.</haxe_doc>
		</fill>
		<sub public="1" set="method" line="155">
			<f a="pos:len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>Returns a new `Bytes` instance that contains a copy of `len` bytes of
		`this` instance, starting at index `pos`.</haxe_doc>
		</sub>
		<getDouble public="1" set="method" line="246">
			<f a="pos">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the IEEE double-precision value at the given position `pos` (in
		little-endian encoding). Result is unspecified if `pos` is outside the
		bounds.</haxe_doc>
		</getDouble>
		<getFloat public="1" set="method" line="269">
			<f a="pos">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the IEEE single-precision value at the given position `pos` (in
		little-endian encoding). Result is unspecified if `pos` is outside the
		bounds.</haxe_doc>
		</getFloat>
		<setFloat public="1" set="method" line="319">
			<f a="pos:v">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Stores the given IEEE single-precision value `v` at the given position
		`pos` in little-endian encoding. Result is unspecified if writing outside
		of bounds.</haxe_doc>
		</setFloat>
		<getString public="1" set="method" line="415">
			<f a="pos:len:?encoding">
				<x path="Int"/>
				<x path="Int"/>
				<e path="haxe.io.Encoding"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the `len`-bytes long string stored at the given position `pos`,
		interpreted with the given `encoding` (UTF-8 by default).</haxe_doc>
		</getString>
		<toString public="1" set="method" line="502">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a `String` representation of the bytes interpreted as UTF-8.</haxe_doc>
		</toString>
		<toHex public="1" set="method" line="524">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a hexadecimal `String` representation of the bytes of `this`
		instance.</haxe_doc>
		</toHex>
		<new set="method" line="34"><f a="length:b">
	<x path="Int"/>
	<t path="haxe.io.BytesData"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.crypto.Base64" params="" file="E:\HaxeToolkit\haxe\std\haxe/crypto/Base64.hx">
		<CHARS public="1" set="null" expr="&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;" line="29" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"</e></m></meta>
		</CHARS>
		<BYTES public="1" set="null" expr="haxe.io.Bytes.ofString(CHARS)" line="30" static="1">
			<c path="haxe.io.Bytes"/>
			<meta><m n=":value"><e>haxe.io.Bytes.ofString(CHARS)</e></m></meta>
		</BYTES>
		<encode public="1" set="method" line="35" static="1">
			<f a="bytes:?complement" v=":true">
				<c path="haxe.io.Bytes"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ complement : true }</e></m></meta>
		</encode>
		<decode public="1" set="method" line="48" static="1">
			<f a="str:?complement" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":value"><e>{ complement : true }</e></m></meta>
		</decode>
		<haxe_doc>Allows one to encode/decode String and bytes using Base64 encoding.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.crypto.BaseCode" params="" file="E:\HaxeToolkit\haxe\std\haxe/crypto/BaseCode.hx">
		<base><c path="haxe.io.Bytes"/></base>
		<nbits><x path="Int"/></nbits>
		<tbl><c path="Array"><x path="Int"/></c></tbl>
		<encodeBytes public="1" set="method" line="44"><f a="b">
	<c path="haxe.io.Bytes"/>
	<c path="haxe.io.Bytes"/>
</f></encodeBytes>
		<initTable set="method" line="72"><f a=""><x path="Void"/></f></initTable>
		<decodeBytes public="1" set="method" line="81"><f a="b">
	<c path="haxe.io.Bytes"/>
	<c path="haxe.io.Bytes"/>
</f></decodeBytes>
		<new public="1" set="method" line="33"><f a="base">
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Allows one to encode/decode String and bytes using a power of two base dictionary.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.crypto.Md5" params="" file="E:\HaxeToolkit\haxe\std\haxe/crypto/Md5.hx">
		<encode public="1" set="method" line="29" static="1"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></encode>
		<str2blks set="method" line="132" static="1"><f a="str">
	<c path="String"/>
	<c path="Array"><x path="Int"/></c>
</f></str2blks>
		<bitOR set="method" line="69"><f a="a:b">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></bitOR>
		<bitXOR set="method" line="75"><f a="a:b">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></bitXOR>
		<bitAND set="method" line="81"><f a="a:b">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></bitAND>
		<addme set="method" line="87"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></addme>
		<hex set="method" line="93"><f a="a">
	<c path="Array"><x path="Int"/></c>
	<c path="String"/>
</f></hex>
		<rol set="method" line="166"><f a="num:cnt">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></rol>
		<cmn set="method" line="170"><f a="q:a:b:x:s:t">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></cmn>
		<ff set="method" line="174"><f a="a:b:c:d:x:s:t">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></ff>
		<gg set="method" line="178"><f a="a:b:c:d:x:s:t">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></gg>
		<hh set="method" line="182"><f a="a:b:c:d:x:s:t">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></hh>
		<ii set="method" line="186"><f a="a:b:c:d:x:s:t">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></ii>
		<doEncode set="method" line="190"><f a="x">
	<c path="Array"><x path="Int"/></c>
	<c path="Array"><x path="Int"/></c>
</f></doEncode>
		<new set="method" line="67"><f a=""><x path="Void"/></f></new>
		<haxe_doc>Creates a MD5 of a String.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.crypto.Sha1" params="" file="E:\HaxeToolkit\haxe\std\haxe/crypto/Sha1.hx">
		<make public="1" set="method" line="35" static="1"><f a="b">
	<c path="haxe.io.Bytes"/>
	<c path="haxe.io.Bytes"/>
</f></make>
		<bytes2blks set="method" line="115" static="1"><f a="b">
	<c path="haxe.io.Bytes"/>
	<c path="Array"><x path="Int"/></c>
</f></bytes2blks>
		<doEncode set="method" line="50"><f a="x">
	<c path="Array"><x path="Int"/></c>
	<c path="Array"><x path="Int"/></c>
</f></doEncode>
		<ft set="method" line="142">
			<f a="t:b:c:d">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Perform the appropriate triplet combination function for the current iteration</haxe_doc>
		</ft>
		<kt set="method" line="155">
			<f a="t">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Determine the appropriate additive constant for the current iteration</haxe_doc>
		</kt>
		<new set="method" line="48"><f a=""><x path="Void"/></f></new>
		<haxe_doc>Creates a Sha1 of a String.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.ds.ArraySort" params="" file="E:\HaxeToolkit\haxe\std\haxe/ds/ArraySort.hx">
		<sort public="1" params="T" set="method" line="42" static="1">
			<f a="a:cmp">
				<c path="Array"><c path="sort.T"/></c>
				<f a=":">
					<c path="sort.T"/>
					<c path="sort.T"/>
					<x path="Int"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[Sorts Array `a` according to the comparison function `cmp`, where
		`cmp(x,y)` returns 0 if `x == y`, a positive Int if `x > y` and a
		negative Int if `x < y`.

		This operation modifies Array `a` in place.

		This operation is stable: The order of equal elements is preserved.

		If `a` or `cmp` are null, the result is unspecified.]]></haxe_doc>
		</sort>
		<rec params="T" set="method" line="46" static="1"><f a="a:cmp:from:to">
	<c path="Array"><c path="rec.T"/></c>
	<f a=":">
		<c path="rec.T"/>
		<c path="rec.T"/>
		<x path="Int"/>
	</f>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></rec>
		<doMerge params="T" set="method" line="68" static="1"><f a="a:cmp:from:pivot:to:len1:len2">
	<c path="Array"><c path="doMerge.T"/></c>
	<f a=":">
		<c path="doMerge.T"/>
		<c path="doMerge.T"/>
		<x path="Int"/>
	</f>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></doMerge>
		<rotate params="T" set="method" line="94" static="1"><f a="a:cmp:from:mid:to">
	<c path="Array"><c path="rotate.T"/></c>
	<f a=":">
		<c path="rotate.T"/>
		<c path="rotate.T"/>
		<x path="Int"/>
	</f>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></rotate>
		<gcd set="method" line="115" static="1"><f a="m:n">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></gcd>
		<upper params="T" set="method" line="124" static="1"><f a="a:cmp:from:to:val">
	<c path="Array"><c path="upper.T"/></c>
	<f a=":">
		<c path="upper.T"/>
		<c path="upper.T"/>
		<x path="Int"/>
	</f>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></upper>
		<lower params="T" set="method" line="139" static="1"><f a="a:cmp:from:to:val">
	<c path="Array"><c path="lower.T"/></c>
	<f a=":">
		<c path="lower.T"/>
		<c path="lower.T"/>
		<x path="Int"/>
	</f>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></lower>
		<swap params="T" set="method" line="153" static="1"><f a="a:i:j">
	<c path="Array"><c path="swap.T"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></swap>
		<haxe_doc>ArraySort provides a stable implementation of merge sort through its `sort`
	method. It should be used instead of `Array.sort` in cases where the order
	of equal elements has to be retained on all targets.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.ds.BalancedTree" params="K:V" file="E:\HaxeToolkit\haxe\std\haxe/ds/BalancedTree.hx">
		<implements path="haxe.IMap">
			<c path="haxe.ds.BalancedTree.K"/>
			<c path="haxe.ds.BalancedTree.V"/>
		</implements>
		<root><c path="haxe.ds.TreeNode">
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.BalancedTree.V"/>
</c></root>
		<set public="1" set="method" line="50">
			<f a="key:value">
				<c path="haxe.ds.BalancedTree.K"/>
				<c path="haxe.ds.BalancedTree.V"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Binds `key` to `value`.

		If `key` is already bound to a value, that binding disappears.

		If `key` is null, the result is unspecified.</haxe_doc>
		</set>
		<get public="1" set="method" line="61">
			<f a="key">
				<c path="haxe.ds.BalancedTree.K"/>
				<x path="Null"><c path="haxe.ds.BalancedTree.V"/></x>
			</f>
			<haxe_doc>Returns the value `key` is bound to.

		If `key` is not bound to any value, `null` is returned.

		If `key` is null, the result is unspecified.</haxe_doc>
		</get>
		<setLoop set="method" line="150"><f a="k:v:node">
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.BalancedTree.V"/>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
</f></setLoop>
		<balance set="method" line="205"><f a="l:k:v:r">
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.BalancedTree.V"/>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
</f></balance>
		<compare set="method" line="225"><f a="k1:k2">
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.BalancedTree.K"/>
	<x path="Int"/>
</f></compare>
		<new public="1" set="method" line="41">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new BalancedTree, which is initially empty.</haxe_doc>
		</new>
		<haxe_doc>BalancedTree allows key-value mapping with arbitrary keys, as long as they
	can be ordered. By default, `Reflect.compare` is used in the `compare`
	method, which can be overridden in subclasses.

	Operations have a logarithmic average and worst-case cost.

	Iteration over keys and values, using `keys` and `iterator` respectively,
	are in-order.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.ds.TreeNode" params="K:V" file="E:\HaxeToolkit\haxe\std\haxe/ds/BalancedTree.hx" module="haxe.ds.BalancedTree">
		<left public="1"><c path="haxe.ds.TreeNode">
	<c path="haxe.ds.TreeNode.K"/>
	<c path="haxe.ds.TreeNode.V"/>
</c></left>
		<right public="1"><c path="haxe.ds.TreeNode">
	<c path="haxe.ds.TreeNode.K"/>
	<c path="haxe.ds.TreeNode.V"/>
</c></right>
		<key public="1"><c path="haxe.ds.TreeNode.K"/></key>
		<value public="1"><c path="haxe.ds.TreeNode.V"/></value>
		<_height><x path="Int"/></_height>
		<new public="1" set="method" line="255">
			<f a="l:k:v:r:?h" v="::::-1">
				<c path="haxe.ds.TreeNode">
					<c path="haxe.ds.TreeNode.K"/>
					<c path="haxe.ds.TreeNode.V"/>
				</c>
				<c path="haxe.ds.TreeNode.K"/>
				<c path="haxe.ds.TreeNode.V"/>
				<c path="haxe.ds.TreeNode">
					<c path="haxe.ds.TreeNode.K"/>
					<c path="haxe.ds.TreeNode.V"/>
				</c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ h : -1 }</e></m></meta>
		</new>
		<haxe_doc>A tree node of `haxe.ds.BalancedTree`.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.ds.EnumValueMap" params="K:V" file="E:\HaxeToolkit\haxe\std\haxe/ds/EnumValueMap.hx">
		<extends path="haxe.ds.BalancedTree">
			<c path="haxe.ds.EnumValueMap.K"/>
			<c path="haxe.ds.EnumValueMap.V"/>
		</extends>
		<implements path="haxe.IMap">
			<c path="haxe.ds.EnumValueMap.K"/>
			<c path="haxe.ds.EnumValueMap.V"/>
		</implements>
		<compare set="method" line="32" override="1"><f a="k1:k2">
	<x path="EnumValue"/>
	<x path="EnumValue"/>
	<x path="Int"/>
</f></compare>
		<compareArgs set="method" line="43"><f a="a1:a2">
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<x path="Int"/>
</f></compareArgs>
		<compareArg set="method" line="55"><f a="v1:v2">
	<d/>
	<d/>
	<x path="Int"/>
</f></compareArg>
		<new public="1" set="method" line="31"><f a=""><x path="Void"/></f></new>
		<haxe_doc>EnumValueMap allows mapping of enum value keys to arbitrary values.

	Keys are compared by value and recursively over their parameters. If any
	parameter is not an enum value, `Reflect.compare` is used to compare them.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<abstract path="haxe.ds.HashMap" params="K:V" file="E:\HaxeToolkit\haxe\std\haxe/ds/HashMap.hx">
		<this><c path="haxe.ds._HashMap.HashMapData">
	<c path="haxe.ds.HashMap.K"/>
	<c path="haxe.ds.HashMap.V"/>
</c></this>
		<haxe_doc>HashMap allows mapping of hashable objects to arbitrary values.

	See `Map` for documentation details.

	@see https://haxe.org/manual/std-Map.html</haxe_doc>
		<impl><class path="haxe.ds._HashMap.HashMap_Impl_" params="" file="E:\HaxeToolkit\haxe\std\haxe/ds/HashMap.hx" private="1" module="haxe.ds.HashMap"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="haxe.ds.IntMap" params="T" file="E:\HaxeToolkit\haxe\std\haxe/ds/IntMap.hx" extern="1">
		<implements path="haxe.IMap">
			<x path="Int"/>
			<c path="haxe.ds.IntMap.T"/>
		</implements>
		<set public="1" set="method">
			<f a="key:value">
				<x path="Int"/>
				<c path="haxe.ds.IntMap.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>See `Map.set`</haxe_doc>
		</set>
		<get public="1" set="method">
			<f a="key">
				<x path="Int"/>
				<x path="Null"><c path="haxe.ds.IntMap.T"/></x>
			</f>
			<haxe_doc>See `Map.get`</haxe_doc>
		</get>
		<exists public="1" set="method">
			<f a="key">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.exists`</haxe_doc>
		</exists>
		<remove public="1" set="method">
			<f a="key">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.remove`</haxe_doc>
		</remove>
		<keys public="1" set="method">
			<f a=""><t path="Iterator"><x path="Int"/></t></f>
			<haxe_doc>See `Map.keys`

		(cs, java) Implementation detail: Do not `set()` any new value while
		iterating, as it may cause a resize, which will break iteration.</haxe_doc>
		</keys>
		<iterator public="1" set="method">
			<f a=""><t path="Iterator"><c path="haxe.ds.IntMap.T"/></t></f>
			<haxe_doc>See `Map.iterator`

		(cs, java) Implementation detail: Do not `set()` any new value while
		iterating, as it may cause a resize, which will break iteration.</haxe_doc>
		</iterator>
		<keyValueIterator public="1" set="method">
			<f a=""><t path="KeyValueIterator">
	<x path="Int"/>
	<c path="haxe.ds.IntMap.T"/>
</t></f>
			<haxe_doc>See `Map.keyValueIterator`</haxe_doc>
		</keyValueIterator>
		<copy public="1" set="method">
			<f a=""><c path="haxe.ds.IntMap"><c path="haxe.ds.IntMap.T"/></c></f>
			<haxe_doc>See `Map.copy`</haxe_doc>
		</copy>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>See `Map.toString`</haxe_doc>
		</toString>
		<clear public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>See `Map.clear`</haxe_doc>
		</clear>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new IntMap.</haxe_doc>
		</new>
		<haxe_doc>IntMap allows mapping of Int keys to arbitrary values.

	See `Map` for documentation details.

	@see https://haxe.org/manual/std-Map.html</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="haxe.ds.List" params="T" file="E:\HaxeToolkit\haxe\std\haxe/ds/List.hx">
		<h><c path="haxe.ds._List.ListNode"><c path="haxe.ds.List.T"/></c></h>
		<q><c path="haxe.ds._List.ListNode"><c path="haxe.ds.List.T"/></c></q>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The length of `this` List.</haxe_doc>
		</length>
		<add public="1" set="method" line="53">
			<f a="item">
				<c path="haxe.ds.List.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds element `item` at the end of `this` List.

		`this.length` increases by 1.</haxe_doc>
		</add>
		<push public="1" set="method" line="68">
			<f a="item">
				<c path="haxe.ds.List.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds element `item` at the beginning of `this` List.

		`this.length` increases by 1.</haxe_doc>
		</push>
		<pop public="1" set="method" line="99">
			<f a=""><x path="Null"><c path="haxe.ds.List.T"/></x></f>
			<haxe_doc>Returns the first element of `this` List, or null if no elements exist.

		The element is removed from `this` List.</haxe_doc>
		</pop>
		<clear public="1" set="method" line="123">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Empties `this` List.

		This function does not traverse the elements, but simply sets the
		internal references to null and `this.length` to 0.</haxe_doc>
		</clear>
		<remove public="1" set="method" line="137">
			<f a="v">
				<c path="haxe.ds.List.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes the first occurrence of `v` in `this` List.

		If `v` is found by checking standard equality, it is removed from `this`
		List and the function returns true.

		Otherwise, false is returned.</haxe_doc>
		</remove>
		<new public="1" set="method" line="44">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new empty list.</haxe_doc>
		</new>
		<haxe_doc>A linked-list of elements. The list is composed of element container objects
	that are chained together. It is optimized so that adding or removing an
	element does not imply copying the whole list content every time.

	@see https://haxe.org/manual/std-List.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.ds._List.ListNode" params="T" file="E:\HaxeToolkit\haxe\std\haxe/ds/List.hx" private="1" module="haxe.ds.List">
		<item public="1"><c path="haxe.ds._List.ListNode.T"/></item>
		<next public="1"><c path="haxe.ds._List.ListNode"><c path="haxe.ds._List.ListNode.T"/></c></next>
		<new public="1" set="method" line="266"><f a="item:next">
	<c path="haxe.ds._List.ListNode.T"/>
	<c path="haxe.ds._List.ListNode"><c path="haxe.ds._List.ListNode.T"/></c>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<abstract path="haxe.ds.Map" params="K:V" file="E:\HaxeToolkit\haxe\std\haxe/ds/Map.hx">
		<from>
			<icast field="fromStringMap"><c path="haxe.ds.StringMap"><c path="fromStringMap.V"/></c></icast>
			<icast field="fromIntMap"><c path="haxe.ds.IntMap"><c path="fromIntMap.V"/></c></icast>
			<icast field="fromObjectMap"><c path="haxe.ds.ObjectMap">
	<c path="fromObjectMap.K"/>
	<c path="fromObjectMap.V"/>
</c></icast>
		</from>
		<this><c path="haxe.IMap">
	<c path="haxe.ds.Map.K"/>
	<c path="haxe.ds.Map.V"/>
</c></this>
		<to>
			<icast field="toStringMap"><c path="haxe.ds.StringMap"><c path="toStringMap.V"/></c></icast>
			<icast field="toIntMap"><c path="haxe.ds.IntMap"><c path="toIntMap.V"/></c></icast>
			<icast field="toEnumValueMapMap"><c path="haxe.ds.EnumValueMap">
	<c path="toEnumValueMapMap.K"/>
	<c path="toEnumValueMapMap.V"/>
</c></icast>
			<icast field="toObjectMap"><c path="haxe.ds.ObjectMap">
	<c path="toObjectMap.K"/>
	<c path="toObjectMap.V"/>
</c></icast>
		</to>
		<haxe_doc><![CDATA[Map allows key to value mapping for arbitrary value types, and many key
	types.

	This is a multi-type abstract, it is instantiated as one of its
	specialization types depending on its type parameters.

	A Map can be instantiated without explicit type parameters. Type inference
	will then determine the type parameters from the usage.

	Maps can also be created with `[key1 => value1, key2 => value2]` syntax.

	Map is an abstract type, it is not available at runtime.

	@see https://haxe.org/manual/std-Map.html]]></haxe_doc>
		<meta><m n=":multiType"><e>@:followWithAbstracts K</e></m></meta>
		<impl><class path="haxe.ds._Map.Map_Impl_" params="" file="E:\HaxeToolkit\haxe\std\haxe/ds/Map.hx" private="1" module="haxe.ds.Map"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="haxe.ds.ObjectMap" params="K:V" file="E:\HaxeToolkit\haxe\std\haxe/ds/ObjectMap.hx" extern="1">
		<implements path="haxe.IMap">
			<c path="haxe.ds.ObjectMap.K"/>
			<c path="haxe.ds.ObjectMap.V"/>
		</implements>
		<set public="1" set="method">
			<f a="key:value">
				<c path="haxe.ds.ObjectMap.K"/>
				<c path="haxe.ds.ObjectMap.V"/>
				<x path="Void"/>
			</f>
			<haxe_doc>See `Map.set`</haxe_doc>
		</set>
		<get public="1" set="method">
			<f a="key">
				<c path="haxe.ds.ObjectMap.K"/>
				<x path="Null"><c path="haxe.ds.ObjectMap.V"/></x>
			</f>
			<haxe_doc>See `Map.get`</haxe_doc>
		</get>
		<exists public="1" set="method">
			<f a="key">
				<c path="haxe.ds.ObjectMap.K"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.exists`</haxe_doc>
		</exists>
		<remove public="1" set="method">
			<f a="key">
				<c path="haxe.ds.ObjectMap.K"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.remove`</haxe_doc>
		</remove>
		<keys public="1" set="method">
			<f a=""><t path="Iterator"><c path="haxe.ds.ObjectMap.K"/></t></f>
			<haxe_doc>See `Map.keys`

		(cs, java) Implementation detail: Do not `set()` any new value while
		iterating, as it may cause a resize, which will break iteration.</haxe_doc>
		</keys>
		<iterator public="1" set="method">
			<f a=""><t path="Iterator"><c path="haxe.ds.ObjectMap.V"/></t></f>
			<haxe_doc>See `Map.iterator`

		(cs, java) Implementation detail: Do not `set()` any new value while
		iterating, as it may cause a resize, which will break iteration.</haxe_doc>
		</iterator>
		<keyValueIterator public="1" set="method">
			<f a=""><t path="KeyValueIterator">
	<c path="haxe.ds.ObjectMap.K"/>
	<c path="haxe.ds.ObjectMap.V"/>
</t></f>
			<haxe_doc>See `Map.keyValueIterator`</haxe_doc>
		</keyValueIterator>
		<copy public="1" set="method">
			<f a=""><c path="haxe.ds.ObjectMap">
	<c path="haxe.ds.ObjectMap.K"/>
	<c path="haxe.ds.ObjectMap.V"/>
</c></f>
			<haxe_doc>See `Map.copy`</haxe_doc>
		</copy>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>See `Map.toString`</haxe_doc>
		</toString>
		<clear public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>See `Map.clear`</haxe_doc>
		</clear>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new ObjectMap.</haxe_doc>
		</new>
		<haxe_doc>ObjectMap allows mapping of object keys to arbitrary values.

	On static targets, the keys are considered to be strong references. Refer
	to `haxe.ds.WeakMap` for a weak reference version.

	See `Map` for documentation details.

	@see https://haxe.org/manual/std-Map.html</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="haxe.ds.ReadOnlyArray" params="T" file="E:\HaxeToolkit\haxe\std\haxe/ds/ReadOnlyArray.hx">
		<from><icast><c path="Array"><c path="haxe.ds.ReadOnlyArray.T"/></c></icast></from>
		<this><c path="Array"><c path="haxe.ds.ReadOnlyArray.T"/></c></this>
		<haxe_doc>`ReadOnlyArray` is an abstract over an ordinary `Array` which only exposes
	APIs that don't modify the instance, hence "read-only".

	Note that this doesn't necessarily mean that the instance is *immutable*.
	Other code holding a reference to the underlying `Array` can still modify it,
	and the reference can be obtained with a `cast`.</haxe_doc>
		<meta><m n=":forward">
	<e>concat</e>
	<e>copy</e>
	<e>filter</e>
	<e>indexOf</e>
	<e>iterator</e>
	<e>join</e>
	<e>lastIndexOf</e>
	<e>map</e>
	<e>slice</e>
	<e>toString</e>
</m></meta>
		<impl><class path="haxe.ds._ReadOnlyArray.ReadOnlyArray_Impl_" params="" file="E:\HaxeToolkit\haxe\std\haxe/ds/ReadOnlyArray.hx" private="1" module="haxe.ds.ReadOnlyArray">
	<length public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>The length of `this` Array.</haxe_doc>
	</length>
	<meta><m n=":keep"/></meta>
</class></impl>
	</abstract>
	<class path="haxe.ds.StringMap" params="T" file="E:\HaxeToolkit\haxe\std\haxe/ds/StringMap.hx" extern="1">
		<implements path="haxe.IMap">
			<c path="String"/>
			<c path="haxe.ds.StringMap.T"/>
		</implements>
		<set public="1" set="method">
			<f a="key:value">
				<c path="String"/>
				<c path="haxe.ds.StringMap.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>See `Map.set`</haxe_doc>
		</set>
		<get public="1" set="method">
			<f a="key">
				<c path="String"/>
				<x path="Null"><c path="haxe.ds.StringMap.T"/></x>
			</f>
			<haxe_doc>See `Map.get`</haxe_doc>
		</get>
		<exists public="1" set="method">
			<f a="key">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.exists`</haxe_doc>
		</exists>
		<remove public="1" set="method">
			<f a="key">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.remove`</haxe_doc>
		</remove>
		<keys public="1" set="method">
			<f a=""><t path="Iterator"><c path="String"/></t></f>
			<haxe_doc>See `Map.keys`

		(cs, java) Implementation detail: Do not `set()` any new value while
		iterating, as it may cause a resize, which will break iteration.</haxe_doc>
		</keys>
		<iterator public="1" set="method">
			<f a=""><t path="Iterator"><c path="haxe.ds.StringMap.T"/></t></f>
			<haxe_doc>See `Map.iterator`

		(cs, java) Implementation detail: Do not `set()` any new value while
		iterating, as it may cause a resize, which will break iteration.</haxe_doc>
		</iterator>
		<keyValueIterator public="1" set="method">
			<f a=""><t path="KeyValueIterator">
	<c path="String"/>
	<c path="haxe.ds.StringMap.T"/>
</t></f>
			<haxe_doc>See `Map.keyValueIterator`</haxe_doc>
		</keyValueIterator>
		<copy public="1" set="method">
			<f a=""><c path="haxe.ds.StringMap"><c path="haxe.ds.StringMap.T"/></c></f>
			<haxe_doc>See `Map.copy`</haxe_doc>
		</copy>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>See `Map.toString`</haxe_doc>
		</toString>
		<clear public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>See `Map.clear`</haxe_doc>
		</clear>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new StringMap.</haxe_doc>
		</new>
		<haxe_doc>StringMap allows mapping of String keys to arbitrary values.

	See `Map` for documentation details.

	@see https://haxe.org/manual/std-Map.html</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="haxe.ds._Vector.VectorData" params="T" file="E:\HaxeToolkit\haxe\std\haxe/ds/Vector.hx" private="1" module="haxe.ds.Vector"><c path="Array"><c path="haxe.ds._Vector.VectorData.T"/></c></typedef>
	<abstract path="haxe.ds.Vector" params="T" file="E:\HaxeToolkit\haxe\std\haxe/ds/Vector.hx">
		<this><t path="haxe.ds._Vector.VectorData"><c path="haxe.ds.Vector.T"/></t></this>
		<haxe_doc>A Vector is a storage of fixed size. It can be faster than Array on some
	targets, and is never slower.

	@see https://haxe.org/manual/std-vector.html</haxe_doc>
		<impl><class path="haxe.ds._Vector.Vector_Impl_" params="" file="E:\HaxeToolkit\haxe\std\haxe/ds/Vector.hx" private="1" module="haxe.ds.Vector">
	<length public="1" get="null" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Returns the length of `this` Vector.</haxe_doc>
	</length>
	<blit public="1" params="T" set="method" line="151" static="1">
		<f a="src:srcPos:dest:destPos:len">
			<x path="haxe.ds.Vector"><c path="blit.T"/></x>
			<x path="Int"/>
			<x path="haxe.ds.Vector"><c path="blit.T"/></x>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Void"/>
		</f>
		<haxe_doc>Copies `length` of elements from `src` Vector, beginning at `srcPos` to
		`dest` Vector, beginning at `destPos`

		The results are unspecified if `length` results in out-of-bounds access,
		or if `src` or `dest` are null</haxe_doc>
	</blit>
	<meta>
		<m n=":keep"/>
		<m n=":directlyUsed"/>
	</meta>
</class></impl>
	</abstract>
	<class path="haxe.ds._Vector.Vector_Impl_" params="" file="E:\HaxeToolkit\haxe\std\haxe/ds/Vector.hx" private="1" module="haxe.ds.Vector">
		<length public="1" get="null" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Returns the length of `this` Vector.</haxe_doc>
		</length>
		<blit public="1" params="T" set="method" line="151" static="1">
			<f a="src:srcPos:dest:destPos:len">
				<x path="haxe.ds.Vector"><c path="blit.T"/></x>
				<x path="Int"/>
				<x path="haxe.ds.Vector"><c path="blit.T"/></x>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Copies `length` of elements from `src` Vector, beginning at `srcPos` to
		`dest` Vector, beginning at `destPos`

		The results are unspecified if `length` results in out-of-bounds access,
		or if `src` or `dest` are null</haxe_doc>
		</blit>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.format.JsonParser" params="" file="E:\HaxeToolkit\haxe\std\haxe/format/JsonParser.hx">
		<str><c path="String"/></str>
		<pos><x path="Int"/></pos>
		<doParse set="method" line="56"><f a=""><d/></f></doParse>
		<parseRec set="method" line="70"><f a=""><d/></f></parseRec>
		<parseString set="method" line="152"><f a=""><c path="String"/></f></parseString>
		<invalidChar set="method" line="312"><f a=""><x path="Void"/></f></invalidChar>
		<invalidNumber set="method" line="317"><f a="start">
	<x path="Int"/>
	<x path="Void"/>
</f></invalidNumber>
		<new set="method" line="51"><f a="str">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>An implementation of JSON parser in Haxe.

	This class is used by `haxe.Json` when native JSON implementation
	is not available.

	@see https://haxe.org/manual/std-Json-parsing.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.format.JsonPrinter" params="" file="E:\HaxeToolkit\haxe\std\haxe/format/JsonPrinter.hx">
		<print public="1" set="method" line="44" static="1">
			<f a="o:?replacer:?space">
				<d/>
				<f a="key:value">
					<d/>
					<d/>
					<d/>
				</f>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Encodes `o`'s value and returns the resulting JSON string.

		If `replacer` is given and is not null, it is used to retrieve
		actual object to be encoded. The `replacer` function takes two parameters,
		the key and the value being encoded. Initial key value is an empty string.

		If `space` is given and is not null, the result will be pretty-printed.
		Successive levels will be indented by this string.</haxe_doc>
		</print>
		<buf><c path="StringBuf"/></buf>
		<replacer><f a="key:value">
	<d/>
	<d/>
	<d/>
</f></replacer>
		<indent><c path="String"/></indent>
		<pretty><x path="Bool"/></pretty>
		<nind><x path="Int"/></nind>
		<write set="method" line="81"><f a="k:v">
	<d/>
	<d/>
	<x path="Void"/>
</f></write>
		<classString set="method" line="157"><f a="v">
	<d/>
	<x path="Void"/>
</f></classString>
		<fieldsString set="method" line="165"><f a="v:fields">
	<d/>
	<c path="Array"><c path="String"/></c>
	<x path="Void"/>
</f></fieldsString>
		<quote set="method" line="196"><f a="s">
	<c path="String"/>
	<x path="Void"/>
</f></quote>
		<new set="method" line="56"><f a="replacer:space">
	<f a="key:value">
		<d/>
		<d/>
		<d/>
	</f>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>An implementation of JSON printer in Haxe.

	This class is used by `haxe.Json` when native JSON implementation
	is not available.

	@see https://haxe.org/manual/std-Json-encoding.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<typedef path="haxe.io.ArrayBufferViewData" params="" file="E:\HaxeToolkit\haxe\std\haxe/io/ArrayBufferView.hx" module="haxe.io.ArrayBufferView"><c path="haxe.io.ArrayBufferViewImpl"/></typedef>
	<class path="haxe.io.ArrayBufferViewImpl" params="" file="E:\HaxeToolkit\haxe\std\haxe/io/ArrayBufferView.hx" module="haxe.io.ArrayBufferView">
		<bytes public="1"><c path="haxe.io.Bytes"/></bytes>
		<byteOffset public="1"><x path="Int"/></byteOffset>
		<byteLength public="1"><x path="Int"/></byteLength>
		<new public="1" set="method" line="32"><f a="bytes:pos:length">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":keep"/></meta>
	</class>
	<abstract path="haxe.io.ArrayBufferView" params="" file="E:\HaxeToolkit\haxe\std\haxe/io/ArrayBufferView.hx">
		<this><t path="haxe.io.ArrayBufferViewData"/></this>
		<impl><class path="haxe.io._ArrayBufferView.ArrayBufferView_Impl_" params="" file="E:\HaxeToolkit\haxe\std\haxe/io/ArrayBufferView.hx" private="1" module="haxe.io.ArrayBufferView">
	<buffer public="1" get="accessor" set="null" static="1">
		<c path="haxe.io.Bytes"/>
		<meta><m n=":impl"/></meta>
	</buffer>
	<byteOffset public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</byteOffset>
	<byteLength public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</byteLength>
	<meta><m n=":keep"/></meta>
</class></impl>
	</abstract>
	<class path="haxe.io.BytesBuffer" params="" file="E:\HaxeToolkit\haxe\std\haxe/io/BytesBuffer.hx">
		<b><c path="Array"><x path="Int"/></c></b>
		<length public="1" get="null" set="null">
			<x path="Int"/>
			<haxe_doc>The length of the buffer in bytes.</haxe_doc>
		</length>
		<addInt32 public="1" set="method" line="133"><f a="v">
	<x path="Int"/>
	<x path="Void"/>
</f></addInt32>
		<addInt64 public="1" set="method" line="144"><f a="v">
	<x path="haxe.Int64"/>
	<x path="Void"/>
</f></addInt64>
		<getBytes public="1" set="method" line="201">
			<f a=""><c path="haxe.io.Bytes"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns either a copy or a reference of the current bytes.
		Once called, the buffer should no longer be used.</haxe_doc>
		</getBytes>
		<new public="1" set="method" line="45"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<typedef path="haxe.io.BytesData" params="" file="E:\HaxeToolkit\haxe\std\haxe/io/BytesData.hx"><c path="Array"><x path="Int"/></c></typedef>
	<class path="haxe.io.Input" params="" file="E:\HaxeToolkit\haxe\std\haxe/io/Input.hx">
		<bigEndian public="1" set="accessor">
			<x path="Bool"/>
			<haxe_doc>Endianness (word byte order) used when reading numbers.

		If `true`, big-endian is used, otherwise `little-endian` is used.</haxe_doc>
		</bigEndian>
		<readByte public="1" set="method" line="49">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Read and return one byte.</haxe_doc>
		</readByte>
		<readBytes public="1" set="method" line="64">
			<f a="s:pos:len">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Read `len` bytes and write them into `s` to the position specified by `pos`.

		Returns the actual length of read data that can be smaller than `len`.

		See `readFullBytes` that tries to read the exact amount of specified bytes.</haxe_doc>
		</readBytes>
		<close public="1" set="method" line="92">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Close the input source.

		Behaviour while reading after calling this method is unspecified.</haxe_doc>
		</close>
		<set_bigEndian set="method" line="94"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_bigEndian>
		<readAll public="1" set="method" line="106">
			<f a="?bufsize">
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>Read and return all available data.

		The `bufsize` optional argument specifies the size of chunks by
		which data is read. Its default value is target-specific.</haxe_doc>
		</readAll>
		<readFullBytes public="1" set="method" line="132">
			<f a="s:pos:len">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Read `len` bytes and write them into `s` to the position specified by `pos`.

		Unlike `readBytes`, this method tries to read the exact `len` amount of bytes.</haxe_doc>
		</readFullBytes>
		<read public="1" set="method" line="145">
			<f a="nbytes">
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>Read and return `nbytes` bytes.</haxe_doc>
		</read>
		<readUntil public="1" set="method" line="163">
			<f a="end">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Read a string until a character code specified by `end` is occurred.

		The final character is not included in the resulting string.</haxe_doc>
		</readUntil>
		<readFloat public="1" set="method" line="199">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Read a 32-bit floating point number.

		Endianness is specified by the `bigEndian` property.</haxe_doc>
		</readFloat>
		<readDouble public="1" set="method" line="208">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Read a 64-bit double-precision floating point number.

		Endianness is specified by the `bigEndian` property.</haxe_doc>
		</readDouble>
		<readInt16 public="1" set="method" line="229">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Read a 16-bit signed integer.

		Endianness is specified by the `bigEndian` property.</haxe_doc>
		</readInt16>
		<readUInt16 public="1" set="method" line="243">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Read a 16-bit unsigned integer.

		Endianness is specified by the `bigEndian` property.</haxe_doc>
		</readUInt16>
		<readUInt24 public="1" set="method" line="269">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Read a 24-bit unsigned integer.

		Endianness is specified by the `bigEndian` property.</haxe_doc>
		</readUInt24>
		<readInt32 public="1" set="method" line="281">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Read a 32-bit signed integer.

		Endianness is specified by the `bigEndian` property.</haxe_doc>
		</readInt32>
		<readString public="1" set="method" line="304">
			<f a="len:?encoding">
				<x path="Int"/>
				<e path="haxe.io.Encoding"/>
				<c path="String"/>
			</f>
			<haxe_doc>Read and `len` bytes as a string.</haxe_doc>
		</readString>
		<haxe_doc>An Input is an abstract reader. See other classes in the `haxe.io` package
	for several possible implementations.

	All functions which read data throw `Eof` when the end of the stream
	is reached.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.io.BytesInput" params="" file="E:\HaxeToolkit\haxe\std\haxe/io/BytesInput.hx">
		<extends path="haxe.io.Input"/>
		<b><t path="haxe.io.BytesData"/></b>
		<pos><x path="Int"/></pos>
		<len><x path="Int"/></len>
		<totlen><x path="Int"/></totlen>
		<position public="1" get="null" set="accessor">
			<x path="Int"/>
			<haxe_doc>The current position in the stream in bytes.</haxe_doc>
		</position>
		<length public="1" get="null" set="null">
			<x path="Int"/>
			<haxe_doc>The length of the stream in bytes.</haxe_doc>
		</length>
		<set_position set="method" line="83"><f a="p">
	<x path="Int"/>
	<x path="Int"/>
</f></set_position>
		<readByte public="1" set="method" line="96" override="1"><f a=""><x path="Int"/></f></readByte>
		<readBytes public="1" set="method" line="119" override="1"><f a="buf:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></readBytes>
		<new public="1" set="method" line="39"><f a="b:?pos:?len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.io.Output" params="" file="E:\HaxeToolkit\haxe\std\haxe/io/Output.hx">
		<bigEndian public="1" set="accessor">
			<x path="Bool"/>
			<haxe_doc>Endianness (word byte order) used when writing numbers.

		If `true`, big-endian is used, otherwise `little-endian` is used.</haxe_doc>
		</bigEndian>
		<writeByte public="1" set="method" line="46">
			<f a="c">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write one byte.</haxe_doc>
		</writeByte>
		<writeBytes public="1" set="method" line="57">
			<f a="s:pos:len">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Write `len` bytes from `s` starting by position specified by `pos`.

		Returns the actual length of written data that can differ from `len`.

		See `writeFullBytes` that tries to write the exact amount of specified bytes.</haxe_doc>
		</writeBytes>
		<flush public="1" set="method" line="85">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Flush any buffered data.</haxe_doc>
		</flush>
		<close public="1" set="method" line="92">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Close the output.

		Behaviour while writing after calling this method is unspecified.</haxe_doc>
		</close>
		<set_bigEndian set="method" line="94"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_bigEndian>
		<write public="1" set="method" line="103">
			<f a="s">
				<c path="haxe.io.Bytes"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write all bytes stored in `s`.</haxe_doc>
		</write>
		<writeFullBytes public="1" set="method" line="120">
			<f a="s:pos:len">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write `len` bytes from `s` starting by position specified by `pos`.

		Unlike `writeBytes`, this method tries to write the exact `len` amount of bytes.</haxe_doc>
		</writeFullBytes>
		<writeFloat public="1" set="method" line="133">
			<f a="x">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write `x` as 32-bit floating point number.

		Endianness is specified by the `bigEndian` property.</haxe_doc>
		</writeFloat>
		<writeInt16 public="1" set="method" line="167">
			<f a="x">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write `x` as 16-bit signed integer.

		Endianness is specified by the `bigEndian` property.</haxe_doc>
		</writeInt16>
		<writeUInt16 public="1" set="method" line="178">
			<f a="x">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write `x` as 16-bit unsigned integer.

		Endianness is specified by the `bigEndian` property.</haxe_doc>
		</writeUInt16>
		<writeInt32 public="1" set="method" line="225">
			<f a="x">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write `x` as 32-bit signed integer.

		Endianness is specified by the `bigEndian` property.</haxe_doc>
		</writeInt32>
		<writeString public="1" set="method" line="278">
			<f a="s:?encoding">
				<c path="String"/>
				<e path="haxe.io.Encoding"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write `s` string.</haxe_doc>
		</writeString>
		<haxe_doc>An Output is an abstract write. A specific output implementation will only
	have to override the `writeByte` and maybe the `write`, `flush` and `close`
	methods. See `File.write` and `String.write` for two ways of creating an
	Output.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.io.BytesOutput" params="" file="E:\HaxeToolkit\haxe\std\haxe/io/BytesOutput.hx">
		<extends path="haxe.io.Output"/>
		<b><c path="haxe.io.BytesBuffer"/></b>
		<length public="1" get="null" set="null">
			<x path="Int"/>
			<haxe_doc>The length of the stream in bytes.</haxe_doc>
		</length>
		<writeByte public="1" set="method" line="51" override="1"><f a="c">
	<x path="Int"/>
	<x path="Void"/>
</f></writeByte>
		<writeBytes public="1" set="method" line="59" override="1"><f a="buf:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></writeBytes>
		<getBytes public="1" set="method" line="137">
			<f a=""><c path="haxe.io.Bytes"/></f>
			<haxe_doc>Returns the `Bytes` of this output.

		This function should not be called more than once on a given
		`BytesOutput` instance.</haxe_doc>
		</getBytes>
		<new public="1" set="method" line="35"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<enum path="haxe.io.Encoding" params="" file="E:\HaxeToolkit\haxe\std\haxe/io/Encoding.hx">
		<UTF8/>
		<RawNative><haxe_doc>Output the string the way the platform represent it in memory. This is the most efficient but is platform-specific</haxe_doc></RawNative>
		<haxe_doc>String binary encoding supported by Haxe I/O</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="haxe.io.Eof" params="" file="E:\HaxeToolkit\haxe\std\haxe/io/Eof.hx">
		<toString set="method" line="32">
			<f a=""><c path="String"/></f>
			<meta><m n=":ifFeature"><e>"haxe.io.Eof.*"</e></m></meta>
		</toString>
		<new public="1" set="method" line="29"><f a=""><x path="Void"/></f></new>
		<haxe_doc>This exception is raised when reading while data is no longer available in the `haxe.io.Input`.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<enum path="haxe.io.Error" params="" file="E:\HaxeToolkit\haxe\std\haxe/io/Error.hx">
		<Blocked><haxe_doc>The IO is set into nonblocking mode and some data cannot be read or written</haxe_doc></Blocked>
		<Overflow><haxe_doc>An integer value is outside its allowed range</haxe_doc></Overflow>
		<OutsideBounds><haxe_doc>An operation on Bytes is outside of its valid range</haxe_doc></OutsideBounds>
		<Custom a="e">
			<d/>
			<haxe_doc>Other errors</haxe_doc>
		</Custom>
		<haxe_doc>The possible IO errors that can occur</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<class path="haxe.io.FPHelper" params="" file="E:\HaxeToolkit\haxe\std\haxe/io/FPHelper.hx">
		<i64tmp expr="Int64.ofInt(0)" line="35" static="1">
			<x path="haxe.Int64"/>
			<meta><m n=":value"><e>Int64.ofInt(0)</e></m></meta>
		</i64tmp>
		<i32ToFloat public="1" set="method" line="133" static="1"><f a="i">
	<x path="Int"/>
	<x path="Float"/>
</f></i32ToFloat>
		<floatToI32 public="1" set="method" line="177" static="1"><f a="f">
	<x path="Float"/>
	<x path="Int"/>
</f></floatToI32>
		<i64ToDouble public="1" set="method" line="214" static="1"><f a="low:high">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
</f></i64ToDouble>
		<doubleToI64 public="1" set="method" line="268" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="haxe.Int64"/>
			</f>
			<haxe_doc>Returns an Int64 representing the bytes representation of the double precision IEEE float value.
		WARNING : for performance reason, the same Int64 value might be reused every time. Copy its low/high values before calling again.
		We still ensure that this is safe to use in a multithread environment</haxe_doc>
		</doubleToI64>
		<haxe_doc>Helper that converts between floating point and binary representation.
	Always works in low-endian encoding.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<typedef path="haxe.io.Float32ArrayData" params="" file="E:\HaxeToolkit\haxe\std\haxe/io/Float32Array.hx" module="haxe.io.Float32Array"><t path="haxe.io.ArrayBufferViewData"/></typedef>
	<abstract path="haxe.io.Float32Array" params="" file="E:\HaxeToolkit\haxe\std\haxe/io/Float32Array.hx">
		<this><t path="haxe.io.Float32ArrayData"/></this>
		<impl><class path="haxe.io._Float32Array.Float32Array_Impl_" params="" file="E:\HaxeToolkit\haxe\std\haxe/io/Float32Array.hx" private="1" module="haxe.io.Float32Array">
	<length public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</length>
	<view public="1" get="accessor" set="null" static="1">
		<x path="haxe.io.ArrayBufferView"/>
		<meta><m n=":impl"/></meta>
	</view>
	<meta><m n=":keep"/></meta>
</class></impl>
	</abstract>
	<class path="haxe.io.Path" params="" file="E:\HaxeToolkit\haxe\std\haxe/io/Path.hx">
		<withoutDirectory public="1" set="method" line="134" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the String representation of `path` without the directory.

		If `path` is `null`, the result is unspecified.</haxe_doc>
		</withoutDirectory>
		<directory public="1" set="method" line="147" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the directory of `path`.

		If the directory is `null`, the empty String `""` is returned.

		If `path` is `null`, the result is unspecified.</haxe_doc>
		</directory>
		<withExtension public="1" set="method" line="175" static="1">
			<f a="path:ext">
				<c path="String"/>
				<x path="Null"><c path="String"/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a String representation of `path` where the extension is `ext`.

		If `path` has no extension, `ext` is added as extension.

		If `path` or `ext` are `null`, the result is unspecified.</haxe_doc>
		</withExtension>
		<join public="1" set="method" line="189" static="1">
			<f a="paths">
				<c path="Array"><c path="String"/></c>
				<c path="String"/>
			</f>
			<haxe_doc>Joins all paths in `paths` together.

		If `paths` is empty, the empty String `""` is returned. Otherwise the
		paths are joined with a slash between them.

		If `paths` is `null`, the result is unspecified.</haxe_doc>
		</join>
		<normalize public="1" set="method" line="210" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Normalize a given `path` (e.g. turn `'/usr/local/../lib'` into `'/usr/lib'`).

		Also replaces backslashes `\` with slashes `/` and afterwards turns
		multiple slashes into a single one.

		If `path` is `null`, the result is unspecified.</haxe_doc>
		</normalize>
		<addTrailingSlash public="1" set="method" line="271" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Adds a trailing slash to `path`, if it does not have one already.

		If the last slash in `path` is a backslash, a backslash is appended to
		`path`.

		If the last slash in `path` is a slash, or if no slash is found, a slash
		is appended to `path`. In particular, this applies to the empty String
		`""`.

		If `path` is `null`, the result is unspecified.</haxe_doc>
		</addTrailingSlash>
		<isAbsolute public="1" set="method" line="314" static="1">
			<f a="path">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns `true` if the path is an absolute path, and `false` otherwise.</haxe_doc>
		</isAbsolute>
		<dir public="1">
			<x path="Null"><c path="String"/></x>
			<haxe_doc>The directory.

		This is the leading part of the path that is not part of the file name
		and the extension.

		Does not end with a `/` or `\` separator.

		If the path has no directory, the value is `null`.</haxe_doc>
		</dir>
		<file public="1">
			<c path="String"/>
			<haxe_doc>The file name.

		This is the part of the part between the directory and the extension.

		If there is no file name, e.g. for `".htaccess"` or `"/dir/"`, the value
		is the empty String `""`.</haxe_doc>
		</file>
		<ext public="1">
			<x path="Null"><c path="String"/></x>
			<haxe_doc>The file extension.

		It is separated from the file name by a dot. This dot is not part of
		the extension.

		If the path has no extension, the value is `null`.</haxe_doc>
		</ext>
		<backslash public="1">
			<x path="Bool"/>
			<haxe_doc>`true` if the last directory separator is a backslash, `false` otherwise.</haxe_doc>
		</backslash>
		<toString public="1" set="method" line="114">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String representation of `this` path.

		If `this.backslash` is `true`, backslash is used as directory separator,
		otherwise slash is used. This only affects the separator between
		`this.dir` and `this.file`.

		If `this.directory` or `this.extension` is `null`, their representation
		is the empty String `""`.</haxe_doc>
		</toString>
		<new public="1" set="method" line="76">
			<f a="path">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new `Path` instance by parsing `path`.

		Path information can be retrieved by accessing the `dir`, `file` and `ext`
		properties.</haxe_doc>
		</new>
		<haxe_doc>This class provides a convenient way of working with paths. It supports the
	common path formats:

	- `directory1/directory2/filename.extension`
	- `directory1\directory2\filename.extension`</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.io.StringInput" params="" file="E:\HaxeToolkit\haxe\std\haxe/io/StringInput.hx">
		<extends path="haxe.io.BytesInput"/>
		<new public="1" set="method" line="26"><f a="s">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<typedef path="haxe.macro.Position" params="" file="E:\HaxeToolkit\haxe\std\haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<min>
				<x path="Int"/>
				<haxe_doc>Position of the first character.</haxe_doc>
			</min>
			<max>
				<x path="Int"/>
				<haxe_doc>Position of the last character.</haxe_doc>
			</max>
			<file>
				<c path="String"/>
				<haxe_doc>Reference to the filename.</haxe_doc>
			</file>
		</a>
		<haxe_doc>Represents a position in a file.</haxe_doc>
	</typedef>
	<enum path="haxe.macro.Binop" params="" file="E:\HaxeToolkit\haxe\std\haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<OpAdd><haxe_doc>`+`</haxe_doc></OpAdd>
		<OpMult><haxe_doc>`*`</haxe_doc></OpMult>
		<OpDiv><haxe_doc>`/`</haxe_doc></OpDiv>
		<OpSub><haxe_doc>`-`</haxe_doc></OpSub>
		<OpAssign><haxe_doc>`=`</haxe_doc></OpAssign>
		<OpEq><haxe_doc>`==`</haxe_doc></OpEq>
		<OpNotEq><haxe_doc>`!=`</haxe_doc></OpNotEq>
		<OpGt><haxe_doc><![CDATA[`>`]]></haxe_doc></OpGt>
		<OpGte><haxe_doc><![CDATA[`>=`]]></haxe_doc></OpGte>
		<OpLt><haxe_doc><![CDATA[`<`]]></haxe_doc></OpLt>
		<OpLte><haxe_doc><![CDATA[`<=`]]></haxe_doc></OpLte>
		<OpAnd><haxe_doc><![CDATA[`&`]]></haxe_doc></OpAnd>
		<OpOr><haxe_doc>`|`</haxe_doc></OpOr>
		<OpXor><haxe_doc>`^`</haxe_doc></OpXor>
		<OpBoolAnd><haxe_doc><![CDATA[`&&`]]></haxe_doc></OpBoolAnd>
		<OpBoolOr><haxe_doc>`||`</haxe_doc></OpBoolOr>
		<OpShl><haxe_doc><![CDATA[`<<`]]></haxe_doc></OpShl>
		<OpShr><haxe_doc><![CDATA[`>>`]]></haxe_doc></OpShr>
		<OpUShr><haxe_doc><![CDATA[`>>>`]]></haxe_doc></OpUShr>
		<OpMod><haxe_doc>`%`</haxe_doc></OpMod>
		<OpAssignOp a="op">
			<e path="haxe.macro.Binop"/>
			<haxe_doc><![CDATA[`+=`
		`-=`
		`/=`
		`*=`
		`<<=`
		`>>=`
		`>>>=`
		`|=`
		`&=`
		`^=`
		`%=`]]></haxe_doc>
		</OpAssignOp>
		<OpInterval><haxe_doc>`...`</haxe_doc></OpInterval>
		<OpArrow><haxe_doc><![CDATA[`=>`]]></haxe_doc></OpArrow>
		<OpIn><haxe_doc>`in`</haxe_doc></OpIn>
		<haxe_doc>A binary operator.
	@see https://haxe.org/manual/types-numeric-operators.html</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<enum path="haxe.macro.Unop" params="" file="E:\HaxeToolkit\haxe\std\haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<OpIncrement><haxe_doc>`++`</haxe_doc></OpIncrement>
		<OpDecrement><haxe_doc>`--`</haxe_doc></OpDecrement>
		<OpNot><haxe_doc>`!`</haxe_doc></OpNot>
		<OpNeg><haxe_doc>`-`</haxe_doc></OpNeg>
		<OpNegBits><haxe_doc>`~`</haxe_doc></OpNegBits>
		<haxe_doc>A unary operator.
	@see https://haxe.org/manual/types-numeric-operators.html</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<typedef path="haxe.macro.Expr" params="" file="E:\HaxeToolkit\haxe\std\haxe/macro/Expr.hx">
		<a>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the expression.</haxe_doc>
			</pos>
			<expr>
				<e path="haxe.macro.ExprDef"/>
				<haxe_doc>The expression kind.</haxe_doc>
			</expr>
		</a>
		<haxe_doc>Represents a node in the AST.
	@see https://haxe.org/manual/macro-reification-expression.html</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.ExprOf" params="T" file="E:\HaxeToolkit\haxe\std\haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<t path="haxe.macro.Expr"/>
		<haxe_doc>Represents a AST node identical to `Expr`, but it allows constraining the
	type of accepted expressions.
	@see https://haxe.org/manual/macro-ExprOf.html</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.Case" params="" file="E:\HaxeToolkit\haxe\std\haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<values>
				<c path="Array"><t path="haxe.macro.Expr"/></c>
				<haxe_doc>The value expressions of the case.</haxe_doc>
			</values>
			<guard>
				<x path="Null"><t path="haxe.macro.Expr"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional guard expressions of the case, if available.</haxe_doc>
			</guard>
			<expr>
				<x path="Null"><t path="haxe.macro.Expr"/></x>
				<haxe_doc>The expression of the case, if available.</haxe_doc>
			</expr>
		</a>
		<haxe_doc>Represents a switch case.
	@see https://haxe.org/manual/expression-switch.html</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.Var" params="" file="E:\HaxeToolkit\haxe\std\haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<type>
				<x path="Null"><e path="haxe.macro.ComplexType"/></x>
				<haxe_doc>The type-hint of the variable, if available.</haxe_doc>
			</type>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the variable.</haxe_doc>
			</name>
			<isFinal>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Whether or not the variable can be assigned to.</haxe_doc>
			</isFinal>
			<expr>
				<x path="Null"><t path="haxe.macro.Expr"/></x>
				<haxe_doc>The expression of the variable, if available.</haxe_doc>
			</expr>
		</a>
		<haxe_doc>Represents a variable in the AST.
	@see https://haxe.org/manual/expression-var.html</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.Catch" params="" file="E:\HaxeToolkit\haxe\std\haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<type>
				<e path="haxe.macro.ComplexType"/>
				<haxe_doc>The type of the catch.</haxe_doc>
			</type>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the catch variable.</haxe_doc>
			</name>
			<expr>
				<t path="haxe.macro.Expr"/>
				<haxe_doc>The expression of the catch.</haxe_doc>
			</expr>
		</a>
		<haxe_doc>Represents a catch in the AST.
	@https://haxe.org/manual/expression-try-catch.html</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.ObjectField" params="" file="E:\HaxeToolkit\haxe\std\haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<quotes>
				<x path="Null"><e path="haxe.macro.QuoteStatus"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>How the field name is quoted.</haxe_doc>
			</quotes>
			<field>
				<c path="String"/>
				<haxe_doc>The name of the field.</haxe_doc>
			</field>
			<expr>
				<t path="haxe.macro.Expr"/>
				<haxe_doc>The field expression.</haxe_doc>
			</expr>
		</a>
		<haxe_doc>Represents the field of an object declaration.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.TypePath" params="" file="E:\HaxeToolkit\haxe\std\haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<sub>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Sub is set on module sub-type access:
		`pack.Module.Type` has name = Module, sub = Type, if available.</haxe_doc>
			</sub>
			<params>
				<x path="Null"><c path="Array"><e path="haxe.macro.TypeParam"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Optional parameters of the type path.</haxe_doc>
			</params>
			<pack>
				<c path="Array"><c path="String"/></c>
				<haxe_doc>Represents the package of the type path.</haxe_doc>
			</pack>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the type path.</haxe_doc>
			</name>
		</a>
		<haxe_doc>Represents a type path in the AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.TypeParamDecl" params="" file="E:\HaxeToolkit\haxe\std\haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<params>
				<x path="Null"><c path="Array"><t path="haxe.macro.TypeParamDecl"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional parameters of the type parameter.</haxe_doc>
			</params>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the type parameter.</haxe_doc>
			</name>
			<meta>
				<x path="Null"><t path="haxe.macro.Metadata"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The metadata of the type parameter.</haxe_doc>
			</meta>
			<constraints>
				<x path="Null"><c path="Array"><e path="haxe.macro.ComplexType"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional constraints of the type parameter.</haxe_doc>
			</constraints>
		</a>
		<haxe_doc>Represents a type parameter declaration in the AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.Function" params="" file="E:\HaxeToolkit\haxe\std\haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<ret>
				<x path="Null"><e path="haxe.macro.ComplexType"/></x>
				<haxe_doc>The return type-hint of the function, if available.</haxe_doc>
			</ret>
			<params>
				<x path="Null"><c path="Array"><t path="haxe.macro.TypeParamDecl"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional list of function parameter type declarations.</haxe_doc>
			</params>
			<expr>
				<x path="Null"><t path="haxe.macro.Expr"/></x>
				<haxe_doc>The expression of the function body, if available.</haxe_doc>
			</expr>
			<args>
				<c path="Array"><t path="haxe.macro.FunctionArg"/></c>
				<haxe_doc>A list of function arguments.</haxe_doc>
			</args>
		</a>
		<haxe_doc>Represents a function in the AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.FunctionArg" params="" file="E:\HaxeToolkit\haxe\std\haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<value>
				<x path="Null"><t path="haxe.macro.Expr"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional value of the function argument, if available.</haxe_doc>
			</value>
			<type>
				<x path="Null"><e path="haxe.macro.ComplexType"/></x>
				<haxe_doc>The type-hint of the function argument, if available.</haxe_doc>
			</type>
			<opt>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Whether or not the function argument is optional.</haxe_doc>
			</opt>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the function argument.</haxe_doc>
			</name>
			<meta>
				<x path="Null"><t path="haxe.macro.Metadata"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The metadata of the function argument.</haxe_doc>
			</meta>
		</a>
		<haxe_doc>Represents a function argument in the AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.MetadataEntry" params="" file="E:\HaxeToolkit\haxe\std\haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the metadata entry.</haxe_doc>
			</pos>
			<params>
				<x path="Null"><c path="Array"><t path="haxe.macro.Expr"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional parameters of the metadata entry.</haxe_doc>
			</params>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the metadata entry.</haxe_doc>
			</name>
		</a>
		<haxe_doc>Represents a metadata entry in the AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.Metadata" params="" file="E:\HaxeToolkit\haxe\std\haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<c path="Array"><t path="haxe.macro.MetadataEntry"/></c>
		<haxe_doc>Represents metadata in the AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.Field" params="" file="E:\HaxeToolkit\haxe\std\haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the field.</haxe_doc>
			</pos>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the field.</haxe_doc>
			</name>
			<meta>
				<x path="Null"><t path="haxe.macro.Metadata"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional metadata of the field.</haxe_doc>
			</meta>
			<kind>
				<e path="haxe.macro.FieldType"/>
				<haxe_doc>The kind of the field.</haxe_doc>
			</kind>
			<doc>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The documentation of the field, if available. If the field has no
		documentation, the value is `null`.</haxe_doc>
			</doc>
			<access>
				<x path="Null"><c path="Array"><e path="haxe.macro.Access"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The access modifiers of the field. By default fields have private access.
		@see https://haxe.org/manual/class-field-access-modifier.html</haxe_doc>
			</access>
		</a>
		<haxe_doc>Represents a field in the AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.TypeDefinition" params="" file="E:\HaxeToolkit\haxe\std\haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position to the type definition.</haxe_doc>
			</pos>
			<params>
				<x path="Null"><c path="Array"><t path="haxe.macro.TypeParamDecl"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The parameter type declarations of the type definition.</haxe_doc>
			</params>
			<pack>
				<c path="Array"><c path="String"/></c>
				<haxe_doc>The package of the type definition.</haxe_doc>
			</pack>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the type definition.</haxe_doc>
			</name>
			<meta>
				<x path="Null"><t path="haxe.macro.Metadata"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional metadata of the type definition.</haxe_doc>
			</meta>
			<kind>
				<e path="haxe.macro.TypeDefKind"/>
				<haxe_doc>The kind of the type definition.</haxe_doc>
			</kind>
			<isExtern>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Whether or not the type is extern.</haxe_doc>
			</isExtern>
			<fields>
				<c path="Array"><t path="haxe.macro.Field"/></c>
				<haxe_doc>The fields of the type definition.</haxe_doc>
			</fields>
			<doc>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The documentation of the type, if available. If the type has no
		documentation, the value is `null`.</haxe_doc>
			</doc>
		</a>
		<haxe_doc>Represents a type definition.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.ImportExpr" params="" file="E:\HaxeToolkit\haxe\std\haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<path>
				<c path="Array"><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<name><c path="String"/></name>
</a></c>
				<haxe_doc>The path to the import expression.</haxe_doc>
			</path>
			<mode>
				<e path="haxe.macro.ImportMode"/>
				<haxe_doc>The mode of the import expression.</haxe_doc>
			</mode>
		</a>
		<haxe_doc>Represents the import expression.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.Ref" params="T" file="E:\HaxeToolkit\haxe\std\haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<toString set="method"><f a=""><c path="String"/></f></toString>
			<get set="method"><f a=""><c path="haxe.macro.Ref.T"/></f></get>
		</a>
		<haxe_doc>Represents a reference to internal compiler structure. It exists to avoid
	expensive encoding if it is not required and to ensure that physical
	equality remains intact.

	A structure is only encoded when user requests it through `ref.get()`.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.AnonType" params="" file="E:\HaxeToolkit\haxe\std\haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<status>
				<e path="haxe.macro.AnonStatus"/>
				<haxe_doc>The status/kind of the structure.</haxe_doc>
			</status>
			<fields>
				<c path="Array"><t path="haxe.macro.ClassField"/></c>
				<haxe_doc>The class fields of the structure.</haxe_doc>
			</fields>
		</a>
		<haxe_doc>Represents information for anonymous structure types.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.TypeParameter" params="" file="E:\HaxeToolkit\haxe\std\haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<t>
				<e path="haxe.macro.Type"/>
				<haxe_doc>The type of the type parameter. It is guaranteed to be a `TInst` with a
		`KTypeParameter` kind.</haxe_doc>
			</t>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the type parameter.</haxe_doc>
			</name>
		</a>
		<haxe_doc>Represents the declaration of type parameters.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.ClassField" params="" file="E:\HaxeToolkit\haxe\std\haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<type>
				<e path="haxe.macro.Type"/>
				<haxe_doc>The type of the class field.</haxe_doc>
			</type>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the class field.</haxe_doc>
			</pos>
			<params>
				<c path="Array"><t path="haxe.macro.TypeParameter"/></c>
				<haxe_doc>The type parameters of the class field.</haxe_doc>
			</params>
			<overloads>
				<t path="haxe.macro.Ref"><c path="Array"><t path="haxe.macro.ClassField"/></c></t>
				<haxe_doc>The overload fields of the class field.</haxe_doc>
			</overloads>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the class field.</haxe_doc>
			</name>
			<meta>
				<t path="haxe.macro.MetaAccess"/>
				<haxe_doc>The metadata of the class field.</haxe_doc>
			</meta>
			<kind>
				<e path="haxe.macro.FieldKind"/>
				<haxe_doc>The class field kind.</haxe_doc>
			</kind>
			<isPublic>
				<x path="Bool"/>
				<haxe_doc>Whether or not the class field is public.</haxe_doc>
			</isPublic>
			<isFinal>
				<x path="Bool"/>
				<haxe_doc>Whether or not the class field is final.</haxe_doc>
			</isFinal>
			<isExtern>
				<x path="Bool"/>
				<haxe_doc>Whether or not the class field is extern.</haxe_doc>
			</isExtern>
			<expr set="method">
				<f a=""><x path="Null"><t path="haxe.macro.TypedExpr"/></x></f>
				<haxe_doc>Returns the typed expression of the class field.</haxe_doc>
			</expr>
			<doc>
				<x path="Null"><c path="String"/></x>
				<haxe_doc>The associated documentation of the class field.</haxe_doc>
			</doc>
		</a>
		<haxe_doc>Represents a class field.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.EnumField" params="" file="E:\HaxeToolkit\haxe\std\haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<type>
				<e path="haxe.macro.Type"/>
				<haxe_doc>The type of the enum constructor.</haxe_doc>
			</type>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the enum constructor.</haxe_doc>
			</pos>
			<params>
				<c path="Array"><t path="haxe.macro.TypeParameter"/></c>
				<haxe_doc>The type parameters of the enum constructor.</haxe_doc>
			</params>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the enum constructor.</haxe_doc>
			</name>
			<meta>
				<t path="haxe.macro.MetaAccess"/>
				<haxe_doc>The metadata of the enum constructor.</haxe_doc>
			</meta>
			<index>
				<x path="Int"/>
				<haxe_doc>The index of the enum constructor, i.e. in which position it appears
		in the syntax.</haxe_doc>
			</index>
			<doc>
				<x path="Null"><c path="String"/></x>
				<haxe_doc>The associated documentation of the enum constructor.</haxe_doc>
			</doc>
		</a>
		<haxe_doc>Represents an enum constructor.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.BaseType" params="" file="E:\HaxeToolkit\haxe\std\haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the type.</haxe_doc>
			</pos>
			<params>
				<c path="Array"><t path="haxe.macro.TypeParameter"/></c>
				<haxe_doc>The type parameters of the type.</haxe_doc>
			</params>
			<pack>
				<c path="Array"><c path="String"/></c>
				<haxe_doc>The package of the type.</haxe_doc>
			</pack>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the type.</haxe_doc>
			</name>
			<module>
				<c path="String"/>
				<haxe_doc>The module name of the type, which might be different.</haxe_doc>
			</module>
			<meta>
				<t path="haxe.macro.MetaAccess"/>
				<haxe_doc>The metadata of the type.</haxe_doc>
			</meta>
			<isPrivate>
				<x path="Bool"/>
				<haxe_doc>Whether or not the type is private.</haxe_doc>
			</isPrivate>
			<isExtern>
				<x path="Bool"/>
				<haxe_doc>Whether or not the type is extern.</haxe_doc>
			</isExtern>
			<exclude set="method">
				<f a=""><x path="Void"/></f>
				<haxe_doc>Allows excluding the type from compilation.</haxe_doc>
			</exclude>
			<doc>
				<x path="Null"><c path="String"/></x>
				<haxe_doc>The associated documentation of the class field.</haxe_doc>
			</doc>
		</a>
		<haxe_doc>The information that all types (`ClassType`, `EnumType`, `DefType`,
	`AbstractType`) have in common.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.ClassType" params="" file="E:\HaxeToolkit\haxe\std\haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<superClass>
				<x path="Null"><a>
	<t><t path="haxe.macro.Ref"><t path="haxe.macro.ClassType"/></t></t>
	<params><c path="Array"><e path="haxe.macro.Type"/></c></params>
</a></x>
				<haxe_doc>The parent class and its type parameters, if available.</haxe_doc>
			</superClass>
			<statics>
				<t path="haxe.macro.Ref"><c path="Array"><t path="haxe.macro.ClassField"/></c></t>
				<haxe_doc>The static fields of the class.</haxe_doc>
			</statics>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the type.</haxe_doc>
			</pos>
			<params>
				<c path="Array"><t path="haxe.macro.TypeParameter"/></c>
				<haxe_doc>The type parameters of the type.</haxe_doc>
			</params>
			<pack>
				<c path="Array"><c path="String"/></c>
				<haxe_doc>The package of the type.</haxe_doc>
			</pack>
			<overrides>
				<c path="Array"><t path="haxe.macro.Ref"><t path="haxe.macro.ClassField"/></t></c>
				<haxe_doc>The list of fields that have override status.</haxe_doc>
			</overrides>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the type.</haxe_doc>
			</name>
			<module>
				<c path="String"/>
				<haxe_doc>The module name of the type, which might be different.</haxe_doc>
			</module>
			<meta>
				<t path="haxe.macro.MetaAccess"/>
				<haxe_doc>The metadata of the type.</haxe_doc>
			</meta>
			<kind>
				<e path="haxe.macro.ClassKind"/>
				<haxe_doc>The kind of the class.</haxe_doc>
			</kind>
			<isPrivate>
				<x path="Bool"/>
				<haxe_doc>Whether or not the type is private.</haxe_doc>
			</isPrivate>
			<isInterface>
				<x path="Bool"/>
				<haxe_doc>If true the type is an interface, otherwise it is a class.</haxe_doc>
			</isInterface>
			<isFinal>
				<x path="Bool"/>
				<haxe_doc>If true the class is final and cannot be extended.</haxe_doc>
			</isFinal>
			<isExtern>
				<x path="Bool"/>
				<haxe_doc>Whether or not the type is extern.</haxe_doc>
			</isExtern>
			<interfaces>
				<c path="Array"><a>
	<t><t path="haxe.macro.Ref"><t path="haxe.macro.ClassType"/></t></t>
	<params><c path="Array"><e path="haxe.macro.Type"/></c></params>
</a></c>
				<haxe_doc>The implemented interfaces and their type parameters.</haxe_doc>
			</interfaces>
			<init>
				<x path="Null"><t path="haxe.macro.TypedExpr"/></x>
				<haxe_doc>The `__init__` expression of the class, if available.</haxe_doc>
			</init>
			<fields>
				<t path="haxe.macro.Ref"><c path="Array"><t path="haxe.macro.ClassField"/></c></t>
				<haxe_doc>The member fields of the class.</haxe_doc>
			</fields>
			<exclude set="method">
				<f a=""><x path="Void"/></f>
				<haxe_doc>Allows excluding the type from compilation.</haxe_doc>
			</exclude>
			<doc>
				<x path="Null"><c path="String"/></x>
				<haxe_doc>The associated documentation of the class field.</haxe_doc>
			</doc>
			<constructor>
				<x path="Null"><t path="haxe.macro.Ref"><t path="haxe.macro.ClassField"/></t></x>
				<haxe_doc>The constructor of the class, if available.</haxe_doc>
			</constructor>
		</a>
		<haxe_doc>Represents a class type.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.EnumType" params="" file="E:\HaxeToolkit\haxe\std\haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the type.</haxe_doc>
			</pos>
			<params>
				<c path="Array"><t path="haxe.macro.TypeParameter"/></c>
				<haxe_doc>The type parameters of the type.</haxe_doc>
			</params>
			<pack>
				<c path="Array"><c path="String"/></c>
				<haxe_doc>The package of the type.</haxe_doc>
			</pack>
			<names>
				<c path="Array"><c path="String"/></c>
				<haxe_doc>An ordered list of enum constructor names.</haxe_doc>
			</names>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the type.</haxe_doc>
			</name>
			<module>
				<c path="String"/>
				<haxe_doc>The module name of the type, which might be different.</haxe_doc>
			</module>
			<meta>
				<t path="haxe.macro.MetaAccess"/>
				<haxe_doc>The metadata of the type.</haxe_doc>
			</meta>
			<isPrivate>
				<x path="Bool"/>
				<haxe_doc>Whether or not the type is private.</haxe_doc>
			</isPrivate>
			<isExtern>
				<x path="Bool"/>
				<haxe_doc>Whether or not the type is extern.</haxe_doc>
			</isExtern>
			<exclude set="method">
				<f a=""><x path="Void"/></f>
				<haxe_doc>Allows excluding the type from compilation.</haxe_doc>
			</exclude>
			<doc>
				<x path="Null"><c path="String"/></x>
				<haxe_doc>The associated documentation of the class field.</haxe_doc>
			</doc>
			<constructs>
				<t path="Map">
					<c path="String"/>
					<t path="haxe.macro.EnumField"/>
				</t>
				<haxe_doc>The available enum constructors.</haxe_doc>
			</constructs>
		</a>
		<haxe_doc>Represents an enum type.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.DefType" params="" file="E:\HaxeToolkit\haxe\std\haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<type>
				<e path="haxe.macro.Type"/>
				<haxe_doc>The target type of the typedef.</haxe_doc>
			</type>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the type.</haxe_doc>
			</pos>
			<params>
				<c path="Array"><t path="haxe.macro.TypeParameter"/></c>
				<haxe_doc>The type parameters of the type.</haxe_doc>
			</params>
			<pack>
				<c path="Array"><c path="String"/></c>
				<haxe_doc>The package of the type.</haxe_doc>
			</pack>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the type.</haxe_doc>
			</name>
			<module>
				<c path="String"/>
				<haxe_doc>The module name of the type, which might be different.</haxe_doc>
			</module>
			<meta>
				<t path="haxe.macro.MetaAccess"/>
				<haxe_doc>The metadata of the type.</haxe_doc>
			</meta>
			<isPrivate>
				<x path="Bool"/>
				<haxe_doc>Whether or not the type is private.</haxe_doc>
			</isPrivate>
			<isExtern>
				<x path="Bool"/>
				<haxe_doc>Whether or not the type is extern.</haxe_doc>
			</isExtern>
			<exclude set="method">
				<f a=""><x path="Void"/></f>
				<haxe_doc>Allows excluding the type from compilation.</haxe_doc>
			</exclude>
			<doc>
				<x path="Null"><c path="String"/></x>
				<haxe_doc>The associated documentation of the class field.</haxe_doc>
			</doc>
		</a>
		<haxe_doc>Represents a typedef.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.AbstractType" params="" file="E:\HaxeToolkit\haxe\std\haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<unops>
				<c path="Array"><a>
	<postFix><x path="Bool"/></postFix>
	<op><e path="haxe.macro.Unop"/></op>
	<field><t path="haxe.macro.ClassField"/></field>
</a></c>
				<haxe_doc>The defined unary operators of the abstract.</haxe_doc>
			</unops>
			<type>
				<e path="haxe.macro.Type"/>
				<haxe_doc>The underlying type of the abstract.</haxe_doc>
			</type>
			<to>
				<c path="Array"><a>
	<t><e path="haxe.macro.Type"/></t>
	<field><x path="Null"><t path="haxe.macro.ClassField"/></x></field>
</a></c>
				<haxe_doc>The available implicit to-casts of the abstract.

		@see https://haxe.org/manual/types-abstract-implicit-casts.html</haxe_doc>
			</to>
			<resolveWrite>
				<x path="Null"><t path="haxe.macro.ClassField"/></x>
				<haxe_doc>The method used for resolving unknown field access, if available.</haxe_doc>
			</resolveWrite>
			<resolve>
				<x path="Null"><t path="haxe.macro.ClassField"/></x>
				<haxe_doc>The method used for resolving unknown field access, if available.</haxe_doc>
			</resolve>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the type.</haxe_doc>
			</pos>
			<params>
				<c path="Array"><t path="haxe.macro.TypeParameter"/></c>
				<haxe_doc>The type parameters of the type.</haxe_doc>
			</params>
			<pack>
				<c path="Array"><c path="String"/></c>
				<haxe_doc>The package of the type.</haxe_doc>
			</pack>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the type.</haxe_doc>
			</name>
			<module>
				<c path="String"/>
				<haxe_doc>The module name of the type, which might be different.</haxe_doc>
			</module>
			<meta>
				<t path="haxe.macro.MetaAccess"/>
				<haxe_doc>The metadata of the type.</haxe_doc>
			</meta>
			<isPrivate>
				<x path="Bool"/>
				<haxe_doc>Whether or not the type is private.</haxe_doc>
			</isPrivate>
			<isExtern>
				<x path="Bool"/>
				<haxe_doc>Whether or not the type is extern.</haxe_doc>
			</isExtern>
			<impl>
				<x path="Null"><t path="haxe.macro.Ref"><t path="haxe.macro.ClassType"/></t></x>
				<haxe_doc>The implementation class of the abstract, if available.</haxe_doc>
			</impl>
			<from>
				<c path="Array"><a>
	<t><e path="haxe.macro.Type"/></t>
	<field><x path="Null"><t path="haxe.macro.ClassField"/></x></field>
</a></c>
				<haxe_doc>The available implicit from-casts of the abstract.

		@see https://haxe.org/manual/types-abstract-implicit-casts.html</haxe_doc>
			</from>
			<exclude set="method">
				<f a=""><x path="Void"/></f>
				<haxe_doc>Allows excluding the type from compilation.</haxe_doc>
			</exclude>
			<doc>
				<x path="Null"><c path="String"/></x>
				<haxe_doc>The associated documentation of the class field.</haxe_doc>
			</doc>
			<binops>
				<c path="Array"><a>
	<op><e path="haxe.macro.Binop"/></op>
	<field><t path="haxe.macro.ClassField"/></field>
</a></c>
				<haxe_doc>The defined binary operators of the abstract.</haxe_doc>
			</binops>
			<array>
				<c path="Array"><t path="haxe.macro.ClassField"/></c>
				<haxe_doc>The defined array-access fields of the abstract.</haxe_doc>
			</array>
		</a>
		<haxe_doc>Represents an abstract type.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.MetaAccess" params="" file="E:\HaxeToolkit\haxe\std\haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<remove set="method">
				<f a="name">
					<c path="String"/>
					<x path="Void"/>
				</f>
				<haxe_doc>Removes all `name` metadata entries from the origin of `this`
		MetaAccess.

		This method might clear several metadata entries of the same name.

		If a `Metadata` array is obtained through a call to `get`, a subsequent
		call to `remove` has no effect on that array.

		If `name` is null, compilation fails with an error.</haxe_doc>
			</remove>
			<has set="method">
				<f a="name">
					<c path="String"/>
					<x path="Bool"/>
				</f>
				<haxe_doc>Tells if the origin of `this` MetaAccess has a `name` metadata entry.

		If `name` is null, compilation fails with an error.</haxe_doc>
			</has>
			<get set="method">
				<f a=""><t path="haxe.macro.Metadata"/></f>
				<haxe_doc>Return the wrapped `Metadata` array.

		Modifying this array has no effect on the origin of `this` MetaAccess.
		The `add` and `remove` methods can be used for that.</haxe_doc>
			</get>
			<extract set="method">
				<f a="name">
					<c path="String"/>
					<c path="Array"><t path="haxe.macro.MetadataEntry"/></c>
				</f>
				<haxe_doc>Extract metadata entries by given `name`.

		If there's no metadata with such name, empty array `[]` is returned.

		If `name` is null, compilation fails with an error.</haxe_doc>
			</extract>
			<add set="method">
				<f a="name:params:pos">
					<c path="String"/>
					<c path="Array"><t path="haxe.macro.Expr"/></c>
					<t path="haxe.macro.Position"/>
					<x path="Void"/>
				</f>
				<haxe_doc>Adds the metadata specified by `name`, `params` and `pos` to the origin
		of `this` MetaAccess.

		Metadata names are not unique during compilation, so this method never
		overwrites a previous metadata.

		If a `Metadata` array is obtained through a call to `get`, a subsequent
		call to `add` has no effect on that array.

		If any argument is null, compilation fails with an error.</haxe_doc>
			</add>
		</a>
		<haxe_doc>MetaAccess is a wrapper for the `Metadata` array. It can be used to add
	metadata to and remove metadata from its origin.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.TVar" params="" file="E:\HaxeToolkit\haxe\std\haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<t set="null">
				<e path="haxe.macro.Type"/>
				<haxe_doc>The type of the variable.</haxe_doc>
			</t>
			<name set="null">
				<c path="String"/>
				<haxe_doc>The name of the variable.</haxe_doc>
			</name>
			<meta set="null">
				<x path="Null"><t path="haxe.macro.MetaAccess"/></x>
				<haxe_doc>The metadata of the variable.</haxe_doc>
			</meta>
			<id set="null">
				<x path="Int"/>
				<haxe_doc>The unique ID of the variable.</haxe_doc>
			</id>
			<extra set="null">
				<x path="Null"><a>
	<params><c path="Array"><t path="haxe.macro.TypeParameter"/></c></params>
	<expr><x path="Null"><t path="haxe.macro.TypedExpr"/></x></expr>
</a></x>
				<haxe_doc>Special information which is internally used to keep track of closure.
		information</haxe_doc>
			</extra>
			<capture set="null">
				<x path="Bool"/>
				<haxe_doc>Whether or not the variable has been captured by a closure.</haxe_doc>
			</capture>
		</a>
		<haxe_doc>Represents a variable in the typed AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.TFunc" params="" file="E:\HaxeToolkit\haxe\std\haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<t>
				<e path="haxe.macro.Type"/>
				<haxe_doc>The return type of the function.</haxe_doc>
			</t>
			<expr>
				<t path="haxe.macro.TypedExpr"/>
				<haxe_doc>The expression of the function body.</haxe_doc>
			</expr>
			<args>
				<c path="Array"><a>
	<value><x path="Null"><t path="haxe.macro.TypedExpr"/></x></value>
	<v><t path="haxe.macro.TVar"/></v>
</a></c>
				<haxe_doc>A list of function arguments identified by an argument variable `v` and
		an optional initialization `value`.</haxe_doc>
			</args>
		</a>
		<haxe_doc>Represents a function in the typed AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.TypedExpr" params="" file="E:\HaxeToolkit\haxe\std\haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<t>
				<e path="haxe.macro.Type"/>
				<haxe_doc>The type of the expression.</haxe_doc>
			</t>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the expression.</haxe_doc>
			</pos>
			<expr>
				<e path="haxe.macro.TypedExprDef"/>
				<haxe_doc>The expression kind.</haxe_doc>
			</expr>
		</a>
		<haxe_doc>Represents a typed AST node.</haxe_doc>
	</typedef>
	<abstract path="haxe.xml._Access.NodeAccess" params="" file="E:\HaxeToolkit\haxe\std\haxe/xml/Access.hx" private="1" module="haxe.xml.Access">
		<from><icast><c path="Xml"/></icast></from>
		<this><c path="Xml"/></this>
		<impl><class path="haxe.xml._Access.NodeAccess_Impl_" params="" file="E:\HaxeToolkit\haxe\std\haxe/xml/Access.hx" private="1" module="haxe.xml.Access">
	<resolve public="1" set="method" line="27" static="1">
		<f a="this:name">
			<c path="Xml"/>
			<c path="String"/>
			<x path="haxe.xml.Access"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":op"><e>a.b</e></m>
		</meta>
	</resolve>
	<meta>
		<m n=":keep"/>
		<m n=":directlyUsed"/>
	</meta>
</class></impl>
	</abstract>
	<class path="haxe.xml._Access.NodeAccess_Impl_" params="" file="E:\HaxeToolkit\haxe\std\haxe/xml/Access.hx" private="1" module="haxe.xml.Access">
		<resolve public="1" set="method" line="27" static="1">
			<f a="this:name">
				<c path="Xml"/>
				<c path="String"/>
				<x path="haxe.xml.Access"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":op"><e>a.b</e></m>
			</meta>
		</resolve>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<abstract path="haxe.xml._Access.AttribAccess" params="" file="E:\HaxeToolkit\haxe\std\haxe/xml/Access.hx" private="1" module="haxe.xml.Access">
		<from><icast><c path="Xml"/></icast></from>
		<this><c path="Xml"/></this>
		<impl><class path="haxe.xml._Access.AttribAccess_Impl_" params="" file="E:\HaxeToolkit\haxe\std\haxe/xml/Access.hx" private="1" module="haxe.xml.Access">
	<resolve public="1" set="method" line="39" static="1">
		<f a="this:name">
			<c path="Xml"/>
			<c path="String"/>
			<c path="String"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":op"><e>a.b</e></m>
		</meta>
	</resolve>
	<meta>
		<m n=":keep"/>
		<m n=":directlyUsed"/>
	</meta>
</class></impl>
	</abstract>
	<class path="haxe.xml._Access.AttribAccess_Impl_" params="" file="E:\HaxeToolkit\haxe\std\haxe/xml/Access.hx" private="1" module="haxe.xml.Access">
		<resolve public="1" set="method" line="39" static="1">
			<f a="this:name">
				<c path="Xml"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":op"><e>a.b</e></m>
			</meta>
		</resolve>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<abstract path="haxe.xml._Access.HasAttribAccess" params="" file="E:\HaxeToolkit\haxe\std\haxe/xml/Access.hx" private="1" module="haxe.xml.Access">
		<from><icast><c path="Xml"/></icast></from>
		<this><c path="Xml"/></this>
		<impl><class path="haxe.xml._Access.HasAttribAccess_Impl_" params="" file="E:\HaxeToolkit\haxe\std\haxe/xml/Access.hx" private="1" module="haxe.xml.Access">
	<resolve public="1" set="method" line="59" static="1">
		<f a="this:name">
			<c path="Xml"/>
			<c path="String"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":op"><e>a.b</e></m>
		</meta>
	</resolve>
	<meta>
		<m n=":keep"/>
		<m n=":directlyUsed"/>
	</meta>
</class></impl>
	</abstract>
	<class path="haxe.xml._Access.HasAttribAccess_Impl_" params="" file="E:\HaxeToolkit\haxe\std\haxe/xml/Access.hx" private="1" module="haxe.xml.Access">
		<resolve public="1" set="method" line="59" static="1">
			<f a="this:name">
				<c path="Xml"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":op"><e>a.b</e></m>
			</meta>
		</resolve>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<abstract path="haxe.xml._Access.HasNodeAccess" params="" file="E:\HaxeToolkit\haxe\std\haxe/xml/Access.hx" private="1" module="haxe.xml.Access">
		<from><icast><c path="Xml"/></icast></from>
		<this><c path="Xml"/></this>
		<impl><class path="haxe.xml._Access.HasNodeAccess_Impl_" params="" file="E:\HaxeToolkit\haxe\std\haxe/xml/Access.hx" private="1" module="haxe.xml.Access">
	<resolve public="1" set="method" line="68" static="1">
		<f a="this:name">
			<c path="Xml"/>
			<c path="String"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":op"><e>a.b</e></m>
		</meta>
	</resolve>
	<meta>
		<m n=":keep"/>
		<m n=":directlyUsed"/>
	</meta>
</class></impl>
	</abstract>
	<class path="haxe.xml._Access.HasNodeAccess_Impl_" params="" file="E:\HaxeToolkit\haxe\std\haxe/xml/Access.hx" private="1" module="haxe.xml.Access">
		<resolve public="1" set="method" line="68" static="1">
			<f a="this:name">
				<c path="Xml"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":op"><e>a.b</e></m>
			</meta>
		</resolve>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<abstract path="haxe.xml._Access.NodeListAccess" params="" file="E:\HaxeToolkit\haxe\std\haxe/xml/Access.hx" private="1" module="haxe.xml.Access">
		<from><icast><c path="Xml"/></icast></from>
		<this><c path="Xml"/></this>
		<impl><class path="haxe.xml._Access.NodeListAccess_Impl_" params="" file="E:\HaxeToolkit\haxe\std\haxe/xml/Access.hx" private="1" module="haxe.xml.Access">
	<resolve public="1" set="method" line="75" static="1">
		<f a="this:name">
			<c path="Xml"/>
			<c path="String"/>
			<c path="Array"><x path="haxe.xml.Access"/></c>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":op"><e>a.b</e></m>
		</meta>
	</resolve>
	<meta>
		<m n=":keep"/>
		<m n=":directlyUsed"/>
	</meta>
</class></impl>
	</abstract>
	<class path="haxe.xml._Access.NodeListAccess_Impl_" params="" file="E:\HaxeToolkit\haxe\std\haxe/xml/Access.hx" private="1" module="haxe.xml.Access">
		<resolve public="1" set="method" line="75" static="1">
			<f a="this:name">
				<c path="Xml"/>
				<c path="String"/>
				<c path="Array"><x path="haxe.xml.Access"/></c>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":op"><e>a.b</e></m>
			</meta>
		</resolve>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<abstract path="haxe.xml.Access" params="" file="E:\HaxeToolkit\haxe\std\haxe/xml/Access.hx">
		<this><c path="Xml"/></this>
		<haxe_doc>The `haxe.xml.Access` API helps providing a fast dot-syntax access to the
	most common `Xml` methods.</haxe_doc>
		<impl><class path="haxe.xml._Access.Access_Impl_" params="" file="E:\HaxeToolkit\haxe\std\haxe/xml/Access.hx" private="1" module="haxe.xml.Access">
	<x public="1" get="null" set="null" static="1">
		<c path="Xml"/>
		<meta><m n=":impl"/></meta>
	</x>
	<name public="1" get="null" set="null" static="1">
		<c path="String"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>The name of the current element. This is the same as `Xml.nodeName`.</haxe_doc>
	</name>
	<innerData public="1" get="accessor" set="null" static="1">
		<c path="String"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>The inner PCDATA or CDATA of the node.

		An exception is thrown if there is no data or if there not only data
		but also other nodes.</haxe_doc>
	</innerData>
	<innerHTML public="1" get="null" set="null" static="1">
		<c path="String"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>The XML string built with all the sub nodes, excluding the current one.</haxe_doc>
	</innerHTML>
	<node public="1" get="null" set="null" static="1">
		<x path="haxe.xml._Access.NodeAccess"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc><![CDATA[Access to the first sub element with the given name.

		An exception is thrown if the element doesn't exists.
		Use `hasNode` to check the existence of a node.

		```haxe
		var access = new haxe.xml.Access(Xml.parse("<user><name>John</name></user>"));
		var user = access.node.user;
		var name = user.node.name;
		trace(name.innerData); // John

		// Uncaught Error: Document is missing element password
		var password = user.node.password;
		```]]></haxe_doc>
	</node>
	<nodes public="1" get="null" set="null" static="1">
		<x path="haxe.xml._Access.NodeListAccess"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc><![CDATA[Access to the List of elements with the given name.
		```haxe
		var fast = new haxe.xml.Access(Xml.parse("
			<users>
				<user name='John'/>
				<user name='Andy'/>
				<user name='Dan'/>
			</users>"
		));

		var users = fast.node.users;
		for (user in users.nodes.user) {
			trace(user.att.name);
		}
		```]]></haxe_doc>
	</nodes>
	<att public="1" get="null" set="null" static="1">
		<x path="haxe.xml._Access.AttribAccess"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc><![CDATA[Access to a given attribute.

		An exception is thrown if the attribute doesn't exists.
		Use `has` to check the existence of an attribute.

		```haxe
		var f = new haxe.xml.Access(Xml.parse("<user name='Mark'></user>"));
		var user = f.node.user;
		if (user.has.name) {
			trace(user.att.name); // Mark
		}
		```]]></haxe_doc>
	</att>
	<has public="1" get="null" set="null" static="1">
		<x path="haxe.xml._Access.HasAttribAccess"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Check the existence of an attribute with the given name.</haxe_doc>
	</has>
	<hasNode public="1" get="null" set="null" static="1">
		<x path="haxe.xml._Access.HasNodeAccess"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc><![CDATA[Check the existence of a sub node with the given name.

		```haxe
		var f = new haxe.xml.Access(Xml.parse("<user><age>31</age></user>"));
		var user = f.node.user;
		if (user.hasNode.age) {
			trace(user.node.age.innerData); // 31
		}
		```]]></haxe_doc>
	</hasNode>
	<elements public="1" get="null" set="null" static="1">
		<t path="Iterator"><x path="haxe.xml.Access"/></t>
		<meta><m n=":impl"/></meta>
		<haxe_doc>The list of all sub-elements which are the nodes with type `Xml.Element`.</haxe_doc>
	</elements>
	<get_innerData set="method" line="215" static="1">
		<f a="this">
			<c path="Xml"/>
			<c path="String"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_innerData>
	<meta>
		<m n=":keep"/>
		<m n=":directlyUsed"/>
	</meta>
</class></impl>
	</abstract>
	<class path="haxe.xml._Access.Access_Impl_" params="" file="E:\HaxeToolkit\haxe\std\haxe/xml/Access.hx" private="1" module="haxe.xml.Access">
		<x public="1" get="null" set="null" static="1">
			<c path="Xml"/>
			<meta><m n=":impl"/></meta>
		</x>
		<name public="1" get="null" set="null" static="1">
			<c path="String"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>The name of the current element. This is the same as `Xml.nodeName`.</haxe_doc>
		</name>
		<innerData public="1" get="accessor" set="null" static="1">
			<c path="String"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>The inner PCDATA or CDATA of the node.

		An exception is thrown if there is no data or if there not only data
		but also other nodes.</haxe_doc>
		</innerData>
		<innerHTML public="1" get="null" set="null" static="1">
			<c path="String"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>The XML string built with all the sub nodes, excluding the current one.</haxe_doc>
		</innerHTML>
		<node public="1" get="null" set="null" static="1">
			<x path="haxe.xml._Access.NodeAccess"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc><![CDATA[Access to the first sub element with the given name.

		An exception is thrown if the element doesn't exists.
		Use `hasNode` to check the existence of a node.

		```haxe
		var access = new haxe.xml.Access(Xml.parse("<user><name>John</name></user>"));
		var user = access.node.user;
		var name = user.node.name;
		trace(name.innerData); // John

		// Uncaught Error: Document is missing element password
		var password = user.node.password;
		```]]></haxe_doc>
		</node>
		<nodes public="1" get="null" set="null" static="1">
			<x path="haxe.xml._Access.NodeListAccess"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc><![CDATA[Access to the List of elements with the given name.
		```haxe
		var fast = new haxe.xml.Access(Xml.parse("
			<users>
				<user name='John'/>
				<user name='Andy'/>
				<user name='Dan'/>
			</users>"
		));

		var users = fast.node.users;
		for (user in users.nodes.user) {
			trace(user.att.name);
		}
		```]]></haxe_doc>
		</nodes>
		<att public="1" get="null" set="null" static="1">
			<x path="haxe.xml._Access.AttribAccess"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc><![CDATA[Access to a given attribute.

		An exception is thrown if the attribute doesn't exists.
		Use `has` to check the existence of an attribute.

		```haxe
		var f = new haxe.xml.Access(Xml.parse("<user name='Mark'></user>"));
		var user = f.node.user;
		if (user.has.name) {
			trace(user.att.name); // Mark
		}
		```]]></haxe_doc>
		</att>
		<has public="1" get="null" set="null" static="1">
			<x path="haxe.xml._Access.HasAttribAccess"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Check the existence of an attribute with the given name.</haxe_doc>
		</has>
		<hasNode public="1" get="null" set="null" static="1">
			<x path="haxe.xml._Access.HasNodeAccess"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc><![CDATA[Check the existence of a sub node with the given name.

		```haxe
		var f = new haxe.xml.Access(Xml.parse("<user><age>31</age></user>"));
		var user = f.node.user;
		if (user.hasNode.age) {
			trace(user.node.age.innerData); // 31
		}
		```]]></haxe_doc>
		</hasNode>
		<elements public="1" get="null" set="null" static="1">
			<t path="Iterator"><x path="haxe.xml.Access"/></t>
			<meta><m n=":impl"/></meta>
			<haxe_doc>The list of all sub-elements which are the nodes with type `Xml.Element`.</haxe_doc>
		</elements>
		<get_innerData set="method" line="215" static="1">
			<f a="this">
				<c path="Xml"/>
				<c path="String"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_innerData>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<abstract path="haxe.xml._Parser.S" params="" file="E:\HaxeToolkit\haxe\std\haxe/xml/Parser.hx" private="1" module="haxe.xml.Parser">
		<this><x path="Int"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="haxe.xml._Parser.S_Impl_" params="" file="E:\HaxeToolkit\haxe\std\haxe/xml/Parser.hx" private="1" module="haxe.xml.Parser"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="haxe.xml.XmlParserException" params="" file="E:\HaxeToolkit\haxe\std\haxe/xml/Parser.hx" module="haxe.xml.Parser">
		<message public="1">
			<c path="String"/>
			<haxe_doc>the XML parsing error message</haxe_doc>
		</message>
		<lineNumber public="1">
			<x path="Int"/>
			<haxe_doc>the line number at which the XML parsing error occurred</haxe_doc>
		</lineNumber>
		<positionAtLine public="1">
			<x path="Int"/>
			<haxe_doc>the character position in the reported line at which the parsing error occurred</haxe_doc>
		</positionAtLine>
		<position public="1">
			<x path="Int"/>
			<haxe_doc>the character position in the XML string at which the parsing error occurred</haxe_doc>
		</position>
		<xml public="1">
			<c path="String"/>
			<haxe_doc>the invalid XML string</haxe_doc>
		</xml>
		<toString public="1" set="method" line="94"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="75"><f a="message:xml:position">
	<c path="String"/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.xml.Parser" params="" file="E:\HaxeToolkit\haxe\std\haxe/xml/Parser.hx">
		<escapes expr="{
	var h = new haxe.ds.StringMap();
	h.set(&quot;lt&quot;, &quot;&lt;&quot;);
	h.set(&quot;gt&quot;, &quot;&gt;&quot;);
	h.set(&quot;amp&quot;, &quot;&amp;&quot;);
	h.set(&quot;quot&quot;, &quot;\&quot;&quot;);
	h.set(&quot;apos&quot;, &quot;&apos;&quot;);
	h;
}" line="100" static="1">
			<c path="haxe.ds.StringMap"><c path="String"/></c>
			<meta><m n=":value"><e><![CDATA[{
	var h = new haxe.ds.StringMap();
	h.set("lt", "<");
	h.set("gt", ">");
	h.set("amp", "&");
	h.set("quot", "\"");
	h.set("apos", "'");
	h;
}]]></e></m></meta>
		</escapes>
		<parse public="1" set="method" line="115" static="1">
			<f a="str:?strict" v=":false">
				<c path="String"/>
				<x path="Bool"/>
				<c path="Xml"/>
			</f>
			<meta><m n=":value"><e>{ strict : false }</e></m></meta>
			<haxe_doc>Parses the String into an XML Document. Set strict parsing to true in order to enable a strict check of XML attributes and entities.

		@throws haxe.xml.XmlParserException</haxe_doc>
		</parse>
		<doParse set="method" line="121" static="1">
			<f a="str:strict:?p:?parent" v="::0:">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Int"/>
				<c path="Xml"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ p : 0 }</e></m></meta>
		</doParse>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.xml.Printer" params="" file="E:\HaxeToolkit\haxe\std\haxe/xml/Printer.hx">
		<print public="1" set="method" line="35" static="1">
			<f a="xml:?pretty" v=":false">
				<c path="Xml"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ pretty : false }</e></m></meta>
			<haxe_doc>Convert `Xml` to string representation.

		Set `pretty` to `true` to prettify the result.</haxe_doc>
		</print>
		<output><c path="StringBuf"/></output>
		<pretty><x path="Bool"/></pretty>
		<writeNode set="method" line="49"><f a="value:tabs">
	<c path="Xml"/>
	<c path="String"/>
	<x path="Void"/>
</f></writeNode>
		<hasChildren set="method" line="114"><f a="value">
	<c path="Xml"/>
	<x path="Bool"/>
</f></hasChildren>
		<new set="method" line="44"><f a="pretty">
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>This class provides utility methods to convert Xml instances to
	String representation.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.zip.Compress" params="" file="E:\HaxeToolkit\haxe\std\haxe/zip/Compress.hx">
		<run public="1" set="method" line="38" static="1"><f a="s:level">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></run>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<enum path="haxe.zip.Huffman" params="" file="E:\HaxeToolkit\haxe\std\haxe/zip/Huffman.hx">
		<Found a="i"><x path="Int"/></Found>
		<NeedBit a="left:right">
			<e path="haxe.zip.Huffman"/>
			<e path="haxe.zip.Huffman"/>
		</NeedBit>
		<NeedBits a="n:table">
			<x path="Int"/>
			<c path="Array"><e path="haxe.zip.Huffman"/></c>
		</NeedBits>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<class path="haxe.zip.HuffTools" params="" file="E:\HaxeToolkit\haxe\std\haxe/zip/Huffman.hx" module="haxe.zip.Huffman">
		<treeDepth set="method" line="34"><f a="t">
	<e path="haxe.zip.Huffman"/>
	<x path="Int"/>
</f></treeDepth>
		<treeCompress set="method" line="45"><f a="t">
	<e path="haxe.zip.Huffman"/>
	<e path="haxe.zip.Huffman"/>
</f></treeCompress>
		<treeWalk set="method" line="62"><f a="table:p:cd:d:t">
	<c path="Array"><e path="haxe.zip.Huffman"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<e path="haxe.zip.Huffman"/>
	<x path="Void"/>
</f></treeWalk>
		<treeMake set="method" line="75"><f a="bits:maxbits:v:len">
	<c path="haxe.ds.IntMap"><x path="Int"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<e path="haxe.zip.Huffman"/>
</f></treeMake>
		<make public="1" set="method" line="86"><f a="lengths:pos:nlengths:maxbits">
	<c path="Array"><x path="Int"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<e path="haxe.zip.Huffman"/>
</f></make>
		<new public="1" set="method" line="32"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.zip._InflateImpl.Window" params="" file="E:\HaxeToolkit\haxe\std\haxe/zip/InflateImpl.hx" private="1" module="haxe.zip.InflateImpl">
		<buffer public="1"><c path="haxe.io.Bytes"/></buffer>
		<pos public="1"><x path="Int"/></pos>
		<crc><c path="haxe.crypto.Adler32"/></crc>
		<slide public="1" set="method" line="44"><f a=""><x path="Void"/></f></slide>
		<addBytes public="1" set="method" line="53"><f a="b:p:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></addBytes>
		<addByte public="1" set="method" line="60"><f a="c">
	<x path="Int"/>
	<x path="Void"/>
</f></addByte>
		<getLastChar public="1" set="method" line="67"><f a=""><x path="Int"/></f></getLastChar>
		<available public="1" set="method" line="71"><f a=""><x path="Int"/></f></available>
		<checksum public="1" set="method" line="75"><f a=""><c path="haxe.crypto.Adler32"/></f></checksum>
		<new public="1" set="method" line="37"><f a="hasCrc">
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<enum path="haxe.zip._InflateImpl.State" params="" file="E:\HaxeToolkit\haxe\std\haxe/zip/InflateImpl.hx" private="1" module="haxe.zip.InflateImpl">
		<Head/>
		<Block/>
		<CData/>
		<Flat/>
		<Crc/>
		<Dist/>
		<DistOne/>
		<Done/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="haxe.zip.InflateImpl" params="" file="E:\HaxeToolkit\haxe\std\haxe/zip/InflateImpl.hx">
		<LEN_EXTRA_BITS_TBL expr="[0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, -1, -1]" line="97" static="1">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e>[0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, -1, -1]</e></m></meta>
		</LEN_EXTRA_BITS_TBL>
		<LEN_BASE_VAL_TBL expr="[3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258]" line="100" static="1">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e>[3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258]</e></m></meta>
		</LEN_BASE_VAL_TBL>
		<DIST_EXTRA_BITS_TBL expr="[0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, -1, -1]" line="103" static="1">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e>[0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, -1, -1]</e></m></meta>
		</DIST_EXTRA_BITS_TBL>
		<DIST_BASE_VAL_TBL expr="[1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577]" line="106" static="1">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e>[1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577]</e></m></meta>
		</DIST_BASE_VAL_TBL>
		<CODE_LENGTHS_POS expr="[16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]" line="109" static="1">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e>[16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]</e></m></meta>
		</CODE_LENGTHS_POS>
		<FIXED_HUFFMAN expr="null" line="127" static="1">
			<e path="haxe.zip.Huffman"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</FIXED_HUFFMAN>
		<run public="1" set="method" line="388" static="1">
			<f a="i:?bufsize" v=":65536">
				<c path="haxe.io.Input"/>
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":value"><e>{ bufsize : 65536 }</e></m></meta>
		</run>
		<nbits><x path="Int"/></nbits>
		<bits><x path="Int"/></bits>
		<state><e path="haxe.zip._InflateImpl.State"/></state>
		<isFinal><x path="Bool"/></isFinal>
		<huffman><e path="haxe.zip.Huffman"/></huffman>
		<huffdist><x path="Null"><e path="haxe.zip.Huffman"/></x></huffdist>
		<htools><c path="haxe.zip.HuffTools"/></htools>
		<len><x path="Int"/></len>
		<dist><x path="Int"/></dist>
		<needed><x path="Int"/></needed>
		<output><c path="haxe.io.Bytes"/></output>
		<outpos><x path="Int"/></outpos>
		<input><c path="haxe.io.Input"/></input>
		<lengths><c path="Array"><x path="Int"/></c></lengths>
		<window><c path="haxe.zip._InflateImpl.Window"/></window>
		<buildFixedHuffman set="method" line="149"><f a=""><e path="haxe.zip.Huffman"/></f></buildFixedHuffman>
		<readBytes public="1" set="method" line="159"><f a="b:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></readBytes>
		<getBits set="method" line="168"><f a="n">
	<x path="Int"/>
	<x path="Int"/>
</f></getBits>
		<getBit set="method" line="179"><f a=""><x path="Bool"/></f></getBit>
		<getRevBits set="method" line="190"><f a="n">
	<x path="Int"/>
	<x path="Int"/>
</f></getRevBits>
		<resetBits set="method" line="199"><f a=""><x path="Void"/></f></resetBits>
		<addBytes set="method" line="204"><f a="b:p:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></addBytes>
		<addByte set="method" line="211"><f a="b">
	<x path="Int"/>
	<x path="Void"/>
</f></addByte>
		<addDistOne set="method" line="218"><f a="n">
	<x path="Int"/>
	<x path="Void"/>
</f></addDistOne>
		<addDist set="method" line="224"><f a="d:len">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></addDist>
		<applyHuffman set="method" line="228"><f a="h">
	<e path="haxe.zip.Huffman"/>
	<x path="Int"/>
</f></applyHuffman>
		<inflateLengths set="method" line="236"><f a="a:max">
	<c path="Array"><x path="Int"/></c>
	<x path="Int"/>
	<x path="Void"/>
</f></inflateLengths>
		<inflateLoop set="method" line="268"><f a=""><x path="Bool"/></f></inflateLoop>
		<new public="1" set="method" line="129">
			<f a="i:?header:?crc" v=":true:true">
				<c path="haxe.io.Input"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ crc : true, header : true }</e></m></meta>
		</new>
		<haxe_doc>A pure Haxe implementation of the ZLIB Inflate algorithm which allows reading compressed data without any platform-specific support.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.zip.Uncompress" params="" file="E:\HaxeToolkit\haxe\std\haxe/zip/Uncompress.hx">
		<run public="1" set="method" line="38" static="1"><f a="src:?bufsize">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></run>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<typedef path="hxd.BitmapInnerData" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/BitmapData.hx" module="hxd.BitmapData"><c path="hxd.BitmapInnerDataImpl"/></typedef>
	<class path="hxd.BitmapInnerDataImpl" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/BitmapData.hx" module="hxd.BitmapData">
		<pixels public="1"><x path="haxe.ds.Vector"><x path="Int"/></x></pixels>
		<width public="1"><x path="Int"/></width>
		<height public="1"><x path="Int"/></height>
		<new public="1" set="method" line="19"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.BitmapData" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/BitmapData.hx">
		<notImplemented get="inline" set="null" line="78" static="1"><f a=""><x path="Void"/></f></notImplemented>
		<fromNative public="1" set="method" line="663" static="1"><f a="data">
	<t path="hxd.BitmapInnerData"/>
	<c path="hxd.BitmapData"/>
</f></fromNative>
		<data><t path="hxd.BitmapInnerData"/></data>
		<width public="1" get="accessor" set="null"><x path="Int"/></width>
		<height public="1" get="accessor" set="null"><x path="Int"/></height>
		<clear public="1" set="method" line="70"><f a="color">
	<x path="Int"/>
	<x path="Void"/>
</f></clear>
		<fill public="1" set="method" line="82"><f a="x:y:width:height:color">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></fill>
		<draw public="1" set="method" line="114"><f a="x:y:src:srcX:srcY:width:height:?blendMode">
	<x path="Int"/>
	<x path="Int"/>
	<c path="hxd.BitmapData"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<e path="h2d.BlendMode"/>
	<x path="Void"/>
</f></draw>
		<drawScaled public="1" set="method" line="169">
			<f a="x:y:width:height:src:srcX:srcY:srcWidth:srcHeight:?blendMode:?smooth" v="::::::::::true">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="hxd.BitmapData"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<e path="h2d.BlendMode"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ smooth : true }</e></m></meta>
		</drawScaled>
		<line public="1" set="method" line="227"><f a="x0:y0:x1:y1:color">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></line>
		<dispose public="1" get="inline" set="null" line="461"><f a=""><x path="Void"/></f></dispose>
		<clone public="1" set="method" line="472"><f a=""><c path="hxd.BitmapData"/></f></clone>
		<sub public="1" set="method" line="476"><f a="x:y:w:h">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="hxd.BitmapData"/>
</f></sub>
		<lock public="1" set="method" line="509">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Inform that we will perform several pixel operations on the BitmapData.</haxe_doc>
		</lock>
		<unlock public="1" set="method" line="521">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Inform that we have finished performing pixel operations on the BitmapData.</haxe_doc>
		</unlock>
		<getPixel public="1" set="method" line="535">
			<f a="x:y">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Access the pixel color value at the given position. Note : this function can be very slow if done many times and the BitmapData has not been locked.</haxe_doc>
		</getPixel>
		<setPixel public="1" set="method" line="556">
			<f a="x:y:c">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Modify the pixel color value at the given position. Note : this function can be very slow if done many times and the BitmapData has not been locked.</haxe_doc>
		</setPixel>
		<get_width get="inline" set="null" line="584"><f a=""><x path="Int"/></f></get_width>
		<get_height get="inline" set="null" line="594"><f a=""><x path="Int"/></f></get_height>
		<getPixels public="1" set="method" line="604"><f a=""><c path="hxd.Pixels"/></f></getPixels>
		<setPixels public="1" set="method" line="623"><f a="pixels">
	<c path="hxd.Pixels"/>
	<x path="Void"/>
</f></setPixels>
		<toNative public="1" get="inline" set="null" line="653"><f a=""><t path="hxd.BitmapInnerData"/></f></toNative>
		<toPNG public="1" set="method" line="675"><f a=""><c path="haxe.io.Bytes"/></f></toPNG>
		<new public="1" set="method" line="45"><f a="width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.Charset" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/Charset.hx">
		<ASCII public="1" expr="&quot; !\&quot;#$%&amp;&apos;()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~&quot;" line="8" static="1">
			<c path="String"/>
			<meta><m n=":value"><e><![CDATA[" !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"]]></e></m></meta>
			<haxe_doc>Contains the whole ASCII charset.</haxe_doc>
		</ASCII>
		<LATIN1 public="1" expr="&quot;Â¡Â¢Â£Â¤Â¥Â¦Â§Â¨Â©ÂªÂ«Â¬-Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹ÂºÂ»Â¼Â½Â¾Â¿Ã€ÃÃ‚ÃƒÃ„Ã…Ã†Ã‡ÃˆÃ‰ÃŠÃ‹ÃŒÃÃŽÃÃÃ‘Ã’Ã“Ã”Ã•Ã–Ã—Ã˜Ã™ÃšÃ›ÃœÃÃžÃŸÃ Ã¡Ã¢Ã£Ã¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯Ã°Ã±Ã²Ã³Ã´ÃµÃ¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Ã½Ã¾Ã¿Å“Ã¦Å’Ã†â‚¬&quot;" line="13" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"Â¡Â¢Â£Â¤Â¥Â¦Â§Â¨Â©ÂªÂ«Â¬-Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹ÂºÂ»Â¼Â½Â¾Â¿Ã€ÃÃ‚ÃƒÃ„Ã…Ã†Ã‡ÃˆÃ‰ÃŠÃ‹ÃŒÃÃŽÃÃÃ‘Ã’Ã“Ã”Ã•Ã–Ã—Ã˜Ã™ÃšÃ›ÃœÃÃžÃŸÃ Ã¡Ã¢Ã£Ã¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯Ã°Ã±Ã²Ã³Ã´ÃµÃ¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Ã½Ã¾Ã¿Å“Ã¦Å’Ã†â‚¬"</e></m></meta>
			<haxe_doc>The Latin1 (ISO 8859-1) charset (only the extra chars, no the ASCII part) + euro symbol</haxe_doc>
		</LATIN1>
		<CYRILLIC public="1" expr="&quot;ÐÐ‘Ð’Ð“Ð”Ð•Ð–Ð—Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯Ð°Ð±Ð²Ð³Ð´ÐµÐ¶Ð·Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿Ñ€ÑÑ‚ÑƒÑ„Ñ…Ñ†Ñ‡ÑˆÑ‰ÑŠÑ‹ÑŒÑÑŽÑâ€”&quot;" line="18" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"ÐÐ‘Ð’Ð“Ð”Ð•Ð–Ð—Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯Ð°Ð±Ð²Ð³Ð´ÐµÐ¶Ð·Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿Ñ€ÑÑ‚ÑƒÑ„Ñ…Ñ†Ñ‡ÑˆÑ‰ÑŠÑ‹ÑŒÑÑŽÑâ€”"</e></m></meta>
			<haxe_doc>Russian support</haxe_doc>
		</CYRILLIC>
		<POLISH public="1" expr="&quot;Ä„Ä†Ä˜ÅÅƒÃ“ÅšÅ¹Å»Ä…Ä‡Ä™Å‚Å„Ã³Å›ÅºÅ¼&quot;" line="23" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"Ä„Ä†Ä˜ÅÅƒÃ“ÅšÅ¹Å»Ä…Ä‡Ä™Å‚Å„Ã³Å›ÅºÅ¼"</e></m></meta>
			<haxe_doc>Polish support</haxe_doc>
		</POLISH>
		<TURKISH public="1" expr="&quot;Ã‚Ã‡ÄžIÄ°ÃŽÃ–ÅžÃœÃ›Ã¢Ã§ÄŸÄ±Ä°Ã®Ã¶ÅŸÃ¼Ã»&quot;" line="28" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"Ã‚Ã‡ÄžIÄ°ÃŽÃ–ÅžÃœÃ›Ã¢Ã§ÄŸÄ±Ä°Ã®Ã¶ÅŸÃ¼Ã»"</e></m></meta>
			<haxe_doc>Turkish support</haxe_doc>
		</TURKISH>
		<JP_KANA public="1" expr="&quot;ã€€ã‚ã„ã†ãˆãŠã‹ããã‘ã“ã•ã—ã™ã›ããŸã¡ã¤ã¦ã¨ãªã«ã¬ã­ã®ã¯ã²ãµã¸ã»ã¾ã¿ã‚€ã‚ã‚‚ã‚„ã‚†ã‚ˆã‚‰ã‚Šã‚‹ã‚Œã‚ã‚ã‚ã‚‘ã‚’ã‚“ãŒãŽãã’ã”ã–ã˜ãšãœãžã ã¢ã¥ã§ã©ã°ã³ã¶ã¹ã¼ã±ã´ã·ãºã½ã‚ƒã‚…ã‚‡ã‚¢ã‚¤ã‚¦ã‚¨ã‚ªã‚«ã‚­ã‚¯ã‚±ã‚³ã‚µã‚·ã‚¹ã‚»ã‚½ã‚¿ãƒãƒ„ãƒ†ãƒˆãƒŠãƒ‹ãƒŒãƒãƒŽãƒãƒ’ãƒ•ãƒ˜ãƒ›ãƒžãƒŸãƒ ãƒ¡ãƒ¢ãƒ¤ãƒ¦ãƒ¨ãƒ©ãƒªãƒ«ãƒ¬ãƒ­ãƒ¯ãƒ°ãƒ±ãƒ²ãƒ³ã‚¬ã‚®ã‚°ã‚²ã‚´ã‚¶ã‚¸ã‚ºã‚¼ã‚¾ãƒ€ãƒ‚ãƒ…ãƒ‡ãƒ‰ãƒãƒ“ãƒ–ãƒ™ãƒœãƒ‘ãƒ”ãƒ—ãƒšãƒãƒ´ãƒ£ã‡ã£ãƒƒãƒ¥ãƒ§ã‚¡ã‚£ã‚¥ã‚§ã‚©ãƒ»ãƒ¼ã€Œã€ã€ã€‚ã€Žã€â€œâ€ï¼ï¼šï¼Ÿï¼…ï¼†ï¼ˆï¼‰ï¼ï¼ï¼‘ï¼’ï¼“ï¼”ï¼•ï¼–ï¼—ï¼˜ï¼™&quot;" line="33" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"ã€€ã‚ã„ã†ãˆãŠã‹ããã‘ã“ã•ã—ã™ã›ããŸã¡ã¤ã¦ã¨ãªã«ã¬ã­ã®ã¯ã²ãµã¸ã»ã¾ã¿ã‚€ã‚ã‚‚ã‚„ã‚†ã‚ˆã‚‰ã‚Šã‚‹ã‚Œã‚ã‚ã‚ã‚‘ã‚’ã‚“ãŒãŽãã’ã”ã–ã˜ãšãœãžã ã¢ã¥ã§ã©ã°ã³ã¶ã¹ã¼ã±ã´ã·ãºã½ã‚ƒã‚…ã‚‡ã‚¢ã‚¤ã‚¦ã‚¨ã‚ªã‚«ã‚­ã‚¯ã‚±ã‚³ã‚µã‚·ã‚¹ã‚»ã‚½ã‚¿ãƒãƒ„ãƒ†ãƒˆãƒŠãƒ‹ãƒŒãƒãƒŽãƒãƒ’ãƒ•ãƒ˜ãƒ›ãƒžãƒŸãƒ ãƒ¡ãƒ¢ãƒ¤ãƒ¦ãƒ¨ãƒ©ãƒªãƒ«ãƒ¬ãƒ­ãƒ¯ãƒ°ãƒ±ãƒ²ãƒ³ã‚¬ã‚®ã‚°ã‚²ã‚´ã‚¶ã‚¸ã‚ºã‚¼ã‚¾ãƒ€ãƒ‚ãƒ…ãƒ‡ãƒ‰ãƒãƒ“ãƒ–ãƒ™ãƒœãƒ‘ãƒ”ãƒ—ãƒšãƒãƒ´ãƒ£ã‡ã£ãƒƒãƒ¥ãƒ§ã‚¡ã‚£ã‚¥ã‚§ã‚©ãƒ»ãƒ¼ã€Œã€ã€ã€‚ã€Žã€â€œâ€ï¼ï¼šï¼Ÿï¼…ï¼†ï¼ˆï¼‰ï¼ï¼ï¼‘ï¼’ï¼“ï¼”ï¼•ï¼–ï¼—ï¼˜ï¼™"</e></m></meta>
			<haxe_doc><![CDATA[Contains Hiragana, Katanaga, japanese punctuaction and full width space (0x3000) full width numbers (0-9) and some full width ascii punctuation (!:?%&()-). Does not include full width A-Za-z.]]></haxe_doc>
		</JP_KANA>
		<UNICODE_SPECIALS public="1" expr="&quot;ï¿½â–¡&quot;" line="38" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"ï¿½â–¡"</e></m></meta>
			<haxe_doc>Special unicode chars (fallback chars)</haxe_doc>
		</UNICODE_SPECIALS>
		<DEFAULT_CHARS public="1" expr="ASCII + LATIN1" line="41" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>ASCII + LATIN1</e></m></meta>
		</DEFAULT_CHARS>
		<inst static="1"><c path="hxd.Charset"/></inst>
		<getDefault public="1" set="method" line="142" static="1"><f a=""><c path="hxd.Charset"/></f></getDefault>
		<map><t path="Map">
	<x path="Int"/>
	<x path="Int"/>
</t></map>
		<resolveChar public="1" params="T" set="method" line="101"><f a="code:glyphs">
	<x path="Int"/>
	<t path="Map">
		<x path="Int"/>
		<c path="resolveChar.T"/>
	</t>
	<x path="Null"><c path="resolveChar.T"/></x>
</f></resolveChar>
		<isCJK public="1" set="method" line="111"><f a="code">
	<x path="Int"/>
	<x path="Bool"/>
</f></isCJK>
		<isSpace public="1" set="method" line="133"><f a="code">
	<x path="Int"/>
	<x path="Bool"/>
</f></isSpace>
		<isBreakChar public="1" set="method" line="137"><f a="code">
	<x path="Int"/>
	<x path="Bool"/>
</f></isBreakChar>
		<new set="method" line="45"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="hxd.Cursor" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/Cursor.hx">
		<Default/>
		<Button/>
		<Move/>
		<TextInput/>
		<Hide/>
		<Custom a="custom"><c path="hxd.CustomCursor"/></Custom>
		<Callback a="f">
			<f a=""><x path="Void"/></f>
			<haxe_doc>When this cursor is selected, call the function itself, which can handle complex logic and is responsible to call hxd.System.setCursor</haxe_doc>
		</Callback>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<class path="hxd.CustomCursor" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/Cursor.hx" module="hxd.Cursor">
		<frames><c path="Array"><c path="hxd.BitmapData"/></c></frames>
		<speed><x path="Float"/></speed>
		<offsetX><x path="Int"/></offsetX>
		<offsetY><x path="Int"/></offsetY>
		<alloc><d/></alloc>
		<dispose public="1" set="method" line="86"><f a=""><x path="Void"/></f></dispose>
		<new public="1" set="method" line="46"><f a="frames:speed:offsetX:offsetY">
	<c path="Array"><c path="hxd.BitmapData"/></c>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":allow"><e>hxd.System</e></m></meta>
	</class>
	<enum path="hxd.EventKind" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/Event.hx" module="hxd.Event">
		<EPush/>
		<ERelease/>
		<EMove/>
		<EOver/>
		<EOut/>
		<EWheel/>
		<EFocus/>
		<EFocusLost/>
		<EKeyDown/>
		<EKeyUp/>
		<EReleaseOutside/>
		<ETextInput/>
		<ECheck><haxe_doc>Used to check if we are still on the interactive if no EMove was triggered this frame.</haxe_doc></ECheck>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="hxd.Event" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/Event.hx">
		<kind public="1"><e path="hxd.EventKind"/></kind>
		<relX public="1"><x path="Float"/></relX>
		<relY public="1"><x path="Float"/></relY>
		<relZ public="1"><x path="Float"/></relZ>
		<propagate public="1">
			<x path="Bool"/>
			<haxe_doc>Will propagate the event to other interactives that are below the current one.</haxe_doc>
		</propagate>
		<cancel public="1">
			<x path="Bool"/>
			<haxe_doc>Will cancel the default behavior for this event as if it had happen outside of the interactive zone.</haxe_doc>
		</cancel>
		<button public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</button>
		<touchId public="1"><x path="Int"/></touchId>
		<keyCode public="1"><x path="Int"/></keyCode>
		<charCode public="1"><x path="Int"/></charCode>
		<wheelDelta public="1"><x path="Float"/></wheelDelta>
		<toString public="1" set="method" line="48"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="42">
			<f a="k:?x:?y" v=":0.:0.">
				<e path="hxd.EventKind"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ y : 0., x : 0. }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="hxd.BrowseOptions" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/File.hx" module="hxd.File"><a>
	<title>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</title>
	<saveFileName>
		<x path="Null"><f a="">
	<c path="String"/>
	<x path="Void"/>
</f></x>
		<meta><m n=":optional"/></meta>
	</saveFileName>
	<relativePath>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
	</relativePath>
	<fileTypes>
		<x path="Null"><c path="Array"><a>
	<name><c path="String"/></name>
	<extensions><c path="Array"><c path="String"/></c></extensions>
</a></c></x>
		<meta><m n=":optional"/></meta>
	</fileTypes>
	<defaultPath>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</defaultPath>
</a></typedef>
	<typedef path="hxd.BrowseSelect" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/File.hx" module="hxd.File"><a>
	<load set="method">
		<f a="onReady">
			<f a="">
				<c path="haxe.io.Bytes"/>
				<x path="Void"/>
			</f>
			<x path="Void"/>
		</f>
		<haxe_doc>allow to load the selected file content</haxe_doc>
	</load>
	<fileName>
		<c path="String"/>
		<haxe_doc>might contain only the file name without the full path depending on sandbox restrictions</haxe_doc>
	</fileName>
</a></typedef>
	<class path="hxd.File" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/File.hx">
		<browse public="1" set="method" line="75" static="1"><f a="onSelect:?options">
	<f a="">
		<t path="hxd.BrowseSelect"/>
		<x path="Void"/>
	</f>
	<t path="hxd.BrowseOptions"/>
	<x path="Void"/>
</f></browse>
		<saveAs public="1" set="method" line="205" static="1"><f a="dataContent:?options">
	<c path="haxe.io.Bytes"/>
	<t path="hxd.BrowseOptions"/>
	<x path="Void"/>
</f></saveAs>
		<exists public="1" set="method" line="243" static="1"><f a="path">
	<c path="String"/>
	<x path="Bool"/>
</f></exists>
		<delete public="1" set="method" line="254" static="1"><f a="path">
	<c path="String"/>
	<x path="Void"/>
</f></delete>
		<listDirectory public="1" set="method" line="267" static="1"><f a="path">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
</f></listDirectory>
		<getBytes public="1" set="method" line="281" static="1"><f a="path">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
</f></getBytes>
		<saveBytes public="1" set="method" line="310" static="1"><f a="path:data">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></saveBytes>
		<load public="1" set="method" line="326" static="1"><f a="path:onLoad:?onError">
	<c path="String"/>
	<f a="">
		<c path="haxe.io.Bytes"/>
		<x path="Void"/>
	</f>
	<f a="">
		<c path="String"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></load>
		<createDirectory public="1" set="method" line="349" static="1"><f a="path">
	<c path="String"/>
	<x path="Void"/>
</f></createDirectory>
		<applicationPath public="1" set="method" line="359" static="1"><f a=""><c path="String"/></f></applicationPath>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="hxd._FloatBuffer.InnerData" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/FloatBuffer.hx" private="1" module="hxd.FloatBuffer"><c path="Array"><t path="hxd.impl.Float32"/></c></typedef>
	<class path="hxd._FloatBuffer.InnerIterator" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/FloatBuffer.hx" private="1" module="hxd.FloatBuffer">
		<b><t path="hxd._FloatBuffer.InnerData"/></b>
		<len><x path="Int"/></len>
		<pos><x path="Int"/></pos>
		<hasNext public="1" get="inline" set="null" line="55"><f a=""><x path="Bool"/></f></hasNext>
		<next public="1" get="inline" set="null" line="58"><f a=""><t path="hxd.impl.Float32"/></f></next>
		<new public="1" get="inline" set="null" line="50"><f a="b">
	<t path="hxd._FloatBuffer.InnerData"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="hxd.FloatBuffer" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/FloatBuffer.hx">
		<this><t path="hxd._FloatBuffer.InnerData"/></this>
		<impl><class path="hxd._FloatBuffer.FloatBuffer_Impl_" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/FloatBuffer.hx" private="1" module="hxd.FloatBuffer">
	<length public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</length>
	<_new public="1" get="inline" set="null" line="67" static="1">
		<f a="?length" v="0">
			<x path="Int"/>
			<x path="hxd.FloatBuffer"/>
		</f>
		<meta>
			<m n=":value"><e>{ length : 0 }</e></m>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<push public="1" get="inline" set="null" line="76" static="1">
		<f a="this:v">
			<t path="hxd._FloatBuffer.InnerData"/>
			<t path="hxd.impl.Float32"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</push>
	<grow public="1" get="inline" set="null" line="84" static="1">
		<f a="this:v">
			<t path="hxd._FloatBuffer.InnerData"/>
			<x path="Int"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</grow>
	<resize public="1" get="inline" set="null" line="95" static="1">
		<f a="this:v">
			<t path="hxd._FloatBuffer.InnerData"/>
			<x path="Int"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</resize>
	<arrayRead get="inline" set="null" line="104" static="1">
		<f a="this:key">
			<t path="hxd._FloatBuffer.InnerData"/>
			<x path="Int"/>
			<t path="hxd.impl.Float32"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":arrayAccess"/>
		</meta>
	</arrayRead>
	<arrayWrite get="inline" set="null" line="108" static="1">
		<f a="this:key:value">
			<t path="hxd._FloatBuffer.InnerData"/>
			<x path="Int"/>
			<t path="hxd.impl.Float32"/>
			<t path="hxd.impl.Float32"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":arrayAccess"/>
		</meta>
	</arrayWrite>
	<getNative public="1" get="inline" set="null" line="112" static="1">
		<f a="this">
			<t path="hxd._FloatBuffer.InnerData"/>
			<t path="hxd._FloatBuffer.InnerData"/>
		</f>
		<meta><m n=":impl"/></meta>
	</getNative>
	<iterator public="1" get="inline" set="null" line="116" static="1">
		<f a="this">
			<t path="hxd._FloatBuffer.InnerData"/>
			<c path="hxd._FloatBuffer.InnerIterator"/>
		</f>
		<meta><m n=":impl"/></meta>
	</iterator>
	<get_length get="inline" set="null" line="120" static="1">
		<f a="this">
			<t path="hxd._FloatBuffer.InnerData"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_length>
</class></impl>
	</abstract>
	<class path="hxd._FloatBuffer.FloatBuffer_Impl_" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/FloatBuffer.hx" private="1" module="hxd.FloatBuffer">
		<length public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</length>
		<_new public="1" get="inline" set="null" line="67" static="1">
			<f a="?length" v="0">
				<x path="Int"/>
				<x path="hxd.FloatBuffer"/>
			</f>
			<meta>
				<m n=":value"><e>{ length : 0 }</e></m>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<push public="1" get="inline" set="null" line="76" static="1">
			<f a="this:v">
				<t path="hxd._FloatBuffer.InnerData"/>
				<t path="hxd.impl.Float32"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</push>
		<grow public="1" get="inline" set="null" line="84" static="1">
			<f a="this:v">
				<t path="hxd._FloatBuffer.InnerData"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</grow>
		<resize public="1" get="inline" set="null" line="95" static="1">
			<f a="this:v">
				<t path="hxd._FloatBuffer.InnerData"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</resize>
		<arrayRead get="inline" set="null" line="104" static="1">
			<f a="this:key">
				<t path="hxd._FloatBuffer.InnerData"/>
				<x path="Int"/>
				<t path="hxd.impl.Float32"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":arrayAccess"/>
			</meta>
		</arrayRead>
		<arrayWrite get="inline" set="null" line="108" static="1">
			<f a="this:key:value">
				<t path="hxd._FloatBuffer.InnerData"/>
				<x path="Int"/>
				<t path="hxd.impl.Float32"/>
				<t path="hxd.impl.Float32"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":arrayAccess"/>
			</meta>
		</arrayWrite>
		<getNative public="1" get="inline" set="null" line="112" static="1">
			<f a="this">
				<t path="hxd._FloatBuffer.InnerData"/>
				<t path="hxd._FloatBuffer.InnerData"/>
			</f>
			<meta><m n=":impl"/></meta>
		</getNative>
		<iterator public="1" get="inline" set="null" line="116" static="1">
			<f a="this">
				<t path="hxd._FloatBuffer.InnerData"/>
				<c path="hxd._FloatBuffer.InnerIterator"/>
			</f>
			<meta><m n=":impl"/></meta>
		</iterator>
		<get_length get="inline" set="null" line="120" static="1">
			<f a="this">
				<t path="hxd._FloatBuffer.InnerData"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_length>
	</class>
	<typedef path="hxd._IndexBuffer.InnerData" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/IndexBuffer.hx" private="1" module="hxd.IndexBuffer"><c path="Array"><t path="hxd.impl.UInt16"/></c></typedef>
	<class path="hxd._IndexBuffer.InnerIterator" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/IndexBuffer.hx" private="1" module="hxd.IndexBuffer">
		<b><t path="hxd._IndexBuffer.InnerData"/></b>
		<len><x path="Int"/></len>
		<pos><x path="Int"/></pos>
		<hasNext public="1" get="inline" set="null" line="14"><f a=""><x path="Bool"/></f></hasNext>
		<next public="1" get="inline" set="null" line="17"><f a=""><x path="Int"/></f></next>
		<new public="1" get="inline" set="null" line="9"><f a="b">
	<t path="hxd._IndexBuffer.InnerData"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="hxd.IndexBuffer" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/IndexBuffer.hx">
		<this><t path="hxd._IndexBuffer.InnerData"/></this>
		<impl><class path="hxd._IndexBuffer.IndexBuffer_Impl_" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/IndexBuffer.hx" private="1" module="hxd.IndexBuffer">
	<length public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</length>
	<_new public="1" get="inline" set="null" line="26" static="1">
		<f a="?length" v="0">
			<x path="Int"/>
			<x path="hxd.IndexBuffer"/>
		</f>
		<meta>
			<m n=":value"><e>{ length : 0 }</e></m>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<push public="1" get="inline" set="null" line="37" static="1">
		<f a="this:v">
			<t path="hxd._IndexBuffer.InnerData"/>
			<x path="Int"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</push>
	<grow public="1" get="inline" set="null" line="45" static="1">
		<f a="this:v">
			<t path="hxd._IndexBuffer.InnerData"/>
			<x path="Int"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</grow>
	<arrayRead get="inline" set="null" line="55" static="1">
		<f a="this:key">
			<t path="hxd._IndexBuffer.InnerData"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":arrayAccess"/>
		</meta>
	</arrayRead>
	<arrayWrite get="inline" set="null" line="59" static="1">
		<f a="this:key:value">
			<t path="hxd._IndexBuffer.InnerData"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":arrayAccess"/>
		</meta>
	</arrayWrite>
	<getNative public="1" get="inline" set="null" line="63" static="1">
		<f a="this">
			<t path="hxd._IndexBuffer.InnerData"/>
			<t path="hxd._IndexBuffer.InnerData"/>
		</f>
		<meta><m n=":impl"/></meta>
	</getNative>
	<iterator public="1" get="inline" set="null" line="67" static="1">
		<f a="this">
			<t path="hxd._IndexBuffer.InnerData"/>
			<c path="hxd._IndexBuffer.InnerIterator"/>
		</f>
		<meta><m n=":impl"/></meta>
	</iterator>
	<get_length get="inline" set="null" line="71" static="1">
		<f a="this">
			<t path="hxd._IndexBuffer.InnerData"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_length>
</class></impl>
	</abstract>
	<class path="hxd._IndexBuffer.IndexBuffer_Impl_" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/IndexBuffer.hx" private="1" module="hxd.IndexBuffer">
		<length public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</length>
		<_new public="1" get="inline" set="null" line="26" static="1">
			<f a="?length" v="0">
				<x path="Int"/>
				<x path="hxd.IndexBuffer"/>
			</f>
			<meta>
				<m n=":value"><e>{ length : 0 }</e></m>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<push public="1" get="inline" set="null" line="37" static="1">
			<f a="this:v">
				<t path="hxd._IndexBuffer.InnerData"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</push>
		<grow public="1" get="inline" set="null" line="45" static="1">
			<f a="this:v">
				<t path="hxd._IndexBuffer.InnerData"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</grow>
		<arrayRead get="inline" set="null" line="55" static="1">
			<f a="this:key">
				<t path="hxd._IndexBuffer.InnerData"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":arrayAccess"/>
			</meta>
		</arrayRead>
		<arrayWrite get="inline" set="null" line="59" static="1">
			<f a="this:key:value">
				<t path="hxd._IndexBuffer.InnerData"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":arrayAccess"/>
			</meta>
		</arrayWrite>
		<getNative public="1" get="inline" set="null" line="63" static="1">
			<f a="this">
				<t path="hxd._IndexBuffer.InnerData"/>
				<t path="hxd._IndexBuffer.InnerData"/>
			</f>
			<meta><m n=":impl"/></meta>
		</getNative>
		<iterator public="1" get="inline" set="null" line="67" static="1">
			<f a="this">
				<t path="hxd._IndexBuffer.InnerData"/>
				<c path="hxd._IndexBuffer.InnerIterator"/>
			</f>
			<meta><m n=":impl"/></meta>
		</iterator>
		<get_length get="inline" set="null" line="71" static="1">
			<f a="this">
				<t path="hxd._IndexBuffer.InnerData"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_length>
	</class>
	<class path="hxd.Math" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/Math.hx">
		<PI public="1" get="inline" set="null" expr="3.14159265358979323" line="5" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>3.14159265358979323</e></m></meta>
		</PI>
		<EPSILON public="1" get="inline" set="null" expr="1e-10" line="6" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1e-10</e></m></meta>
		</EPSILON>
		<POSITIVE_INFINITY public="1" get="accessor" set="null" static="1"><x path="Float"/></POSITIVE_INFINITY>
		<NEGATIVE_INFINITY public="1" get="accessor" set="null" static="1"><x path="Float"/></NEGATIVE_INFINITY>
		<NaN public="1" get="accessor" set="null" static="1"><x path="Float"/></NaN>
		<get_POSITIVE_INFINITY get="inline" set="null" line="12" static="1"><f a=""><x path="Float"/></f></get_POSITIVE_INFINITY>
		<get_NEGATIVE_INFINITY get="inline" set="null" line="16" static="1"><f a=""><x path="Float"/></f></get_NEGATIVE_INFINITY>
		<get_NaN get="inline" set="null" line="20" static="1"><f a=""><x path="Float"/></f></get_NaN>
		<isNaN public="1" get="inline" set="null" line="24" static="1"><f a="v">
	<x path="Float"/>
	<x path="Bool"/>
</f></isNaN>
		<fmt public="1" set="method" line="29" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></fmt>
		<floor public="1" get="inline" set="null" line="47" static="1"><f a="f">
	<x path="Float"/>
	<x path="Int"/>
</f></floor>
		<ceil public="1" get="inline" set="null" line="51" static="1"><f a="f">
	<x path="Float"/>
	<x path="Int"/>
</f></ceil>
		<round public="1" get="inline" set="null" line="55" static="1"><f a="f">
	<x path="Float"/>
	<x path="Int"/>
</f></round>
		<clamp public="1" get="inline" set="null" line="59" static="1">
			<f a="f:?min:?max" v=":0.:1.">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>{ max : 1., min : 0. }</e></m></meta>
		</clamp>
		<pow public="1" get="inline" set="null" line="63" static="1"><f a="v:p">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></pow>
		<scaleTime public="1" get="inline" set="null" line="67" static="1"><f a="v:et">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></scaleTime>
		<cos public="1" get="inline" set="null" line="71" static="1"><f a="f">
	<x path="Float"/>
	<x path="Float"/>
</f></cos>
		<sin public="1" get="inline" set="null" line="75" static="1"><f a="f">
	<x path="Float"/>
	<x path="Float"/>
</f></sin>
		<tan public="1" get="inline" set="null" line="79" static="1"><f a="f">
	<x path="Float"/>
	<x path="Float"/>
</f></tan>
		<acos public="1" get="inline" set="null" line="83" static="1"><f a="f">
	<x path="Float"/>
	<x path="Float"/>
</f></acos>
		<asin public="1" get="inline" set="null" line="87" static="1"><f a="f">
	<x path="Float"/>
	<x path="Float"/>
</f></asin>
		<atan public="1" get="inline" set="null" line="91" static="1"><f a="f">
	<x path="Float"/>
	<x path="Float"/>
</f></atan>
		<sqrt public="1" get="inline" set="null" line="95" static="1"><f a="f">
	<x path="Float"/>
	<x path="Float"/>
</f></sqrt>
		<invSqrt public="1" get="inline" set="null" line="99" static="1"><f a="f">
	<x path="Float"/>
	<x path="Float"/>
</f></invSqrt>
		<atan2 public="1" get="inline" set="null" line="103" static="1"><f a="dy:dx">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></atan2>
		<abs public="1" get="inline" set="null" line="107" static="1"><f a="f">
	<x path="Float"/>
	<x path="Float"/>
</f></abs>
		<max public="1" get="inline" set="null" line="111" static="1"><f a="a:b">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></max>
		<min public="1" get="inline" set="null" line="115" static="1"><f a="a:b">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></min>
		<iabs public="1" get="inline" set="null" line="119" static="1"><f a="i">
	<x path="Int"/>
	<x path="Int"/>
</f></iabs>
		<imax public="1" get="inline" set="null" line="123" static="1"><f a="a:b">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></imax>
		<imin public="1" get="inline" set="null" line="127" static="1"><f a="a:b">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></imin>
		<iclamp public="1" get="inline" set="null" line="131" static="1"><f a="v:min:max">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></iclamp>
		<lerp public="1" get="inline" set="null" line="138" static="1">
			<f a="a:b:k">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Linear interpolation between two values. When k is 0 a is returned, when it's 1, b is returned.</haxe_doc>
		</lerp>
		<bitCount public="1" get="inline" set="null" line="142" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></bitCount>
		<isPOT public="1" get="inline" set="null" line="148" static="1"><f a="v">
	<x path="Int"/>
	<x path="Bool"/>
</f></isPOT>
		<nextPOT public="1" get="inline" set="null" line="152" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></nextPOT>
		<distanceSq public="1" get="inline" set="null" line="162" static="1">
			<f a="dx:dy:?dz" v="::0.">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>{ dz : 0. }</e></m></meta>
		</distanceSq>
		<distance public="1" get="inline" set="null" line="166" static="1">
			<f a="dx:dy:?dz" v="::0.">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>{ dz : 0. }</e></m></meta>
		</distance>
		<colorLerp public="1" set="method" line="173" static="1">
			<f a="c1:c2:k">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Linear interpolation between two colors (ARGB).</haxe_doc>
		</colorLerp>
		<angle public="1" get="inline" set="null" line="192" static="1"><f a="da">
	<x path="Float"/>
	<x path="Float"/>
</f></angle>
		<angleLerp public="1" get="inline" set="null" line="198" static="1"><f a="a:b:k">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></angleLerp>
		<angleMove public="1" get="inline" set="null" line="205" static="1">
			<f a="a:b:max">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Move angle a towards angle b with a max increment. Return the new angle.</haxe_doc>
		</angleMove>
		<shuffle public="1" params="T" get="inline" set="null" line="210" static="1"><f a="a">
	<c path="Array"><c path="shuffle.T"/></c>
	<x path="Void"/>
</f></shuffle>
		<random public="1" get="inline" set="null" line="221" static="1">
			<f a="?max" v="1.0">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>{ max : 1.0 }</e></m></meta>
		</random>
		<srand public="1" set="method" line="228" static="1">
			<f a="?max" v="1.0">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>{ max : 1.0 }</e></m></meta>
			<haxe_doc>Returns a signed random between -max and max (both included).</haxe_doc>
		</srand>
		<b2f public="1" get="inline" set="null" line="238" static="1">
			<f a="v">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* takes an int , masks it and devide so that it safely maps 0...255 to 0...1.0
	 * @paramv an int between 0 and 255 will be masked
	 * @return a float between( 0 and 1)</haxe_doc>
		</b2f>
		<f2b public="1" get="inline" set="null" line="247" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* takes a float , clamps it and multipy so that it safely maps 0...1 to 0...255.0
	 * @param	f a float
	 * @return an int [0...255]</haxe_doc>
		</f2b>
		<umod public="1" get="inline" set="null" line="254" static="1">
			<f a="value:modulo">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* returns the modulo but always positive</haxe_doc>
		</umod>
		<ufmod public="1" get="inline" set="null" line="262" static="1">
			<f a="value:modulo">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* returns the modulo but always positive</haxe_doc>
		</ufmod>
		<degToRad public="1" get="inline" set="null" line="270" static="1">
			<f a="deg">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Convert degrees to radians</haxe_doc>
		</degToRad>
		<radToDeg public="1" get="inline" set="null" line="277" static="1">
			<f a="rad">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Convert radians to degrees</haxe_doc>
		</radToDeg>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="hxd.Flags" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/Pixels.hx" module="hxd.Pixels">
		<ReadOnly/>
		<AlphaPremultiplied/>
		<FlipY/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<abstract path="hxd.PixelsARGB" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/Pixels.hx" module="hxd.Pixels">
		<from><icast field="fromPixels"><c path="hxd.Pixels"/></icast></from>
		<this><c path="hxd.Pixels"/></this>
		<to><icast><c path="hxd.Pixels"/></icast></to>
		<meta><m n=":forward">
	<e>bytes</e>
	<e>width</e>
	<e>height</e>
	<e>offset</e>
	<e>flags</e>
	<e>clear</e>
	<e>dispose</e>
	<e>toPNG</e>
	<e>clone</e>
	<e>toVector</e>
	<e>sub</e>
	<e>blit</e>
</m></meta>
		<impl><class path="hxd._Pixels.PixelsARGB_Impl_" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/Pixels.hx" private="1" module="hxd.Pixels">
	<getPixel public="1" get="inline" set="null" line="13" static="1">
		<f a="this:x:y">
			<c path="hxd.Pixels"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</getPixel>
	<setPixel public="1" get="inline" set="null" line="17" static="1">
		<f a="this:x:y:v">
			<c path="hxd.Pixels"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</setPixel>
	<fromPixels public="1" set="method" line="21" static="1">
		<f a="p">
			<c path="hxd.Pixels"/>
			<x path="hxd.PixelsARGB"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromPixels>
	<meta><m n=":directlyUsed"/></meta>
</class></impl>
	</abstract>
	<class path="hxd._Pixels.PixelsARGB_Impl_" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/Pixels.hx" private="1" module="hxd.Pixels">
		<getPixel public="1" get="inline" set="null" line="13" static="1">
			<f a="this:x:y">
				<c path="hxd.Pixels"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</getPixel>
		<setPixel public="1" get="inline" set="null" line="17" static="1">
			<f a="this:x:y:v">
				<c path="hxd.Pixels"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</setPixel>
		<fromPixels public="1" set="method" line="21" static="1">
			<f a="p">
				<c path="hxd.Pixels"/>
				<x path="hxd.PixelsARGB"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromPixels>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="hxd.PixelsFloat" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/Pixels.hx" module="hxd.Pixels">
		<from><icast field="fromPixels"><c path="hxd.Pixels"/></icast></from>
		<this><c path="hxd.Pixels"/></this>
		<to><icast><c path="hxd.Pixels"/></icast></to>
		<meta><m n=":forward">
	<e>bytes</e>
	<e>format</e>
	<e>width</e>
	<e>height</e>
	<e>offset</e>
	<e>flags</e>
	<e>clear</e>
	<e>dispose</e>
	<e>toPNG</e>
	<e>clone</e>
	<e>toVector</e>
	<e>sub</e>
	<e>blit</e>
</m></meta>
		<impl><class path="hxd._Pixels.PixelsFloat_Impl_" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/Pixels.hx" private="1" module="hxd.Pixels">
	<getPixelF public="1" get="inline" set="null" line="31" static="1">
		<f a="this:x:y">
			<c path="hxd.Pixels"/>
			<x path="Int"/>
			<x path="Int"/>
			<c path="h3d.Vector"/>
		</f>
		<meta><m n=":impl"/></meta>
	</getPixelF>
	<setPixelF public="1" get="inline" set="null" line="45" static="1">
		<f a="this:x:y:v">
			<c path="hxd.Pixels"/>
			<x path="Int"/>
			<x path="Int"/>
			<c path="h3d.Vector"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</setPixelF>
	<fromPixels public="1" set="method" line="61" static="1">
		<f a="p">
			<c path="hxd.Pixels"/>
			<x path="hxd.PixelsFloat"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromPixels>
	<invalidFormat set="method" line="66" static="1">
		<f a="this">
			<c path="hxd.Pixels"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</invalidFormat>
</class></impl>
	</abstract>
	<class path="hxd._Pixels.PixelsFloat_Impl_" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/Pixels.hx" private="1" module="hxd.Pixels">
		<getPixelF public="1" get="inline" set="null" line="31" static="1">
			<f a="this:x:y">
				<c path="hxd.Pixels"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="h3d.Vector"/>
			</f>
			<meta><m n=":impl"/></meta>
		</getPixelF>
		<setPixelF public="1" get="inline" set="null" line="45" static="1">
			<f a="this:x:y:v">
				<c path="hxd.Pixels"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="h3d.Vector"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</setPixelF>
		<fromPixels public="1" set="method" line="61" static="1">
			<f a="p">
				<c path="hxd.Pixels"/>
				<x path="hxd.PixelsFloat"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromPixels>
		<invalidFormat set="method" line="66" static="1">
			<f a="this">
				<c path="hxd.Pixels"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</invalidFormat>
	</class>
	<abstract path="hxd.Channel" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/Pixels.hx" module="hxd.Pixels">
		<this><x path="Int"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="hxd._Pixels.Channel_Impl_" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/Pixels.hx" private="1" module="hxd.Pixels">
	<R public="1" get="inline" set="null" expr="cast 0" line="72" static="1">
		<x path="hxd.Channel"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</R>
	<G public="1" get="inline" set="null" expr="cast 1" line="73" static="1">
		<x path="hxd.Channel"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</G>
	<B public="1" get="inline" set="null" expr="cast 2" line="74" static="1">
		<x path="hxd.Channel"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</B>
	<A public="1" get="inline" set="null" expr="cast 3" line="75" static="1">
		<x path="hxd.Channel"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</A>
	<toInt public="1" get="inline" set="null" line="76" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toInt>
	<fromInt public="1" get="inline" set="null" line="77" static="1"><f a="v">
	<x path="Int"/>
	<x path="hxd.Channel"/>
</f></fromInt>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="hxd._Pixels.Channel_Impl_" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/Pixels.hx" private="1" module="hxd.Pixels">
		<R public="1" get="inline" set="null" expr="cast 0" line="72" static="1">
			<x path="hxd.Channel"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</R>
		<G public="1" get="inline" set="null" expr="cast 1" line="73" static="1">
			<x path="hxd.Channel"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</G>
		<B public="1" get="inline" set="null" expr="cast 2" line="74" static="1">
			<x path="hxd.Channel"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</B>
		<A public="1" get="inline" set="null" expr="cast 3" line="75" static="1">
			<x path="hxd.Channel"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</A>
		<toInt public="1" get="inline" set="null" line="76" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toInt>
		<fromInt public="1" get="inline" set="null" line="77" static="1"><f a="v">
	<x path="Int"/>
	<x path="hxd.Channel"/>
</f></fromInt>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="hxd.Pixels" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/Pixels.hx">
		<switchEndian public="1" get="inline" set="null" line="101" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></switchEndian>
		<switchBR public="1" get="inline" set="null" line="105" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></switchBR>
		<calcStride public="1" set="method" line="442" static="1"><f a="width:format">
	<x path="Int"/>
	<e path="hxd.PixelFormat"/>
	<x path="Int"/>
</f></calcStride>
		<S3TC_SIZES expr="[0, -1, 1, 1, -1, 1, 1, 1]" line="465" static="1">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e>[0, -1, 1, 1, -1, 1, 1, 1]</e></m></meta>
		</S3TC_SIZES>
		<getChannelOffset public="1" set="method" line="471" static="1">
			<f a="format:channel">
				<e path="hxd.PixelFormat"/>
				<x path="hxd.Channel"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the byte offset for the requested channel (0=R,1=G,2=B,3=A)
		Returns -1 if the channel is not found</haxe_doc>
		</getChannelOffset>
		<alloc public="1" set="method" line="498" static="1"><f a="width:height:format">
	<x path="Int"/>
	<x path="Int"/>
	<e path="hxd.PixelFormat"/>
	<c path="hxd.Pixels"/>
</f></alloc>
		<bytes public="1"><c path="haxe.io.Bytes"/></bytes>
		<format public="1" get="accessor" set="null"><e path="hxd.PixelFormat"/></format>
		<width public="1" set="null"><x path="Int"/></width>
		<height public="1" set="null"><x path="Int"/></height>
		<stride public="1" set="null"><x path="Int"/></stride>
		<offset public="1"><x path="Int"/></offset>
		<flags public="1"><x path="haxe.EnumFlags"><e path="hxd.Flags"/></x></flags>
		<bytesPerPixel><x path="Int"/></bytesPerPixel>
		<innerFormat set="accessor"><e path="hxd.PixelFormat"/></innerFormat>
		<get_format get="inline" set="null" line="109"><f a=""><e path="hxd.PixelFormat"/></f></get_format>
		<set_innerFormat set="method" line="111"><f a="fmt">
	<e path="hxd.PixelFormat"/>
	<e path="hxd.PixelFormat"/>
</f></set_innerFormat>
		<invalidFormat set="method" line="118"><f a=""><x path="Void"/></f></invalidFormat>
		<sub public="1" set="method" line="122"><f a="x:y:width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="hxd.Pixels"/>
</f></sub>
		<yflip get="inline" set="null" line="136"><f a="y">
	<x path="Int"/>
	<x path="Int"/>
</f></yflip>
		<blit public="1" set="method" line="140"><f a="x:y:src:srcX:srcY:width:height">
	<x path="Int"/>
	<x path="Int"/>
	<c path="hxd.Pixels"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></blit>
		<clear public="1" set="method" line="158">
			<f a="color:?preserveMask" v=":0">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ preserveMask : 0 }</e></m></meta>
		</clear>
		<toVector public="1" set="method" line="206"><f a=""><x path="haxe.ds.Vector"><x path="Int"/></x></f></toVector>
		<makeSquare public="1" set="method" line="248"><f a="?copy">
	<x path="Bool"/>
	<c path="hxd.Pixels"/>
</f></makeSquare>
		<copyInner set="method" line="278"><f a=""><x path="Void"/></f></copyInner>
		<willChange get="inline" set="null" line="286"><f a=""><x path="Void"/></f></willChange>
		<setFlip public="1" set="method" line="290"><f a="b">
	<x path="Bool"/>
	<x path="Void"/>
</f></setFlip>
		<convert public="1" set="method" line="310"><f a="target">
	<e path="hxd.PixelFormat"/>
	<x path="Void"/>
</f></convert>
		<getPixel public="1" set="method" line="381"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getPixel>
		<setPixel public="1" set="method" line="396"><f a="x:y:color">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setPixel>
		<dispose public="1" set="method" line="411"><f a=""><x path="Void"/></f></dispose>
		<toPNG public="1" set="method" line="415">
			<f a="?level" v="9">
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":value"><e>{ level : 9 }</e></m></meta>
		</toPNG>
		<clone public="1" set="method" line="430"><f a=""><c path="hxd.Pixels"/></f></clone>
		<new public="1" set="method" line="92">
			<f a="width:height:bytes:format:?offset" v="::::0">
				<x path="Int"/>
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
				<e path="hxd.PixelFormat"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ offset : 0 }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="hxd.Res" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/Res.hx">
		<load public="1" set="method" line="9" static="1"><f a="name">
	<c path="String"/>
	<c path="hxd.res.Any"/>
</f></load>
		<initEmbed public="1" set="method" static="1"><f a="?options">
	<t path="hxd.res.EmbedOptions"/>
	<d/>
</f></initEmbed>
		<initLocal public="1" set="method" static="1"><f a="?configuration">
	<d/>
	<d/>
</f></initLocal>
		<initPak public="1" set="method" static="1"><f a="?file">
	<d/>
	<d/>
</f></initPak>
		<loader public="1" get="accessor" set="accessor" static="1"><c path="hxd.res.Loader"/></loader>
		<get_loader set="method" line="4" static="1"><f a=""><c path="hxd.res.Loader"/></f></get_loader>
		<set_loader set="method" line="4" static="1"><f a="l">
	<c path="hxd.res.Loader"/>
	<c path="hxd.res.Loader"/>
</f></set_loader>
		<unknown public="1" get="accessor" set="null" static="1"><c path="hxd.res.Image"/></unknown>
		<get_unknown get="inline" set="null" line="4" static="1">
			<f a=""><c path="hxd.res.Image"/></f>
			<meta><m n=":extern"/></meta>
		</get_unknown>
		<tileset_ public="1" get="accessor" set="null" static="1"><c path="hxd.res.Image"/></tileset_>
		<get_tileset_ get="inline" set="null" line="4" static="1">
			<f a=""><c path="hxd.res.Image"/></f>
			<meta><m n=":extern"/></meta>
		</get_tileset_>
		<tileset_stage_2 public="1" get="accessor" set="null" static="1"><c path="hxd.res.Image"/></tileset_stage_2>
		<get_tileset_stage_2 get="inline" set="null" line="4" static="1">
			<f a=""><c path="hxd.res.Image"/></f>
			<meta><m n=":extern"/></meta>
		</get_tileset_stage_2>
		<tileset_2 public="1" get="accessor" set="null" static="1"><c path="hxd.res.Image"/></tileset_2>
		<get_tileset_2 get="inline" set="null" line="4" static="1">
			<f a=""><c path="hxd.res.Image"/></f>
			<meta><m n=":extern"/></meta>
		</get_tileset_2>
		<test_tiles_4 public="1" get="accessor" set="null" static="1"><c path="cherry.res.TiledMapFile"/></test_tiles_4>
		<get_test_tiles_4 get="inline" set="null" line="4" static="1">
			<f a=""><c path="cherry.res.TiledMapFile"/></f>
			<meta><m n=":extern"/></meta>
		</get_test_tiles_4>
		<test_tiles_3 public="1" get="accessor" set="null" static="1"><c path="cherry.res.TiledMapFile"/></test_tiles_3>
		<get_test_tiles_3 get="inline" set="null" line="4" static="1">
			<f a=""><c path="cherry.res.TiledMapFile"/></f>
			<meta><m n=":extern"/></meta>
		</get_test_tiles_3>
		<shop public="1" get="accessor" set="null" static="1"><c path="cherry.res.TiledMapFile"/></shop>
		<get_shop get="inline" set="null" line="4" static="1">
			<f a=""><c path="cherry.res.TiledMapFile"/></f>
			<meta><m n=":extern"/></meta>
		</get_shop>
		<objectset public="1" get="accessor" set="null" static="1"><c path="hxd.res.Image"/></objectset>
		<get_objectset get="inline" set="null" line="4" static="1">
			<f a=""><c path="hxd.res.Image"/></f>
			<meta><m n=":extern"/></meta>
		</get_objectset>
		<confirm public="1" get="accessor" set="null" static="1"><c path="hxd.res.Image"/></confirm>
		<get_confirm get="inline" set="null" line="4" static="1">
			<f a=""><c path="hxd.res.Image"/></f>
			<meta><m n=":extern"/></meta>
		</get_confirm>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>hxd.res.FileTree.build()</e></m>
		</meta>
	</class>
	<class path="hxd.SceneEvents" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/SceneEvents.hx">
		<window><c path="hxd.Window"/></window>
		<scenes><c path="Array"><c path="hxd.InteractiveScene"/></c></scenes>
		<overList><c path="Array"><c path="hxd.Interactive"/></c></overList>
		<overCandidates><c path="Array"><a>
	<z><x path="Float"/></z>
	<y><x path="Float"/></y>
	<x><x path="Float"/></x>
	<s><c path="hxd.InteractiveScene"/></s>
	<i><c path="hxd.Interactive"/></i>
</a></c></overCandidates>
		<overIndex expr="-1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</overIndex>
		<currentFocus><c path="hxd.Interactive"/></currentFocus>
		<pendingEvents><c path="Array"><c path="hxd.Event"/></c></pendingEvents>
		<pushList><c path="Array"><c path="hxd.Interactive"/></c></pushList>
		<currentDrag><a>
	<ref><x path="Null"><x path="Int"/></x></ref>
	<onCancel><f a=""><x path="Void"/></f></onCancel>
	<f><f a="">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></f>
</a></currentDrag>
		<mouseX expr="-1.">
			<x path="Float"/>
			<meta><m n=":value"><e>-1.</e></m></meta>
		</mouseX>
		<mouseY expr="-1.">
			<x path="Float"/>
			<meta><m n=":value"><e>-1.</e></m></meta>
		</mouseY>
		<lastTouch expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</lastTouch>
		<focusLost expr="new hxd.Event(EFocusLost)">
			<c path="hxd.Event"/>
			<meta><m n=":value"><e>new hxd.Event(EFocusLost)</e></m></meta>
		</focusLost>
		<checkPos expr="new hxd.Event(ECheck)">
			<c path="hxd.Event"/>
			<meta><m n=":value"><e>new hxd.Event(ECheck)</e></m></meta>
		</checkPos>
		<onOut expr="new hxd.Event(EOut)">
			<c path="hxd.Event"/>
			<meta><m n=":value"><e>new hxd.Event(EOut)</e></m></meta>
		</onOut>
		<onOver expr="new hxd.Event(EOver)">
			<c path="hxd.Event"/>
			<meta><m n=":value"><e>new hxd.Event(EOver)</e></m></meta>
		</onOver>
		<isOut expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</isOut>
		<enablePhysicalMouse public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* enablePhysicalMouse : enable mouse movements of system mouse, set it to false anse use setMousePos instead to manually set mouse position</haxe_doc>
		</enablePhysicalMouse>
		<mouseCheckMove public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* enable/disable per frame check of elements under mouse (default:true)</haxe_doc>
		</mouseCheckMove>
		<defaultCursor public="1" set="accessor" expr="Default">
			<e path="hxd.Cursor"/>
			<meta><m n=":value"><e>Default</e></m></meta>
			<haxe_doc>* Default cursor when there is no Interactive present under cursor.</haxe_doc>
		</defaultCursor>
		<setMousePos public="1" set="method" line="69"><f a="xPos:yPos">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setMousePos>
		<onRemove set="method" line="74"><f a="i">
	<c path="hxd.Interactive"/>
	<x path="Void"/>
</f></onRemove>
		<addScene public="1" set="method" line="92"><f a="s:?index">
	<c path="hxd.InteractiveScene"/>
	<x path="Int"/>
	<x path="Void"/>
</f></addScene>
		<removeScene public="1" set="method" line="97"><f a="s">
	<c path="hxd.InteractiveScene"/>
	<x path="Void"/>
</f></removeScene>
		<dispose public="1" set="method" line="101"><f a=""><x path="Void"/></f></dispose>
		<focus public="1" set="method" line="105"><f a="i">
	<c path="hxd.Interactive"/>
	<x path="Void"/>
</f></focus>
		<blur public="1" set="method" line="122"><f a=""><x path="Void"/></f></blur>
		<checkFocus set="method" line="131"><f a=""><x path="Void"/></f></checkFocus>
		<emitEvent set="method" line="142"><f a="event">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></emitEvent>
		<checkEvents public="1" set="method" line="309"><f a=""><x path="Void"/></f></checkEvents>
		<startDrag public="1" set="method" line="382"><f a="f:?onCancel:?refEvent">
	<f a="">
		<c path="hxd.Event"/>
		<x path="Void"/>
	</f>
	<f a=""><x path="Void"/></f>
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></startDrag>
		<stopDrag public="1" set="method" line="388"><f a=""><x path="Void"/></f></stopDrag>
		<getFocus public="1" set="method" line="394"><f a=""><c path="hxd.Interactive"/></f></getFocus>
		<updateCursor public="1" set="method" line="398"><f a="i">
	<c path="hxd.Interactive"/>
	<x path="Void"/>
</f></updateCursor>
		<set_defaultCursor set="method" line="402"><f a="c">
	<e path="hxd.Cursor"/>
	<e path="hxd.Cursor"/>
</f></set_defaultCursor>
		<selectCursor set="method" line="410"><f a=""><x path="Void"/></f></selectCursor>
		<onEvent set="method" line="424"><f a="e">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></onEvent>
		<dispatchListeners set="method" line="429"><f a="event">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></dispatchListeners>
		<new public="1" set="method" line="58"><f a="?window">
	<c path="hxd.Window"/>
	<x path="Void"/>
</f></new>
	</class>
	<enum path="hxd.Platform" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/System.hx" module="hxd.System">
		<IOS/>
		<Android/>
		<WebGL/>
		<PC/>
		<Console/>
		<FlashPlayer/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="hxd.SystemValue" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/System.hx" module="hxd.System">
		<IsTouch/>
		<IsWindowed/>
		<IsMobile/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="hxd.System" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/System.hx">
		<width public="1" get="accessor" set="null" static="1"><x path="Int"/></width>
		<height public="1" get="accessor" set="null" static="1"><x path="Int"/></height>
		<lang public="1" get="accessor" set="null" static="1"><c path="String"/></lang>
		<platform public="1" get="accessor" set="null" static="1"><e path="hxd.Platform"/></platform>
		<screenDPI public="1" get="accessor" set="null" static="1"><x path="Float"/></screenDPI>
		<setCursor public="1" expr="setNativeCursor" line="29" static="1">
			<f a="">
				<e path="hxd.Cursor"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>setNativeCursor</e></m></meta>
			<haxe_doc>Sets current cursor and can be replaced by custom function to manually operate displayed cursor.
		When called, it should call `hxd.System.setNativeCursor` and pass desired `hxd.Cursor` to it.</haxe_doc>
		</setCursor>
		<allowTimeout public="1" get="accessor" set="accessor" static="1">
			<x path="Bool"/>
			<haxe_doc>Can be used to temporarly disable infinite loop check</haxe_doc>
		</allowTimeout>
		<timeoutTick public="1" set="method" line="39" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>If you have a time consuming calculus that might trigger a timeout, you can either disable timeouts with [allowTimeout] or call timeoutTick() frequently.</haxe_doc>
		</timeoutTick>
		<loopFunc static="1"><f a=""><x path="Void"/></f></loopFunc>
		<getCurrentLoop public="1" set="method" line="44" static="1"><f a=""><f a=""><x path="Void"/></f></f></getCurrentLoop>
		<setLoop public="1" set="method" line="48" static="1"><f a="f">
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></setLoop>
		<start public="1" set="method" line="52" static="1"><f a="callb">
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></start>
		<setNativeCursor public="1" set="method" line="60" static="1">
			<f a="c">
				<e path="hxd.Cursor"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets currently shown cursor.
		This method is designated to be used by custom `hxd.System.setCursor`.
		Calling it outside of automated Interactive cursor update system leads to undefined behavior, and not advised.</haxe_doc>
		</setNativeCursor>
		<getDeviceName public="1" set="method" line="63" static="1"><f a=""><c path="String"/></f></getDeviceName>
		<getDefaultFrameRate public="1" set="method" line="67" static="1"><f a=""><x path="Float"/></f></getDefaultFrameRate>
		<getValue public="1" set="method" line="71" static="1"><f a="s">
	<e path="hxd.SystemValue"/>
	<x path="Bool"/>
</f></getValue>
		<exit public="1" set="method" line="75" static="1"><f a=""><x path="Void"/></f></exit>
		<openURL public="1" set="method" line="78" static="1"><f a="url">
	<c path="String"/>
	<x path="Void"/>
</f></openURL>
		<get_width set="method" line="82" static="1"><f a=""><x path="Int"/></f></get_width>
		<get_height set="method" line="83" static="1"><f a=""><x path="Int"/></f></get_height>
		<get_lang set="method" line="84" static="1"><f a=""><c path="String"/></f></get_lang>
		<get_platform set="method" line="85" static="1"><f a=""><e path="hxd.Platform"/></f></get_platform>
		<get_screenDPI set="method" line="86" static="1"><f a=""><x path="Int"/></f></get_screenDPI>
		<get_allowTimeout set="method" line="87" static="1"><f a=""><x path="Bool"/></f></get_allowTimeout>
		<set_allowTimeout set="method" line="88" static="1"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_allowTimeout>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.Timer" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/Timer.hx">
		<wantedFPS public="1" expr="60." line="14" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>60.</e></m></meta>
			<haxe_doc>The FPS on which "tmod" have values are based on.
		Can be freely configured if your gameplay runs at a different speed.
		Default : 60</haxe_doc>
		</wantedFPS>
		<maxDeltaTime public="1" expr="0.5" line="21" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.5</e></m></meta>
			<haxe_doc>The maximum amount of time between two frames (in seconds).
		If the time exceed this amount, Timer will consider these lags are to be ignored.
		Default : 0.5</haxe_doc>
		</maxDeltaTime>
		<smoothFactor public="1" expr="0.95" line="28" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.95</e></m></meta>
			<haxe_doc>The smoothing done between frames. A smoothing of 0 gives "real time" values, higher values will smooth
		the results for tmod/dt/fps over frames using the formula   dt = lerp(dt, elapsedTime, smoothFactor)
		Default : 0 on HashLink, 0.95 on other platforms</haxe_doc>
		</smoothFactor>
		<lastTimeStamp public="1" set="null" expr="haxe.Timer.stamp()" line="33" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>haxe.Timer.stamp()</e></m></meta>
			<haxe_doc>The last timestamp in which update() function was called.</haxe_doc>
		</lastTimeStamp>
		<elapsedTime public="1" set="null" expr="0." line="38" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
			<haxe_doc>The amount of time (unsmoothed) that was spent since the last frame.</haxe_doc>
		</elapsedTime>
		<frameCount public="1" expr="0" line="43" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>A frame counter, increases on each call to update()</haxe_doc>
		</frameCount>
		<dt public="1" expr="1 / wantedFPS" line="49" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1 / wantedFPS</e></m></meta>
			<haxe_doc>The smoothed elapsed time (in seconds).</haxe_doc>
		</dt>
		<tmod public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<haxe_doc>The smoothed frame modifier, based on wantedFPS. Its value is the same as dt/wantedFPS
		Allows to express movements in terms of pixels-per-frame-at-wantedFPS instead of per second.</haxe_doc>
		</tmod>
		<currentDT expr="1 / wantedFPS" line="57" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1 / wantedFPS</e></m></meta>
		</currentDT>
		<update public="1" set="method" line="62" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Update the timer calculus on each frame. This is automatically called by hxd.App</haxe_doc>
		</update>
		<get_tmod get="inline" set="null" line="74" static="1"><f a=""><x path="Float"/></f></get_tmod>
		<set_tmod get="inline" set="null" line="78" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_tmod>
		<fps public="1" set="method" line="86" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>The current smoothed FPS.</haxe_doc>
		</fps>
		<skip public="1" set="method" line="95" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>After some loading / long processing, call skip() in order to prevent
		it from impacting your smoothed values.</haxe_doc>
		</skip>
		<reset public="1" set="method" line="103" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Similar as skip() but also reset dt to default value.
		Can be used when starting a new game if you want to discard any previous measurement.</haxe_doc>
		</reset>
		<haxe_doc>The Timer class acts as a global time measurement that can be accessed from various parts of the engine.
	These three values are representation of the same underlying calculus: tmod, dt, fps</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="hxd.DisplayMode" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/Window.hx" module="hxd.Window">
		<Windowed/>
		<Borderless/>
		<Fullscreen/>
		<FullscreenResize/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="hxd.Window" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/Window.hx">
		<inst expr="null" line="76" static="1">
			<c path="hxd.Window"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</inst>
		<getInstance public="1" set="method" line="77" static="1"><f a=""><c path="hxd.Window"/></f></getInstance>
		<resizeEvents><t path="List"><f a=""><x path="Void"/></f></t></resizeEvents>
		<eventTargets><t path="List"><f a="">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></t></eventTargets>
		<width public="1" get="accessor" set="null"><x path="Int"/></width>
		<height public="1" get="accessor" set="null"><x path="Int"/></height>
		<mouseX public="1" get="accessor" set="null"><x path="Int"/></mouseX>
		<mouseY public="1" get="accessor" set="null"><x path="Int"/></mouseY>
		<mouseLock public="1" get="accessor" set="accessor"><x path="Bool"/></mouseLock>
		<vsync public="1" get="accessor" set="accessor"><x path="Bool"/></vsync>
		<isFocused public="1" get="accessor" set="null"><x path="Bool"/></isFocused>
		<title public="1" get="accessor" set="accessor"><c path="String"/></title>
		<displayMode public="1" get="accessor" set="accessor"><e path="hxd.DisplayMode"/></displayMode>
		<onClose public="1" set="dynamic" line="31"><f a=""><x path="Bool"/></f></onClose>
		<event public="1" set="method" line="35"><f a="e">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></event>
		<addEventTarget public="1" set="method" line="40"><f a="et">
	<f a="">
		<c path="hxd.Event"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></addEventTarget>
		<removeEventTarget public="1" set="method" line="44"><f a="et">
	<f a="">
		<c path="hxd.Event"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></removeEventTarget>
		<addResizeEvent public="1" set="method" line="52"><f a="f">
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></addResizeEvent>
		<removeResizeEvent public="1" set="method" line="56"><f a="f">
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></removeResizeEvent>
		<onResize set="method" line="64"><f a="e">
	<d/>
	<x path="Void"/>
</f></onResize>
		<resize public="1" set="method" line="69"><f a="width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></resize>
		<setFullScreen public="1" set="method" line="73">
			<f a="v">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":deprecated"><e>"Use the displayMode property instead"</e></m></meta>
		</setFullScreen>
		<get_mouseX set="method" line="82"><f a=""><x path="Int"/></f></get_mouseX>
		<get_mouseY set="method" line="86"><f a=""><x path="Int"/></f></get_mouseY>
		<get_width set="method" line="90"><f a=""><x path="Int"/></f></get_width>
		<get_height set="method" line="94"><f a=""><x path="Int"/></f></get_height>
		<get_mouseLock set="method" line="98"><f a=""><x path="Bool"/></f></get_mouseLock>
		<set_mouseLock set="method" line="102"><f a="v">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_mouseLock>
		<get_vsync set="method" line="107"><f a=""><x path="Bool"/></f></get_vsync>
		<set_vsync set="method" line="109"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_vsync>
		<get_isFocused set="method" line="114"><f a=""><x path="Bool"/></f></get_isFocused>
		<get_displayMode set="method" line="116"><f a=""><e path="hxd.DisplayMode"/></f></get_displayMode>
		<set_displayMode set="method" line="119"><f a="m">
	<e path="hxd.DisplayMode"/>
	<e path="hxd.DisplayMode"/>
</f></set_displayMode>
		<get_title set="method" line="123"><f a=""><c path="String"/></f></get_title>
		<set_title set="method" line="126"><f a="t">
	<c path="String"/>
	<c path="String"/>
</f></set_title>
		<new set="method" line="26"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.earcut.EarNode" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/earcut/Earcut.hx" module="hxd.earcut.Earcut">
		<next public="1"><c path="hxd.earcut.EarNode"/></next>
		<prev public="1"><c path="hxd.earcut.EarNode"/></prev>
		<nextZ public="1"><c path="hxd.earcut.EarNode"/></nextZ>
		<prevZ public="1"><c path="hxd.earcut.EarNode"/></prevZ>
		<allocNext public="1"><c path="hxd.earcut.EarNode"/></allocNext>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<i public="1"><x path="Int"/></i>
		<z public="1"><x path="Int"/></z>
		<steiner public="1"><x path="Bool"/></steiner>
		<new public="1" set="method" line="14"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.earcut.Earcut" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/earcut/Earcut.hx">
		<triangles><c path="Array"><x path="Int"/></c></triangles>
		<cache><c path="hxd.earcut.EarNode"/></cache>
		<allocated><c path="hxd.earcut.EarNode"/></allocated>
		<minX><x path="Float"/></minX>
		<minY><x path="Float"/></minY>
		<size><x path="Float"/></size>
		<hasSize><x path="Bool"/></hasSize>
		<triangulate public="1" params="T" set="method" line="34">
			<f a="points:?holes">
				<c path="Array"><c path="triangulate.T"/></c>
				<c path="Array"><x path="Int"/></c>
				<c path="Array"><x path="Int"/></c>
			</f>
			<meta><m n=":generic"/></meta>
		</triangulate>
		<triangulateNode public="1" set="method" line="48"><f a="root:useZOrder">
	<c path="hxd.earcut.EarNode"/>
	<x path="Bool"/>
	<c path="Array"><x path="Int"/></c>
</f></triangulateNode>
		<setLinkedList params="T" set="method" line="90">
			<f a="points:start:end:clockwise">
				<c path="Array"><c path="setLinkedList.T"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="hxd.earcut.EarNode"/>
			</f>
			<meta><m n=":generic"/></meta>
		</setLinkedList>
		<eliminateHoles params="T" set="method" line="124">
			<f a="points:holes:root">
				<c path="Array"><c path="eliminateHoles.T"/></c>
				<c path="Array"><x path="Int"/></c>
				<c path="hxd.earcut.EarNode"/>
				<c path="hxd.earcut.EarNode"/>
			</f>
			<meta><m n=":generic"/></meta>
		</eliminateHoles>
		<eliminateHole set="method" line="147"><f a="hole:root">
	<c path="hxd.earcut.EarNode"/>
	<c path="hxd.earcut.EarNode"/>
	<x path="Void"/>
</f></eliminateHole>
		<findHoleBridge set="method" line="156"><f a="hole:root">
	<c path="hxd.earcut.EarNode"/>
	<c path="hxd.earcut.EarNode"/>
	<c path="hxd.earcut.EarNode"/>
</f></findHoleBridge>
		<getLeftmost set="method" line="201"><f a="node">
	<c path="hxd.earcut.EarNode"/>
	<c path="hxd.earcut.EarNode"/>
</f></getLeftmost>
		<compareX get="inline" set="null" line="212"><f a="a:b">
	<c path="hxd.earcut.EarNode"/>
	<c path="hxd.earcut.EarNode"/>
	<x path="Int"/>
</f></compareX>
		<equals get="inline" set="null" line="216"><f a="p1:p2">
	<c path="hxd.earcut.EarNode"/>
	<c path="hxd.earcut.EarNode"/>
	<x path="Bool"/>
</f></equals>
		<area get="inline" set="null" line="220"><f a="p:q:r">
	<c path="hxd.earcut.EarNode"/>
	<c path="hxd.earcut.EarNode"/>
	<c path="hxd.earcut.EarNode"/>
	<x path="Float"/>
</f></area>
		<intersects get="inline" set="null" line="224"><f a="p1:q1:p2:q2">
	<c path="hxd.earcut.EarNode"/>
	<c path="hxd.earcut.EarNode"/>
	<c path="hxd.earcut.EarNode"/>
	<c path="hxd.earcut.EarNode"/>
	<x path="Bool"/>
</f></intersects>
		<locallyInside get="inline" set="null" line="229"><f a="a:b">
	<c path="hxd.earcut.EarNode"/>
	<c path="hxd.earcut.EarNode"/>
	<x path="Bool"/>
</f></locallyInside>
		<filterPoints set="method" line="235">
			<f a="start:?end" v=":null">
				<c path="hxd.earcut.EarNode"/>
				<c path="hxd.earcut.EarNode"/>
				<c path="hxd.earcut.EarNode"/>
			</f>
			<meta><m n=":value"><e>{ end : null }</e></m></meta>
		</filterPoints>
		<removeNode get="inline" set="null" line="253"><f a="p">
	<c path="hxd.earcut.EarNode"/>
	<x path="Void"/>
</f></removeNode>
		<allocNode get="inline" set="null" line="260">
			<f a="i:x:y:?last" v=":::null">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="hxd.earcut.EarNode"/>
				<c path="hxd.earcut.EarNode"/>
			</f>
			<meta><m n=":value"><e>{ last : null }</e></m></meta>
		</allocNode>
		<earcutLinked set="method" line="282">
			<f a="ear:?pass" v=":0">
				<c path="hxd.earcut.EarNode"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ pass : 0 }</e></m></meta>
		</earcutLinked>
		<isEar set="method" line="333"><f a="ear">
	<c path="hxd.earcut.EarNode"/>
	<x path="Bool"/>
</f></isEar>
		<isEarHashed set="method" line="352"><f a="ear">
	<c path="hxd.earcut.EarNode"/>
	<x path="Bool"/>
</f></isEarHashed>
		<cureLocalIntersections set="method" line="393"><f a="start">
	<c path="hxd.earcut.EarNode"/>
	<c path="hxd.earcut.EarNode"/>
</f></cureLocalIntersections>
		<splitEarcut set="method" line="419"><f a="start">
	<c path="hxd.earcut.EarNode"/>
	<x path="Void"/>
</f></splitEarcut>
		<splitPolygon set="method" line="446"><f a="a:b">
	<c path="hxd.earcut.EarNode"/>
	<c path="hxd.earcut.EarNode"/>
	<c path="hxd.earcut.EarNode"/>
</f></splitPolygon>
		<pointInTriangle get="inline" set="null" line="467"><f a="ax:ay:bx:by:cx:cy:px:py">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></pointInTriangle>
		<isValidDiagonal set="method" line="474"><f a="a:b">
	<c path="hxd.earcut.EarNode"/>
	<c path="hxd.earcut.EarNode"/>
	<x path="Bool"/>
</f></isValidDiagonal>
		<middleInside set="method" line="480"><f a="a:b">
	<c path="hxd.earcut.EarNode"/>
	<c path="hxd.earcut.EarNode"/>
	<x path="Bool"/>
</f></middleInside>
		<intersectsPolygon set="method" line="495"><f a="a:b">
	<c path="hxd.earcut.EarNode"/>
	<c path="hxd.earcut.EarNode"/>
	<x path="Bool"/>
</f></intersectsPolygon>
		<zOrder get="inline" set="null" line="505"><f a="px:py">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
</f></zOrder>
		<indexCurve set="method" line="523"><f a="start">
	<c path="hxd.earcut.EarNode"/>
	<x path="Void"/>
</f></indexCurve>
		<sortLinked set="method" line="538"><f a="list">
	<c path="hxd.earcut.EarNode"/>
	<c path="hxd.earcut.EarNode"/>
</f></sortLinked>
		<new public="1" set="method" line="31"><f a=""><x path="Void"/></f></new>
		<haxe_doc>Ported from https://github.com/mapbox/earcut by @ncannasse</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.fmt.bfnt.FontParser" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fmt/bfnt/FontParser.hx">
		<parse public="1" set="method" line="12" static="1">
			<f a="bytes:path:resolveTile">
				<c path="haxe.io.Bytes"/>
				<c path="String"/>
				<f a="">
					<c path="String"/>
					<c path="h2d.Tile"/>
				</f>
				<c path="h2d.Font"/>
			</f>
			<meta><m n=":access"><e>h2d.Font</e></m></meta>
		</parse>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.fmt.bfnt.Reader" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fmt/bfnt/Reader.hx">
		<parse public="1" get="inline" set="null" line="47" static="1"><f a="bytes:resolveTile">
	<c path="haxe.io.Bytes"/>
	<f a="">
		<c path="String"/>
		<c path="h2d.Tile"/>
	</f>
	<c path="h2d.Font"/>
</f></parse>
		<i><c path="haxe.io.Input"/></i>
		<read public="1" set="method" line="14"><f a="resolveTile">
	<f a="">
		<c path="String"/>
		<c path="h2d.Tile"/>
	</f>
	<c path="h2d.Font"/>
</f></read>
		<new public="1" set="method" line="10"><f a="i">
	<c path="haxe.io.Input"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>h2d.Font</e></m>
		</meta>
	</class>
	<class path="hxd.fmt.bfnt.Writer" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fmt/bfnt/Writer.hx">
		<VERSION get="inline" set="null" expr="1" line="8" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</VERSION>
		<out><c path="haxe.io.Output"/></out>
		<write public="1" set="method" line="26"><f a="font">
	<c path="h2d.Font"/>
	<x path="Void"/>
</f></write>
		<writeString get="inline" set="null" line="76"><f a="s">
	<c path="String"/>
	<x path="Void"/>
</f></writeString>
		<new public="1" set="method" line="22"><f a="out">
	<c path="haxe.io.Output"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>h2d.Font</e></m>
		</meta>
	</class>
	<class path="hxd.fmt.fbx.TmpObject" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fmt/fbx/BaseLibrary.hx" module="hxd.fmt.fbx.BaseLibrary">
		<index public="1"><x path="Int"/></index>
		<model public="1"><t path="hxd.fmt.fbx.FbxNode"/></model>
		<parent public="1"><c path="hxd.fmt.fbx.TmpObject"/></parent>
		<isJoint public="1"><x path="Bool"/></isJoint>
		<isMesh public="1"><x path="Bool"/></isMesh>
		<childs public="1"><c path="Array"><c path="hxd.fmt.fbx.TmpObject"/></c></childs>
		<obj public="1"><c path="h3d.scene.Object"/></obj>
		<joint public="1"><c path="h3d.anim.Joint"/></joint>
		<skin public="1"><c path="hxd.fmt.fbx.TmpObject"/></skin>
		<new public="1" set="method" line="24"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.fmt.fbx._BaseLibrary.AnimCurve" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fmt/fbx/BaseLibrary.hx" private="1" module="hxd.fmt.fbx.BaseLibrary">
		<def public="1"><c path="hxd.fmt.fbx.DefaultMatrixes"/></def>
		<object public="1"><c path="String"/></object>
		<t public="1"><a>
	<z><c path="Array"><x path="Float"/></c></z>
	<y><c path="Array"><x path="Float"/></c></y>
	<x><c path="Array"><x path="Float"/></c></x>
	<t><c path="Array"><x path="Float"/></c></t>
</a></t>
		<r public="1"><a>
	<z><c path="Array"><x path="Float"/></c></z>
	<y><c path="Array"><x path="Float"/></c></y>
	<x><c path="Array"><x path="Float"/></c></x>
	<t><c path="Array"><x path="Float"/></c></t>
</a></r>
		<s public="1"><a>
	<z><c path="Array"><x path="Float"/></c></z>
	<y><c path="Array"><x path="Float"/></c></y>
	<x><c path="Array"><x path="Float"/></c></x>
	<t><c path="Array"><x path="Float"/></c></t>
</a></s>
		<a public="1"><a>
	<v><c path="Array"><x path="Float"/></c></v>
	<t><c path="Array"><x path="Float"/></c></t>
</a></a>
		<fov public="1"><a>
	<v><c path="Array"><x path="Float"/></c></v>
	<t><c path="Array"><x path="Float"/></c></t>
</a></fov>
		<roll public="1"><a>
	<v><c path="Array"><x path="Float"/></c></v>
	<t><c path="Array"><x path="Float"/></c></t>
</a></roll>
		<uv public="1"><c path="Array"><a>
	<v><x path="Float"/></v>
	<u><x path="Float"/></u>
	<t><x path="Float"/></t>
</a></c></uv>
		<new public="1" set="method" line="39"><f a="def:object">
	<c path="hxd.fmt.fbx.DefaultMatrixes"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.fmt.fbx.DefaultMatrixes" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fmt/fbx/BaseLibrary.hx" module="hxd.fmt.fbx.BaseLibrary">
		<rightHandToLeft public="1" get="inline" set="null" line="57" static="1"><f a="m">
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></rightHandToLeft>
		<trans public="1"><x path="Null"><c path="h3d.col.Point"/></x></trans>
		<scale public="1"><x path="Null"><c path="h3d.col.Point"/></x></scale>
		<rotate public="1"><x path="Null"><c path="h3d.col.Point"/></x></rotate>
		<preRot public="1"><x path="Null"><c path="h3d.col.Point"/></x></preRot>
		<wasRemoved public="1"><x path="Null"><x path="Int"/></x></wasRemoved>
		<transPos public="1"><c path="h3d.Matrix"/></transPos>
		<toMatrix public="1" set="method" line="69"><f a="leftHand">
	<x path="Bool"/>
	<c path="h3d.Matrix"/>
</f></toMatrix>
		<toQuaternion public="1" set="method" line="80"><f a="leftHand">
	<x path="Bool"/>
	<c path="h3d.Quat"/>
</f></toQuaternion>
		<new public="1" set="method" line="54"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.fmt.fbx.BaseLibrary" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fmt/fbx/BaseLibrary.hx">
		<root><t path="hxd.fmt.fbx.FbxNode"/></root>
		<ids><t path="Map">
	<x path="Int"/>
	<t path="hxd.fmt.fbx.FbxNode"/>
</t></ids>
		<connect><t path="Map">
	<x path="Int"/>
	<c path="Array"><x path="Int"/></c>
</t></connect>
		<namedConnect><t path="Map">
	<x path="Int"/>
	<t path="Map">
		<c path="String"/>
		<x path="Int"/>
	</t>
</t></namedConnect>
		<invConnect><t path="Map">
	<x path="Int"/>
	<c path="Array"><x path="Int"/></c>
</t></invConnect>
		<leftHand><x path="Bool"/></leftHand>
		<defaultModelMatrixes><t path="Map">
	<c path="String"/>
	<c path="hxd.fmt.fbx.DefaultMatrixes"/>
</t></defaultModelMatrixes>
		<uvAnims><t path="Map">
	<c path="String"/>
	<c path="Array"><a>
	<v><x path="Float"/></v>
	<u><x path="Float"/></u>
	<t><x path="Float"/></t>
</a></c>
</t></uvAnims>
		<animationEvents><c path="Array"><a>
	<frame><x path="Int"/></frame>
	<data><c path="String"/></data>
</a></c></animationEvents>
		<isMaya><x path="Bool"/></isMaya>
		<fileName public="1"><c path="String"/></fileName>
		<version public="1" expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
			<haxe_doc>The FBX version that was decoded</haxe_doc>
		</version>
		<keepJoints public="1">
			<t path="Map">
				<c path="String"/>
				<x path="Bool"/>
			</t>
			<haxe_doc>Allows to prevent some terminal unskinned joints to be removed, for instance if we want to track their position</haxe_doc>
		</keepJoints>
		<skipObjects public="1">
			<t path="Map">
				<c path="String"/>
				<x path="Bool"/>
			</t>
			<haxe_doc>Allows to skip some objects from being processed as if they were not part of the FBX</haxe_doc>
		</skipObjects>
		<bonesPerVertex public="1" expr="3">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
			<haxe_doc>Set how many bones per vertex should be created in skin data in makeObject(). Default is 3</haxe_doc>
		</bonesPerVertex>
		<maxBonesPerSkin public="1" expr="34">
			<x path="Int"/>
			<meta><m n=":value"><e>34</e></m></meta>
			<haxe_doc>If there are too many bones, the model will be split in separate render passes.</haxe_doc>
		</maxBonesPerSkin>
		<unskinnedJointsAsObjects public="1">
			<x path="Bool"/>
			<haxe_doc>Consider unskinned joints to be simple objects</haxe_doc>
		</unskinnedJointsAsObjects>
		<allowVertexColor public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</allowVertexColor>
		<normalizeScaleOrient public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>Convert centimeters to meters and axis to Z-up (Maya FBX export)</haxe_doc>
		</normalizeScaleOrient>
		<reset set="method" line="153"><f a=""><x path="Void"/></f></reset>
		<loadFile public="1" set="method" line="161"><f a="data">
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></loadFile>
		<load public="1" set="method" line="165"><f a="root">
	<t path="hxd.fmt.fbx.FbxNode"/>
	<x path="Void"/>
</f></load>
		<updateModelScale set="method" line="212"><f a=""><x path="Void"/></f></updateModelScale>
		<convertPoints set="method" line="319"><f a="a">
	<c path="Array"><x path="Float"/></c>
	<x path="Void"/>
</f></convertPoints>
		<leftHandConvert public="1" set="method" line="327"><f a=""><x path="Void"/></f></leftHandConvert>
		<init set="method" line="342"><f a="n">
	<t path="hxd.fmt.fbx.FbxNode"/>
	<x path="Void"/>
</f></init>
		<getGeometry public="1" set="method" line="392">
			<f a="?name" v="&quot;&quot;">
				<c path="String"/>
				<c path="hxd.fmt.fbx.Geometry"/>
			</f>
			<meta><m n=":value"><e>{ name : "" }</e></m></meta>
		</getGeometry>
		<getParent public="1" set="method" line="404"><f a="node:nodeName:?opt">
	<t path="hxd.fmt.fbx.FbxNode"/>
	<c path="String"/>
	<x path="Bool"/>
	<x path="Null"><t path="hxd.fmt.fbx.FbxNode"/></x>
</f></getParent>
		<getChild public="1" set="method" line="413"><f a="node:nodeName:?opt">
	<t path="hxd.fmt.fbx.FbxNode"/>
	<c path="String"/>
	<x path="Bool"/>
	<x path="Null"><t path="hxd.fmt.fbx.FbxNode"/></x>
</f></getChild>
		<getSpecChild public="1" set="method" line="422"><f a="node:name">
	<t path="hxd.fmt.fbx.FbxNode"/>
	<c path="String"/>
	<x path="Null"><t path="hxd.fmt.fbx.FbxNode"/></x>
</f></getSpecChild>
		<getChilds public="1" set="method" line="432"><f a="node:?nodeName">
	<t path="hxd.fmt.fbx.FbxNode"/>
	<c path="String"/>
	<c path="Array"><x path="Null"><t path="hxd.fmt.fbx.FbxNode"/></x></c>
</f></getChilds>
		<getParents public="1" set="method" line="445"><f a="node:?nodeName">
	<t path="hxd.fmt.fbx.FbxNode"/>
	<c path="String"/>
	<c path="Array"><x path="Null"><t path="hxd.fmt.fbx.FbxNode"/></x></c>
</f></getParents>
		<getRoot public="1" set="method" line="458"><f a=""><t path="hxd.fmt.fbx.FbxNode"/></f></getRoot>
		<ignoreMissingObject public="1" set="method" line="462"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></ignoreMissingObject>
		<buildHierarchy set="method" line="471"><f a=""><a>
	<root><c path="hxd.fmt.fbx.TmpObject"/></root>
	<objects><c path="Array"><c path="hxd.fmt.fbx.TmpObject"/></c></objects>
</a></f></buildHierarchy>
		<getObjectCurve set="method" line="581"><f a="curves:model:curveName:animName">
	<t path="Map">
		<x path="Int"/>
		<c path="hxd.fmt.fbx._BaseLibrary.AnimCurve"/>
	</t>
	<t path="hxd.fmt.fbx.FbxNode"/>
	<c path="String"/>
	<c path="String"/>
	<c path="hxd.fmt.fbx._BaseLibrary.AnimCurve"/>
</f></getObjectCurve>
		<mergeModels public="1" set="method" line="613"><f a="modelNames">
	<c path="Array"><c path="String"/></c>
	<x path="Void"/>
</f></mergeModels>
		<addLink set="method" line="691"><f a="parent:child">
	<t path="hxd.fmt.fbx.FbxNode"/>
	<t path="hxd.fmt.fbx.FbxNode"/>
	<x path="Void"/>
</f></addLink>
		<removeLink set="method" line="698"><f a="parent:child">
	<t path="hxd.fmt.fbx.FbxNode"/>
	<t path="hxd.fmt.fbx.FbxNode"/>
	<x path="Void"/>
</f></removeLink>
		<checkData set="method" line="705"><f a="t">
	<a>
		<z><c path="Array"><x path="Float"/></c></z>
		<y><c path="Array"><x path="Float"/></c></y>
		<x><c path="Array"><x path="Float"/></c></x>
	</a>
	<x path="Bool"/>
</f></checkData>
		<roundValues set="method" line="729">
			<f a="data:def:?mult" v="::1.">
				<c path="Array"><x path="Float"/></c>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ mult : 1. }</e></m></meta>
		</roundValues>
		<getAnimationNames public="1" set="method" line="745">
			<f a=""><c path="Array"><c path="String"/></c></f>
			<haxe_doc>Returns an array of names with all animations present in FBX file.</haxe_doc>
		</getAnimationNames>
		<loadAnimation public="1" set="method" line="754"><f a="?animName:?root:?lib">
	<c path="String"/>
	<t path="hxd.fmt.fbx.FbxNode"/>
	<c path="hxd.fmt.fbx.BaseLibrary"/>
	<c path="h3d.anim.Animation"/>
</f></loadAnimation>
		<sortDistinctFloats set="method" line="1172"><f a="a:b">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
</f></sortDistinctFloats>
		<isNullJoint set="method" line="1176"><f a="model">
	<t path="hxd.fmt.fbx.FbxNode"/>
	<x path="Bool"/>
</f></isNullJoint>
		<getModelPath set="method" line="1188"><f a="model">
	<t path="hxd.fmt.fbx.FbxNode"/>
	<x path="Null"><c path="String"/></x>
</f></getModelPath>
		<autoMerge set="method" line="1196"><f a=""><x path="Void"/></f></autoMerge>
		<keepJoint set="method" line="1246"><f a="j">
	<c path="h3d.anim.Joint"/>
	<x path="Bool"/>
</f></keepJoint>
		<createSkin set="method" line="1250"><f a="hskins:hgeom:rootJoints:bonesPerVertex">
	<t path="Map">
		<x path="Int"/>
		<c path="h3d.anim.Skin"/>
	</t>
	<t path="Map">
		<x path="Int"/>
		<a>
			<vertexCount set="method"><f a=""><x path="Int"/></f></vertexCount>
			<setSkin set="method"><f a="s">
	<c path="h3d.anim.Skin"/>
	<x path="Void"/>
</f></setSkin>
		</a>
	</t>
	<c path="Array"><c path="h3d.anim.Joint"/></c>
	<x path="Int"/>
	<x path="Null"><c path="h3d.anim.Skin"/></x>
</f></createSkin>
		<round set="method" line="1319"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></round>
		<updateDefaultMatrix set="method" line="1324"><f a="model:d">
	<t path="hxd.fmt.fbx.FbxNode"/>
	<c path="hxd.fmt.fbx.DefaultMatrixes"/>
	<x path="Void"/>
</f></updateDefaultMatrix>
		<getDefaultMatrixes set="method" line="1401"><f a="model">
	<t path="hxd.fmt.fbx.FbxNode"/>
	<x path="Null"><c path="hxd.fmt.fbx.DefaultMatrixes"/></x>
</f></getDefaultMatrixes>
		<new public="1" set="method" line="145"><f a="fileName">
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<enum path="hxd.fmt.fbx.FbxProp" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fmt/fbx/Data.hx" module="hxd.fmt.fbx.Data">
		<PInt a="v"><x path="Int"/></PInt>
		<PFloat a="v"><x path="Float"/></PFloat>
		<PString a="v"><c path="String"/></PString>
		<PIdent a="i"><c path="String"/></PIdent>
		<PInts a="v"><c path="Array"><x path="Int"/></c></PInts>
		<PFloats a="v"><c path="Array"><x path="Float"/></c></PFloats>
		<PBinary a="v"><c path="haxe.io.Bytes"/></PBinary>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<typedef path="hxd.fmt.fbx.FbxNode" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fmt/fbx/Data.hx" module="hxd.fmt.fbx.Data"><a>
	<props><c path="Array"><e path="hxd.fmt.fbx.FbxProp"/></c></props>
	<name><c path="String"/></name>
	<childs><c path="Array"><t path="hxd.fmt.fbx.FbxNode"/></c></childs>
</a></typedef>
	<class path="hxd.fmt.fbx.FbxTools" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fmt/fbx/Data.hx" module="hxd.fmt.fbx.Data">
		<get public="1" set="method" line="21" static="1">
			<f a="n:path:?opt" v="::false">
				<t path="hxd.fmt.fbx.FbxNode"/>
				<c path="String"/>
				<x path="Bool"/>
				<t path="hxd.fmt.fbx.FbxNode"/>
			</f>
			<meta><m n=":value"><e>{ opt : false }</e></m></meta>
		</get>
		<getAll public="1" set="method" line="41" static="1"><f a="n:path">
	<t path="hxd.fmt.fbx.FbxNode"/>
	<c path="String"/>
	<c path="Array"><t path="hxd.fmt.fbx.FbxNode"/></c>
</f></getAll>
		<getInts public="1" set="method" line="57" static="1"><f a="n">
	<t path="hxd.fmt.fbx.FbxNode"/>
	<c path="Array"><x path="Int"/></c>
</f></getInts>
		<getFloats public="1" set="method" line="68" static="1"><f a="n">
	<t path="hxd.fmt.fbx.FbxNode"/>
	<c path="Array"><x path="Float"/></c>
</f></getFloats>
		<hasProp public="1" set="method" line="87" static="1"><f a="n:p">
	<t path="hxd.fmt.fbx.FbxNode"/>
	<e path="hxd.fmt.fbx.FbxProp"/>
	<x path="Bool"/>
</f></hasProp>
		<idToInt set="method" line="94" static="1"><f a="f">
	<x path="Float"/>
	<x path="Int"/>
</f></idToInt>
		<toInt public="1" set="method" line="104" static="1"><f a="n">
	<e path="hxd.fmt.fbx.FbxProp"/>
	<x path="Int"/>
</f></toInt>
		<toFloat public="1" set="method" line="113" static="1"><f a="n">
	<e path="hxd.fmt.fbx.FbxProp"/>
	<x path="Float"/>
</f></toFloat>
		<toString public="1" set="method" line="122" static="1"><f a="n">
	<e path="hxd.fmt.fbx.FbxProp"/>
	<c path="String"/>
</f></toString>
		<toBinary public="1" set="method" line="130" static="1"><f a="n">
	<e path="hxd.fmt.fbx.FbxProp"/>
	<c path="haxe.io.Bytes"/>
</f></toBinary>
		<getId public="1" set="method" line="138" static="1"><f a="n">
	<t path="hxd.fmt.fbx.FbxNode"/>
	<x path="Int"/>
</f></getId>
		<getName public="1" set="method" line="148" static="1"><f a="n">
	<t path="hxd.fmt.fbx.FbxNode"/>
	<x path="Null"><c path="String"/></x>
</f></getName>
		<getType public="1" set="method" line="157" static="1"><f a="n">
	<t path="hxd.fmt.fbx.FbxNode"/>
	<c path="String"/>
</f></getType>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.fmt.fbx.Geometry" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fmt/fbx/Geometry.hx">
		<lib><c path="hxd.fmt.fbx.BaseLibrary"/></lib>
		<root><t path="hxd.fmt.fbx.FbxNode"/></root>
		<getRoot public="1" set="method" line="14"><f a=""><t path="hxd.fmt.fbx.FbxNode"/></f></getRoot>
		<getVertices public="1" set="method" line="18"><f a=""><c path="Array"><x path="Float"/></c></f></getVertices>
		<getPolygons public="1" set="method" line="22"><f a=""><c path="Array"><x path="Int"/></c></f></getPolygons>
		<getMaterials public="1" set="method" line="26"><f a=""><x path="Null"><c path="Array"><x path="Int"/></c></x></f></getMaterials>
		<getMaterialByTriangle public="1" set="method" line="31"><f a=""><c path="Array"><x path="Int"/></c></f></getMaterialByTriangle>
		<merge public="1" set="method" line="48"><f a="g:materials">
	<c path="hxd.fmt.fbx.Geometry"/>
	<c path="Array"><x path="Int"/></c>
	<x path="Void"/>
</f></merge>
		<getIndexes public="1" set="method" line="148">
			<f a=""><a>
	<vidx><c path="Array"><x path="Int"/></c></vidx>
	<idx><c path="Array"><x path="Int"/></c></idx>
</a></f>
			<haxe_doc>Decode polygon informations into triangle indexes and vertices indexes.
		Returns vidx, which is the list of vertices indexes and iout which is the index buffer for the full vertex model</haxe_doc>
		</getIndexes>
		<getNormals public="1" set="method" line="172"><f a=""><c path="Array"><x path="Float"/></c></f></getNormals>
		<getTangents public="1" set="method" line="176">
			<f a="?opt" v="false">
				<x path="Bool"/>
				<c path="Array"><x path="Float"/></c>
			</f>
			<meta><m n=":value"><e>{ opt : false }</e></m></meta>
		</getTangents>
		<getBinormals public="1" set="method" line="180">
			<f a="?opt" v="false">
				<x path="Bool"/>
				<c path="Array"><x path="Float"/></c>
			</f>
			<meta><m n=":value"><e>{ opt : false }</e></m></meta>
		</getBinormals>
		<processVectors set="method" line="184">
			<f a="layer:name:?opt" v="::false">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
				<c path="Array"><x path="Float"/></c>
			</f>
			<meta><m n=":value"><e>{ opt : false }</e></m></meta>
		</processVectors>
		<getColors public="1" set="method" line="204"><f a=""><a>
	<values><c path="Array"><x path="Float"/></c></values>
	<index><c path="Array"><x path="Int"/></c></index>
</a></f></getColors>
		<getUVs public="1" set="method" line="212"><f a=""><c path="Array"><a>
	<values><c path="Array"><x path="Float"/></c></values>
	<index><c path="Array"><x path="Int"/></c></index>
</a></c></f></getUVs>
		<getGeomMatrix public="1" set="method" line="227">
			<f a=""><c path="h3d.Matrix"/></f>
			<meta><m n=":access"><e>hxd.fmt.fbx.BaseLibrary.leftHand</e></m></meta>
		</getGeomMatrix>
		<new public="1" set="method" line="9"><f a="l:root">
	<c path="hxd.fmt.fbx.BaseLibrary"/>
	<t path="hxd.fmt.fbx.FbxNode"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.fmt.fbx.HMDOut" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fmt/fbx/HMDOut.hx">
		<extends path="hxd.fmt.fbx.BaseLibrary"/>
		<d><c path="hxd.fmt.hmd.Data"/></d>
		<dataOut><c path="haxe.io.BytesOutput"/></dataOut>
		<filePath><c path="String"/></filePath>
		<tmp expr="haxe.io.Bytes.alloc(4)">
			<c path="haxe.io.Bytes"/>
			<meta><m n=":value"><e>haxe.io.Bytes.alloc(4)</e></m></meta>
		</tmp>
		<absoluteTexturePath public="1"><x path="Bool"/></absoluteTexturePath>
		<optimizeSkin public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</optimizeSkin>
		<floatSkinIndexes public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</floatSkinIndexes>
		<int32tof set="method" line="20"><f a="v">
	<x path="Int"/>
	<x path="Float"/>
</f></int32tof>
		<keepJoint set="method" line="28" override="1"><f a="j">
	<c path="h3d.anim.Joint"/>
	<x path="Bool"/>
</f></keepJoint>
		<buildTangents set="method" line="37"><f a="geom">
	<c path="hxd.fmt.fbx.Geometry"/>
	<c path="Array"><x path="Float"/></c>
</f></buildTangents>
		<buildGeom set="method" line="131"><f a="geom:skin:dataOut:genTangents">
	<c path="hxd.fmt.fbx.Geometry"/>
	<c path="h3d.anim.Skin"/>
	<c path="haxe.io.BytesOutput"/>
	<x path="Bool"/>
	<a>
		<materials><c path="Array"><x path="Int"/></c></materials>
		<g><c path="hxd.fmt.hmd.Geometry"/></g>
	</a>
</f></buildGeom>
		<addModels set="method" line="362"><f a="includeGeometry">
	<x path="Bool"/>
	<x path="Void"/>
</f></addModels>
		<makeTexturePath set="method" line="632"><f a="tex">
	<t path="hxd.fmt.fbx.FbxNode"/>
	<c path="String"/>
</f></makeTexturePath>
		<makeSkin set="method" line="654"><f a="skin:obj">
	<c path="h3d.anim.Skin"/>
	<c path="hxd.fmt.fbx.TmpObject"/>
	<c path="hxd.fmt.hmd.Skin"/>
</f></makeSkin>
		<makePosition set="method" line="693"><f a="m">
	<c path="h3d.Matrix"/>
	<c path="hxd.fmt.hmd.Position"/>
</f></makePosition>
		<writeFloat get="inline" set="null" line="712"><f a="f">
	<x path="Float"/>
	<x path="Void"/>
</f></writeFloat>
		<writeFrame set="method" line="716"><f a="o:fid">
	<c path="h3d.anim.LinearObject"/>
	<x path="Int"/>
	<x path="Void"/>
</f></writeFrame>
		<makeAnimation set="method" line="748"><f a="anim">
	<c path="h3d.anim.Animation"/>
	<c path="hxd.fmt.hmd.Animation"/>
</f></makeAnimation>
		<toHMD public="1" set="method" line="838"><f a="filePath:includeGeometry">
	<c path="String"/>
	<x path="Bool"/>
	<c path="hxd.fmt.hmd.Data"/>
</f></toHMD>
		<new public="1" set="method" line="6"><f a="fileName">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="hxd.fmt.fbx._Parser.Token" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fmt/fbx/Parser.hx" private="1" module="hxd.fmt.fbx.Parser">
		<TIdent a="s"><c path="String"/></TIdent>
		<TNode a="s"><c path="String"/></TNode>
		<TInt a="s"><c path="String"/></TInt>
		<TFloat a="s"><c path="String"/></TFloat>
		<TString a="s"><c path="String"/></TString>
		<TLength a="v"><x path="Int"/></TLength>
		<TBraceOpen/>
		<TBraceClose/>
		<TColon/>
		<TEof/>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<class path="hxd.fmt.fbx.Parser" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fmt/fbx/Parser.hx">
		<parse public="1" set="method" line="501" static="1"><f a="data">
	<c path="haxe.io.Bytes"/>
	<t path="hxd.fmt.fbx.FbxNode"/>
</f></parse>
		<line><x path="Int"/></line>
		<buf><c path="String"/></buf>
		<bytes><c path="haxe.io.Bytes"/></bytes>
		<pos><x path="Int"/></pos>
		<token><x path="Null"><e path="hxd.fmt.fbx._Parser.Token"/></x></token>
		<binary><x path="Bool"/></binary>
		<fbxVersion><x path="Int"/></fbxVersion>
		<parseText set="method" line="31"><f a="str">
	<c path="String"/>
	<t path="hxd.fmt.fbx.FbxNode"/>
</f></parseText>
		<parseBytes set="method" line="44"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<t path="hxd.fmt.fbx.FbxNode"/>
</f></parseBytes>
		<parseNodes set="method" line="87"><f a=""><c path="Array"><t path="hxd.fmt.fbx.FbxNode"/></c></f></parseNodes>
		<parseNode set="method" line="100"><f a=""><t path="hxd.fmt.fbx.FbxNode"/></f></parseNode>
		<parseBinaryNodes set="method" line="176"><f a="output">
	<c path="Array"><t path="hxd.fmt.fbx.FbxNode"/></c>
	<x path="Void"/>
</f></parseBinaryNodes>
		<parseBinaryNode set="method" line="185"><f a="nextRecord">
	<x path="Int"/>
	<t path="hxd.fmt.fbx.FbxNode"/>
</f></parseBinaryNode>
		<readBinaryProperty set="method" line="212"><f a=""><e path="hxd.fmt.fbx.FbxProp"/></f></readBinaryProperty>
		<except set="method" line="319"><f a="except">
	<e path="hxd.fmt.fbx._Parser.Token"/>
	<x path="Void"/>
</f></except>
		<peek set="method" line="325"><f a=""><x path="Null"><e path="hxd.fmt.fbx._Parser.Token"/></x></f></peek>
		<next set="method" line="331"><f a=""><e path="hxd.fmt.fbx._Parser.Token"/></f></next>
		<error set="method" line="339"><f a="msg">
	<c path="String"/>
	<d/>
</f></error>
		<unexpected set="method" line="344"><f a="t">
	<e path="hxd.fmt.fbx._Parser.Token"/>
	<d/>
</f></unexpected>
		<tokenStr set="method" line="348"><f a="t">
	<e path="hxd.fmt.fbx._Parser.Token"/>
	<c path="String"/>
</f></tokenStr>
		<nextChar get="inline" set="null" line="363"><f a=""><x path="Int"/></f></nextChar>
		<getVersionedInt32 get="inline" set="null" line="367"><f a=""><x path="Int"/></f></getVersionedInt32>
		<getInt32 get="inline" set="null" line="374"><f a=""><x path="Int"/></f></getInt32>
		<getInt16 get="inline" set="null" line="380"><f a=""><x path="Int"/></f></getInt16>
		<getFloat get="inline" set="null" line="386"><f a=""><x path="Float"/></f></getFloat>
		<getDouble get="inline" set="null" line="392"><f a=""><x path="Float"/></f></getDouble>
		<i64ToFloat get="inline" set="null" line="398"><f a="i64">
	<x path="haxe.Int64"/>
	<x path="Float"/>
</f></i64ToFloat>
		<getByte get="inline" set="null" line="403"><f a=""><x path="Int"/></f></getByte>
		<getBuf get="inline" set="null" line="407"><f a="pos:len">
	<x path="Int"/>
	<x path="Int"/>
	<c path="String"/>
</f></getBuf>
		<isIdentChar get="inline" set="null" line="411"><f a="c">
	<x path="Int"/>
	<x path="Bool"/>
</f></isIdentChar>
		<nextToken set="method" line="416">
			<f a=""><e path="hxd.fmt.fbx._Parser.Token"/></f>
			<meta><m n=":noDebug"/></meta>
		</nextToken>
		<new set="method" line="28"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="hxd.fmt.hmd.GeometryDataFormat" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fmt/hmd/Data.hx" module="hxd.fmt.hmd.Data">
		<this><x path="Int"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="hxd.fmt.hmd._Data.GeometryDataFormat_Impl_" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fmt/hmd/Data.hx" private="1" module="hxd.fmt.hmd.Data">
	<DFloat public="1" get="inline" set="null" expr="cast 1" line="5" static="1">
		<x path="hxd.fmt.hmd.GeometryDataFormat"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DFloat>
	<DVec2 public="1" get="inline" set="null" expr="cast 2" line="6" static="1">
		<x path="hxd.fmt.hmd.GeometryDataFormat"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DVec2>
	<DVec3 public="1" get="inline" set="null" expr="cast 3" line="7" static="1">
		<x path="hxd.fmt.hmd.GeometryDataFormat"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DVec3>
	<DVec4 public="1" get="inline" set="null" expr="cast 4" line="8" static="1">
		<x path="hxd.fmt.hmd.GeometryDataFormat"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DVec4>
	<DBytes4 public="1" get="inline" set="null" expr="cast 9" line="9" static="1">
		<x path="hxd.fmt.hmd.GeometryDataFormat"/>
		<meta>
			<m n=":value"><e>cast 9</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DBytes4>
	<_new get="inline" set="null" line="11" static="1">
		<f a="v">
			<x path="Int"/>
			<x path="hxd.fmt.hmd.GeometryDataFormat"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<getSize public="1" get="inline" set="null" line="15" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</getSize>
	<toInt public="1" get="inline" set="null" line="19" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toInt>
	<toString public="1" set="method" line="23" static="1">
		<f a="this">
			<x path="Int"/>
			<c path="String"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toString>
	<fromInt public="1" get="inline" set="null" line="33" static="1"><f a="v">
	<x path="Int"/>
	<x path="hxd.fmt.hmd.GeometryDataFormat"/>
</f></fromInt>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="hxd.fmt.hmd._Data.GeometryDataFormat_Impl_" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fmt/hmd/Data.hx" private="1" module="hxd.fmt.hmd.Data">
		<DFloat public="1" get="inline" set="null" expr="cast 1" line="5" static="1">
			<x path="hxd.fmt.hmd.GeometryDataFormat"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DFloat>
		<DVec2 public="1" get="inline" set="null" expr="cast 2" line="6" static="1">
			<x path="hxd.fmt.hmd.GeometryDataFormat"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DVec2>
		<DVec3 public="1" get="inline" set="null" expr="cast 3" line="7" static="1">
			<x path="hxd.fmt.hmd.GeometryDataFormat"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DVec3>
		<DVec4 public="1" get="inline" set="null" expr="cast 4" line="8" static="1">
			<x path="hxd.fmt.hmd.GeometryDataFormat"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DVec4>
		<DBytes4 public="1" get="inline" set="null" expr="cast 9" line="9" static="1">
			<x path="hxd.fmt.hmd.GeometryDataFormat"/>
			<meta>
				<m n=":value"><e>cast 9</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DBytes4>
		<_new get="inline" set="null" line="11" static="1">
			<f a="v">
				<x path="Int"/>
				<x path="hxd.fmt.hmd.GeometryDataFormat"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<getSize public="1" get="inline" set="null" line="15" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</getSize>
		<toInt public="1" get="inline" set="null" line="19" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toInt>
		<toString public="1" set="method" line="23" static="1">
			<f a="this">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toString>
		<fromInt public="1" get="inline" set="null" line="33" static="1"><f a="v">
	<x path="Int"/>
	<x path="hxd.fmt.hmd.GeometryDataFormat"/>
</f></fromInt>
		<meta><m n=":enum"/></meta>
	</class>
	<typedef path="hxd.fmt.hmd.DataPosition" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fmt/hmd/Data.hx" module="hxd.fmt.hmd.Data"><x path="Int"/></typedef>
	<typedef path="hxd.fmt.hmd.Index" params="T" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fmt/hmd/Data.hx" module="hxd.fmt.hmd.Data"><x path="Int"/></typedef>
	<enum path="hxd.fmt.hmd.Property" params="T" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fmt/hmd/Data.hx" module="hxd.fmt.hmd.Data">
		<CameraFOVY a="v"><x path="Float"/></CameraFOVY>
		<Unused_HasMaterialFlags/>
		<HasExtraTextures/>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<typedef path="hxd.fmt.hmd.Properties" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fmt/hmd/Data.hx" module="hxd.fmt.hmd.Data"><x path="Null"><c path="Array"><e path="hxd.fmt.hmd.Property"><d/></e></c></x></typedef>
	<class path="hxd.fmt.hmd.Position" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fmt/hmd/Data.hx" module="hxd.fmt.hmd.Data">
		<QTMP expr="new h3d.Quat()" line="91" static="1">
			<c path="h3d.Quat"/>
			<meta><m n=":value"><e>new h3d.Quat()</e></m></meta>
		</QTMP>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<z public="1"><x path="Float"/></z>
		<qx public="1"><x path="Float"/></qx>
		<qy public="1"><x path="Float"/></qy>
		<qz public="1"><x path="Float"/></qz>
		<qw public="1" get="accessor" set="null"><x path="Float"/></qw>
		<sx public="1"><x path="Float"/></sx>
		<sy public="1"><x path="Float"/></sy>
		<sz public="1"><x path="Float"/></sz>
		<loadQuaternion public="1" get="inline" set="null" line="63"><f a="q">
	<c path="h3d.Quat"/>
	<x path="Void"/>
</f></loadQuaternion>
		<get_qw set="method" line="70"><f a=""><x path="Float"/></f></get_qw>
		<toMatrix public="1" set="method" line="75">
			<f a="?postScale" v="false">
				<x path="Bool"/>
				<c path="h3d.Matrix"/>
			</f>
			<meta><m n=":value"><e>{ postScale : false }</e></m></meta>
		</toMatrix>
		<new public="1" set="method" line="60"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.fmt.hmd.GeometryFormat" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fmt/hmd/Data.hx" module="hxd.fmt.hmd.Data">
		<name public="1"><c path="String"/></name>
		<format public="1"><x path="hxd.fmt.hmd.GeometryDataFormat"/></format>
		<new public="1" set="method" line="97"><f a="name:format">
	<c path="String"/>
	<x path="hxd.fmt.hmd.GeometryDataFormat"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.fmt.hmd.Geometry" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fmt/hmd/Data.hx" module="hxd.fmt.hmd.Data">
		<props public="1"><t path="hxd.fmt.hmd.Properties"/></props>
		<vertexCount public="1"><x path="Int"/></vertexCount>
		<vertexStride public="1"><x path="Int"/></vertexStride>
		<vertexFormat public="1"><c path="Array"><c path="hxd.fmt.hmd.GeometryFormat"/></c></vertexFormat>
		<vertexPosition public="1"><t path="hxd.fmt.hmd.DataPosition"/></vertexPosition>
		<indexCount public="1" get="accessor" set="null"><x path="Int"/></indexCount>
		<indexCounts public="1"><c path="Array"><x path="Int"/></c></indexCounts>
		<indexPosition public="1"><t path="hxd.fmt.hmd.DataPosition"/></indexPosition>
		<bounds public="1"><c path="h3d.col.Bounds"/></bounds>
		<get_indexCount set="method" line="115"><f a=""><x path="Int"/></f></get_indexCount>
		<new public="1" set="method" line="113"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.fmt.hmd.Material" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fmt/hmd/Data.hx" module="hxd.fmt.hmd.Data">
		<name public="1"><c path="String"/></name>
		<props public="1"><t path="hxd.fmt.hmd.Properties"/></props>
		<diffuseTexture public="1"><x path="Null"><c path="String"/></x></diffuseTexture>
		<specularTexture public="1"><x path="Null"><c path="String"/></x></specularTexture>
		<normalMap public="1"><x path="Null"><c path="String"/></x></normalMap>
		<blendMode public="1"><t path="h3d.mat.BlendMode"/></blendMode>
		<new public="1" set="method" line="131"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.fmt.hmd.SkinJoint" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fmt/hmd/Data.hx" module="hxd.fmt.hmd.Data">
		<name public="1"><c path="String"/></name>
		<props public="1"><t path="hxd.fmt.hmd.Properties"/></props>
		<parent public="1"><t path="hxd.fmt.hmd.Index"><c path="hxd.fmt.hmd.SkinJoint"/></t></parent>
		<position public="1"><c path="hxd.fmt.hmd.Position"/></position>
		<bind public="1"><x path="Int"/></bind>
		<transpos public="1"><x path="Null"><c path="hxd.fmt.hmd.Position"/></x></transpos>
		<new public="1" set="method" line="142"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.fmt.hmd.SkinSplit" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fmt/hmd/Data.hx" module="hxd.fmt.hmd.Data">
		<materialIndex public="1"><x path="Int"/></materialIndex>
		<joints public="1"><c path="Array"><t path="hxd.fmt.hmd.Index"><c path="hxd.fmt.hmd.SkinJoint"/></t></c></joints>
		<new public="1" set="method" line="149"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.fmt.hmd.Skin" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fmt/hmd/Data.hx" module="hxd.fmt.hmd.Data">
		<name public="1"><c path="String"/></name>
		<props public="1"><t path="hxd.fmt.hmd.Properties"/></props>
		<joints public="1"><c path="Array"><c path="hxd.fmt.hmd.SkinJoint"/></c></joints>
		<split public="1"><x path="Null"><c path="Array"><c path="hxd.fmt.hmd.SkinSplit"/></c></x></split>
		<new public="1" set="method" line="158"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.fmt.hmd.Model" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fmt/hmd/Data.hx" module="hxd.fmt.hmd.Data">
		<name public="1"><c path="String"/></name>
		<props public="1"><t path="hxd.fmt.hmd.Properties"/></props>
		<parent public="1"><t path="hxd.fmt.hmd.Index"><c path="hxd.fmt.hmd.Model"/></t></parent>
		<follow public="1"><x path="Null"><c path="String"/></x></follow>
		<position public="1"><c path="hxd.fmt.hmd.Position"/></position>
		<geometry public="1"><t path="hxd.fmt.hmd.Index"><c path="hxd.fmt.hmd.Geometry"/></t></geometry>
		<materials public="1"><x path="Null"><c path="Array"><t path="hxd.fmt.hmd.Index"><c path="hxd.fmt.hmd.Material"/></t></c></x></materials>
		<skin public="1"><x path="Null"><c path="hxd.fmt.hmd.Skin"/></x></skin>
		<new public="1" set="method" line="171"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="hxd.fmt.hmd.AnimationFlag" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fmt/hmd/Data.hx" module="hxd.fmt.hmd.Data">
		<HasPosition/>
		<HasRotation/>
		<HasScale/>
		<HasUV/>
		<HasAlpha/>
		<SingleFrame/>
		<HasProps/>
		<Reserved/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="hxd.fmt.hmd.AnimationObject" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fmt/hmd/Data.hx" module="hxd.fmt.hmd.Data">
		<name public="1"><c path="String"/></name>
		<flags public="1"><x path="haxe.EnumFlags"><e path="hxd.fmt.hmd.AnimationFlag"/></x></flags>
		<props public="1"><c path="Array"><c path="String"/></c></props>
		<getStride public="1" set="method" line="192"><f a=""><x path="Int"/></f></getStride>
		<new public="1" set="method" line="190"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.fmt.hmd.AnimationEvent" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fmt/hmd/Data.hx" module="hxd.fmt.hmd.Data">
		<frame public="1"><x path="Int"/></frame>
		<data public="1"><c path="String"/></data>
		<new public="1" set="method" line="207"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.fmt.hmd.Animation" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fmt/hmd/Data.hx" module="hxd.fmt.hmd.Data">
		<name public="1"><c path="String"/></name>
		<props public="1"><t path="hxd.fmt.hmd.Properties"/></props>
		<frames public="1"><x path="Int"/></frames>
		<sampling public="1"><x path="Float"/></sampling>
		<speed public="1"><x path="Float"/></speed>
		<loop public="1"><x path="Bool"/></loop>
		<objects public="1"><c path="Array"><c path="hxd.fmt.hmd.AnimationObject"/></c></objects>
		<events public="1"><x path="Null"><c path="Array"><c path="hxd.fmt.hmd.AnimationEvent"/></c></x></events>
		<dataPosition public="1"><t path="hxd.fmt.hmd.DataPosition"/></dataPosition>
		<new public="1" set="method" line="221"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.fmt.hmd.Data" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fmt/hmd/Data.hx">
		<CURRENT_VERSION public="1" get="inline" set="null" expr="3" line="227" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</CURRENT_VERSION>
		<version public="1"><x path="Int"/></version>
		<props public="1"><t path="hxd.fmt.hmd.Properties"/></props>
		<geometries public="1"><c path="Array"><c path="hxd.fmt.hmd.Geometry"/></c></geometries>
		<materials public="1"><c path="Array"><c path="hxd.fmt.hmd.Material"/></c></materials>
		<models public="1"><c path="Array"><c path="hxd.fmt.hmd.Model"/></c></models>
		<animations public="1"><c path="Array"><c path="hxd.fmt.hmd.Animation"/></c></animations>
		<dataPosition public="1"><x path="Int"/></dataPosition>
		<data public="1"><c path="haxe.io.Bytes"/></data>
		<new public="1" set="method" line="238"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.fmt.hmd._Library.FormatMap" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fmt/hmd/Library.hx" private="1" module="hxd.fmt.hmd.Library">
		<size public="1"><x path="Int"/></size>
		<offset public="1"><x path="Int"/></offset>
		<def public="1"><c path="h3d.Vector"/></def>
		<next public="1"><c path="hxd.fmt.hmd._Library.FormatMap"/></next>
		<new public="1" set="method" line="9"><f a="size:offset:def:next">
	<x path="Int"/>
	<x path="Int"/>
	<c path="h3d.Vector"/>
	<c path="hxd.fmt.hmd._Library.FormatMap"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.fmt.hmd.GeometryBuffer" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fmt/hmd/Library.hx" module="hxd.fmt.hmd.Library">
		<vertexes public="1"><x path="haxe.ds.Vector"><t path="hxd.impl.Float32"/></x></vertexes>
		<indexes public="1"><x path="haxe.ds.Vector"><t path="hxd.impl.UInt16"/></x></indexes>
		<new public="1" set="method" line="20"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.fmt.hmd.Library" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fmt/hmd/Library.hx">
		<resource public="1" set="null"><c path="hxd.res.Resource"/></resource>
		<header public="1" set="null"><c path="hxd.fmt.hmd.Data"/></header>
		<cachedPrimitives><c path="Array"><c path="h3d.prim.HMDModel"/></c></cachedPrimitives>
		<cachedAnimations><t path="Map">
	<c path="String"/>
	<c path="h3d.anim.Animation"/>
</t></cachedAnimations>
		<cachedSkin><t path="Map">
	<c path="String"/>
	<c path="h3d.anim.Skin"/>
</t></cachedSkin>
		<tmp expr="haxe.io.Bytes.alloc(4)">
			<c path="haxe.io.Bytes"/>
			<meta><m n=":value"><e>haxe.io.Bytes.alloc(4)</e></m></meta>
		</tmp>
		<getData public="1" set="method" line="41"><f a=""><c path="haxe.io.Bytes"/></f></getData>
		<getDefaultFormat public="1" set="method" line="51"><f a="stride">
	<x path="Int"/>
	<a>
		<format><c path="Array"><c path="hxd.fmt.hmd.GeometryFormat"/></c></format>
		<defs><c path="Array"><c path="h3d.Vector"/></c></defs>
	</a>
</f></getDefaultFormat>
		<load public="1" set="method" line="73">
			<f a="format:?defaults:?modelIndex" v="::-1">
				<c path="Array"><c path="hxd.fmt.hmd.GeometryFormat"/></c>
				<c path="Array"><c path="h3d.Vector"/></c>
				<x path="Int"/>
				<a>
					<vertex><x path="hxd.FloatBuffer"/></vertex>
					<index><x path="hxd.IndexBuffer"/></index>
				</a>
			</f>
			<meta><m n=":value"><e>{ modelIndex : -1 }</e></m></meta>
		</load>
		<getBuffers public="1" set="method" line="111">
			<f a="geom:format:?defaults:?material">
				<c path="hxd.fmt.hmd.Geometry"/>
				<c path="Array"><c path="hxd.fmt.hmd.GeometryFormat"/></c>
				<c path="Array"><c path="h3d.Vector"/></c>
				<x path="Int"/>
				<c path="hxd.fmt.hmd.GeometryBuffer"/>
			</f>
			<meta><m n=":noDebug"/></meta>
		</getBuffers>
		<makePrimitive set="method" line="253"><f a="id">
	<x path="Int"/>
	<c path="h3d.prim.HMDModel"/>
</f></makePrimitive>
		<makeMaterial set="method" line="262"><f a="model:mid:loadTexture">
	<c path="hxd.fmt.hmd.Model"/>
	<x path="Int"/>
	<f a="">
		<c path="String"/>
		<c path="h3d.mat.Texture"/>
	</f>
	<c path="h3d.mat.Material"/>
</f></makeMaterial>
		<makeSkin set="method" line="283">
			<f a="skin">
				<c path="hxd.fmt.hmd.Skin"/>
				<x path="Null"><c path="h3d.anim.Skin"/></x>
			</f>
			<meta><m n=":access"><e>h3d.anim.Skin</e></m></meta>
		</makeSkin>
		<getModelProperty public="1" params="T" set="method" line="320"><f a="objName:p:?def">
	<c path="String"/>
	<e path="hxd.fmt.hmd.Property"><c path="getModelProperty.T"/></e>
	<c path="getModelProperty.T"/>
	<x path="Null"><c path="getModelProperty.T"/></x>
</f></getModelProperty>
		<makeObject public="1" set="method" line="335"><f a="?loadTexture">
	<f a="">
		<c path="String"/>
		<c path="h3d.mat.Texture"/>
	</f>
	<c path="h3d.scene.Object"/>
</f></makeObject>
		<loadAnimation public="1" set="method" line="366"><f a="?name">
	<c path="String"/>
	<c path="h3d.anim.Animation"/>
</f></loadAnimation>
		<makeAnimation set="method" line="397"><f a="a">
	<c path="hxd.fmt.hmd.Animation"/>
	<c path="h3d.anim.BufferAnimation"/>
</f></makeAnimation>
		<makeLinearAnimation set="method" line="480"><f a="a">
	<c path="hxd.fmt.hmd.Animation"/>
	<c path="h3d.anim.LinearAnimation"/>
</f></makeLinearAnimation>
		<loadSkin public="1" set="method" line="570">
			<f a="geom:skin">
				<c path="hxd.fmt.hmd.Geometry"/>
				<c path="h3d.anim.Skin"/>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>h3d.anim.Skin</e></m></meta>
		</loadSkin>
		<ftoint32 set="method" line="589"><f a="v">
	<t path="hxd.impl.Float32"/>
	<x path="Int"/>
</f></ftoint32>
		<new public="1" set="method" line="33"><f a="res:header">
	<c path="hxd.res.Resource"/>
	<c path="hxd.fmt.hmd.Data"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.fmt.hmd.Reader" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fmt/hmd/Reader.hx">
		<BLEND expr="Type.allEnums(h2d.BlendMode)" line="6" static="1">
			<c path="Array"><e path="h2d.BlendMode"/></c>
			<meta><m n=":value"><e>Type.allEnums(h2d.BlendMode)</e></m></meta>
		</BLEND>
		<CULLING expr="Type.allEnums(h3d.mat.Data.Face)" line="7" static="1">
			<c path="Array"><e path="h3d.mat.Face"/></c>
			<meta><m n=":value"><e>Type.allEnums(h3d.mat.Data.Face)</e></m></meta>
		</CULLING>
		<HMD_STRINGS static="1"><t path="Map">
	<c path="String"/>
	<c path="String"/>
</t></HMD_STRINGS>
		<i><c path="haxe.io.Input"/></i>
		<version><x path="Int"/></version>
		<readProperty set="method" line="16"><f a=""><e path="hxd.fmt.hmd.Property"><x path="Float"/></e></f></readProperty>
		<readProps set="method" line="29"><f a=""><c path="Array"><e path="hxd.fmt.hmd.Property"><x path="Float"/></e></c></f></readProps>
		<readName set="method" line="38"><f a=""><c path="String"/></f></readName>
		<readCachedName set="method" line="49"><f a=""><x path="Null"><c path="String"/></x></f></readCachedName>
		<readPosition set="method" line="60">
			<f a="?hasScale" v="true">
				<x path="Bool"/>
				<c path="hxd.fmt.hmd.Position"/>
			</f>
			<meta><m n=":value"><e>{ hasScale : true }</e></m></meta>
		</readPosition>
		<readBounds set="method" line="80"><f a=""><c path="h3d.col.Bounds"/></f></readBounds>
		<readSkin set="method" line="91"><f a=""><c path="hxd.fmt.hmd.Skin"/></f></readSkin>
		<readHeader public="1" set="method" line="126"><f a=""><c path="hxd.fmt.hmd.Data"/></f></readHeader>
		<read public="1" set="method" line="222"><f a=""><c path="hxd.fmt.hmd.Data"/></f></read>
		<new public="1" set="method" line="12"><f a="i">
	<c path="haxe.io.Input"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.fmt.hmd.Writer" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fmt/hmd/Writer.hx">
		<out><c path="haxe.io.Output"/></out>
		<version><x path="Int"/></version>
		<writeProperty set="method" line="13"><f a="p">
	<e path="hxd.fmt.hmd.Property"><d/></e>
	<x path="Void"/>
</f></writeProperty>
		<writeProps set="method" line="23"><f a="props">
	<t path="hxd.fmt.hmd.Properties"/>
	<x path="Void"/>
</f></writeProps>
		<writeName set="method" line="37"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></writeName>
		<writeFloat get="inline" set="null" line="50"><f a="f">
	<x path="Float"/>
	<x path="Void"/>
</f></writeFloat>
		<writePosition set="method" line="54">
			<f a="p:?hasScale" v=":true">
				<c path="hxd.fmt.hmd.Position"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ hasScale : true }</e></m></meta>
		</writePosition>
		<writeBounds set="method" line="68"><f a="b">
	<c path="h3d.col.Bounds"/>
	<x path="Void"/>
</f></writeBounds>
		<writeSkin set="method" line="77"><f a="s">
	<c path="hxd.fmt.hmd.Skin"/>
	<x path="Void"/>
</f></writeSkin>
		<write public="1" set="method" line="102"><f a="d">
	<c path="hxd.fmt.hmd.Data"/>
	<x path="Void"/>
</f></write>
		<new public="1" set="method" line="9"><f a="out">
	<c path="haxe.io.Output"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.fs.BytesFileEntry" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fs/BytesFileSystem.hx" module="hxd.fs.BytesFileSystem">
		<extends path="hxd.fs.FileEntry"/>
		<fullPath><c path="String"/></fullPath>
		<bytes><c path="haxe.io.Bytes"/></bytes>
		<pos><x path="Int"/></pos>
		<get_path set="method" line="17" override="1"><f a=""><c path="String"/></f></get_path>
		<getSign public="1" set="method" line="21" override="1"><f a=""><x path="Int"/></f></getSign>
		<getBytes public="1" set="method" line="25" override="1"><f a=""><c path="haxe.io.Bytes"/></f></getBytes>
		<open public="1" set="method" line="29" override="1"><f a=""><x path="Void"/></f></open>
		<skip public="1" set="method" line="33" override="1"><f a="nbytes">
	<x path="Int"/>
	<x path="Void"/>
</f></skip>
		<readByte public="1" set="method" line="36" override="1"><f a=""><x path="Int"/></f></readByte>
		<read public="1" set="method" line="40" override="1"><f a="out:pos:size">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></read>
		<close public="1" set="method" line="45" override="1"><f a=""><x path="Void"/></f></close>
		<load public="1" set="method" line="48" override="1"><f a="?onReady">
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></load>
		<loadBitmap public="1" set="method" line="52" override="1"><f a="onLoaded">
	<f a="">
		<x path="hxd.fs.LoadedBitmap"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></loadBitmap>
		<exists public="1" set="method" line="79" override="1"><f a="name">
	<c path="String"/>
	<x path="Bool"/>
</f></exists>
		<get public="1" set="method" line="80" override="1"><f a="name">
	<c path="String"/>
	<c path="hxd.fs.FileEntry"/>
</f></get>
		<iterator public="1" set="method" line="82" override="1"><f a=""><c path="hxd.impl.ArrayIterator_hxd_fs_FileEntry"/></f></iterator>
		<get_size set="method" line="84" override="1"><f a=""><x path="Int"/></f></get_size>
		<new public="1" set="method" line="11"><f a="path:bytes">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.fs.BytesFileSystem" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fs/BytesFileSystem.hx">
		<implements path="hxd.fs.FileSystem"/>
		<getRoot public="1" set="method" line="93"><f a=""><c path="hxd.fs.FileEntry"/></f></getRoot>
		<getBytes set="method" line="98"><f a="path">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
</f></getBytes>
		<exists public="1" set="method" line="103"><f a="path">
	<c path="String"/>
	<x path="Bool"/>
</f></exists>
		<get public="1" set="method" line="107"><f a="path">
	<c path="String"/>
	<c path="hxd.fs.BytesFileEntry"/>
</f></get>
		<dispose public="1" set="method" line="113"><f a=""><x path="Void"/></f></dispose>
		<dir public="1" set="method" line="116"><f a="path">
	<c path="String"/>
	<c path="Array"><c path="hxd.fs.FileEntry"/></c>
</f></dir>
		<new set="method" line="90"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="hxd.fs.ConvertFBX2HMD" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fs/Convert.hx" module="hxd.fs.Convert">
		<extends path="hxd.fs.Convert"/>
		<_ expr="Convert.register(new ConvertFBX2HMD())" line="89" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>Convert.register(new ConvertFBX2HMD())</e></m></meta>
		</_>
		<convert public="1" set="method" line="78" override="1"><f a=""><x path="Void"/></f></convert>
		<new public="1" set="method" line="74"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="hxd.fs.Command" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fs/Convert.hx" module="hxd.fs.Convert">
		<extends path="hxd.fs.Convert"/>
		<cmd><c path="String"/></cmd>
		<args><c path="Array"><c path="String"/></c></args>
		<convert public="1" set="method" line="104" override="1"><f a=""><x path="Void"/></f></convert>
		<new public="1" set="method" line="98"><f a="fr:to:cmd:args">
	<a><split set="null"><f a="">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
</f></split></a>
	<c path="String"/>
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
	<x path="Void"/>
</f></new>
	</class>
	<class path="hxd.fs.ConvertWAV2MP3" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fs/Convert.hx" module="hxd.fs.Convert">
		<extends path="hxd.fs.Convert"/>
		<_ expr="Convert.register(new ConvertWAV2MP3())" line="121" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>Convert.register(new ConvertWAV2MP3())</e></m></meta>
		</_>
		<convert public="1" set="method" line="117" override="1"><f a=""><x path="Void"/></f></convert>
		<new public="1" set="method" line="113"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="hxd.fs.ConvertWAV2OGG" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fs/Convert.hx" module="hxd.fs.Convert">
		<extends path="hxd.fs.Convert"/>
		<_ expr="Convert.register(new ConvertWAV2OGG())" line="147" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>Convert.register(new ConvertWAV2OGG())</e></m></meta>
		</_>
		<convert public="1" set="method" line="131" override="1"><f a=""><x path="Void"/></f></convert>
		<new public="1" set="method" line="127"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="hxd.fs.ConvertTGA2PNG" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fs/Convert.hx" module="hxd.fs.Convert">
		<extends path="hxd.fs.Convert"/>
		<_ expr="Convert.register(new ConvertTGA2PNG())" line="186" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>Convert.register(new ConvertTGA2PNG())</e></m></meta>
		</_>
		<convert public="1" set="method" line="157" override="1"><f a=""><x path="Void"/></f></convert>
		<new public="1" set="method" line="153"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="hxd.fs.ConvertFNT2BFNT" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fs/Convert.hx" module="hxd.fs.Convert">
		<extends path="hxd.fs.Convert"/>
		<_ expr="Convert.register(new ConvertFNT2BFNT())" line="215" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>Convert.register(new ConvertFNT2BFNT())</e></m></meta>
		</_>
		<emptyTile><c path="h2d.Tile"/></emptyTile>
		<convert public="1" set="method" line="200" override="1"><f a=""><x path="Void"/></f></convert>
		<resolveTile set="method" line="208"><f a="path">
	<c path="String"/>
	<c path="h2d.Tile"/>
</f></resolveTile>
		<new public="1" set="method" line="194"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="hxd.fs.CompressIMG" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fs/Convert.hx" module="hxd.fs.Convert">
		<extends path="hxd.fs.Convert"/>
		<_ expr="Convert.register(new CompressIMG(&quot;png,tga,jpg,jpeg&quot;, &quot;dds&quot;))" line="226" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>Convert.register(new CompressIMG("png,tga,jpg,jpeg", "dds"))</e></m></meta>
		</_>
		<convert public="1" set="method" line="222" override="1"><f a=""><x path="Void"/></f></convert>
		<new public="1" set="method" line="220"><f a="sourceExts:destExt">
	<a><split set="null"><f a="">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
</f></split></a>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="hxd.fs.DummyConvert" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fs/Convert.hx" module="hxd.fs.Convert">
		<extends path="hxd.fs.Convert"/>
		<_ expr="[Convert.register(new DummyConvert(null, &quot;dummy&quot;)), Convert.register(new DummyConvert(null, &quot;remove&quot;))]" line="236" static="1">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e>[Convert.register(new DummyConvert(null, "dummy")), Convert.register(new DummyConvert(null, "remove"))]</e></m></meta>
		</_>
		<convert public="1" set="method" line="232" override="1"><f a=""><x path="Void"/></f></convert>
		<new public="1" set="method" line="230"><f a="sourceExts:destExt">
	<a><split set="null"><f a="">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
</f></split></a>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<typedef path="hxd.fs.ConvertConfig" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fs/FileConverter.hx" module="hxd.fs.FileConverter"><a>
	<rules><c path="Array"><t path="hxd.fs.ConvertRule"/></c></rules>
	<obj><d/></obj>
</a></typedef>
	<typedef path="hxd.fs.ConvertRule" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fs/FileConverter.hx" module="hxd.fs.FileConverter"><a>
	<pt><e path="hxd.fs.ConvertPattern"/></pt>
	<priority><x path="Int"/></priority>
	<cmd><t path="hxd.fs.ConvertCommand"/></cmd>
</a></typedef>
	<enum path="hxd.fs.ConvertPattern" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fs/FileConverter.hx" module="hxd.fs.FileConverter">
		<Filename a="name"><c path="String"/></Filename>
		<Regexp a="r"><c path="EReg"/></Regexp>
		<Ext a="e"><c path="String"/></Ext>
		<Exts a="e"><c path="Array"><c path="String"/></c></Exts>
		<Wildcard/>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<typedef path="hxd.fs.ConvertCommand" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fs/FileConverter.hx" module="hxd.fs.FileConverter"><a>
	<then>
		<x path="Null"><t path="hxd.fs.ConvertCommand"/></x>
		<meta><m n=":optional"/></meta>
	</then>
	<paramsStr>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</paramsStr>
	<params>
		<x path="Null"><d/></x>
		<meta><m n=":optional"/></meta>
	</params>
	<conv><c path="Array"><c path="hxd.fs.Convert"/></c></conv>
</a></typedef>
	<class path="hxd.fs.FileInput" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fs/FileInput.hx">
		<extends path="haxe.io.Input"/>
		<f><c path="hxd.fs.FileEntry"/></f>
		<skip public="1" set="method" line="12"><f a="nbytes">
	<x path="Int"/>
	<x path="Void"/>
</f></skip>
		<readByte public="1" set="method" line="16" override="1"><f a=""><x path="Int"/></f></readByte>
		<readBytes public="1" set="method" line="20" override="1"><f a="b:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></readBytes>
		<close public="1" set="method" line="25" override="1"><f a=""><x path="Void"/></f></close>
		<new public="1" set="method" line="7"><f a="f">
	<c path="hxd.fs.FileEntry"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="hxd.fs.LoadedBitmapData" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fs/LoadedBitmap.hx" module="hxd.fs.LoadedBitmap"><c path="hxd.BitmapData"/></typedef>
	<abstract path="hxd.fs.LoadedBitmap" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fs/LoadedBitmap.hx">
		<this><t path="hxd.fs.LoadedBitmapData"/></this>
		<impl><class path="hxd.fs._LoadedBitmap.LoadedBitmap_Impl_" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fs/LoadedBitmap.hx" private="1" module="hxd.fs.LoadedBitmap">
	<_new public="1" get="inline" set="null" line="13" static="1">
		<f a="data">
			<t path="hxd.fs.LoadedBitmapData"/>
			<x path="hxd.fs.LoadedBitmap"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<toBitmap public="1" set="method" line="17" static="1">
		<f a="this">
			<t path="hxd.fs.LoadedBitmapData"/>
			<c path="hxd.BitmapData"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toBitmap>
	<toNative public="1" get="inline" set="null" line="29" static="1">
		<f a="this">
			<t path="hxd.fs.LoadedBitmapData"/>
			<t path="hxd.fs.LoadedBitmapData"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toNative>
	<meta><m n=":directlyUsed"/></meta>
</class></impl>
	</abstract>
	<class path="hxd.fs._LoadedBitmap.LoadedBitmap_Impl_" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fs/LoadedBitmap.hx" private="1" module="hxd.fs.LoadedBitmap">
		<_new public="1" get="inline" set="null" line="13" static="1">
			<f a="data">
				<t path="hxd.fs.LoadedBitmapData"/>
				<x path="hxd.fs.LoadedBitmap"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<toBitmap public="1" set="method" line="17" static="1">
			<f a="this">
				<t path="hxd.fs.LoadedBitmapData"/>
				<c path="hxd.BitmapData"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toBitmap>
		<toNative public="1" get="inline" set="null" line="29" static="1">
			<f a="this">
				<t path="hxd.fs.LoadedBitmapData"/>
				<t path="hxd.fs.LoadedBitmapData"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toNative>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.fs.LocalEntry" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fs/LocalFileSystem.hx" module="hxd.fs.LocalFileSystem">
		<extends path="hxd.fs.FileEntry"/>
		<WATCH_INDEX expr="0" line="124" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</WATCH_INDEX>
		<WATCH_LIST expr="null" line="125" static="1">
			<c path="Array"><c path="hxd.fs.LocalEntry"/></c>
			<meta><m n=":value"><e>null</e></m></meta>
		</WATCH_LIST>
		<tmpDir expr="null" line="126" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</tmpDir>
		<checkFiles set="method" line="132" static="1"><f a=""><x path="Void"/></f></checkFiles>
		<fs><c path="hxd.fs.LocalFileSystem"/></fs>
		<relPath><c path="String"/></relPath>
		<file><c path="String"/></file>
		<originalFile><c path="String"/></originalFile>
		<fread><c path="sys.io.FileInput"/></fread>
		<getSign public="1" set="method" line="23" override="1"><f a=""><x path="Int"/></f></getSign>
		<getBytes public="1" set="method" line="31" override="1"><f a=""><c path="haxe.io.Bytes"/></f></getBytes>
		<open public="1" set="method" line="35" override="1"><f a=""><x path="Void"/></f></open>
		<skip public="1" set="method" line="42" override="1"><f a="nbytes">
	<x path="Int"/>
	<x path="Void"/>
</f></skip>
		<readByte public="1" set="method" line="46" override="1"><f a=""><x path="Int"/></f></readByte>
		<read public="1" set="method" line="50" override="1"><f a="out:pos:size">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></read>
		<close public="1" set="method" line="54" override="1"><f a=""><x path="Void"/></f></close>
		<isDirCached><x path="Null"><x path="Bool"/></x></isDirCached>
		<get_isDirectory set="method" line="62" override="1"><f a=""><x path="Bool"/></f></get_isDirectory>
		<load public="1" set="method" line="67" override="1"><f a="?onReady">
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></load>
		<loadBitmap public="1" set="method" line="75" override="1"><f a="onLoaded">
	<f a="">
		<x path="hxd.fs.LoadedBitmap"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></loadBitmap>
		<get_path set="method" line="90" override="1"><f a=""><c path="String"/></f></get_path>
		<exists public="1" set="method" line="94" override="1"><f a="name">
	<c path="String"/>
	<x path="Bool"/>
</f></exists>
		<get public="1" set="method" line="98" override="1"><f a="name">
	<c path="String"/>
	<c path="hxd.fs.LocalEntry"/>
</f></get>
		<get_size set="method" line="102" override="1"><f a=""><x path="Int"/></f></get_size>
		<iterator public="1" set="method" line="106" override="1"><f a=""><c path="hxd.impl.ArrayIterator_hxd_fs_FileEntry"/></f></iterator>
		<watchCallback><f a=""><x path="Void"/></f></watchCallback>
		<watchTime><x path="Float"/></watchTime>
		<getModifTime get="inline" set="null" line="128"><f a=""><x path="Float"/></f></getModifTime>
		<watch public="1" set="method" line="160" override="1"><f a="onChanged">
	<x path="Null"><f a=""><x path="Void"/></f></x>
	<x path="Void"/>
</f></watch>
		<new set="method" line="16"><f a="fs:name:relPath:file">
	<c path="hxd.fs.LocalFileSystem"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>hxd.fs.LocalFileSystem</e></m>
			<m n=":allow"><e>hxd.fs.FileConverter</e></m>
			<m n=":access"><e>hxd.fs.LocalFileSystem</e></m>
		</meta>
	</class>
	<class path="hxd.fs.LocalFileSystem" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fs/LocalFileSystem.hx">
		<implements path="hxd.fs.FileSystem"/>
		<isWindows expr="Sys.systemName() == &quot;Windows&quot;" line="195" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>Sys.systemName() == "Windows"</e></m></meta>
		</isWindows>
		<root><c path="hxd.fs.FileEntry"/></root>
		<fileCache expr="new Map&lt;String,{ var r : LocalEntry}&gt;()">
			<x path="haxe.ds.Map">
				<c path="String"/>
				<a><r><c path="hxd.fs.LocalEntry"/></r></a>
			</x>
			<meta><m n=":value"><e><![CDATA[new Map<String,{ var r : LocalEntry}>()]]></e></m></meta>
		</fileCache>
		<baseDir public="1" set="null"><c path="String"/></baseDir>
		<convert public="1" set="null"><c path="hxd.fs.FileConverter"/></convert>
		<getAbsolutePath public="1" set="method" line="224"><f a="f">
	<c path="hxd.fs.FileEntry"/>
	<c path="String"/>
</f></getAbsolutePath>
		<getRoot public="1" set="method" line="229"><f a=""><c path="hxd.fs.FileEntry"/></f></getRoot>
		<directoryCache expr="new Map()">
			<t path="Map">
				<c path="String"/>
				<t path="Map">
					<c path="String"/>
					<x path="Bool"/>
				</t>
			</t>
			<meta><m n=":value"><e>new Map()</e></m></meta>
		</directoryCache>
		<checkPath set="method" line="235"><f a="path">
	<c path="String"/>
	<x path="Bool"/>
</f></checkPath>
		<open set="method" line="258">
			<f a="path:?check" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="hxd.fs.LocalEntry"/>
			</f>
			<meta><m n=":value"><e>{ check : true }</e></m></meta>
		</open>
		<clearCache public="1" set="method" line="276"><f a=""><x path="Void"/></f></clearCache>
		<exists public="1" set="method" line="283"><f a="path">
	<c path="String"/>
	<x path="Bool"/>
</f></exists>
		<get public="1" set="method" line="288"><f a="path">
	<c path="String"/>
	<c path="hxd.fs.LocalEntry"/>
</f></get>
		<dispose public="1" set="method" line="295"><f a=""><x path="Void"/></f></dispose>
		<dir public="1" set="method" line="299"><f a="path">
	<c path="String"/>
	<c path="Array"><c path="hxd.fs.FileEntry"/></c>
</f></dir>
		<new public="1" set="method" line="197"><f a="dir:configuration">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.fs.NotFound" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fs/NotFound.hx">
		<path public="1"><c path="String"/></path>
		<toString set="method" line="8">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
		</toString>
		<new public="1" set="method" line="5"><f a="path">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="hxd.impl.BufferFlags" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/impl/Allocator.hx" module="hxd.impl.Allocator">
		<this><x path="Int"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="hxd.impl._Allocator.BufferFlags_Impl_" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/impl/Allocator.hx" private="1" module="hxd.impl.Allocator">
	<Dynamic public="1" get="inline" set="null" expr="cast 0" line="4" static="1">
		<x path="hxd.impl.BufferFlags"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Dynamic>
	<UniformDynamic public="1" get="inline" set="null" expr="cast 1" line="5" static="1">
		<x path="hxd.impl.BufferFlags"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</UniformDynamic>
	<toInt public="1" get="inline" set="null" line="6" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toInt>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="hxd.impl._Allocator.BufferFlags_Impl_" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/impl/Allocator.hx" private="1" module="hxd.impl.Allocator">
		<Dynamic public="1" get="inline" set="null" expr="cast 0" line="4" static="1">
			<x path="hxd.impl.BufferFlags"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Dynamic>
		<UniformDynamic public="1" get="inline" set="null" expr="cast 1" line="5" static="1">
			<x path="hxd.impl.BufferFlags"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</UniformDynamic>
		<toInt public="1" get="inline" set="null" line="6" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toInt>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="hxd.impl.Allocator" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/impl/Allocator.hx">
		<inst static="1"><c path="hxd.impl.Allocator"/></inst>
		<set public="1" set="method" line="54" static="1"><f a="a">
	<c path="hxd.impl.Allocator"/>
	<x path="Void"/>
</f></set>
		<get public="1" set="method" line="57" static="1"><f a=""><c path="hxd.impl.Allocator"/></f></get>
		<allocBuffer public="1" set="method" line="18"><f a="vertices:stride:flags">
	<x path="Int"/>
	<x path="Int"/>
	<x path="hxd.impl.BufferFlags"/>
	<c path="h3d.Buffer"/>
</f></allocBuffer>
		<disposeBuffer public="1" set="method" line="22"><f a="b">
	<c path="h3d.Buffer"/>
	<x path="Void"/>
</f></disposeBuffer>
		<allocIndexBuffer public="1" set="method" line="26"><f a="count">
	<x path="Int"/>
	<c path="h3d.Indexes"/>
</f></allocIndexBuffer>
		<disposeIndexBuffer public="1" set="method" line="30"><f a="i">
	<c path="h3d.Indexes"/>
	<x path="Void"/>
</f></disposeIndexBuffer>
		<onContextLost public="1" set="method" line="34"><f a=""><x path="Void"/></f></onContextLost>
		<allocFloats public="1" set="method" line="39"><f a="count">
	<x path="Int"/>
	<x path="hxd.FloatBuffer"/>
</f></allocFloats>
		<disposeFloats public="1" set="method" line="43"><f a="f">
	<x path="hxd.FloatBuffer"/>
	<x path="Void"/>
</f></disposeFloats>
		<allocIndexes public="1" set="method" line="46"><f a="count">
	<x path="Int"/>
	<x path="hxd.IndexBuffer"/>
</f></allocIndexes>
		<disposeIndexes public="1" set="method" line="50"><f a="i">
	<x path="hxd.IndexBuffer"/>
	<x path="Void"/>
</f></disposeIndexes>
		<new public="1" set="method" line="13"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.impl.Api" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/impl/Api.hx"><downcast public="1" params="T:S" get="inline" set="null" line="5" static="1"><f a="value:c">
	<c path="downcast.T"/>
	<x path="Class"><c path="downcast.S"/></x>
	<c path="downcast.S"/>
</f></downcast></class>
	<class path="hxd.impl.ArrayIterator" params="T" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/impl/ArrayIterator.hx">
		<i><x path="Int"/></i>
		<l><x path="Int"/></l>
		<a><c path="Array"><c path="hxd.impl.ArrayIterator.T"/></c></a>
		<hasNext public="1" get="inline" set="null" line="12"><f a=""><x path="Bool"/></f></hasNext>
		<next public="1" get="inline" set="null" line="15"><f a=""><c path="hxd.impl.ArrayIterator.T"/></f></next>
		<new public="1" get="inline" set="null" line="7"><f a="a">
	<c path="Array"><c path="hxd.impl.ArrayIterator.T"/></c>
	<x path="Void"/>
</f></new>
		<meta><m n=":generic"/></meta>
	</class>
	<typedef path="hxd.impl.Float32" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/impl/Float32.hx"><x path="Float"/></typedef>
	<typedef path="hxd.impl.Serializable" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/impl/Serializable.hx"><c path="hxd.impl._Serializable.NoSerializeSupport"/></typedef>
	<typedef path="hxd.impl.StructSerializable" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/impl/Serializable.hx" module="hxd.impl.Serializable"><c path="hxd.impl._Serializable.NoSerializeSupport"/></typedef>
	<typedef path="hxd.impl.Float32Array" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/impl/TypedArray.hx" module="hxd.impl.TypedArray"><x path="haxe.ds.Vector"><t path="hxd.impl.Float32"/></x></typedef>
	<typedef path="hxd.impl.UInt16" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/impl/UInt16.hx"><x path="Int"/></typedef>
	<typedef path="hxd.impl._UncheckedBytes.InnerData" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/impl/UncheckedBytes.hx" private="1" module="hxd.impl.UncheckedBytes"><t path="haxe.io.BytesData"/></typedef>
	<abstract path="hxd.impl.UncheckedBytes" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/impl/UncheckedBytes.hx">
		<from><icast field="fromBytes"><c path="haxe.io.Bytes"/></icast></from>
		<this><t path="hxd.impl._UncheckedBytes.InnerData"/></this>
		<impl><class path="hxd.impl._UncheckedBytes.UncheckedBytes_Impl_" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/impl/UncheckedBytes.hx" private="1" module="hxd.impl.UncheckedBytes">
	<_new get="inline" set="null" line="7" static="1">
		<f a="v">
			<t path="hxd.impl._UncheckedBytes.InnerData"/>
			<x path="hxd.impl.UncheckedBytes"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<get get="inline" set="null" line="11" static="1">
		<f a="this:i">
			<t path="hxd.impl._UncheckedBytes.InnerData"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":arrayAccess"/>
		</meta>
	</get>
	<set get="inline" set="null" line="19" static="1">
		<f a="this:i:v">
			<t path="hxd.impl._UncheckedBytes.InnerData"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":arrayAccess"/>
		</meta>
	</set>
	<fromBytes public="1" get="inline" set="null" line="28" static="1">
		<f a="b">
			<c path="haxe.io.Bytes"/>
			<x path="hxd.impl.UncheckedBytes"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromBytes>
</class></impl>
	</abstract>
	<class path="hxd.impl._UncheckedBytes.UncheckedBytes_Impl_" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/impl/UncheckedBytes.hx" private="1" module="hxd.impl.UncheckedBytes">
		<_new get="inline" set="null" line="7" static="1">
			<f a="v">
				<t path="hxd.impl._UncheckedBytes.InnerData"/>
				<x path="hxd.impl.UncheckedBytes"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<get get="inline" set="null" line="11" static="1">
			<f a="this:i">
				<t path="hxd.impl._UncheckedBytes.InnerData"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":arrayAccess"/>
			</meta>
		</get>
		<set get="inline" set="null" line="19" static="1">
			<f a="this:i:v">
				<t path="hxd.impl._UncheckedBytes.InnerData"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":arrayAccess"/>
			</meta>
		</set>
		<fromBytes public="1" get="inline" set="null" line="28" static="1">
			<f a="b">
				<c path="haxe.io.Bytes"/>
				<x path="hxd.impl.UncheckedBytes"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromBytes>
	</class>
	<class path="hxd.net.BinaryLoader" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/net/BinaryLoader.hx">
		<url public="1" set="null"><c path="String"/></url>
		<onLoaded public="1" set="dynamic" line="14"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></onLoaded>
		<onProgress public="1" set="dynamic" line="17"><f a="cur:max">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></onProgress>
		<onError public="1" set="dynamic" line="20"><f a="msg">
	<c path="String"/>
	<x path="Void"/>
</f></onError>
		<load public="1" set="method" line="24"><f a=""><x path="Void"/></f></load>
		<new public="1" set="method" line="10"><f a="url">
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="hxd.poly2tri.Edge" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/poly2tri/Edge.hx">
		<p public="1"><c path="hxd.poly2tri.Point"/></p>
		<q public="1"><c path="hxd.poly2tri.Point"/></q>
		<toString public="1" set="method" line="42"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="8"><f a="p1:p2">
	<c path="hxd.poly2tri.Point"/>
	<c path="hxd.poly2tri.Point"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="hxd.poly2tri.Point" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/poly2tri/Point.hx">
		<sortPoints public="1" set="method" line="50" static="1"><f a="points">
	<c path="Array"><c path="hxd.poly2tri.Point"/></c>
	<x path="Void"/>
</f></sortPoints>
		<cmpPoints public="1" set="method" line="55" static="1"><f a="l:r">
	<c path="hxd.poly2tri.Point"/>
	<c path="hxd.poly2tri.Point"/>
	<x path="Int"/>
</f></cmpPoints>
		<C_ID public="1" expr="0" line="69" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</C_ID>
		<id public="1"><x path="Int"/></id>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<edge_list public="1" get="accessor" set="null"><c path="Array"><c path="hxd.poly2tri.Edge"/></c></edge_list>
		<get_edge_list set="method" line="33"><f a=""><c path="Array"><c path="hxd.poly2tri.Edge"/></c></f></get_edge_list>
		<equals public="1" get="inline" set="null" line="41"><f a="that">
	<c path="hxd.poly2tri.Point"/>
	<x path="Bool"/>
</f></equals>
		<toString public="1" set="method" line="64"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="22"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="hxd.res._Any.SingleFileSystem" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/res/Any.hx" private="1" module="hxd.res.Any">
		<extends path="hxd.fs.BytesFileSystem"/>
		<path><c path="String"/></path>
		<bytes><c path="haxe.io.Bytes"/></bytes>
		<getBytes set="method" line="14" override="1"><f a="p">
	<c path="String"/>
	<x path="Null"><c path="haxe.io.Bytes"/></x>
</f></getBytes>
		<new public="1" set="method" line="8"><f a="path:bytes">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.res.Any" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/res/Any.hx">
		<extends path="hxd.res.Resource"/>
		<fromBytes public="1" set="method" line="66" static="1"><f a="path:bytes">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
	<c path="hxd.res.Any"/>
</f></fromBytes>
		<loader><c path="hxd.res.Loader"/></loader>
		<toModel public="1" set="method" line="30"><f a=""><c path="hxd.res.Model"/></f></toModel>
		<toTexture public="1" set="method" line="34"><f a=""><c path="h3d.mat.Texture"/></f></toTexture>
		<toTile public="1" set="method" line="38"><f a=""><c path="h2d.Tile"/></f></toTile>
		<toText public="1" set="method" line="42"><f a=""><c path="String"/></f></toText>
		<toImage public="1" set="method" line="46"><f a=""><c path="hxd.res.Image"/></f></toImage>
		<toSound public="1" set="method" line="50"><f a=""><c path="hxd.res.Sound"/></f></toSound>
		<toPrefab public="1" set="method" line="54"><f a=""><c path="hxd.res.Resource"/></f></toPrefab>
		<to public="1" params="T" set="method" line="58"><f a="c">
	<x path="Class"><c path="to.T"/></x>
	<c path="to.T"/>
</f></to>
		<iterator public="1" get="inline" set="null" line="62"><f a=""><c path="hxd.impl.ArrayIterator_hxd_res_Any"/></f></iterator>
		<new public="1" set="method" line="25"><f a="loader:entry">
	<c path="hxd.res.Loader"/>
	<c path="hxd.fs.FileEntry"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>hxd.res.Loader</e></m>
		</meta>
	</class>
	<class path="hxd.res.BitmapFont" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/res/BitmapFont.hx">
		<extends path="hxd.res.Resource"/>
		<loader><c path="hxd.res.Loader"/></loader>
		<font><c path="h2d.Font"/></font>
		<sdfFonts><c path="Array"><c path="h2d.Font"/></c></sdfFonts>
		<toFont public="1" set="method" line="19"><f a=""><c path="h2d.Font"/></f></toFont>
		<toSdfFont public="1" set="method" line="31">
			<f a="?size:?channel:?alphaCutoff:?smoothing" v=":0:0.5:1 / 32">
				<x path="Int"/>
				<x path="h2d.SDFChannel"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="h2d.Font"/>
			</f>
			<meta><m n=":value"><e>{ smoothing : 1 / 32, alphaCutoff : 0.5, channel : 0 }</e></m></meta>
			<haxe_doc>Load and cache Signed Distance Field font with specified size, channel, alphaCutoff and smoothing. ( default : initial size, red, 0.5, 1 / 32 )
		For more information on SDF texture generation refer to this page: https://github.com/libgdx/libgdx/wiki/Distance-field-fonts
		For more information on MSDF texture generation refer to this page: https://github.com/Chlumsky/msdfgen</haxe_doc>
		</toSdfFont>
		<resolveSdfTile set="method" line="50"><f a="path">
	<c path="String"/>
	<c path="h2d.Tile"/>
</f></resolveSdfTile>
		<resolveTile set="method" line="56"><f a="path">
	<c path="String"/>
	<c path="h2d.Tile"/>
</f></resolveTile>
		<new public="1" set="method" line="14"><f a="entry">
	<c path="hxd.fs.FileEntry"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.res.DefaultFont" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/res/DefaultFont.hx">
		<get public="1" set="method" line="5" static="1"><f a=""><c path="h2d.Font"/></f></get>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.res.Embed" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/res/Embed.hx">
		<getFileContent public="1" set="method" static="1"><f a="file">
	<d/>
	<d/>
</f></getFileContent>
		<getResource public="1" set="method" static="1"><f a="file">
	<d/>
	<d/>
</f></getResource>
		<embedFont public="1" set="method" static="1"><f a="file:?chars:?skipErrors">
	<d/>
	<d/>
	<d/>
	<d/>
</f></embedFont>
	</class>
	<typedef path="hxd.res.EmbedOptions" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/res/EmbedOptions.hx"><a>
	<fontsChars>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</fontsChars>
	<configuration>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</configuration>
</a></typedef>
	<abstract path="hxd.res.ImageFormat" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/res/Image.hx" module="hxd.res.Image">
		<this><x path="Int"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="hxd.res._Image.ImageFormat_Impl_" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/res/Image.hx" private="1" module="hxd.res.Image">
	<Jpg public="1" get="inline" set="null" expr="cast 0" line="5" static="1">
		<x path="hxd.res.ImageFormat"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Jpg>
	<Png public="1" get="inline" set="null" expr="cast 1" line="6" static="1">
		<x path="hxd.res.ImageFormat"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Png>
	<Gif public="1" get="inline" set="null" expr="cast 2" line="7" static="1">
		<x path="hxd.res.ImageFormat"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Gif>
	<Tga public="1" get="inline" set="null" expr="cast 3" line="8" static="1">
		<x path="hxd.res.ImageFormat"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Tga>
	<Dds public="1" get="inline" set="null" expr="cast 4" line="9" static="1">
		<x path="hxd.res.ImageFormat"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Dds>
	<useAsyncDecode public="1" get="accessor" set="null" static="1">
		<x path="Bool"/>
		<meta><m n=":impl"/></meta>
	</useAsyncDecode>
	<get_useAsyncDecode get="inline" set="null" line="17" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_useAsyncDecode>
	<toInt get="inline" set="null" line="25" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toInt>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="hxd.res._Image.ImageFormat_Impl_" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/res/Image.hx" private="1" module="hxd.res.Image">
		<Jpg public="1" get="inline" set="null" expr="cast 0" line="5" static="1">
			<x path="hxd.res.ImageFormat"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Jpg>
		<Png public="1" get="inline" set="null" expr="cast 1" line="6" static="1">
			<x path="hxd.res.ImageFormat"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Png>
		<Gif public="1" get="inline" set="null" expr="cast 2" line="7" static="1">
			<x path="hxd.res.ImageFormat"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Gif>
		<Tga public="1" get="inline" set="null" expr="cast 3" line="8" static="1">
			<x path="hxd.res.ImageFormat"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Tga>
		<Dds public="1" get="inline" set="null" expr="cast 4" line="9" static="1">
			<x path="hxd.res.ImageFormat"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Dds>
		<useAsyncDecode public="1" get="accessor" set="null" static="1">
			<x path="Bool"/>
			<meta><m n=":impl"/></meta>
		</useAsyncDecode>
		<get_useAsyncDecode get="inline" set="null" line="17" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_useAsyncDecode>
		<toInt get="inline" set="null" line="25" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toInt>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="hxd.res.Image" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/res/Image.hx">
		<extends path="hxd.res.Resource"/>
		<ALLOW_NPOT public="1" expr="true" line="34" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>Specify if we will automatically convert non-power-of-two textures to power-of-two.</haxe_doc>
		</ALLOW_NPOT>
		<DEFAULT_FILTER public="1" expr="Linear" line="35" static="1">
			<e path="h3d.mat.Filter"/>
			<meta><m n=":value"><e>Linear</e></m></meta>
		</DEFAULT_FILTER>
		<DEFAULT_ASYNC public="1" expr="false" line="40" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>Forces async decoding for images if available on the target platform.</haxe_doc>
		</DEFAULT_ASYNC>
		<ENABLE_AUTO_WATCH expr="true" line="42" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</ENABLE_AUTO_WATCH>
		<tex><c path="h3d.mat.Texture"/></tex>
		<inf><a>
	<width><x path="Int"/></width>
	<height><x path="Int"/></height>
	<format><x path="hxd.res.ImageFormat"/></format>
	<bc><x path="Int"/></bc>
</a></inf>
		<getFormat public="1" set="method" line="47"><f a=""><x path="hxd.res.ImageFormat"/></f></getFormat>
		<getSize public="1" set="method" line="52"><f a=""><a>
	<width><x path="Int"/></width>
	<height><x path="Int"/></height>
</a></f></getSize>
		<getPixels public="1" set="method" line="146"><f a="?fmt:?flipY">
	<e path="hxd.PixelFormat"/>
	<x path="Bool"/>
	<c path="hxd.Pixels"/>
</f></getPixels>
		<toBitmap public="1" set="method" line="248"><f a=""><c path="hxd.BitmapData"/></f></toBitmap>
		<watchCallb set="method" line="257"><f a=""><x path="Void"/></f></watchCallb>
		<loadTexture set="method" line="267"><f a=""><x path="Void"/></f></loadTexture>
		<toTexture public="1" set="method" line="315"><f a=""><c path="h3d.mat.Texture"/></f></toTexture>
		<toTile public="1" set="method" line="337"><f a=""><c path="h2d.Tile"/></f></toTile>
		<new public="1" set="method" line="29"><f a="entry">
	<c path="hxd.fs.FileEntry"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.res.Model" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/res/Model.hx">
		<extends path="hxd.res.Resource"/>
		<toHmd public="1" set="method" line="5"><f a=""><c path="hxd.fmt.hmd.Library"/></f></toHmd>
		<new public="1" set="method" line="3"><f a="entry">
	<c path="hxd.fs.FileEntry"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="hxd.res.Filter" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/res/NanoJpeg.hx" module="hxd.res.NanoJpeg">
		<Fast/>
		<Chromatic/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<abstract path="hxd.res._NanoJpeg.FastBytes" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/res/NanoJpeg.hx" private="1" module="hxd.res.NanoJpeg">
		<this><c path="haxe.io.Bytes"/></this>
		<impl><class path="hxd.res._NanoJpeg.FastBytes_Impl_" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/res/NanoJpeg.hx" private="1" module="hxd.res.NanoJpeg">
	<_new public="1" get="inline" set="null" line="27" static="1">
		<f a="b">
			<c path="haxe.io.Bytes"/>
			<x path="hxd.res._NanoJpeg.FastBytes"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<get get="inline" set="null" line="30" static="1">
		<f a="this:i">
			<c path="haxe.io.Bytes"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":arrayAccess"/>
		</meta>
	</get>
	<set get="inline" set="null" line="33" static="1">
		<f a="this:i:v">
			<c path="haxe.io.Bytes"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Void"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":arrayAccess"/>
		</meta>
	</set>
</class></impl>
	</abstract>
	<class path="hxd.res._NanoJpeg.FastBytes_Impl_" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/res/NanoJpeg.hx" private="1" module="hxd.res.NanoJpeg">
		<_new public="1" get="inline" set="null" line="27" static="1">
			<f a="b">
				<c path="haxe.io.Bytes"/>
				<x path="hxd.res._NanoJpeg.FastBytes"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<get get="inline" set="null" line="30" static="1">
			<f a="this:i">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":arrayAccess"/>
			</meta>
		</get>
		<set get="inline" set="null" line="33" static="1">
			<f a="this:i:v">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":arrayAccess"/>
			</meta>
		</set>
	</class>
	<class path="hxd.res._NanoJpeg.Component" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/res/NanoJpeg.hx" private="1" module="hxd.res.NanoJpeg">
		<cid public="1"><x path="Int"/></cid>
		<ssx public="1"><x path="Int"/></ssx>
		<ssy public="1"><x path="Int"/></ssy>
		<width public="1"><x path="Int"/></width>
		<height public="1"><x path="Int"/></height>
		<stride public="1"><x path="Int"/></stride>
		<qtsel public="1"><x path="Int"/></qtsel>
		<actabsel public="1"><x path="Int"/></actabsel>
		<dctabsel public="1"><x path="Int"/></dctabsel>
		<dcpred public="1"><x path="Int"/></dcpred>
		<pixels public="1"><c path="haxe.io.Bytes"/></pixels>
		<new public="1" set="method" line="50"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.res.NanoJpeg" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/res/NanoJpeg.hx">
		<BLOCKSIZE get="inline" set="null" expr="64" line="57" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>64</e></m></meta>
		</BLOCKSIZE>
		<W1 get="inline" set="null" expr="2841" line="355" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2841</e></m></meta>
		</W1>
		<W2 get="inline" set="null" expr="2676" line="356" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2676</e></m></meta>
		</W2>
		<W3 get="inline" set="null" expr="2408" line="357" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2408</e></m></meta>
		</W3>
		<W5 get="inline" set="null" expr="1609" line="358" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1609</e></m></meta>
		</W5>
		<W6 get="inline" set="null" expr="1108" line="359" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1108</e></m></meta>
		</W6>
		<W7 get="inline" set="null" expr="565" line="360" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>565</e></m></meta>
		</W7>
		<CF4A get="inline" set="null" expr="-9" line="527" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>-9</e></m></meta>
		</CF4A>
		<CF4B get="inline" set="null" expr="111" line="528" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>111</e></m></meta>
		</CF4B>
		<CF4C get="inline" set="null" expr="29" line="529" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>29</e></m></meta>
		</CF4C>
		<CF4D get="inline" set="null" expr="-3" line="530" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>-3</e></m></meta>
		</CF4D>
		<CF3A get="inline" set="null" expr="28" line="531" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>28</e></m></meta>
		</CF3A>
		<CF3B get="inline" set="null" expr="109" line="532" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>109</e></m></meta>
		</CF3B>
		<CF3C get="inline" set="null" expr="-9" line="533" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>-9</e></m></meta>
		</CF3C>
		<CF3X get="inline" set="null" expr="104" line="534" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>104</e></m></meta>
		</CF3X>
		<CF3Y get="inline" set="null" expr="27" line="535" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>27</e></m></meta>
		</CF3Y>
		<CF3Z get="inline" set="null" expr="-3" line="536" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>-3</e></m></meta>
		</CF3Z>
		<CF2A get="inline" set="null" expr="139" line="537" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>139</e></m></meta>
		</CF2A>
		<CF2B get="inline" set="null" expr="-11" line="538" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>-11</e></m></meta>
		</CF2B>
		<CF get="inline" set="null" line="539" static="1"><f a="x">
	<x path="Int"/>
	<x path="Int"/>
</f></CF>
		<njClip get="inline" set="null" line="541" static="1"><f a="x">
	<x path="Int"/>
	<x path="Int"/>
</f></njClip>
		<inst expr="null" line="742" static="1">
			<c path="hxd.res.NanoJpeg"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</inst>
		<decode public="1" set="method" line="743" static="1">
			<f a="bytes:?filter:?position:?size" v="::0:-1">
				<c path="haxe.io.Bytes"/>
				<e path="hxd.res.Filter"/>
				<x path="Int"/>
				<x path="Int"/>
				<a>
					<width><x path="Int"/></width>
					<pixels><c path="haxe.io.Bytes"/></pixels>
					<height><x path="Int"/></height>
				</a>
			</f>
			<meta><m n=":value"><e>{ size : -1, position : 0 }</e></m></meta>
		</decode>
		<bytes><c path="haxe.io.Bytes"/></bytes>
		<pos><x path="Int"/></pos>
		<size><x path="Int"/></size>
		<length><x path="Int"/></length>
		<width><x path="Int"/></width>
		<height><x path="Int"/></height>
		<ncomp><x path="Int"/></ncomp>
		<comps><x path="haxe.ds.Vector"><c path="hxd.res._NanoJpeg.Component"/></x></comps>
		<counts><x path="haxe.ds.Vector"><x path="Int"/></x></counts>
		<qtab><x path="haxe.ds.Vector"><x path="haxe.ds.Vector"><x path="Int"/></x></x></qtab>
		<qtused><x path="Int"/></qtused>
		<qtavail><x path="Int"/></qtavail>
		<vlctab><x path="haxe.ds.Vector"><c path="haxe.io.Bytes"/></x></vlctab>
		<block><x path="haxe.ds.Vector"><x path="Int"/></x></block>
		<njZZ><x path="haxe.ds.Vector"><x path="Int"/></x></njZZ>
		<progressive><x path="Bool"/></progressive>
		<mbsizex><x path="Int"/></mbsizex>
		<mbsizey><x path="Int"/></mbsizey>
		<mbwidth><x path="Int"/></mbwidth>
		<mbheight><x path="Int"/></mbheight>
		<rstinterval><x path="Int"/></rstinterval>
		<buf><x path="Int"/></buf>
		<bufbits><x path="Int"/></bufbits>
		<pixels><c path="haxe.io.Bytes"/></pixels>
		<filter><e path="hxd.res.Filter"/></filter>
		<alloc get="inline" set="null" line="106"><f a="nbytes">
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></alloc>
		<free get="inline" set="null" line="110"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></free>
		<njInit set="method" line="113"><f a="bytes:pos:size:filter">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<e path="hxd.res.Filter"/>
	<x path="Void"/>
</f></njInit>
		<cleanup set="method" line="133"><f a=""><x path="Void"/></f></cleanup>
		<njSkip get="inline" set="null" line="147"><f a="count">
	<x path="Int"/>
	<x path="Void"/>
</f></njSkip>
		<syntax get="inline" set="null" line="154"><f a="flag">
	<x path="Bool"/>
	<x path="Void"/>
</f></syntax>
		<get get="inline" set="null" line="160"><f a="p">
	<x path="Int"/>
	<x path="Int"/>
</f></get>
		<njDecode16 get="inline" set="null" line="164"><f a="p">
	<x path="Int"/>
	<x path="Int"/>
</f></njDecode16>
		<njByteAlign get="inline" set="null" line="168"><f a=""><x path="Void"/></f></njByteAlign>
		<njShowBits set="method" line="172"><f a="bits">
	<x path="Int"/>
	<x path="Int"/>
</f></njShowBits>
		<njSkipBits get="inline" set="null" line="204"><f a="bits">
	<x path="Int"/>
	<x path="Void"/>
</f></njSkipBits>
		<njGetBits get="inline" set="null" line="210"><f a="bits">
	<x path="Int"/>
	<x path="Int"/>
</f></njGetBits>
		<njDecodeLength get="inline" set="null" line="216"><f a=""><x path="Void"/></f></njDecodeLength>
		<njSkipMarker get="inline" set="null" line="223"><f a=""><x path="Void"/></f></njSkipMarker>
		<njDecodeSOF set="method" line="228"><f a=""><x path="Void"/></f></njDecodeSOF>
		<njDecodeDQT set="method" line="280"><f a=""><x path="Void"/></f></njDecodeDQT>
		<njDecodeDHT set="method" line="294"><f a=""><x path="Void"/></f></njDecodeDHT>
		<njDecodeDRI set="method" line="330"><f a=""><x path="Void"/></f></njDecodeDRI>
		<vlcCode><x path="Int"/></vlcCode>
		<njGetVLC get="inline" set="null" line="340"><f a="vlc">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
</f></njGetVLC>
		<njRowIDCT get="inline" set="null" line="362"><f a="bp">
	<x path="Int"/>
	<x path="Void"/>
</f></njRowIDCT>
		<njColIDCT get="inline" set="null" line="406"><f a="bp:out:po:stride">
	<x path="Int"/>
	<x path="hxd.res._NanoJpeg.FastBytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></njColIDCT>
		<njDecodeBlock set="method" line="455"><f a="c:po">
	<c path="hxd.res._NanoJpeg.Component"/>
	<x path="Int"/>
	<x path="Void"/>
</f></njDecodeBlock>
		<notSupported set="method" line="478"><f a=""><x path="Void"/></f></notSupported>
		<njDecodeScan set="method" line="482"><f a=""><x path="Void"/></f></njDecodeScan>
		<njUpsampleH set="method" line="545"><f a="c">
	<c path="hxd.res._NanoJpeg.Component"/>
	<x path="Void"/>
</f></njUpsampleH>
		<njUpsampleV set="method" line="574"><f a="c">
	<c path="hxd.res._NanoJpeg.Component"/>
	<x path="Void"/>
</f></njUpsampleV>
		<njUpsample set="method" line="602"><f a="c">
	<c path="hxd.res._NanoJpeg.Component"/>
	<x path="Void"/>
</f></njUpsample>
		<njConvert set="method" line="632"><f a=""><c path="haxe.io.Bytes"/></f></njConvert>
		<njDecode set="method" line="702"><f a=""><a>
	<width><x path="Int"/></width>
	<pixels><c path="haxe.io.Bytes"/></pixels>
	<height><x path="Int"/></height>
</a></f></njDecode>
		<new set="method" line="88"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":noDebug"/>
		</meta>
	</class>
	<typedef path="hxd.res.NotFound" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/res/NotFound.hx"><c path="hxd.fs.NotFound"/></typedef>
	<typedef path="hxd.res.Prefab" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/res/Prefab.hx"><c path="hxd.res.Resource"/></typedef>
	<enum path="hxd.res.SoundFormat" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/res/Sound.hx" module="hxd.res.Sound">
		<Wav/>
		<Mp3/>
		<OggVorbis/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="hxd.res.Sound" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/res/Sound.hx">
		<extends path="hxd.res.Resource"/>
		<ENABLE_AUTO_WATCH expr="true" line="11" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</ENABLE_AUTO_WATCH>
		<supportedFormat public="1" set="method" line="17" static="1"><f a="fmt">
	<e path="hxd.res.SoundFormat"/>
	<x path="Bool"/>
</f></supportedFormat>
		<startWorker public="1" set="method" line="80" static="1"><f a=""><x path="Bool"/></f></startWorker>
		<data><c path="hxd.snd.Data"/></data>
		<channel><c path="hxd.snd.Channel"/></channel>
		<lastPlay public="1" set="null" expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</lastPlay>
		<getData public="1" set="method" line="30"><f a=""><c path="hxd.snd.Data"/></f></getData>
		<dispose public="1" set="method" line="60"><f a=""><x path="Void"/></f></dispose>
		<stop public="1" set="method" line="65"><f a=""><x path="Void"/></f></stop>
		<play public="1" set="method" line="72">
			<f a="?loop:?volume:?channelGroup:?soundGroup" v="false:1.::">
				<x path="Bool"/>
				<x path="Float"/>
				<c path="hxd.snd.ChannelGroup"/>
				<c path="hxd.snd.SoundGroup"/>
				<c path="hxd.snd.Channel"/>
			</f>
			<meta><m n=":value"><e>{ volume : 1., loop : false }</e></m></meta>
		</play>
		<watchCallb set="method" line="85">
			<f a=""><x path="Void"/></f>
			<meta><m n=":access"><e>hxd.snd.ChannelBase</e></m></meta>
		</watchCallb>
		<new public="1" set="method" line="9"><f a="entry">
	<c path="hxd.fs.FileEntry"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.snd.ChannelBase" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/snd/ChannelBase.hx">
		<priority public="1" expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</priority>
		<mute public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</mute>
		<effects public="1" expr="[]">
			<c path="Array"><c path="hxd.snd.Effect"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</effects>
		<bindedEffects public="1" expr="[]">
			<c path="Array"><c path="hxd.snd.Effect"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</bindedEffects>
		<volume public="1" set="accessor" expr="1.">
			<x path="Float"/>
			<meta><m n=":value"><e>1.</e></m></meta>
		</volume>
		<currentFade><a>
	<targetVolume><x path="Float"/></targetVolume>
	<startVolume><x path="Float"/></startVolume>
	<start><x path="Float"/></start>
	<onEnd><f a=""><x path="Void"/></f></onEnd>
	<duration><x path="Float"/></duration>
</a></currentFade>
		<currentVolume><x path="Float"/></currentVolume>
		<getEffect public="1" params="T" set="method" line="18"><f a="etype">
	<x path="Class"><c path="getEffect.T"/></x>
	<c path="getEffect.T"/>
</f></getEffect>
		<set_volume set="method" line="27"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_volume>
		<fadeTo public="1" set="method" line="32">
			<f a="volume:?time:?onEnd" v=":1.:">
				<x path="Float"/>
				<x path="Float"/>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ time : 1. }</e></m></meta>
		</fadeTo>
		<updateCurrentVolume set="method" line="36"><f a="now">
	<x path="Float"/>
	<x path="Void"/>
</f></updateCurrentVolume>
		<addEffect public="1" params="T" set="method" line="52">
			<f a="e">
				<c path="addEffect.T"/>
				<c path="addEffect.T"/>
			</f>
			<meta><m n=":access"><e>hxd.snd.Manager</e></m></meta>
		</addEffect>
		<removeEffect public="1" set="method" line="60">
			<f a="e">
				<c path="hxd.snd.Effect"/>
				<x path="Void"/>
			</f>
			<meta><m n=":access"><e>hxd.snd.Manager</e></m></meta>
		</removeEffect>
		<new set="method" line="15"><f a=""><x path="Void"/></f></new>
		<meta><m n=":allow"><e>hxd.snd.Manager</e></m></meta>
	</class>
	<class path="hxd.snd.Channel" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/snd/Channel.hx">
		<extends path="hxd.snd.ChannelBase"/>
		<ID expr="0" line="5" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</ID>
		<next public="1">
			<c path="hxd.snd.Channel"/>
			<meta><m n=":noCompletion"/></meta>
		</next>
		<manager><c path="hxd.snd.Manager"/></manager>
		<source><c path="hxd.snd.Source"/></source>
		<id><x path="Int"/></id>
		<sound public="1" set="null"><c path="hxd.res.Sound"/></sound>
		<duration public="1" set="null"><x path="Float"/></duration>
		<soundGroup public="1" set="null"><c path="hxd.snd.SoundGroup"/></soundGroup>
		<channelGroup public="1" set="null"><c path="hxd.snd.ChannelGroup"/></channelGroup>
		<position public="1" set="accessor" expr="0.0">
			<x path="Float"/>
			<meta><m n=":value"><e>0.0</e></m></meta>
		</position>
		<pause public="1" set="accessor" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</pause>
		<loop public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</loop>
		<allowVirtual public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</allowVirtual>
		<audibleVolume expr="1.0">
			<x path="Float"/>
			<meta><m n=":value"><e>1.0</e></m></meta>
		</audibleVolume>
		<lastStamp expr="0.0">
			<x path="Float"/>
			<meta><m n=":value"><e>0.0</e></m></meta>
		</lastStamp>
		<isVirtual expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</isVirtual>
		<isLoading expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</isLoading>
		<positionChanged expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</positionChanged>
		<queue expr="[]">
			<c path="Array"><c path="hxd.res.Sound"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</queue>
		<onEnd public="1" set="dynamic" line="39">
			<f a=""><x path="Void"/></f>
			<haxe_doc>onEnd() is called when a sound which does not loop has finished playing
		or when we switch buffer in a queue
		or when a sound which is streamed loops.</haxe_doc>
		</onEnd>
		<set_position set="method" line="42"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_position>
		<set_pause set="method" line="50"><f a="v">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_pause>
		<updateCurrentVolume set="method" line="55" override="1"><f a="now">
	<x path="Float"/>
	<x path="Void"/>
</f></updateCurrentVolume>
		<calcAudibleVolume public="1" set="method" line="72"><f a="now">
	<x path="Float"/>
	<x path="Void"/>
</f></calcAudibleVolume>
		<queueSound public="1" set="method" line="86">
			<f a="sound">
				<c path="hxd.res.Sound"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Add a sound to the queue. When the current sound is finished playing, the next one will seamlessly continue.
		This will also trigger an onEnd() event.</haxe_doc>
		</queueSound>
		<stop public="1" set="method" line="90"><f a=""><x path="Void"/></f></stop>
		<isReleased public="1" set="method" line="94"><f a=""><x path="Bool"/></f></isReleased>
		<new set="method" line="29"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>hxd.snd.Manager</e></m>
		</meta>
	</class>
	<class path="hxd.snd.ChannelGroup" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/snd/ChannelGroup.hx">
		<extends path="hxd.snd.ChannelBase"/>
		<name public="1" set="null"><c path="String"/></name>
		<new public="1" set="method" line="7"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="hxd.snd.SampleFormat" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/snd/Data.hx" module="hxd.snd.Data">
		<UI8/>
		<I16/>
		<F32/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="hxd.snd.Data" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/snd/Data.hx">
		<formatBytes public="1" get="inline" set="null" line="165" static="1"><f a="format">
	<e path="hxd.snd.SampleFormat"/>
	<x path="Int"/>
</f></formatBytes>
		<samples public="1" set="null"><x path="Int"/></samples>
		<samplingRate public="1" set="null"><x path="Int"/></samplingRate>
		<sampleFormat public="1" set="null"><e path="hxd.snd.SampleFormat"/></sampleFormat>
		<channels public="1" set="null"><x path="Int"/></channels>
		<duration public="1" get="accessor" set="null"><x path="Float"/></duration>
		<isLoading public="1" set="method" line="18"><f a=""><x path="Bool"/></f></isLoading>
		<decode public="1" set="method" line="22"><f a="out:outPos:sampleStart:sampleCount">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></decode>
		<resample public="1" set="method" line="45"><f a="rate:format:channels">
	<x path="Int"/>
	<e path="hxd.snd.SampleFormat"/>
	<x path="Int"/>
	<c path="hxd.snd.Data"/>
</f></resample>
		<resampleBuffer public="1" set="method" line="67">
			<f a="out:outPos:input:inPos:rate:format:channels:samples">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<e path="hxd.snd.SampleFormat"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noDebug"/></meta>
		</resampleBuffer>
		<decodeBuffer set="method" line="157"><f a="out:outPos:sampleStart:sampleCount">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></decodeBuffer>
		<getBytesPerSample public="1" set="method" line="161"><f a=""><x path="Int"/></f></getBytesPerSample>
		<load public="1" set="method" line="178">
			<f a="onEnd">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<haxe_doc>Some platforms might require some data to be loaded before we can start decoding.
		Use load() and wait for onEnd to make sure that the sound data and the correct number of samples is available.
		onEnd() might be called back immediately if the data is already available.</haxe_doc>
		</load>
		<get_duration set="method" line="182"><f a=""><x path="Float"/></f></get_duration>
	</class>
	<typedef path="hxd.snd.SourceHandle" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/snd/Driver.hx" module="hxd.snd.Driver"><c path="hxd.snd.openal.SourceHandle"/></typedef>
	<typedef path="hxd.snd.BufferHandle" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/snd/Driver.hx" module="hxd.snd.Driver"><c path="hxd.snd.openal.BufferHandle"/></typedef>
	<class path="hxd.snd.EffectDriver" params="T" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/snd/Driver.hx" module="hxd.snd.Driver">
		<acquire public="1" set="method" line="17"><f a=""><x path="Void"/></f></acquire>
		<release public="1" set="method" line="18"><f a=""><x path="Void"/></f></release>
		<update public="1" set="method" line="19"><f a="e">
	<c path="hxd.snd.EffectDriver.T"/>
	<x path="Void"/>
</f></update>
		<bind public="1" set="method" line="20"><f a="e:source">
	<c path="hxd.snd.EffectDriver.T"/>
	<t path="hxd.snd.SourceHandle"/>
	<x path="Void"/>
</f></bind>
		<apply public="1" set="method" line="21"><f a="e:source">
	<c path="hxd.snd.EffectDriver.T"/>
	<t path="hxd.snd.SourceHandle"/>
	<x path="Void"/>
</f></apply>
		<unbind public="1" set="method" line="22"><f a="e:source">
	<c path="hxd.snd.EffectDriver.T"/>
	<t path="hxd.snd.SourceHandle"/>
	<x path="Void"/>
</f></unbind>
		<new public="1" set="method" line="15"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="hxd.snd.DriverFeature" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/snd/Driver.hx" module="hxd.snd.Driver">
		<MasterVolume/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="hxd.snd.Driver" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/snd/Driver.hx" interface="1">
		<hasFeature public="1" set="method"><f a="d">
	<e path="hxd.snd.DriverFeature"/>
	<x path="Bool"/>
</f></hasFeature>
		<setMasterVolume public="1" set="method"><f a="value">
	<x path="Float"/>
	<x path="Void"/>
</f></setMasterVolume>
		<setListenerParams public="1" set="method"><f a="position:direction:up:?velocity">
	<c path="h3d.Vector"/>
	<c path="h3d.Vector"/>
	<c path="h3d.Vector"/>
	<c path="h3d.Vector"/>
	<x path="Void"/>
</f></setListenerParams>
		<createSource public="1" set="method"><f a=""><t path="hxd.snd.SourceHandle"/></f></createSource>
		<playSource public="1" set="method"><f a="source">
	<t path="hxd.snd.SourceHandle"/>
	<x path="Void"/>
</f></playSource>
		<stopSource public="1" set="method"><f a="source">
	<t path="hxd.snd.SourceHandle"/>
	<x path="Void"/>
</f></stopSource>
		<setSourceVolume public="1" set="method"><f a="source:value">
	<t path="hxd.snd.SourceHandle"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setSourceVolume>
		<destroySource public="1" set="method"><f a="source">
	<t path="hxd.snd.SourceHandle"/>
	<x path="Void"/>
</f></destroySource>
		<createBuffer public="1" set="method"><f a=""><t path="hxd.snd.BufferHandle"/></f></createBuffer>
		<setBufferData public="1" set="method"><f a="buffer:data:size:format:channelCount:samplingRate">
	<t path="hxd.snd.BufferHandle"/>
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<e path="hxd.snd.SampleFormat"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setBufferData>
		<destroyBuffer public="1" set="method"><f a="buffer">
	<t path="hxd.snd.BufferHandle"/>
	<x path="Void"/>
</f></destroyBuffer>
		<queueBuffer public="1" set="method"><f a="source:buffer:sampleStart:endOfStream">
	<t path="hxd.snd.SourceHandle"/>
	<t path="hxd.snd.BufferHandle"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></queueBuffer>
		<unqueueBuffer public="1" set="method"><f a="source:buffer">
	<t path="hxd.snd.SourceHandle"/>
	<t path="hxd.snd.BufferHandle"/>
	<x path="Void"/>
</f></unqueueBuffer>
		<getProcessedBuffers public="1" set="method"><f a="source">
	<t path="hxd.snd.SourceHandle"/>
	<x path="Int"/>
</f></getProcessedBuffers>
		<getPlayedSampleCount public="1" set="method"><f a="source">
	<t path="hxd.snd.SourceHandle"/>
	<x path="Int"/>
</f></getPlayedSampleCount>
		<update public="1" set="method"><f a=""><x path="Void"/></f></update>
		<dispose public="1" set="method"><f a=""><x path="Void"/></f></dispose>
		<getEffectDriver public="1" set="method"><f a="type">
	<c path="String"/>
	<c path="hxd.snd.EffectDriver"><d/></c>
</f></getEffectDriver>
	</class>
	<class path="hxd.snd.Effect" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/snd/Effect.hx">
		<next public="1">
			<c path="hxd.snd.Effect"/>
			<meta><m n=":noCompletion"/></meta>
		</next>
		<refs><x path="Int"/></refs>
		<retainTime><x path="Float"/></retainTime>
		<lastStamp><x path="Float"/></lastStamp>
		<driver><c path="hxd.snd.EffectDriver"><d/></c></driver>
		<priority><x path="Int"/></priority>
		<applyAudibleVolumeModifier public="1" set="method" line="28"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></applyAudibleVolumeModifier>
		<getVolumeModifier public="1" set="method" line="33"><f a=""><x path="Float"/></f></getVolumeModifier>
		<new public="1" set="method" line="14"><f a="type">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":allow"><e>hxd.snd.Manager</e></m></meta>
	</class>
	<class path="hxd.snd.Listener" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/snd/Listener.hx">
		<position public="1"><c path="h3d.Vector"/></position>
		<direction public="1"><c path="h3d.Vector"/></direction>
		<velocity public="1"><c path="h3d.Vector"/></velocity>
		<up public="1"><c path="h3d.Vector"/></up>
		<syncCamera public="1" set="method" line="17"><f a="cam">
	<c path="h3d.Camera"/>
	<x path="Void"/>
</f></syncCamera>
		<new public="1" set="method" line="10"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.snd.Source" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/snd/Manager.hx" module="hxd.snd.Manager">
		<ID expr="0" line="8" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</ID>
		<id public="1" set="null"><x path="Int"/></id>
		<handle public="1"><t path="hxd.snd.SourceHandle"/></handle>
		<channel public="1"><c path="hxd.snd.Channel"/></channel>
		<buffers public="1"><c path="Array"><c path="hxd.snd.Buffer"/></c></buffers>
		<volume public="1" expr="-1.0">
			<x path="Float"/>
			<meta><m n=":value"><e>-1.0</e></m></meta>
		</volume>
		<playing public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</playing>
		<start public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</start>
		<streamSound public="1"><c path="hxd.res.Sound"/></streamSound>
		<streamBuffer public="1"><c path="haxe.io.Bytes"/></streamBuffer>
		<streamStart public="1"><x path="Int"/></streamStart>
		<streamPos public="1"><x path="Int"/></streamPos>
		<dispose public="1" set="method" line="30"><f a=""><x path="Void"/></f></dispose>
		<new public="1" set="method" line="24"><f a="driver">
	<c path="hxd.snd.Driver"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>hxd.snd.Manager</e></m>
		</meta>
	</class>
	<class path="hxd.snd.Buffer" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/snd/Manager.hx" module="hxd.snd.Manager">
		<handle public="1"><t path="hxd.snd.BufferHandle"/></handle>
		<sound public="1"><c path="hxd.res.Sound"/></sound>
		<isEnd public="1"><x path="Bool"/></isEnd>
		<isStream public="1"><x path="Bool"/></isStream>
		<refs public="1"><x path="Int"/></refs>
		<lastStop public="1"><x path="Float"/></lastStop>
		<start public="1"><x path="Int"/></start>
		<end public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</end>
		<samples public="1"><x path="Int"/></samples>
		<sampleRate public="1"><x path="Int"/></sampleRate>
		<dispose public="1" set="method" line="55"><f a=""><x path="Void"/></f></dispose>
		<new public="1" set="method" line="49"><f a="driver">
	<c path="hxd.snd.Driver"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>hxd.snd.Manager</e></m>
		</meta>
	</class>
	<class path="hxd.snd.Manager" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/snd/Manager.hx">
		<STREAM_DURATION public="1" expr="5." line="62" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>5.</e></m></meta>
		</STREAM_DURATION>
		<STREAM_BUFFER_SAMPLE_COUNT public="1" expr="44100" line="63" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>44100</e></m></meta>
		</STREAM_BUFFER_SAMPLE_COUNT>
		<BUFFER_QUEUE_LENGTH public="1" expr="2" line="64" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</BUFFER_QUEUE_LENGTH>
		<MAX_SOURCES public="1" expr="16" line="65" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>16</e></m></meta>
		</MAX_SOURCES>
		<SOUND_BUFFER_CACHE_SIZE public="1" expr="256" line="66" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>256</e></m></meta>
		</SOUND_BUFFER_CACHE_SIZE>
		<VIRTUAL_VOLUME_THRESHOLD public="1" expr="1e-5" line="67" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1e-5</e></m></meta>
		</VIRTUAL_VOLUME_THRESHOLD>
		<BUFFER_STREAM_SPLIT public="1" expr="16" line="72" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>16</e></m></meta>
			<haxe_doc>Allows to decode big streaming buffers over X split frames. 0 to disable</haxe_doc>
		</BUFFER_STREAM_SPLIT>
		<instance static="1"><c path="hxd.snd.Manager"/></instance>
		<get public="1" set="method" line="147" static="1"><f a=""><c path="hxd.snd.Manager"/></f></get>
		<regEffect set="method" line="627" static="1"><f a="list:e">
	<c path="hxd.snd.Effect"/>
	<c path="hxd.snd.Effect"/>
	<c path="hxd.snd.Effect"/>
</f></regEffect>
		<masterVolume public="1"><x path="Float"/></masterVolume>
		<masterSoundGroup public="1" set="null"><c path="hxd.snd.SoundGroup"/></masterSoundGroup>
		<masterChannelGroup public="1" set="null"><c path="hxd.snd.ChannelGroup"/></masterChannelGroup>
		<listener public="1"><c path="hxd.snd.Listener"/></listener>
		<timeOffset public="1" expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</timeOffset>
		<updateEvent><c path="haxe.MainEvent"/></updateEvent>
		<cachedBytes><c path="haxe.io.Bytes"/></cachedBytes>
		<resampleBytes><c path="haxe.io.Bytes"/></resampleBytes>
		<driver><c path="hxd.snd.Driver"/></driver>
		<channels><c path="hxd.snd.Channel"/></channels>
		<sources><c path="Array"><c path="hxd.snd.Source"/></c></sources>
		<now><x path="Float"/></now>
		<soundBufferCount><x path="Int"/></soundBufferCount>
		<soundBufferMap><t path="Map">
	<c path="String"/>
	<c path="hxd.snd.Buffer"/>
</t></soundBufferMap>
		<soundBufferKeys><c path="Array"><c path="String"/></c></soundBufferKeys>
		<freeStreamBuffers><c path="Array"><c path="hxd.snd.Buffer"/></c></freeStreamBuffers>
		<effectGC><c path="Array"><c path="hxd.snd.Effect"/></c></effectGC>
		<hasMasterVolume><x path="Bool"/></hasMasterVolume>
		<suspended public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</suspended>
		<getTmpBytes set="method" line="135"><f a="size">
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></getTmpBytes>
		<getResampleBytes set="method" line="141"><f a="size">
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></getResampleBytes>
		<stopAll public="1" set="method" line="156"><f a=""><x path="Void"/></f></stopAll>
		<stopAllNotLooping public="1" set="method" line="161"><f a=""><x path="Void"/></f></stopAllNotLooping>
		<stopByName public="1" set="method" line="170"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></stopByName>
		<getAll public="1" set="method" line="182">
			<f a="sound">
				<c path="hxd.res.Sound"/>
				<t path="Iterator"><c path="hxd.snd.Channel"/></t>
			</f>
			<haxe_doc>Returns iterator with all active instances of a Sound at the call time.</haxe_doc>
		</getAll>
		<cleanCache public="1" set="method" line="193"><f a=""><x path="Void"/></f></cleanCache>
		<dispose public="1" set="method" line="208"><f a=""><x path="Void"/></f></dispose>
		<play public="1" set="method" line="229"><f a="sound:?channelGroup:?soundGroup">
	<c path="hxd.res.Sound"/>
	<c path="hxd.snd.ChannelGroup"/>
	<c path="hxd.snd.SoundGroup"/>
	<c path="hxd.snd.Channel"/>
</f></play>
		<updateVirtualChannels set="method" line="250"><f a="now">
	<x path="Float"/>
	<x path="Void"/>
</f></updateVirtualChannels>
		<update public="1" set="method" line="283"><f a=""><x path="Void"/></f></update>
		<progressiveDecodeBuffer set="method" line="571"><f a="s:snd:start">
	<c path="hxd.snd.Source"/>
	<c path="hxd.res.Sound"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></progressiveDecodeBuffer>
		<queueBuffer set="method" line="595"><f a="s:snd:start">
	<c path="hxd.snd.Source"/>
	<c path="hxd.res.Sound"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></queueBuffer>
		<unqueueBuffer set="method" line="618"><f a="s">
	<c path="hxd.snd.Source"/>
	<x path="Null"><c path="hxd.snd.Buffer"/></x>
</f></unqueueBuffer>
		<bindEffect set="method" line="637"><f a="c:s:e">
	<c path="hxd.snd.Channel"/>
	<c path="hxd.snd.Source"/>
	<c path="hxd.snd.Effect"/>
	<x path="Void"/>
</f></bindEffect>
		<unbindEffect set="method" line="644"><f a="c:s:e">
	<c path="hxd.snd.Channel"/>
	<c path="hxd.snd.Source"/>
	<c path="hxd.snd.Effect"/>
	<x path="Void"/>
</f></unbindEffect>
		<releaseSource set="method" line="653"><f a="s">
	<c path="hxd.snd.Source"/>
	<x path="Void"/>
</f></releaseSource>
		<targetRate><x path="Int"/></targetRate>
		<targetFormat><e path="hxd.snd.SampleFormat"/></targetFormat>
		<targetChannels><x path="Int"/></targetChannels>
		<checkTargetFormat set="method" line="674">
			<f a="dat:?forceMono" v=":false">
				<c path="hxd.snd.Data"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ forceMono : false }</e></m></meta>
		</checkTargetFormat>
		<getSoundBuffer set="method" line="694"><f a="snd:grp">
	<c path="hxd.res.Sound"/>
	<c path="hxd.snd.SoundGroup"/>
	<c path="hxd.snd.Buffer"/>
</f></getSoundBuffer>
		<fillSoundBuffer set="method" line="716">
			<f a="buf:dat:?forceMono" v="::false">
				<c path="hxd.snd.Buffer"/>
				<c path="hxd.snd.Data"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ forceMono : false }</e></m></meta>
		</fillSoundBuffer>
		<getStreamBuffer set="method" line="728"><f a="src:snd:grp:start">
	<c path="hxd.snd.Source"/>
	<c path="hxd.res.Sound"/>
	<c path="hxd.snd.SoundGroup"/>
	<x path="Int"/>
	<c path="hxd.snd.Buffer"/>
</f></getStreamBuffer>
		<sortChannel set="method" line="772"><f a="a:b">
	<c path="hxd.snd.Channel"/>
	<c path="hxd.snd.Channel"/>
	<x path="Int"/>
</f></sortChannel>
		<sortEffect set="method" line="788"><f a="a:b">
	<c path="hxd.snd.Effect"/>
	<c path="hxd.snd.Effect"/>
	<x path="Int"/>
</f></sortEffect>
		<releaseChannel set="method" line="792"><f a="c">
	<c path="hxd.snd.Channel"/>
	<x path="Void"/>
</f></releaseChannel>
		<new set="method" line="101"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.snd.Mp3Data" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/snd/Mp3Data.hx">
		<extends path="hxd.snd.Data"/>
		<decodeBuffer set="method" line="143" override="1"><f a="out:outPos:sampleStart:sampleCount">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></decodeBuffer>
		<new public="1" set="method" line="28"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.snd.NativeChannel" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/snd/NativeChannel.hx">
		<bufferSamples public="1" set="null"><x path="Int"/></bufferSamples>
		<onSample set="method" line="214"><f a="out">
	<x path="haxe.io.Float32Array"/>
	<x path="Void"/>
</f></onSample>
		<stop public="1" set="method" line="217"><f a=""><x path="Void"/></f></stop>
		<new public="1" set="method" line="127"><f a="bufferSamples">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="hxd.snd.SoundGroup" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/snd/SoundGroup.hx">
		<name public="1" set="null"><c path="String"/></name>
		<volume public="1"><x path="Float"/></volume>
		<maxAudible public="1"><x path="Int"/></maxAudible>
		<mono public="1"><x path="Bool"/></mono>
		<numAudible><x path="Int"/></numAudible>
		<lastUpdate><x path="Float"/></lastUpdate>
		<new public="1" set="method" line="13"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>hxd.snd.Manager</e></m>
		</meta>
	</class>
	<class path="hxd.snd.WavData" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/snd/WavData.hx">
		<extends path="hxd.snd.Data"/>
		<rawData><c path="haxe.io.Bytes"/></rawData>
		<init set="method" line="13"><f a="d">
	<t path="format.wav.WAVE"/>
	<x path="Void"/>
</f></init>
		<decodeBuffer set="method" line="27" override="1"><f a="out:outPos:sampleStart:sampleCount">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></decodeBuffer>
		<new public="1" set="method" line="8"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="hxd.snd.openal.AL" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/snd/openal/AudioTypes.hx" module="hxd.snd.openal.AudioTypes"><c path="hxd.snd.openal.Emulator"/></typedef>
	<class path="hxd.snd.openal.BufferHandle" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/snd/openal/AudioTypes.hx" module="hxd.snd.openal.AudioTypes">
		<inst public="1"><c path="hxd.snd.openal.Buffer"/></inst>
		<isEnd public="1"><x path="Bool"/></isEnd>
		<new public="1" set="method" line="16"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.snd.openal.SourceHandle" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/snd/openal/AudioTypes.hx" module="hxd.snd.openal.AudioTypes">
		<inst public="1"><c path="hxd.snd.openal.Source"/></inst>
		<sampleOffset public="1"><x path="Int"/></sampleOffset>
		<playing public="1"><x path="Bool"/></playing>
		<nextAuxiliarySend><x path="Int"/></nextAuxiliarySend>
		<freeAuxiliarySends><c path="Array"><x path="Int"/></c></freeAuxiliarySends>
		<effectToAuxiliarySend><t path="Map">
	<c path="hxd.snd.Effect"/>
	<x path="Int"/>
</t></effectToAuxiliarySend>
		<acquireAuxiliarySend public="1" set="method" line="34"><f a="effect">
	<c path="hxd.snd.Effect"/>
	<x path="Int"/>
</f></acquireAuxiliarySend>
		<getAuxiliarySend public="1" set="method" line="42"><f a="effect">
	<c path="hxd.snd.Effect"/>
	<x path="Int"/>
</f></getAuxiliarySend>
		<releaseAuxiliarySend public="1" set="method" line="46"><f a="effect">
	<c path="hxd.snd.Effect"/>
	<x path="Int"/>
</f></releaseAuxiliarySend>
		<new public="1" set="method" line="27"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.snd.openal.Driver" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/snd/openal/Driver.hx">
		<implements path="hxd.snd.Driver"/>
		<device public="1" set="null"><c path="hxd.snd.openal.Device"/></device>
		<context public="1" set="null"><c path="hxd.snd.openal.Context"/></context>
		<maxAuxiliarySends public="1" set="null"><x path="Int"/></maxAuxiliarySends>
		<tmpBytes><c path="haxe.io.Bytes"/></tmpBytes>
		<hasFeature public="1" set="method" line="39"><f a="f">
	<e path="hxd.snd.DriverFeature"/>
	<x path="Bool"/>
</f></hasFeature>
		<getTmpBytes public="1" set="method" line="45"><f a="size">
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></getTmpBytes>
		<setMasterVolume public="1" set="method" line="50"><f a="value">
	<x path="Float"/>
	<x path="Void"/>
</f></setMasterVolume>
		<setListenerParams public="1" set="method" line="54"><f a="position:direction:up:?velocity">
	<c path="h3d.Vector"/>
	<c path="h3d.Vector"/>
	<c path="h3d.Vector"/>
	<c path="h3d.Vector"/>
	<x path="Void"/>
</f></setListenerParams>
		<createSource public="1" set="method" line="73"><f a=""><c path="hxd.snd.openal.SourceHandle"/></f></createSource>
		<destroySource public="1" set="method" line="85"><f a="source">
	<c path="hxd.snd.openal.SourceHandle"/>
	<x path="Void"/>
</f></destroySource>
		<playSource public="1" set="method" line="93"><f a="source">
	<c path="hxd.snd.openal.SourceHandle"/>
	<x path="Void"/>
</f></playSource>
		<stopSource public="1" set="method" line="99"><f a="source">
	<c path="hxd.snd.openal.SourceHandle"/>
	<x path="Void"/>
</f></stopSource>
		<setSourceVolume public="1" set="method" line="104"><f a="source:value">
	<c path="hxd.snd.openal.SourceHandle"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setSourceVolume>
		<createBuffer public="1" set="method" line="108"><f a=""><c path="hxd.snd.openal.BufferHandle"/></f></createBuffer>
		<destroyBuffer public="1" set="method" line="116"><f a="buffer">
	<c path="hxd.snd.openal.BufferHandle"/>
	<x path="Void"/>
</f></destroyBuffer>
		<setBufferData public="1" set="method" line="122"><f a="buffer:data:size:format:channelCount:samplingRate">
	<c path="hxd.snd.openal.BufferHandle"/>
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<e path="hxd.snd.SampleFormat"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setBufferData>
		<getPlayedSampleCount public="1" set="method" line="135"><f a="source">
	<c path="hxd.snd.openal.SourceHandle"/>
	<x path="Int"/>
</f></getPlayedSampleCount>
		<getProcessedBuffers public="1" set="method" line="142"><f a="source">
	<c path="hxd.snd.openal.SourceHandle"/>
	<x path="Int"/>
</f></getProcessedBuffers>
		<queueBuffer public="1" set="method" line="146"><f a="source:buffer:sampleStart:endOfStream">
	<c path="hxd.snd.openal.SourceHandle"/>
	<c path="hxd.snd.openal.BufferHandle"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></queueBuffer>
		<unqueueBuffer public="1" set="method" line="167"><f a="source:buffer">
	<c path="hxd.snd.openal.SourceHandle"/>
	<c path="hxd.snd.openal.BufferHandle"/>
	<x path="Void"/>
</f></unqueueBuffer>
		<update public="1" set="method" line="180"><f a=""><x path="Void"/></f></update>
		<dispose public="1" set="method" line="183"><f a=""><x path="Void"/></f></dispose>
		<getEffectDriver public="1" set="method" line="189"><f a="type">
	<c path="String"/>
	<c path="hxd.snd.EffectDriver"><d/></c>
</f></getEffectDriver>
		<new public="1" set="method" line="21"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="hxd.snd.openal._Emulator.F32" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/snd/openal/Emulator.hx" private="1" module="hxd.snd.openal.Emulator"><x path="Float"/></typedef>
	<typedef path="hxd.snd.openal._Emulator.Bytes" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/snd/openal/Emulator.hx" private="1" module="hxd.snd.openal.Emulator"><c path="haxe.io.Bytes"/></typedef>
	<class path="hxd.snd.openal._Emulator.Channel" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/snd/openal/Emulator.hx" private="1" module="hxd.snd.openal.Emulator">
		<extends path="hxd.snd.NativeChannel"/>
		<FADE_START get="inline" set="null" expr="10" line="10" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>10</e></m></meta>
		</FADE_START>
		<source><c path="hxd.snd.openal.Source"/></source>
		<startup expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</startup>
		<onSample set="method" line="21" override="1">
			<f a="out">
				<x path="haxe.io.Float32Array"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noDebug"/></meta>
		</onSample>
		<new public="1" set="method" line="12"><f a="source:samples">
	<c path="hxd.snd.openal.Source"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.snd.openal.Source" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/snd/openal/Emulator.hx" module="hxd.snd.openal.Emulator">
		<STOP_DELAY get="inline" set="null" expr="0" line="82" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</STOP_DELAY>
		<CHANNEL_BUFSIZE public="1" expr="4096" line="84" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4096</e></m></meta>
		</CHANNEL_BUFSIZE>
		<ID expr="0" line="86" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</ID>
		<all expr="new Map&lt;Int,Source&gt;()" line="87" static="1">
			<x path="haxe.ds.Map">
				<x path="Int"/>
				<c path="hxd.snd.openal.Source"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new Map<Int,Source>()]]></e></m></meta>
		</all>
		<ofInt public="1" get="inline" set="null" line="139" static="1"><f a="i">
	<x path="Int"/>
	<x path="Null"><c path="hxd.snd.openal.Source"/></x>
</f></ofInt>
		<id public="1"><x path="Int"/></id>
		<chan public="1"><c path="hxd.snd.NativeChannel"/></chan>
		<playedTime public="1" expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</playedTime>
		<currentSample public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</currentSample>
		<buffers public="1" expr="[]">
			<c path="Array"><c path="hxd.snd.openal.Buffer"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</buffers>
		<loop public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</loop>
		<volume public="1" expr="1.">
			<t path="hxd.snd.openal._Emulator.F32"/>
			<meta><m n=":value"><e>1.</e></m></meta>
		</volume>
		<playing public="1" get="accessor" set="null"><x path="Bool"/></playing>
		<duration public="1"><x path="Float"/></duration>
		<frequency public="1"><x path="Int"/></frequency>
		<updateDuration public="1" set="method" line="106"><f a=""><x path="Void"/></f></updateDuration>
		<get_playing get="inline" set="null" line="113"><f a=""><x path="Bool"/></f></get_playing>
		<play public="1" set="method" line="115"><f a=""><x path="Void"/></f></play>
		<stop public="1" set="method" line="122">
			<f a="?immediate" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ immediate : false }</e></m></meta>
		</stop>
		<dispose public="1" set="method" line="132"><f a=""><x path="Void"/></f></dispose>
		<toInt public="1" get="inline" set="null" line="138"><f a=""><x path="Int"/></f></toInt>
		<new public="1" set="method" line="101"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.snd.openal.Buffer" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/snd/openal/Emulator.hx" module="hxd.snd.openal.Emulator">
		<ID expr="0" line="144" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</ID>
		<all expr="new Map&lt;Int,Buffer&gt;()" line="145" static="1">
			<x path="haxe.ds.Map">
				<x path="Int"/>
				<c path="hxd.snd.openal.Buffer"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new Map<Int,Buffer>()]]></e></m></meta>
		</all>
		<ofInt public="1" get="inline" set="null" line="170" static="1"><f a="i">
	<x path="Int"/>
	<x path="Null"><c path="hxd.snd.openal.Buffer"/></x>
</f></ofInt>
		<id public="1"><x path="Int"/></id>
		<data public="1"><x path="haxe.ds.Vector"><t path="hxd.snd.openal._Emulator.F32"/></x></data>
		<frequency public="1" expr="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</frequency>
		<samples public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</samples>
		<dispose public="1" set="method" line="157"><f a=""><x path="Void"/></f></dispose>
		<alloc public="1" set="method" line="163"><f a="size">
	<x path="Int"/>
	<x path="haxe.ds.Vector"><t path="hxd.snd.openal._Emulator.F32"/></x>
</f></alloc>
		<toInt public="1" get="inline" set="null" line="169"><f a=""><x path="Int"/></f></toInt>
		<new public="1" set="method" line="152"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.snd.openal.Emulator" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/snd/openal/Emulator.hx">
		<NATIVE_FREQ public="1" get="accessor" set="null" static="1"><x path="Int"/></NATIVE_FREQ>
		<CACHED_FREQ static="1"><x path="Null"><x path="Int"/></x></CACHED_FREQ>
		<get_NATIVE_FREQ set="method" line="182" static="1"><f a=""><x path="Null"><x path="Int"/></x></f></get_NATIVE_FREQ>
		<dopplerFactor public="1" set="method" line="190" static="1"><f a="value">
	<t path="hxd.snd.openal._Emulator.F32"/>
	<x path="Void"/>
</f></dopplerFactor>
		<dopplerVelocity public="1" set="method" line="191" static="1"><f a="value">
	<t path="hxd.snd.openal._Emulator.F32"/>
	<x path="Void"/>
</f></dopplerVelocity>
		<speedOfSound public="1" set="method" line="192" static="1"><f a="value">
	<t path="hxd.snd.openal._Emulator.F32"/>
	<x path="Void"/>
</f></speedOfSound>
		<distanceModel public="1" set="method" line="193" static="1"><f a="distanceModel">
	<x path="Int"/>
	<x path="Void"/>
</f></distanceModel>
		<enable public="1" set="method" line="196" static="1"><f a="capability">
	<x path="Int"/>
	<x path="Void"/>
</f></enable>
		<disable public="1" set="method" line="197" static="1"><f a="capability">
	<x path="Int"/>
	<x path="Void"/>
</f></disable>
		<isEnabled public="1" set="method" line="198" static="1"><f a="capability">
	<x path="Int"/>
	<x path="Bool"/>
</f></isEnabled>
		<getBooleanv public="1" set="method" line="201" static="1"><f a="param:values">
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Void"/>
</f></getBooleanv>
		<getIntegerv public="1" set="method" line="204" static="1"><f a="param:values">
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Void"/>
</f></getIntegerv>
		<getFloatv public="1" set="method" line="207" static="1"><f a="param:values">
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Void"/>
</f></getFloatv>
		<getDoublev public="1" set="method" line="210" static="1"><f a="param:values">
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Void"/>
</f></getDoublev>
		<getString public="1" set="method" line="214" static="1"><f a="param">
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
</f></getString>
		<getBoolean public="1" set="method" line="218" static="1"><f a="param">
	<x path="Int"/>
	<x path="Bool"/>
</f></getBoolean>
		<getInteger public="1" set="method" line="222" static="1"><f a="param">
	<x path="Int"/>
	<x path="Int"/>
</f></getInteger>
		<getFloat public="1" set="method" line="226" static="1"><f a="param">
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.F32"/>
</f></getFloat>
		<getDouble public="1" set="method" line="230" static="1"><f a="param">
	<x path="Int"/>
	<x path="Float"/>
</f></getDouble>
		<getError public="1" set="method" line="235" static="1"><f a=""><x path="Int"/></f></getError>
		<loadExtensions public="1" set="method" line="240" static="1"><f a=""><x path="Void"/></f></loadExtensions>
		<isExtensionPresent public="1" set="method" line="242" static="1"><f a="extname">
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Bool"/>
</f></isExtensionPresent>
		<getEnumValue public="1" set="method" line="246" static="1"><f a="ename">
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Int"/>
</f></getEnumValue>
		<listenerf public="1" set="method" line="252" static="1"><f a="param:value">
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.F32"/>
	<x path="Void"/>
</f></listenerf>
		<listener3f public="1" set="method" line="261" static="1"><f a="param:value1:value2:value3">
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.F32"/>
	<t path="hxd.snd.openal._Emulator.F32"/>
	<t path="hxd.snd.openal._Emulator.F32"/>
	<x path="Void"/>
</f></listener3f>
		<listenerfv public="1" set="method" line="262" static="1"><f a="param:values">
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Void"/>
</f></listenerfv>
		<listeneri public="1" set="method" line="263" static="1"><f a="param:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></listeneri>
		<listener3i public="1" set="method" line="264" static="1"><f a="param:value1:value2:value3">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></listener3i>
		<listeneriv public="1" set="method" line="265" static="1"><f a="param:values">
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Void"/>
</f></listeneriv>
		<getListenerf public="1" set="method" line="268" static="1"><f a="param">
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.F32"/>
</f></getListenerf>
		<getListener3f public="1" set="method" line="271" static="1"><f a="param:values">
	<x path="Int"/>
	<c path="Array"><t path="hxd.snd.openal._Emulator.F32"/></c>
	<x path="Void"/>
</f></getListener3f>
		<getListenerfv public="1" set="method" line="275" static="1"><f a="param:values">
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Void"/>
</f></getListenerfv>
		<getListeneri public="1" set="method" line="278" static="1"><f a="param">
	<x path="Int"/>
	<x path="Int"/>
</f></getListeneri>
		<getListener3i public="1" set="method" line="281" static="1"><f a="param:values">
	<x path="Int"/>
	<c path="Array"><x path="Int"/></c>
	<x path="Void"/>
</f></getListener3i>
		<getListeneriv public="1" set="method" line="284" static="1"><f a="param:values">
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Void"/>
</f></getListeneriv>
		<genSources public="1" set="method" line="289" static="1"><f a="n:sources">
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Void"/>
</f></genSources>
		<deleteSources public="1" set="method" line="294" static="1"><f a="n:sources">
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Void"/>
</f></deleteSources>
		<isSource public="1" set="method" line="299" static="1"><f a="source">
	<c path="hxd.snd.openal.Source"/>
	<x path="Bool"/>
</f></isSource>
		<sourcef public="1" set="method" line="304" static="1"><f a="source:param:value">
	<c path="hxd.snd.openal.Source"/>
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.F32"/>
	<x path="Void"/>
</f></sourcef>
		<source3f public="1" set="method" line="325" static="1"><f a="source:param:value1:value2:value3">
	<c path="hxd.snd.openal.Source"/>
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.F32"/>
	<t path="hxd.snd.openal._Emulator.F32"/>
	<t path="hxd.snd.openal._Emulator.F32"/>
	<x path="Void"/>
</f></source3f>
		<sourcefv public="1" set="method" line="333" static="1"><f a="source:param:values">
	<c path="hxd.snd.openal.Source"/>
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Void"/>
</f></sourcefv>
		<sourcei public="1" set="method" line="339" static="1"><f a="source:param:value">
	<c path="hxd.snd.openal.Source"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></sourcei>
		<source3i public="1" set="method" line="362" static="1"><f a="source:param:value1:value2:value3">
	<c path="hxd.snd.openal.Source"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></source3i>
		<sourceiv public="1" set="method" line="368" static="1"><f a="source:param:values">
	<c path="hxd.snd.openal.Source"/>
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Void"/>
</f></sourceiv>
		<getSourcef public="1" set="method" line="376" static="1"><f a="source:param">
	<c path="hxd.snd.openal.Source"/>
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.F32"/>
</f></getSourcef>
		<getSourcei public="1" set="method" line="396" static="1"><f a="source:param">
	<c path="hxd.snd.openal.Source"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getSourcei>
		<getSource3f public="1" set="method" line="418" static="1"><f a="source:param:values">
	<c path="hxd.snd.openal.Source"/>
	<x path="Int"/>
	<c path="Array"><t path="hxd.snd.openal._Emulator.F32"/></c>
	<x path="Void"/>
</f></getSource3f>
		<getSourcefv public="1" set="method" line="421" static="1"><f a="source:param:values">
	<c path="hxd.snd.openal.Source"/>
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Void"/>
</f></getSourcefv>
		<getSource3i public="1" set="method" line="424" static="1"><f a="source:param:values">
	<c path="hxd.snd.openal.Source"/>
	<x path="Int"/>
	<c path="Array"><x path="Int"/></c>
	<x path="Void"/>
</f></getSource3i>
		<getSourceiv public="1" set="method" line="427" static="1"><f a="source:param:values">
	<c path="hxd.snd.openal.Source"/>
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Void"/>
</f></getSourceiv>
		<sourcePlayv public="1" set="method" line="432" static="1"><f a="n:sources">
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Void"/>
</f></sourcePlayv>
		<sourceStopv public="1" set="method" line="435" static="1"><f a="n:sources">
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Void"/>
</f></sourceStopv>
		<sourceRewindv public="1" set="method" line="438" static="1"><f a="n:sources">
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Void"/>
</f></sourceRewindv>
		<sourcePausev public="1" set="method" line="441" static="1"><f a="n:sources">
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Void"/>
</f></sourcePausev>
		<sourcePlay public="1" set="method" line="445" static="1"><f a="source">
	<c path="hxd.snd.openal.Source"/>
	<x path="Void"/>
</f></sourcePlay>
		<sourceStop public="1" set="method" line="449" static="1"><f a="source">
	<c path="hxd.snd.openal.Source"/>
	<x path="Void"/>
</f></sourceStop>
		<sourceRewind public="1" set="method" line="454" static="1"><f a="source">
	<c path="hxd.snd.openal.Source"/>
	<x path="Void"/>
</f></sourceRewind>
		<sourcePause public="1" set="method" line="457" static="1"><f a="source">
	<c path="hxd.snd.openal.Source"/>
	<x path="Void"/>
</f></sourcePause>
		<sourceQueueBuffers public="1" set="method" line="462" static="1"><f a="source:nb:buffers">
	<c path="hxd.snd.openal.Source"/>
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Void"/>
</f></sourceQueueBuffers>
		<sourceUnqueueBuffers public="1" set="method" line="471" static="1"><f a="source:nb:buffers">
	<c path="hxd.snd.openal.Source"/>
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Void"/>
</f></sourceUnqueueBuffers>
		<genBuffers public="1" set="method" line="487" static="1"><f a="n:buffers">
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Void"/>
</f></genBuffers>
		<deleteBuffers public="1" set="method" line="491" static="1"><f a="n:buffers">
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Void"/>
</f></deleteBuffers>
		<isBuffer public="1" set="method" line="495" static="1"><f a="buffer">
	<c path="hxd.snd.openal.Buffer"/>
	<x path="Bool"/>
</f></isBuffer>
		<bufferData public="1" set="method" line="500" static="1">
			<f a="buffer:format:data:size:freq">
				<c path="hxd.snd.openal.Buffer"/>
				<x path="Int"/>
				<t path="hxd.snd.openal._Emulator.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noDebug"/></meta>
		</bufferData>
		<bufferf public="1" set="method" line="555" static="1"><f a="buffer:param:value">
	<c path="hxd.snd.openal.Buffer"/>
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.F32"/>
	<x path="Void"/>
</f></bufferf>
		<buffer3f public="1" set="method" line="561" static="1"><f a="buffer:param:value1:value2:value3">
	<c path="hxd.snd.openal.Buffer"/>
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.F32"/>
	<t path="hxd.snd.openal._Emulator.F32"/>
	<t path="hxd.snd.openal._Emulator.F32"/>
	<x path="Void"/>
</f></buffer3f>
		<bufferfv public="1" set="method" line="567" static="1"><f a="buffer:param:values">
	<c path="hxd.snd.openal.Buffer"/>
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Void"/>
</f></bufferfv>
		<bufferi public="1" set="method" line="573" static="1"><f a="buffer:param:value">
	<c path="hxd.snd.openal.Buffer"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></bufferi>
		<buffer3i public="1" set="method" line="579" static="1"><f a="buffer:param:value1:value2:value3">
	<c path="hxd.snd.openal.Buffer"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></buffer3i>
		<bufferiv public="1" set="method" line="585" static="1"><f a="buffer:param:values">
	<c path="hxd.snd.openal.Buffer"/>
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Void"/>
</f></bufferiv>
		<getBufferf public="1" set="method" line="593" static="1"><f a="buffer:param">
	<c path="hxd.snd.openal.Buffer"/>
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.F32"/>
</f></getBufferf>
		<getBuffer3f public="1" set="method" line="596" static="1"><f a="buffer:param:values">
	<c path="hxd.snd.openal.Buffer"/>
	<x path="Int"/>
	<c path="Array"><t path="hxd.snd.openal._Emulator.F32"/></c>
	<x path="Void"/>
</f></getBuffer3f>
		<getBufferfv public="1" set="method" line="599" static="1"><f a="buffer:param:values">
	<c path="hxd.snd.openal.Buffer"/>
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Void"/>
</f></getBufferfv>
		<getBufferi public="1" set="method" line="602" static="1"><f a="buffer:param">
	<c path="hxd.snd.openal.Buffer"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getBufferi>
		<getBuffer3i public="1" set="method" line="611" static="1"><f a="buffer:param:values">
	<c path="hxd.snd.openal.Buffer"/>
	<x path="Int"/>
	<c path="Array"><x path="Int"/></c>
	<x path="Void"/>
</f></getBuffer3i>
		<getBufferiv public="1" set="method" line="614" static="1"><f a="buffer:param:values">
	<c path="hxd.snd.openal.Buffer"/>
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Void"/>
</f></getBufferiv>
		<FORMAT_MONOF32 public="1" get="inline" set="null" expr="0x1110" line="621" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1110</e></m></meta>
		</FORMAT_MONOF32>
		<FORMAT_STEREOF32 public="1" get="inline" set="null" expr="0x1111" line="622" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1111</e></m></meta>
		</FORMAT_STEREOF32>
		<NONE public="1" get="inline" set="null" expr="0" line="628" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</NONE>
		<FALSE public="1" get="inline" set="null" expr="0" line="629" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</FALSE>
		<TRUE public="1" get="inline" set="null" expr="1" line="630" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</TRUE>
		<SOURCE_RELATIVE public="1" get="inline" set="null" expr="0x202" line="632" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x202</e></m></meta>
		</SOURCE_RELATIVE>
		<CONE_INNER_ANGLE public="1" get="inline" set="null" expr="0x1001" line="633" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1001</e></m></meta>
		</CONE_INNER_ANGLE>
		<CONE_OUTER_ANGLE public="1" get="inline" set="null" expr="0x1002" line="634" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1002</e></m></meta>
		</CONE_OUTER_ANGLE>
		<PITCH public="1" get="inline" set="null" expr="0x1003" line="635" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1003</e></m></meta>
		</PITCH>
		<POSITION public="1" get="inline" set="null" expr="0x1004" line="637" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1004</e></m></meta>
		</POSITION>
		<DIRECTION public="1" get="inline" set="null" expr="0x1005" line="638" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1005</e></m></meta>
		</DIRECTION>
		<VELOCITY public="1" get="inline" set="null" expr="0x1006" line="640" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1006</e></m></meta>
		</VELOCITY>
		<LOOPING public="1" get="inline" set="null" expr="0x1007" line="641" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1007</e></m></meta>
		</LOOPING>
		<BUFFER public="1" get="inline" set="null" expr="0x1009" line="642" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1009</e></m></meta>
		</BUFFER>
		<GAIN public="1" get="inline" set="null" expr="0x100A" line="644" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x100A</e></m></meta>
		</GAIN>
		<MIN_GAIN public="1" get="inline" set="null" expr="0x100D" line="645" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x100D</e></m></meta>
		</MIN_GAIN>
		<MAX_GAIN public="1" get="inline" set="null" expr="0x100E" line="646" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x100E</e></m></meta>
		</MAX_GAIN>
		<ORIENTATION public="1" get="inline" set="null" expr="0x100F" line="647" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x100F</e></m></meta>
		</ORIENTATION>
		<SOURCE_STATE public="1" get="inline" set="null" expr="0x1010" line="648" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1010</e></m></meta>
		</SOURCE_STATE>
		<INITIAL public="1" get="inline" set="null" expr="0x1011" line="651" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1011</e></m></meta>
		</INITIAL>
		<PLAYING public="1" get="inline" set="null" expr="0x1012" line="652" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1012</e></m></meta>
		</PLAYING>
		<PAUSED public="1" get="inline" set="null" expr="0x1013" line="653" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1013</e></m></meta>
		</PAUSED>
		<STOPPED public="1" get="inline" set="null" expr="0x1014" line="654" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1014</e></m></meta>
		</STOPPED>
		<BUFFERS_QUEUED public="1" get="inline" set="null" expr="0x1015" line="656" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1015</e></m></meta>
		</BUFFERS_QUEUED>
		<BUFFERS_PROCESSED public="1" get="inline" set="null" expr="0x1016" line="657" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1016</e></m></meta>
		</BUFFERS_PROCESSED>
		<REFERENCE_DISTANCE public="1" get="inline" set="null" expr="0x1020" line="659" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1020</e></m></meta>
		</REFERENCE_DISTANCE>
		<ROLLOFF_FACTOR public="1" get="inline" set="null" expr="0x1021" line="660" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1021</e></m></meta>
		</ROLLOFF_FACTOR>
		<CONE_OUTER_GAIN public="1" get="inline" set="null" expr="0x1022" line="661" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1022</e></m></meta>
		</CONE_OUTER_GAIN>
		<MAX_DISTANCE public="1" get="inline" set="null" expr="0x1023" line="662" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1023</e></m></meta>
		</MAX_DISTANCE>
		<SEC_OFFSET public="1" get="inline" set="null" expr="0x1024" line="664" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1024</e></m></meta>
		</SEC_OFFSET>
		<SAMPLE_OFFSET public="1" get="inline" set="null" expr="0x1025" line="665" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1025</e></m></meta>
		</SAMPLE_OFFSET>
		<BYTE_OFFSET public="1" get="inline" set="null" expr="0x1026" line="666" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1026</e></m></meta>
		</BYTE_OFFSET>
		<SOURCE_TYPE public="1" get="inline" set="null" expr="0x1027" line="667" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1027</e></m></meta>
		</SOURCE_TYPE>
		<STATIC public="1" get="inline" set="null" expr="0x1028" line="670" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1028</e></m></meta>
		</STATIC>
		<STREAMING public="1" get="inline" set="null" expr="0x1029" line="671" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1029</e></m></meta>
		</STREAMING>
		<UNDETERMINED public="1" get="inline" set="null" expr="0x1030" line="672" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1030</e></m></meta>
		</UNDETERMINED>
		<FORMAT_MONO8 public="1" get="inline" set="null" expr="0x1100" line="675" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1100</e></m></meta>
		</FORMAT_MONO8>
		<FORMAT_MONO16 public="1" get="inline" set="null" expr="0x1101" line="676" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1101</e></m></meta>
		</FORMAT_MONO16>
		<FORMAT_STEREO8 public="1" get="inline" set="null" expr="0x1102" line="677" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1102</e></m></meta>
		</FORMAT_STEREO8>
		<FORMAT_STEREO16 public="1" get="inline" set="null" expr="0x1103" line="678" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1103</e></m></meta>
		</FORMAT_STEREO16>
		<FREQUENCY public="1" get="inline" set="null" expr="0x2001" line="681" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x2001</e></m></meta>
		</FREQUENCY>
		<BITS public="1" get="inline" set="null" expr="0x2002" line="682" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x2002</e></m></meta>
		</BITS>
		<CHANNELS public="1" get="inline" set="null" expr="0x2003" line="683" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x2003</e></m></meta>
		</CHANNELS>
		<SIZE public="1" get="inline" set="null" expr="0x2004" line="684" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x2004</e></m></meta>
		</SIZE>
		<UNUSED public="1" get="inline" set="null" expr="0x2010" line="687" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x2010</e></m></meta>
		</UNUSED>
		<PENDING public="1" get="inline" set="null" expr="0x2011" line="688" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x2011</e></m></meta>
		</PENDING>
		<PROCESSED public="1" get="inline" set="null" expr="0x2012" line="689" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x2012</e></m></meta>
		</PROCESSED>
		<NO_ERROR public="1" get="inline" set="null" expr="0" line="692" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</NO_ERROR>
		<INVALID_NAME public="1" get="inline" set="null" expr="0xA001" line="693" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xA001</e></m></meta>
		</INVALID_NAME>
		<INVALID_ENUM public="1" get="inline" set="null" expr="0xA002" line="694" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xA002</e></m></meta>
		</INVALID_ENUM>
		<INVALID_VALUE public="1" get="inline" set="null" expr="0xA003" line="695" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xA003</e></m></meta>
		</INVALID_VALUE>
		<INVALID_OPERATION public="1" get="inline" set="null" expr="0xA004" line="696" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xA004</e></m></meta>
		</INVALID_OPERATION>
		<OUT_OF_MEMORY public="1" get="inline" set="null" expr="0xA005" line="697" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xA005</e></m></meta>
		</OUT_OF_MEMORY>
		<VENDOR public="1" get="inline" set="null" expr="0xB001" line="700" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xB001</e></m></meta>
		</VENDOR>
		<VERSION public="1" get="inline" set="null" expr="0xB002" line="701" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xB002</e></m></meta>
		</VERSION>
		<RENDERER public="1" get="inline" set="null" expr="0xB003" line="702" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xB003</e></m></meta>
		</RENDERER>
		<EXTENSIONS public="1" get="inline" set="null" expr="0xB004" line="703" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xB004</e></m></meta>
		</EXTENSIONS>
		<DOPPLER_FACTOR public="1" get="inline" set="null" expr="0xC000" line="706" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xC000</e></m></meta>
		</DOPPLER_FACTOR>
		<DOPPLER_VELOCITY public="1" get="inline" set="null" expr="0xC001" line="707" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xC001</e></m></meta>
		</DOPPLER_VELOCITY>
		<SPEED_OF_SOUND public="1" get="inline" set="null" expr="0xC003" line="708" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xC003</e></m></meta>
		</SPEED_OF_SOUND>
		<DISTANCE_MODEL public="1" get="inline" set="null" expr="0xD000" line="709" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xD000</e></m></meta>
		</DISTANCE_MODEL>
		<INVERSE_DISTANCE public="1" get="inline" set="null" expr="0xD001" line="712" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xD001</e></m></meta>
		</INVERSE_DISTANCE>
		<INVERSE_DISTANCE_CLAMPED public="1" get="inline" set="null" expr="0xD002" line="713" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xD002</e></m></meta>
		</INVERSE_DISTANCE_CLAMPED>
		<LINEAR_DISTANCE public="1" get="inline" set="null" expr="0xD003" line="714" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xD003</e></m></meta>
		</LINEAR_DISTANCE>
		<LINEAR_DISTANCE_CLAMPED public="1" get="inline" set="null" expr="0xD004" line="715" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xD004</e></m></meta>
		</LINEAR_DISTANCE_CLAMPED>
		<EXPONENT_DISTANCE public="1" get="inline" set="null" expr="0xD005" line="716" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xD005</e></m></meta>
		</EXPONENT_DISTANCE>
		<EXPONENT_DISTANCE_CLAMPED public="1" get="inline" set="null" expr="0xD006" line="717" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xD006</e></m></meta>
		</EXPONENT_DISTANCE_CLAMPED>
		<haxe_doc>On platforms that don't have native support for OpenAL, the Driver uses this
	emulator that only requires a NativeChannel implementation</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.snd.openal.Device" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/snd/openal/Emulator.hx" module="hxd.snd.openal.Emulator">
		<new public="1" set="method" line="725"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.snd.openal.Context" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/snd/openal/Emulator.hx" module="hxd.snd.openal.Emulator">
		<device public="1"><c path="hxd.snd.openal.Device"/></device>
		<new public="1" set="method" line="731"><f a="d">
	<c path="hxd.snd.openal.Device"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.snd.openal.ALC" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/snd/openal/Emulator.hx" module="hxd.snd.openal.Emulator">
		<ctx expr="null" line="738" static="1">
			<c path="hxd.snd.openal.Context"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</ctx>
		<getError public="1" set="method" line="740" static="1"><f a="device">
	<c path="hxd.snd.openal.Device"/>
	<x path="Int"/>
</f></getError>
		<createContext public="1" set="method" line="745" static="1"><f a="device:attrlist">
	<c path="hxd.snd.openal.Device"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<c path="hxd.snd.openal.Context"/>
</f></createContext>
		<makeContextCurrent public="1" set="method" line="749" static="1"><f a="context">
	<c path="hxd.snd.openal.Context"/>
	<x path="Bool"/>
</f></makeContextCurrent>
		<processContext public="1" set="method" line="754" static="1"><f a="context">
	<c path="hxd.snd.openal.Context"/>
	<x path="Void"/>
</f></processContext>
		<suspendContext public="1" set="method" line="757" static="1"><f a="context">
	<c path="hxd.snd.openal.Context"/>
	<x path="Void"/>
</f></suspendContext>
		<destroyContext public="1" set="method" line="760" static="1"><f a="context">
	<c path="hxd.snd.openal.Context"/>
	<x path="Void"/>
</f></destroyContext>
		<getCurrentContext public="1" set="method" line="763" static="1"><f a=""><c path="hxd.snd.openal.Context"/></f></getCurrentContext>
		<getContextsDevice public="1" set="method" line="767" static="1"><f a="context">
	<c path="hxd.snd.openal.Context"/>
	<c path="hxd.snd.openal.Device"/>
</f></getContextsDevice>
		<openDevice public="1" set="method" line="772" static="1"><f a="devicename">
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<c path="hxd.snd.openal.Device"/>
</f></openDevice>
		<closeDevice public="1" set="method" line="776" static="1"><f a="device">
	<c path="hxd.snd.openal.Device"/>
	<x path="Bool"/>
</f></closeDevice>
		<loadExtensions public="1" set="method" line="781" static="1"><f a="alDevice">
	<c path="hxd.snd.openal.Device"/>
	<x path="Void"/>
</f></loadExtensions>
		<isExtensionPresent public="1" set="method" line="783" static="1"><f a="device:extname">
	<c path="hxd.snd.openal.Device"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Bool"/>
</f></isExtensionPresent>
		<getEnumValue public="1" set="method" line="786" static="1"><f a="device:enumname">
	<c path="hxd.snd.openal.Device"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Int"/>
</f></getEnumValue>
		<getString public="1" set="method" line="792" static="1"><f a="device:param">
	<c path="hxd.snd.openal.Device"/>
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
</f></getString>
		<getIntegerv public="1" set="method" line="795" static="1"><f a="device:param:size:values">
	<c path="hxd.snd.openal.Device"/>
	<x path="Int"/>
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Void"/>
</f></getIntegerv>
		<FALSE public="1" get="inline" set="null" expr="0" line="813" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</FALSE>
		<TRUE public="1" get="inline" set="null" expr="1" line="814" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</TRUE>
		<FREQUENCY public="1" get="inline" set="null" expr="0x1007" line="817" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1007</e></m></meta>
		</FREQUENCY>
		<REFRESH public="1" get="inline" set="null" expr="0x1008" line="818" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1008</e></m></meta>
		</REFRESH>
		<SYNC public="1" get="inline" set="null" expr="0x1009" line="819" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1009</e></m></meta>
		</SYNC>
		<MONO_SOURCES public="1" get="inline" set="null" expr="0x1010" line="820" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1010</e></m></meta>
		</MONO_SOURCES>
		<STEREO_SOURCES public="1" get="inline" set="null" expr="0x1011" line="821" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1011</e></m></meta>
		</STEREO_SOURCES>
		<NO_ERROR public="1" get="inline" set="null" expr="0" line="824" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</NO_ERROR>
		<INVALID_DEVICE public="1" get="inline" set="null" expr="0xA001" line="825" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xA001</e></m></meta>
		</INVALID_DEVICE>
		<INVALID_CONTEXT public="1" get="inline" set="null" expr="0xA002" line="826" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xA002</e></m></meta>
		</INVALID_CONTEXT>
		<INVALID_ENUM public="1" get="inline" set="null" expr="0xA003" line="827" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xA003</e></m></meta>
		</INVALID_ENUM>
		<INVALID_VALUE public="1" get="inline" set="null" expr="0xA004" line="828" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xA004</e></m></meta>
		</INVALID_VALUE>
		<OUT_OF_MEMORY public="1" get="inline" set="null" expr="0xA005" line="829" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xA005</e></m></meta>
		</OUT_OF_MEMORY>
		<MAJOR_VERSION public="1" get="inline" set="null" expr="0x1000" line="832" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1000</e></m></meta>
		</MAJOR_VERSION>
		<MINOR_VERSION public="1" get="inline" set="null" expr="0x1001" line="833" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1001</e></m></meta>
		</MINOR_VERSION>
		<ATTRIBUTES_SIZE public="1" get="inline" set="null" expr="0x1002" line="836" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1002</e></m></meta>
		</ATTRIBUTES_SIZE>
		<ALL_ATTRIBUTES public="1" get="inline" set="null" expr="0x1003" line="837" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1003</e></m></meta>
		</ALL_ATTRIBUTES>
		<DEFAULT_DEVICE_SPECIFIER public="1" get="inline" set="null" expr="0x1004" line="840" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1004</e></m></meta>
		</DEFAULT_DEVICE_SPECIFIER>
		<DEVICE_SPECIFIER public="1" get="inline" set="null" expr="0x1005" line="841" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1005</e></m></meta>
		</DEVICE_SPECIFIER>
		<EXTENSIONS public="1" get="inline" set="null" expr="0x1006" line="842" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1006</e></m></meta>
		</EXTENSIONS>
		<EXT_CAPTURE public="1" get="inline" set="null" expr="1" line="845" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</EXT_CAPTURE>
		<CAPTURE_DEVICE_SPECIFIER public="1" get="inline" set="null" expr="0x310" line="846" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x310</e></m></meta>
		</CAPTURE_DEVICE_SPECIFIER>
		<CAPTURE_DEFAULT_DEVICE_SPECIFIER public="1" get="inline" set="null" expr="0x311" line="847" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x311</e></m></meta>
		</CAPTURE_DEFAULT_DEVICE_SPECIFIER>
		<CAPTURE_SAMPLES public="1" get="inline" set="null" expr="0x312" line="848" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x312</e></m></meta>
		</CAPTURE_SAMPLES>
		<ENUMERATE_ALL_EXT public="1" get="inline" set="null" expr="1" line="851" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</ENUMERATE_ALL_EXT>
		<DEFAULT_ALL_DEVICES_SPECIFIER public="1" get="inline" set="null" expr="0x1012" line="852" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1012</e></m></meta>
		</DEFAULT_ALL_DEVICES_SPECIFIER>
		<ALL_DEVICES_SPECIFIER public="1" get="inline" set="null" expr="0x1013" line="853" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1013</e></m></meta>
		</ALL_DEVICES_SPECIFIER>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.snd.openal.EFX" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/snd/openal/Emulator.hx" module="hxd.snd.openal.Emulator">
		<EFX_MAJOR_VERSION public="1" get="inline" set="null" expr="0x20001" line="860" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x20001</e></m></meta>
		</EFX_MAJOR_VERSION>
		<EFX_MINOR_VERSION public="1" get="inline" set="null" expr="0x20002" line="861" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x20002</e></m></meta>
		</EFX_MINOR_VERSION>
		<MAX_AUXILIARY_SENDS public="1" get="inline" set="null" expr="0x20003" line="862" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x20003</e></m></meta>
		</MAX_AUXILIARY_SENDS>
		<METERS_PER_UNIT public="1" get="inline" set="null" expr="0x20004" line="865" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x20004</e></m></meta>
		</METERS_PER_UNIT>
		<DIRECT_FILTER public="1" get="inline" set="null" expr="0x20005" line="868" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x20005</e></m></meta>
		</DIRECT_FILTER>
		<FILTER_NULL public="1" get="inline" set="null" expr="0x0000" line="869" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0000</e></m></meta>
		</FILTER_NULL>
	</class>
	<enum path="hxsl.Type" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Ast.hx" module="hxsl.Ast">
		<TVoid/>
		<TInt/>
		<TBool/>
		<TFloat/>
		<TString/>
		<TVec a="size:t">
			<x path="Int"/>
			<e path="hxsl.VecType"/>
		</TVec>
		<TMat3/>
		<TMat4/>
		<TMat3x4/>
		<TBytes a="size"><x path="Int"/></TBytes>
		<TSampler2D/>
		<TSampler2DArray/>
		<TSamplerCube/>
		<TStruct a="vl"><c path="Array"><t path="hxsl.TVar"/></c></TStruct>
		<TFun a="variants"><c path="Array"><t path="hxsl.FunType"/></c></TFun>
		<TArray a="t:size">
			<e path="hxsl.Type"/>
			<e path="hxsl.SizeDecl"/>
		</TArray>
		<TBuffer a="t:size">
			<e path="hxsl.Type"/>
			<e path="hxsl.SizeDecl"/>
		</TBuffer>
		<TChannel a="size"><x path="Int"/></TChannel>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<enum path="hxsl.VecType" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Ast.hx" module="hxsl.Ast">
		<VInt/>
		<VFloat/>
		<VBool/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="hxsl.SizeDecl" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Ast.hx" module="hxsl.Ast">
		<SConst a="v"><x path="Int"/></SConst>
		<SVar a="v"><t path="hxsl.TVar"/></SVar>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<typedef path="hxsl.FunType" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Ast.hx" module="hxsl.Ast"><a>
	<ret><e path="hxsl.Type"/></ret>
	<args><c path="Array"><a>
	<type><e path="hxsl.Type"/></type>
	<name><c path="String"/></name>
</a></c></args>
</a></typedef>
	<class path="hxsl.Error" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Ast.hx" module="hxsl.Ast">
		<t public="1" set="method" line="51" static="1"><f a="msg:pos">
	<c path="String"/>
	<t path="hxsl.Position"/>
	<d/>
</f></t>
		<msg public="1"><c path="String"/></msg>
		<pos public="1"><t path="hxsl.Position"/></pos>
		<toString public="1" set="method" line="47"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="42"><f a="msg:pos">
	<c path="String"/>
	<t path="hxsl.Position"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="hxsl.Position" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Ast.hx" module="hxsl.Ast"><t path="haxe.macro.Position"/></typedef>
	<typedef path="hxsl.Expr" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Ast.hx" module="hxsl.Ast"><a>
	<pos><t path="hxsl.Position"/></pos>
	<expr><e path="hxsl.ExprDef"/></expr>
</a></typedef>
	<typedef path="hxsl.Binop" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Ast.hx" module="hxsl.Ast"><e path="haxe.macro.Binop"/></typedef>
	<typedef path="hxsl.Unop" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Ast.hx" module="hxsl.Ast"><e path="haxe.macro.Unop"/></typedef>
	<enum path="hxsl.VarKind" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Ast.hx" module="hxsl.Ast">
		<Global/>
		<Input/>
		<Param/>
		<Var/>
		<Local/>
		<Output/>
		<Function/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="hxsl.VarQualifier" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Ast.hx" module="hxsl.Ast">
		<Const a="?max"><x path="Int"/></Const>
		<Private/>
		<Nullable/>
		<PerObject/>
		<Name a="n"><c path="String"/></Name>
		<Shared/>
		<Precision a="p"><e path="hxsl.Prec"/></Precision>
		<Range a="min:max">
			<x path="Float"/>
			<x path="Float"/>
		</Range>
		<Ignore/>
		<PerInstance a="v"><x path="Int"/></PerInstance>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<enum path="hxsl.Prec" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Ast.hx" module="hxsl.Ast">
		<Low/>
		<Medium/>
		<High/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<typedef path="hxsl.VarDecl" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Ast.hx" module="hxsl.Ast"><a>
	<type><x path="Null"><e path="hxsl.Type"/></x></type>
	<qualifiers><c path="Array"><e path="hxsl.VarQualifier"/></c></qualifiers>
	<name><c path="String"/></name>
	<kind><x path="Null"><e path="hxsl.VarKind"/></x></kind>
	<expr><x path="Null"><t path="hxsl.Expr"/></x></expr>
</a></typedef>
	<typedef path="hxsl.FunDecl" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Ast.hx" module="hxsl.Ast"><a>
	<ret><x path="Null"><e path="hxsl.Type"/></x></ret>
	<name><c path="String"/></name>
	<expr><t path="hxsl.Expr"/></expr>
	<args><c path="Array"><t path="hxsl.VarDecl"/></c></args>
</a></typedef>
	<enum path="hxsl.Const" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Ast.hx" module="hxsl.Ast">
		<CNull/>
		<CBool a="b"><x path="Bool"/></CBool>
		<CInt a="v"><x path="Int"/></CInt>
		<CFloat a="v"><x path="Float"/></CFloat>
		<CString a="v"><c path="String"/></CString>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<enum path="hxsl.ExprDef" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Ast.hx" module="hxsl.Ast">
		<EConst a="c"><e path="hxsl.Const"/></EConst>
		<EIdent a="i"><c path="String"/></EIdent>
		<EParenthesis a="e"><t path="hxsl.Expr"/></EParenthesis>
		<EField a="e:f">
			<t path="hxsl.Expr"/>
			<c path="String"/>
		</EField>
		<EBinop a="op:e1:e2">
			<t path="hxsl.Binop"/>
			<t path="hxsl.Expr"/>
			<t path="hxsl.Expr"/>
		</EBinop>
		<EUnop a="op:e1">
			<t path="hxsl.Unop"/>
			<t path="hxsl.Expr"/>
		</EUnop>
		<ECall a="e:args">
			<t path="hxsl.Expr"/>
			<c path="Array"><t path="hxsl.Expr"/></c>
		</ECall>
		<EBlock a="el"><c path="Array"><t path="hxsl.Expr"/></c></EBlock>
		<EVars a="v"><c path="Array"><t path="hxsl.VarDecl"/></c></EVars>
		<EFunction a="f"><t path="hxsl.FunDecl"/></EFunction>
		<EIf a="econd:eif:eelse">
			<t path="hxsl.Expr"/>
			<t path="hxsl.Expr"/>
			<x path="Null"><t path="hxsl.Expr"/></x>
		</EIf>
		<EDiscard/>
		<EFor a="v:loop:block">
			<c path="String"/>
			<t path="hxsl.Expr"/>
			<t path="hxsl.Expr"/>
		</EFor>
		<EReturn a="?e"><t path="hxsl.Expr"/></EReturn>
		<EBreak/>
		<EContinue/>
		<EArray a="e:eindex">
			<t path="hxsl.Expr"/>
			<t path="hxsl.Expr"/>
		</EArray>
		<EArrayDecl a="el"><c path="Array"><t path="hxsl.Expr"/></c></EArrayDecl>
		<ESwitch a="e:cases:def">
			<t path="hxsl.Expr"/>
			<c path="Array"><a>
	<values><c path="Array"><t path="hxsl.Expr"/></c></values>
	<expr><t path="hxsl.Expr"/></expr>
</a></c>
			<x path="Null"><t path="hxsl.Expr"/></x>
		</ESwitch>
		<EWhile a="cond:loop:normalWhile">
			<t path="hxsl.Expr"/>
			<t path="hxsl.Expr"/>
			<x path="Bool"/>
		</EWhile>
		<EMeta a="name:args:e">
			<c path="String"/>
			<c path="Array"><t path="hxsl.Expr"/></c>
			<t path="hxsl.Expr"/>
		</EMeta>
	</enum>
	<typedef path="hxsl.TVar" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Ast.hx" module="hxsl.Ast"><a>
	<type><e path="hxsl.Type"/></type>
	<qualifiers>
		<x path="Null"><c path="Array"><e path="hxsl.VarQualifier"/></c></x>
		<meta><m n=":optional"/></meta>
	</qualifiers>
	<parent>
		<x path="Null"><t path="hxsl.TVar"/></x>
		<meta><m n=":optional"/></meta>
	</parent>
	<name><c path="String"/></name>
	<kind><e path="hxsl.VarKind"/></kind>
	<id><x path="Int"/></id>
</a></typedef>
	<typedef path="hxsl.TFunction" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Ast.hx" module="hxsl.Ast"><a>
	<ret><e path="hxsl.Type"/></ret>
	<ref><t path="hxsl.TVar"/></ref>
	<kind><e path="hxsl.FunctionKind"/></kind>
	<expr><t path="hxsl.TExpr"/></expr>
	<args><c path="Array"><t path="hxsl.TVar"/></c></args>
</a></typedef>
	<enum path="hxsl.FunctionKind" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Ast.hx" module="hxsl.Ast">
		<Vertex/>
		<Fragment/>
		<Init/>
		<Helper/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="hxsl.TGlobal" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Ast.hx" module="hxsl.Ast">
		<Radians/>
		<Degrees/>
		<Sin/>
		<Cos/>
		<Tan/>
		<Asin/>
		<Acos/>
		<Atan/>
		<Pow/>
		<Exp/>
		<Log/>
		<Exp2/>
		<Log2/>
		<Sqrt/>
		<Inversesqrt/>
		<Abs/>
		<Sign/>
		<Floor/>
		<Ceil/>
		<Fract/>
		<Mod/>
		<Min/>
		<Max/>
		<Clamp/>
		<Mix/>
		<Step/>
		<Smoothstep/>
		<Length/>
		<Distance/>
		<Dot/>
		<Cross/>
		<Normalize/>
		<LReflect/>
		<Texture/>
		<TextureLod/>
		<Texel/>
		<TexelLod/>
		<ToInt/>
		<ToFloat/>
		<ToBool/>
		<Vec2/>
		<Vec3/>
		<Vec4/>
		<IVec2/>
		<IVec3/>
		<IVec4/>
		<BVec2/>
		<BVec3/>
		<BVec4/>
		<Mat2/>
		<Mat3/>
		<Mat4/>
		<Mat3x4/>
		<Saturate/>
		<Pack/>
		<Unpack/>
		<PackNormal/>
		<UnpackNormal/>
		<ScreenToUv/>
		<UvToScreen/>
		<DFdx/>
		<DFdy/>
		<Fwidth/>
		<ChannelRead/>
		<ChannelReadLod/>
		<ChannelFetch/>
		<ChannelFetchLod/>
		<Trace/>
		<VertexID/>
		<InstanceID/>
		<FragCoord/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="hxsl.Component" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Ast.hx" module="hxsl.Ast">
		<X/>
		<Y/>
		<Z/>
		<W/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="hxsl.TExprDef" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Ast.hx" module="hxsl.Ast">
		<TConst a="c"><e path="hxsl.Const"/></TConst>
		<TVar a="v"><t path="hxsl.TVar"/></TVar>
		<TGlobal a="g"><e path="hxsl.TGlobal"/></TGlobal>
		<TParenthesis a="e"><t path="hxsl.TExpr"/></TParenthesis>
		<TBlock a="el"><c path="Array"><t path="hxsl.TExpr"/></c></TBlock>
		<TBinop a="op:e1:e2">
			<t path="hxsl.Binop"/>
			<t path="hxsl.TExpr"/>
			<t path="hxsl.TExpr"/>
		</TBinop>
		<TUnop a="op:e1">
			<t path="hxsl.Unop"/>
			<t path="hxsl.TExpr"/>
		</TUnop>
		<TVarDecl a="v:?init">
			<t path="hxsl.TVar"/>
			<t path="hxsl.TExpr"/>
		</TVarDecl>
		<TCall a="e:args">
			<t path="hxsl.TExpr"/>
			<c path="Array"><t path="hxsl.TExpr"/></c>
		</TCall>
		<TSwiz a="e:regs">
			<t path="hxsl.TExpr"/>
			<c path="Array"><e path="hxsl.Component"/></c>
		</TSwiz>
		<TIf a="econd:eif:eelse">
			<t path="hxsl.TExpr"/>
			<t path="hxsl.TExpr"/>
			<x path="Null"><t path="hxsl.TExpr"/></x>
		</TIf>
		<TDiscard/>
		<TReturn a="?e"><t path="hxsl.TExpr"/></TReturn>
		<TFor a="v:it:loop">
			<t path="hxsl.TVar"/>
			<t path="hxsl.TExpr"/>
			<t path="hxsl.TExpr"/>
		</TFor>
		<TContinue/>
		<TBreak/>
		<TArray a="e:index">
			<t path="hxsl.TExpr"/>
			<t path="hxsl.TExpr"/>
		</TArray>
		<TArrayDecl a="el"><c path="Array"><t path="hxsl.TExpr"/></c></TArrayDecl>
		<TSwitch a="e:cases:def">
			<t path="hxsl.TExpr"/>
			<c path="Array"><a>
	<values><c path="Array"><t path="hxsl.TExpr"/></c></values>
	<expr><t path="hxsl.TExpr"/></expr>
</a></c>
			<x path="Null"><t path="hxsl.TExpr"/></x>
		</TSwitch>
		<TWhile a="e:loop:normalWhile">
			<t path="hxsl.TExpr"/>
			<t path="hxsl.TExpr"/>
			<x path="Bool"/>
		</TWhile>
		<TMeta a="m:args:e">
			<c path="String"/>
			<c path="Array"><e path="hxsl.Const"/></c>
			<t path="hxsl.TExpr"/>
		</TMeta>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<typedef path="hxsl.TExpr" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Ast.hx" module="hxsl.Ast"><a>
	<t><e path="hxsl.Type"/></t>
	<p><t path="hxsl.Position"/></p>
	<e><e path="hxsl.TExprDef"/></e>
</a></typedef>
	<typedef path="hxsl.ShaderData" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Ast.hx" module="hxsl.Ast"><a>
	<vars><c path="Array"><t path="hxsl.TVar"/></c></vars>
	<name><c path="String"/></name>
	<funs><c path="Array"><t path="hxsl.TFunction"/></c></funs>
</a></typedef>
	<class path="hxsl.Tools" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Ast.hx" module="hxsl.Ast">
		<UID expr="0" line="291" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</UID>
		<SWIZ public="1" expr="Component.createAll()" line="293" static="1">
			<c path="Array"><e path="hxsl.Component"/></c>
			<meta><m n=":value"><e>Component.createAll()</e></m></meta>
		</SWIZ>
		<MAX_CHANNELS_BITS public="1" expr="3" line="294" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</MAX_CHANNELS_BITS>
		<allocVarId public="1" set="method" line="296" static="1"><f a=""><x path="Int"/></f></allocVarId>
		<getName public="1" set="method" line="306" static="1"><f a="v">
	<t path="hxsl.TVar"/>
	<c path="String"/>
</f></getName>
		<getConstBits public="1" set="method" line="317" static="1"><f a="v">
	<t path="hxsl.TVar"/>
	<x path="Int"/>
</f></getConstBits>
		<isConst public="1" set="method" line="341" static="1"><f a="v">
	<t path="hxsl.TVar"/>
	<x path="Bool"/>
</f></isConst>
		<isStruct public="1" set="method" line="353" static="1"><f a="v">
	<t path="hxsl.TVar"/>
	<x path="Bool"/>
</f></isStruct>
		<isArray public="1" set="method" line="357" static="1"><f a="v">
	<t path="hxsl.TVar"/>
	<x path="Bool"/>
</f></isArray>
		<hasQualifier public="1" set="method" line="361" static="1"><f a="v:q">
	<t path="hxsl.TVar"/>
	<e path="hxsl.VarQualifier"/>
	<x path="Bool"/>
</f></hasQualifier>
		<isSampler public="1" set="method" line="369" static="1"><f a="t">
	<e path="hxsl.Type"/>
	<x path="Bool"/>
</f></isSampler>
		<toString public="1" set="method" line="378" static="1"><f a="t">
	<e path="hxsl.Type"/>
	<c path="String"/>
</f></toString>
		<toType public="1" set="method" line="395" static="1"><f a="t">
	<e path="hxsl.VecType"/>
	<e path="hxsl.Type"/>
</f></toType>
		<hasSideEffect public="1" set="method" line="403" static="1"><f a="e">
	<t path="hxsl.TExpr"/>
	<x path="Bool"/>
</f></hasSideEffect>
		<iter public="1" set="method" line="443" static="1"><f a="e:f">
	<t path="hxsl.TExpr"/>
	<f a="">
		<t path="hxsl.TExpr"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></iter>
		<map public="1" set="method" line="472" static="1"><f a="e:f">
	<t path="hxsl.TExpr"/>
	<f a="">
		<t path="hxsl.TExpr"/>
		<t path="hxsl.TExpr"/>
	</f>
	<t path="hxsl.TExpr"/>
</f></map>
		<size public="1" set="method" line="494" static="1"><f a="t">
	<e path="hxsl.Type"/>
	<x path="Int"/>
</f></size>
		<evalConst public="1" set="method" line="514" static="1"><f a="e">
	<t path="hxsl.TExpr"/>
	<d/>
</f></evalConst>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxsl.Tools2" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Ast.hx" module="hxsl.Ast">
		<toString public="1" set="method" line="539" static="1"><f a="g">
	<e path="hxsl.TGlobal"/>
	<c path="String"/>
</f></toString>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxsl.Tools3" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Ast.hx" module="hxsl.Ast"><toString public="1" set="method" line="548" static="1"><f a="s">
	<t path="hxsl.ShaderData"/>
	<c path="String"/>
</f></toString></class>
	<class path="hxsl.Tools4" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Ast.hx" module="hxsl.Ast"><toString public="1" set="method" line="556" static="1"><f a="e">
	<t path="hxsl.TExpr"/>
	<c path="String"/>
</f></toString></class>
	<class path="hxsl.BatchShader" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/BatchShader.hx">
		<extends path="hxsl.Shader"/>
		<SRC expr="&quot;HXSLEGh4c2wuQmF0Y2hTaGFkZXICAQtCYXRjaF9Db3VudAECAAEAAAABAAIMQmF0Y2hfQnVmZmVyEAUMAQIAAAA&quot;" line="5" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"HXSLEGh4c2wuQmF0Y2hTaGFkZXICAQtCYXRjaF9Db3VudAECAAEAAAABAAIMQmF0Y2hfQnVmZmVyEAUMAQIAAAA"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<Batch_Count public="1" get="accessor" set="accessor"><x path="Int"/></Batch_Count>
		<Batch_Count__ expr="0">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":noCompletion"/>
			</meta>
		</Batch_Count__>
		<get_Batch_Count get="inline" set="null" line="5">
			<f a=""><x path="Int"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_Batch_Count>
		<set_Batch_Count get="inline" set="null" line="5">
			<f a="_v">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_Batch_Count>
		<Batch_Buffer public="1" get="accessor" set="accessor"><t path="hxsl.Buffer"/></Batch_Buffer>
		<Batch_Buffer__>
			<t path="hxsl.Buffer"/>
			<meta><m n=":noCompletion"/></meta>
		</Batch_Buffer__>
		<get_Batch_Buffer get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Buffer"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_Batch_Buffer>
		<set_Batch_Buffer get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Buffer"/>
				<t path="hxsl.Buffer"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_Batch_Buffer>
		<updateConstants public="1" set="method" line="5" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="5" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="3"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":src"><e><![CDATA[{
	@const(65536) var Batch_Count:Int;
	@param var Batch_Buffer:Buffer<Vec4,Batch_Count>;
}]]></e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="hxsl.SearchMap" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Cache.hx" module="hxsl.Cache">
		<linked public="1"><c path="hxsl.RuntimeShader"/></linked>
		<next public="1"><t path="Map">
	<x path="Int"/>
	<c path="hxsl.SearchMap"/>
</t></next>
		<new public="1" set="method" line="8"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxsl.Cache" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Cache.hx">
		<INST static="1"><c path="hxsl.Cache"/></INST>
		<get public="1" set="method" line="551" static="1"><f a=""><c path="hxsl.Cache"/></f></get>
		<set public="1" set="method" line="558" static="1"><f a="c">
	<c path="hxsl.Cache"/>
	<x path="Void"/>
</f></set>
		<clear public="1" set="method" line="562" static="1"><f a=""><x path="Void"/></f></clear>
		<linkCache><c path="hxsl.SearchMap"/></linkCache>
		<linkShaders><t path="Map">
	<c path="String"/>
	<c path="hxsl.Shader"/>
</t></linkShaders>
		<batchShaders><t path="Map">
	<x path="Int"/>
	<c path="hxsl.SharedShader"/>
</t></batchShaders>
		<byID><t path="Map">
	<c path="String"/>
	<c path="hxsl.RuntimeShader"/>
</t></byID>
		<constsToGlobal public="1"><x path="Bool"/></constsToGlobal>
		<getLinkShader public="1" set="method" line="36">
			<f a="vars">
				<c path="Array"><e path="hxsl.Output"/></c>
				<x path="Null"><c path="hxsl.Shader"/></x>
			</f>
			<haxe_doc>Creates a shader that generate the output requested.</haxe_doc>
		</getLinkShader>
		<link public="1" set="method" line="154">
			<f a="shaders:batchMode">
				<c path="hxsl.ShaderList"/>
				<x path="Bool"/>
				<c path="hxsl.RuntimeShader"/>
			</f>
			<meta><m n=":noDebug"/></meta>
		</link>
		<compileRuntimeShader set="method" line="171"><f a="shaders:batchMode">
	<c path="hxsl.ShaderList"/>
	<x path="Bool"/>
	<c path="hxsl.RuntimeShader"/>
</f></compileRuntimeShader>
		<buildRuntimeShader set="method" line="310"><f a="vertex:fragment:paramVars">
	<t path="hxsl.ShaderData"/>
	<t path="hxsl.ShaderData"/>
	<t path="Map">
		<x path="Int"/>
		<a>
			<instance><x path="Int"/></instance>
			<index><x path="Int"/></index>
		</a>
	</t>
	<c path="hxsl.RuntimeShader"/>
</f></buildRuntimeShader>
		<initGlobals set="method" line="326"><f a="r:s">
	<c path="hxsl.RuntimeShader"/>
	<c path="hxsl.RuntimeShaderData"/>
	<x path="Void"/>
</f></initGlobals>
		<getPath set="method" line="340"><f a="v">
	<t path="hxsl.TVar"/>
	<c path="String"/>
</f></getPath>
		<flattenShader set="method" line="346"><f a="s:kind:params">
	<t path="hxsl.ShaderData"/>
	<e path="hxsl.FunctionKind"/>
	<t path="Map">
		<x path="Int"/>
		<a>
			<instance><x path="Int"/></instance>
			<index><x path="Int"/></index>
		</a>
	</t>
	<c path="hxsl.RuntimeShaderData"/>
</f></flattenShader>
		<makeBatchShader public="1" set="method" line="417"><f a="rt">
	<c path="hxsl.RuntimeShader"/>
	<c path="hxsl.BatchShader"/>
</f></makeBatchShader>
		<createBatchShader set="method" line="428"><f a="rt">
	<c path="hxsl.RuntimeShader"/>
	<c path="hxsl.SharedShader"/>
</f></createBatchShader>
		<new set="method" line="25"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="hxsl.Channel" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Channel.hx">
		<Unknown/>
		<R/>
		<G/>
		<B/>
		<A/>
		<PackedFloat/>
		<PackedNormal/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<typedef path="hxsl.ChannelTexture" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/ChannelTexture.hx"><a>
	<texture><t path="hxsl.ChannelTextureType"/></texture>
	<channel><e path="hxsl.Channel"/></channel>
</a></typedef>
	<class path="hxsl.Clone" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Clone.hx">
		<shaderData public="1" set="method" line="75" static="1"><f a="s">
	<t path="hxsl.ShaderData"/>
	<t path="hxsl.ShaderData"/>
</f></shaderData>
		<varMap public="1"><t path="Map">
	<x path="Int"/>
	<t path="hxsl.TVar"/>
</t></varMap>
		<tvar public="1" set="method" line="12"><f a="v">
	<t path="hxsl.TVar"/>
	<t path="hxsl.TVar"/>
</f></tvar>
		<tfun public="1" set="method" line="28"><f a="f">
	<t path="hxsl.TFunction"/>
	<t path="hxsl.TFunction"/>
</f></tfun>
		<ttype public="1" set="method" line="38"><f a="t">
	<e path="hxsl.Type"/>
	<e path="hxsl.Type"/>
</f></ttype>
		<texpr public="1" set="method" line="51"><f a="e">
	<t path="hxsl.TExpr"/>
	<t path="hxsl.TExpr"/>
</f></texpr>
		<shader public="1" set="method" line="67"><f a="s">
	<t path="hxsl.ShaderData"/>
	<t path="hxsl.ShaderData"/>
</f></shader>
		<new public="1" set="method" line="8"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxsl._Dce.Exit" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Dce.hx" private="1" module="hxsl.Dce"><new public="1" set="method" line="5"><f a=""><x path="Void"/></f></new></class>
	<class path="hxsl._Dce.VarDeps" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Dce.hx" private="1" module="hxsl.Dce">
		<v public="1"><t path="hxsl.TVar"/></v>
		<keep public="1"><x path="Bool"/></keep>
		<used public="1"><x path="Bool"/></used>
		<deps public="1"><t path="Map">
	<x path="Int"/>
	<c path="hxsl._Dce.VarDeps"/>
</t></deps>
		<new public="1" set="method" line="14"><f a="v">
	<t path="hxsl.TVar"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxsl.Dce" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Dce.hx">
		<used><t path="Map">
	<x path="Int"/>
	<c path="hxsl._Dce.VarDeps"/>
</t></used>
		<channelVars><c path="Array"><t path="hxsl.TVar"/></c></channelVars>
		<markAsKeep><x path="Bool"/></markAsKeep>
		<debug get="inline" set="null" line="30"><f a="msg:?pos">
	<c path="String"/>
	<t path="haxe.PosInfos"/>
	<x path="Void"/>
</f></debug>
		<dce public="1" set="method" line="37"><f a="vertex:fragment">
	<t path="hxsl.ShaderData"/>
	<t path="hxsl.ShaderData"/>
	<a>
		<vertex><t path="hxsl.ShaderData"/></vertex>
		<fragment><t path="hxsl.ShaderData"/></fragment>
	</a>
</f></dce>
		<get set="method" line="107"><f a="v">
	<t path="hxsl.TVar"/>
	<x path="Null"><c path="hxsl._Dce.VarDeps"/></x>
</f></get>
		<markRec set="method" line="116"><f a="v">
	<c path="hxsl._Dce.VarDeps"/>
	<x path="Void"/>
</f></markRec>
		<link set="method" line="124"><f a="v:writeTo">
	<t path="hxsl.TVar"/>
	<c path="Array"><c path="hxsl._Dce.VarDeps"/></c>
	<x path="Void"/>
</f></link>
		<check set="method" line="141"><f a="e:writeTo:isAffected">
	<t path="hxsl.TExpr"/>
	<c path="Array"><c path="hxsl._Dce.VarDeps"/></c>
	<c path="Array"><c path="hxsl._Dce.VarDeps"/></c>
	<x path="Void"/>
</f></check>
		<checkBranches set="method" line="203"><f a="e">
	<t path="hxsl.TExpr"/>
	<x path="Void"/>
</f></checkBranches>
		<mapExpr set="method" line="214"><f a="e:isVar">
	<t path="hxsl.TExpr"/>
	<x path="Bool"/>
	<t path="hxsl.TExpr"/>
</f></mapExpr>
		<new public="1" set="method" line="27"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxsl.Eval" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Eval.hx">
		<varMap public="1"><t path="Map">
	<t path="hxsl.TVar"/>
	<t path="hxsl.TVar"/>
</t></varMap>
		<inlineCalls public="1"><x path="Bool"/></inlineCalls>
		<unrollLoops public="1"><x path="Bool"/></unrollLoops>
		<eliminateConditionals public="1"><x path="Bool"/></eliminateConditionals>
		<constants><t path="Map">
	<x path="Int"/>
	<e path="hxsl.TExprDef"/>
</t></constants>
		<funMap><t path="Map">
	<t path="hxsl.TVar"/>
	<t path="hxsl.TFunction"/>
</t></funMap>
		<curFun><t path="hxsl.TFunction"/></curFun>
		<setConstant public="1" set="method" line="25"><f a="v:c">
	<t path="hxsl.TVar"/>
	<e path="hxsl.Const"/>
	<x path="Void"/>
</f></setConstant>
		<mapVar set="method" line="29"><f a="v">
	<t path="hxsl.TVar"/>
	<x path="Null"><a>
	<type><e path="hxsl.Type"/></type>
	<qualifiers>
		<x path="Null"><c path="Array"><e path="hxsl.VarQualifier"/></c></x>
		<meta><m n=":optional"/></meta>
	</qualifiers>
	<parent>
		<x path="Null"><t path="hxsl.TVar"/></x>
		<meta><m n=":optional"/></meta>
	</parent>
	<name><c path="String"/></name>
	<kind><e path="hxsl.VarKind"/></kind>
	<id><x path="Int"/></id>
</a></x>
</f></mapVar>
		<eval public="1" set="method" line="73"><f a="s">
	<t path="hxsl.ShaderData"/>
	<t path="hxsl.ShaderData"/>
</f></eval>
		<markReturn><x path="Bool"/></markReturn>
		<hasReturn set="method" line="100"><f a="e">
	<t path="hxsl.TExpr"/>
	<x path="Bool"/>
</f></hasReturn>
		<hasReturnLoop set="method" line="106"><f a="e">
	<t path="hxsl.TExpr"/>
	<x path="Void"/>
</f></hasReturnLoop>
		<handleReturn set="method" line="115">
			<f a="e:?isFinal" v=":false">
				<t path="hxsl.TExpr"/>
				<x path="Bool"/>
				<t path="hxsl.TExpr"/>
			</f>
			<meta><m n=":value"><e>{ isFinal : false }</e></m></meta>
		</handleReturn>
		<handleReturnDef set="method" line="155"><f a="e">
	<t path="hxsl.TExpr"/>
	<t path="hxsl.TExpr"/>
</f></handleReturnDef>
		<evalCall set="method" line="159"><f a="g:args:oldArgs:pos">
	<e path="hxsl.TGlobal"/>
	<c path="Array"><t path="hxsl.TExpr"/></c>
	<c path="Array"><t path="hxsl.TExpr"/></c>
	<t path="hxsl.Position"/>
	<e path="hxsl.TExprDef"/>
</f></evalCall>
		<constantsToString set="method" line="212"><f a=""><c path="String"/></f></constantsToString>
		<ifBlock set="method" line="216"><f a="e">
	<t path="hxsl.TExpr"/>
	<t path="hxsl.TExpr"/>
</f></ifBlock>
		<evalExpr set="method" line="222">
			<f a="e:?isVal" v=":true">
				<t path="hxsl.TExpr"/>
				<x path="Bool"/>
				<t path="hxsl.TExpr"/>
			</f>
			<meta><m n=":value"><e>{ isVal : true }</e></m></meta>
		</evalExpr>
		<new public="1" set="method" line="19"><f a=""><x path="Void"/></f></new>
		<haxe_doc>Evaluator : will substitute some variables (usually constants) by their runtime value and will
	evaluate and reduce the expression, unroll loops, etc.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxsl._Flatten.Alloc" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Flatten.hx" private="1" module="hxsl.Flatten">
		<t public="1"><e path="hxsl.VecType"/></t>
		<pos public="1"><x path="Int"/></pos>
		<size public="1"><x path="Int"/></size>
		<g public="1"><t path="hxsl.TVar"/></g>
		<v public="1"><x path="Null"><t path="hxsl.TVar"/></x></v>
		<new public="1" set="method" line="10"><f a="g:t:pos:size">
	<t path="hxsl.TVar"/>
	<e path="hxsl.VecType"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="hxsl.ARead" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Flatten.hx" module="hxsl.Flatten">
		<AIndex a="a"><c path="hxsl._Flatten.Alloc"/></AIndex>
		<AOffset a="a:stride:delta">
			<c path="hxsl._Flatten.Alloc"/>
			<x path="Int"/>
			<t path="hxsl.TExpr"/>
		</AOffset>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<class path="hxsl.Flatten" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Flatten.hx">
		<globals><c path="Array"><t path="hxsl.TVar"/></c></globals>
		<params><c path="Array"><t path="hxsl.TVar"/></c></params>
		<outVars><c path="Array"><t path="hxsl.TVar"/></c></outVars>
		<varMap><t path="Map">
	<t path="hxsl.TVar"/>
	<c path="hxsl._Flatten.Alloc"/>
</t></varMap>
		<econsts><t path="hxsl.TExpr"/></econsts>
		<consts public="1"><c path="Array"><x path="Float"/></c></consts>
		<allocData public="1"><t path="Map">
	<t path="hxsl.TVar"/>
	<c path="Array"><c path="hxsl._Flatten.Alloc"/></c>
</t></allocData>
		<flatten public="1" set="method" line="36"><f a="s:kind:constsToGlobal">
	<t path="hxsl.ShaderData"/>
	<e path="hxsl.FunctionKind"/>
	<x path="Bool"/>
	<t path="hxsl.ShaderData"/>
</f></flatten>
		<mapFun set="method" line="96"><f a="f:mapExpr">
	<t path="hxsl.TFunction"/>
	<f a="">
		<t path="hxsl.TExpr"/>
		<t path="hxsl.TExpr"/>
	</f>
	<t path="hxsl.TFunction"/>
</f></mapFun>
		<mapExpr set="method" line="106"><f a="e">
	<t path="hxsl.TExpr"/>
	<t path="hxsl.TExpr"/>
</f></mapExpr>
		<mapConsts set="method" line="137"><f a="e">
	<t path="hxsl.TExpr"/>
	<t path="hxsl.TExpr"/>
</f></mapConsts>
		<allocConst set="method" line="200"><f a="v:p">
	<x path="Float"/>
	<t path="hxsl.Position"/>
	<t path="hxsl.TExpr"/>
</f></allocConst>
		<allocConsts set="method" line="209"><f a="va:p">
	<c path="Array"><x path="Float"/></c>
	<t path="hxsl.Position"/>
	<t path="hxsl.TExpr"/>
</f></allocConsts>
		<mkInt get="inline" set="null" line="250"><f a="v:pos">
	<x path="Int"/>
	<t path="hxsl.Position"/>
	<a>
		<t><e path="hxsl.Type"/></t>
		<p><t path="hxsl.Position"/></p>
		<e><e path="hxsl.TExprDef"/></e>
	</a>
</f></mkInt>
		<readIndex get="inline" set="null" line="254"><f a="a:index:pos">
	<c path="hxsl._Flatten.Alloc"/>
	<x path="Int"/>
	<t path="hxsl.Position"/>
	<t path="hxsl.TExpr"/>
</f></readIndex>
		<readOffset get="inline" set="null" line="258"><f a="a:stride:delta:index:pos">
	<c path="hxsl._Flatten.Alloc"/>
	<x path="Int"/>
	<t path="hxsl.TExpr"/>
	<x path="Int"/>
	<t path="hxsl.Position"/>
	<t path="hxsl.TExpr"/>
</f></readOffset>
		<access set="method" line="264"><f a="a:t:pos:acc">
	<c path="hxsl._Flatten.Alloc"/>
	<e path="hxsl.Type"/>
	<t path="hxsl.Position"/>
	<e path="hxsl.ARead"/>
	<t path="hxsl.TExpr"/>
</f></access>
		<optimize set="method" line="323"><f a="e">
	<t path="hxsl.TExpr"/>
	<a>
		<t><e path="hxsl.Type"/></t>
		<p><t path="hxsl.Position"/></p>
		<e><e path="hxsl.TExprDef"/></e>
	</a>
</f></optimize>
		<packTextures set="method" line="348"><f a="name:vars:t">
	<c path="String"/>
	<c path="Array"><t path="hxsl.TVar"/></c>
	<e path="hxsl.Type"/>
	<c path="Array"><c path="hxsl._Flatten.Alloc"/></c>
</f></packTextures>
		<packBuffers set="method" line="377"><f a="vars">
	<c path="Array"><t path="hxsl.TVar"/></c>
	<x path="Void"/>
</f></packBuffers>
		<pack set="method" line="396"><f a="name:kind:vars:t">
	<c path="String"/>
	<e path="hxsl.VarKind"/>
	<c path="Array"><t path="hxsl.TVar"/></c>
	<e path="hxsl.VecType"/>
	<t path="hxsl.TVar"/>
</f></pack>
		<varSize set="method" line="444"><f a="v:t">
	<e path="hxsl.Type"/>
	<e path="hxsl.VecType"/>
	<x path="Int"/>
</f></varSize>
		<gatherVar set="method" line="456"><f a="v">
	<t path="hxsl.TVar"/>
	<x path="Void"/>
</f></gatherVar>
		<new public="1" set="method" line="33"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="hxsl.GlobalSlot" params="T" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Globals.hx" module="hxsl.Globals">
		<this><x path="Int"/></this>
		<impl><class path="hxsl._Globals.GlobalSlot_Impl_" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Globals.hx" private="1" module="hxsl.Globals">
	<_new public="1" get="inline" set="null" line="5" static="1">
		<f a="name">
			<c path="String"/>
			<x path="hxsl.GlobalSlot"><c path="hxsl.GlobalSlot.T"/></x>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<toInt public="1" get="inline" set="null" line="8" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toInt>
	<set public="1" get="inline" set="null" line="11" static="1">
		<f a="this:globals:v">
			<x path="Int"/>
			<c path="hxsl.Globals"/>
			<c path="hxsl.GlobalSlot.T"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set>
	<get public="1" get="inline" set="null" line="14" static="1">
		<f a="this:globals">
			<x path="Int"/>
			<c path="hxsl.Globals"/>
			<c path="hxsl.GlobalSlot.T"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get>
</class></impl>
	</abstract>
	<class path="hxsl._Globals.GlobalSlot_Impl_" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Globals.hx" private="1" module="hxsl.Globals">
		<_new public="1" get="inline" set="null" line="5" static="1">
			<f a="name">
				<c path="String"/>
				<x path="hxsl.GlobalSlot"><c path="hxsl.GlobalSlot.T"/></x>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<toInt public="1" get="inline" set="null" line="8" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toInt>
		<set public="1" get="inline" set="null" line="11" static="1">
			<f a="this:globals:v">
				<x path="Int"/>
				<c path="hxsl.Globals"/>
				<c path="hxsl.GlobalSlot.T"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set>
		<get public="1" get="inline" set="null" line="14" static="1">
			<f a="this:globals">
				<x path="Int"/>
				<c path="hxsl.Globals"/>
				<c path="hxsl.GlobalSlot.T"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get>
	</class>
	<class path="hxsl.Globals" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Globals.hx">
		<ALL static="1"><c path="Array"><c path="String"/></c></ALL>
		<MAP static="1"><t path="Map">
	<c path="String"/>
	<x path="Int"/>
</t></MAP>
		<allocID public="1" set="method" line="62" static="1"><f a="path">
	<c path="String"/>
	<x path="Int"/>
</f></allocID>
		<getIDName public="1" set="method" line="79" static="1"><f a="id">
	<x path="Int"/>
	<c path="String"/>
</f></getIDName>
		<map><t path="Map">
	<x path="Int"/>
	<d/>
</t></map>
		<channels expr="[]">
			<c path="Array"><c path="h3d.mat.Texture"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</channels>
		<maxChannels><x path="Int"/></maxChannels>
		<set public="1" set="method" line="29"><f a="path:v">
	<c path="String"/>
	<d/>
	<x path="Void"/>
</f></set>
		<get public="1" set="method" line="33"><f a="path">
	<c path="String"/>
	<d/>
</f></get>
		<fastSet public="1" get="inline" set="null" line="37"><f a="id:v">
	<x path="Int"/>
	<d/>
	<x path="Void"/>
</f></fastSet>
		<fastGet public="1" get="inline" set="null" line="41"><f a="id">
	<x path="Int"/>
	<d/>
</f></fastGet>
		<resetChannels public="1" get="inline" set="null" line="45"><f a=""><x path="Void"/></f></resetChannels>
		<allocChannelID public="1" set="method" line="49"><f a="t">
	<c path="h3d.mat.Texture"/>
	<x path="Int"/>
</f></allocChannelID>
		<new public="1" set="method" line="25"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxsl._Linker.AllocatedVar" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Linker.hx" private="1" module="hxsl.Linker">
		<id public="1"><x path="Int"/></id>
		<v public="1"><t path="hxsl.TVar"/></v>
		<path public="1"><c path="String"/></path>
		<merged public="1"><c path="Array"><t path="hxsl.TVar"/></c></merged>
		<kind public="1"><x path="Null"><e path="hxsl.FunctionKind"/></x></kind>
		<parent public="1"><c path="hxsl._Linker.AllocatedVar"/></parent>
		<instanceIndex public="1"><x path="Int"/></instanceIndex>
		<new public="1" set="method" line="12"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxsl._Linker.ShaderInfos" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Linker.hx" private="1" module="hxsl.Linker">
		<UID expr="0" line="17" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</UID>
		<uid public="1"><x path="Int"/></uid>
		<name public="1"><c path="String"/></name>
		<priority public="1"><x path="Int"/></priority>
		<body public="1"><t path="hxsl.TExpr"/></body>
		<usedFunctions public="1"><c path="Array"><t path="hxsl.TFunction"/></c></usedFunctions>
		<deps public="1"><t path="Map">
	<c path="hxsl._Linker.ShaderInfos"/>
	<x path="Bool"/>
</t></deps>
		<read public="1"><t path="Map">
	<x path="Int"/>
	<c path="hxsl._Linker.AllocatedVar"/>
</t></read>
		<write public="1"><t path="Map">
	<x path="Int"/>
	<c path="hxsl._Linker.AllocatedVar"/>
</t></write>
		<processed public="1"><t path="Map">
	<x path="Int"/>
	<x path="Bool"/>
</t></processed>
		<vertex public="1"><x path="Null"><x path="Bool"/></x></vertex>
		<onStack public="1"><x path="Bool"/></onStack>
		<hasDiscard public="1"><x path="Bool"/></hasDiscard>
		<marked public="1"><x path="Null"><x path="Bool"/></x></marked>
		<new public="1" set="method" line="31"><f a="n:v">
	<c path="String"/>
	<x path="Null"><x path="Bool"/></x>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxsl.Linker" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Linker.hx">
		<allVars public="1"><c path="Array"><c path="hxsl._Linker.AllocatedVar"/></c></allVars>
		<varMap><t path="Map">
	<c path="String"/>
	<c path="hxsl._Linker.AllocatedVar"/>
</t></varMap>
		<curShader><c path="hxsl._Linker.ShaderInfos"/></curShader>
		<shaders><c path="Array"><c path="hxsl._Linker.ShaderInfos"/></c></shaders>
		<varIdMap><t path="Map">
	<x path="Int"/>
	<x path="Int"/>
</t></varIdMap>
		<locals><t path="Map">
	<x path="Int"/>
	<x path="Bool"/>
</t></locals>
		<curInstance><x path="Int"/></curInstance>
		<batchMode><x path="Bool"/></batchMode>
		<isBatchShader><x path="Bool"/></isBatchShader>
		<debugDepth expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</debugDepth>
		<debug get="inline" set="null" line="59"><f a="msg:?pos">
	<c path="String"/>
	<t path="haxe.PosInfos"/>
	<x path="Void"/>
</f></debug>
		<error set="method" line="67"><f a="msg:p">
	<c path="String"/>
	<t path="hxsl.Position"/>
	<d/>
</f></error>
		<mergeVar set="method" line="71"><f a="path:v:v2:p">
	<c path="String"/>
	<t path="hxsl.TVar"/>
	<t path="hxsl.TVar"/>
	<t path="hxsl.Position"/>
	<x path="Void"/>
</f></mergeVar>
		<allocVar set="method" line="101"><f a="v:p:?path:?parent">
	<t path="hxsl.TVar"/>
	<t path="hxsl.Position"/>
	<c path="String"/>
	<c path="hxsl._Linker.AllocatedVar"/>
	<c path="hxsl._Linker.AllocatedVar"/>
</f></allocVar>
		<mapExprVar set="method" line="174"><f a="e">
	<t path="hxsl.TExpr"/>
	<a>
		<t><e path="hxsl.Type"/></t>
		<p><t path="hxsl.Position"/></p>
		<e><e path="hxsl.TExprDef"/></e>
	</a>
</f></mapExprVar>
		<addShader set="method" line="227"><f a="name:vertex:e:p">
	<c path="String"/>
	<x path="Null"><x path="Bool"/></x>
	<t path="hxsl.TExpr"/>
	<x path="Int"/>
	<c path="hxsl._Linker.ShaderInfos"/>
</f></addShader>
		<sortByPriorityDesc set="method" line="238"><f a="s1:s2">
	<c path="hxsl._Linker.ShaderInfos"/>
	<c path="hxsl._Linker.ShaderInfos"/>
	<x path="Int"/>
</f></sortByPriorityDesc>
		<buildDependency set="method" line="244"><f a="s:v:isWritten">
	<c path="hxsl._Linker.ShaderInfos"/>
	<c path="hxsl._Linker.AllocatedVar"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></buildDependency>
		<initDependencies set="method" line="272"><f a="s">
	<c path="hxsl._Linker.ShaderInfos"/>
	<x path="Void"/>
</f></initDependencies>
		<collect set="method" line="295"><f a="cur:out:vertex">
	<c path="hxsl._Linker.ShaderInfos"/>
	<c path="Array"><c path="hxsl._Linker.ShaderInfos"/></c>
	<x path="Bool"/>
	<x path="Void"/>
</f></collect>
		<uniqueLocals set="method" line="317"><f a="expr:locals">
	<t path="hxsl.TExpr"/>
	<t path="Map">
		<c path="String"/>
		<x path="Bool"/>
	</t>
	<x path="Void"/>
</f></uniqueLocals>
		<link public="1" set="method" line="336"><f a="shadersData">
	<c path="Array"><t path="hxsl.ShaderData"/></c>
	<t path="hxsl.ShaderData"/>
</f></link>
		<new public="1" set="method" line="55">
			<f a="?batchMode" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ batchMode : false }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="hxsl.Output" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Output.hx">
		<Const a="v"><x path="Float"/></Const>
		<Value a="v:?size">
			<c path="String"/>
			<x path="Int"/>
		</Value>
		<PackNormal a="v"><e path="hxsl.Output"/></PackNormal>
		<PackFloat a="v"><e path="hxsl.Output"/></PackFloat>
		<Vec2 a="a"><c path="Array"><e path="hxsl.Output"/></c></Vec2>
		<Vec3 a="a"><c path="Array"><e path="hxsl.Output"/></c></Vec3>
		<Vec4 a="a"><c path="Array"><e path="hxsl.Output"/></c></Vec4>
		<Swiz a="a:swiz">
			<e path="hxsl.Output"/>
			<c path="Array"><e path="hxsl.Component"/></c>
		</Swiz>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<class path="hxsl.Printer" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Printer.hx">
		<SWIZ expr="[&quot;x&quot;, &quot;y&quot;, &quot;z&quot;, &quot;w&quot;]" line="129" static="1">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>["x", "y", "z", "w"]</e></m></meta>
		</SWIZ>
		<opStr public="1" set="method" line="300" static="1"><f a="op">
	<t path="hxsl.Binop"/>
	<c path="String"/>
</f></opStr>
		<toString public="1" set="method" line="331" static="1">
			<f a="e:?varId" v=":false">
				<t path="hxsl.TExpr"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ varId : false }</e></m></meta>
		</toString>
		<shaderToString public="1" set="method" line="335" static="1">
			<f a="s:?varId" v=":false">
				<t path="hxsl.ShaderData"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ varId : false }</e></m></meta>
		</shaderToString>
		<check public="1" set="method" line="339" static="1"><f a="s:?from">
	<t path="hxsl.ShaderData"/>
	<c path="Array"><t path="hxsl.ShaderData"/></c>
	<x path="Void"/>
</f></check>
		<buffer><c path="StringBuf"/></buffer>
		<varId><x path="Bool"/></varId>
		<add get="inline" set="null" line="13"><f a="v">
	<d/>
	<x path="Void"/>
</f></add>
		<shaderString public="1" set="method" line="17"><f a="s">
	<t path="hxsl.ShaderData"/>
	<c path="String"/>
</f></shaderString>
		<varString public="1" set="method" line="32"><f a="v">
	<t path="hxsl.TVar"/>
	<c path="String"/>
</f></varString>
		<funString public="1" set="method" line="38"><f a="f">
	<t path="hxsl.TFunction"/>
	<c path="String"/>
</f></funString>
		<exprString public="1" set="method" line="44"><f a="e">
	<t path="hxsl.TExpr"/>
	<c path="String"/>
</f></exprString>
		<addVar set="method" line="50">
			<f a="v:defKind:?tabs:?parent" v="::&quot;&quot;:">
				<t path="hxsl.TVar"/>
				<e path="hxsl.VarKind"/>
				<c path="String"/>
				<t path="hxsl.TVar"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ tabs : "" }</e></m></meta>
		</addVar>
		<addFun set="method" line="103"><f a="f">
	<t path="hxsl.TFunction"/>
	<x path="Void"/>
</f></addFun>
		<addVarName set="method" line="119"><f a="v">
	<t path="hxsl.TVar"/>
	<x path="Void"/>
</f></addVarName>
		<addConst set="method" line="131"><f a="c">
	<e path="hxsl.Const"/>
	<x path="Void"/>
</f></addConst>
		<addExpr set="method" line="141"><f a="e:tabs">
	<t path="hxsl.TExpr"/>
	<c path="String"/>
	<x path="Void"/>
</f></addExpr>
		<new public="1" set="method" line="9">
			<f a="?varId" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ varId : false }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxsl.AllocParam" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/RuntimeShader.hx" module="hxsl.RuntimeShader">
		<name public="1"><c path="String"/></name>
		<pos public="1"><x path="Int"/></pos>
		<instance public="1"><x path="Int"/></instance>
		<index public="1"><x path="Int"/></index>
		<type public="1"><e path="hxsl.Type"/></type>
		<perObjectGlobal public="1"><c path="hxsl.AllocGlobal"/></perObjectGlobal>
		<next public="1"><c path="hxsl.AllocParam"/></next>
		<clone public="1" set="method" line="18">
			<f a="?resetGID" v="false">
				<x path="Bool"/>
				<c path="hxsl.AllocParam"/>
			</f>
			<meta><m n=":value"><e>{ resetGID : false }</e></m></meta>
		</clone>
		<new public="1" set="method" line="11"><f a="name:pos:instance:index:type">
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<e path="hxsl.Type"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxsl.AllocGlobal" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/RuntimeShader.hx" module="hxsl.RuntimeShader">
		<pos public="1"><x path="Int"/></pos>
		<gid public="1"><x path="Int"/></gid>
		<path public="1"><c path="String"/></path>
		<type public="1"><e path="hxsl.Type"/></type>
		<next public="1"><c path="hxsl.AllocGlobal"/></next>
		<clone public="1" set="method" line="38">
			<f a="?resetGID" v="false">
				<x path="Bool"/>
				<c path="hxsl.AllocGlobal"/>
			</f>
			<meta><m n=":value"><e>{ resetGID : false }</e></m></meta>
		</clone>
		<new public="1" set="method" line="32"><f a="pos:path:type">
	<x path="Int"/>
	<c path="String"/>
	<e path="hxsl.Type"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxsl.RuntimeShaderData" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/RuntimeShader.hx" module="hxsl.RuntimeShader">
		<vertex public="1"><x path="Bool"/></vertex>
		<data public="1"><t path="hxsl.ShaderData"/></data>
		<code public="1"><c path="String"/></code>
		<params public="1"><c path="hxsl.AllocParam"/></params>
		<paramsSize public="1"><x path="Int"/></paramsSize>
		<globals public="1"><c path="hxsl.AllocGlobal"/></globals>
		<globalsSize public="1"><x path="Int"/></globalsSize>
		<textures public="1"><c path="hxsl.AllocParam"/></textures>
		<texturesCount public="1"><x path="Int"/></texturesCount>
		<buffers public="1"><c path="hxsl.AllocParam"/></buffers>
		<bufferCount public="1"><x path="Int"/></bufferCount>
		<consts public="1"><c path="Array"><x path="Float"/></c></consts>
		<new public="1" set="method" line="59"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxsl.ShaderInstanceDesc" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/RuntimeShader.hx" module="hxsl.RuntimeShader">
		<shader public="1"><c path="hxsl.SharedShader"/></shader>
		<bits public="1"><x path="Int"/></bits>
		<index public="1"><x path="Int"/></index>
		<new public="1" set="method" line="67"><f a="shader:bits">
	<c path="hxsl.SharedShader"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxsl.RuntimeShader" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/RuntimeShader.hx">
		<UID expr="0" line="75" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</UID>
		<id public="1"><x path="Int"/></id>
		<vertex public="1"><c path="hxsl.RuntimeShaderData"/></vertex>
		<fragment public="1"><c path="hxsl.RuntimeShaderData"/></fragment>
		<globals public="1"><t path="Map">
	<x path="Int"/>
	<x path="Bool"/>
</t></globals>
		<signature public="1">
			<c path="String"/>
			<haxe_doc>Signature of the resulting HxSL code.
		Several shaders with the different specification might still get the same resulting signature.</haxe_doc>
		</signature>
		<batchMode public="1"><x path="Bool"/></batchMode>
		<spec public="1"><a>
	<signature><c path="String"/></signature>
	<instances><c path="Array"><c path="hxsl.ShaderInstanceDesc"/></c></instances>
</a></spec>
		<hasGlobal public="1" get="inline" set="null" line="93"><f a="gid">
	<x path="Int"/>
	<x path="Bool"/>
</f></hasGlobal>
		<new public="1" set="method" line="89"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxsl.Serializer" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Serializer.hx">
		<TVECS expr="new Map()" line="101" static="1">
			<x path="haxe.ds.Map">
				<x path="Int"/>
				<e path="hxsl.Type"/>
			</x>
			<meta><m n=":value"><e>new Map()</e></m></meta>
		</TVECS>
		<BOPS expr="{
	var ops = Binop.createAll();
	ops.insert(OpAssignOp(null).getIndex(), null);
	ops;
}" line="304" static="1">
			<c path="Array"><e path="haxe.macro.Binop"/></c>
			<meta><m n=":value"><e>{
	var ops = Binop.createAll();
	ops.insert(OpAssignOp(null).getIndex(), null);
	ops;
}</e></m></meta>
		</BOPS>
		<UNOPS expr="Unop.createAll()" line="309" static="1">
			<c path="Array"><e path="haxe.macro.Unop"/></c>
			<meta><m n=":value"><e>Unop.createAll()</e></m></meta>
		</UNOPS>
		<TGLOBALS expr="hxsl.TGlobal.createAll()" line="310" static="1">
			<c path="Array"><e path="hxsl.TGlobal"/></c>
			<meta><m n=":value"><e>hxsl.TGlobal.createAll()</e></m></meta>
		</TGLOBALS>
		<TSWIZ expr="new Map()" line="311" static="1">
			<x path="haxe.ds.Map">
				<x path="Int"/>
				<c path="Array"><e path="hxsl.Component"/></c>
			</x>
			<meta><m n=":value"><e>new Map()</e></m></meta>
		</TSWIZ>
		<REGS expr="[X, Y, Z, W]" line="312" static="1">
			<c path="Array"><e path="hxsl.Component"/></c>
			<meta><m n=":value"><e>[X, Y, Z, W]</e></m></meta>
		</REGS>
		<VKINDS expr="VarKind.createAll()" line="364" static="1">
			<c path="Array"><e path="hxsl.VarKind"/></c>
			<meta><m n=":value"><e>VarKind.createAll()</e></m></meta>
		</VKINDS>
		<PRECS expr="Prec.createAll()" line="365" static="1">
			<c path="Array"><e path="hxsl.Prec"/></c>
			<meta><m n=":value"><e>Prec.createAll()</e></m></meta>
		</PRECS>
		<FKIND expr="FunctionKind.createAll()" line="407" static="1">
			<c path="Array"><e path="hxsl.FunctionKind"/></c>
			<meta><m n=":value"><e>FunctionKind.createAll()</e></m></meta>
		</FKIND>
		<SIGN expr="0x8B741D" line="419" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8B741D</e></m></meta>
		</SIGN>
		<run public="1" set="method" line="448" static="1"><f a="s">
	<t path="hxsl.ShaderData"/>
	<c path="String"/>
</f></run>
		<out><c path="haxe.io.BytesBuffer"/></out>
		<input><c path="haxe.io.BytesInput"/></input>
		<varMap><t path="Map">
	<x path="Int"/>
	<t path="hxsl.TVar"/>
</t></varMap>
		<idMap><t path="Map">
	<x path="Int"/>
	<x path="Int"/>
</t></idMap>
		<typeIdMap><t path="Map">
	<e path="hxsl.Type"/>
	<x path="Int"/>
</t></typeIdMap>
		<types><c path="Array"><e path="hxsl.Type"/></c></types>
		<uid expr="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</uid>
		<tid expr="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</tid>
		<writeArr params="T" get="inline" set="null" line="18"><f a="arr:f">
	<c path="Array"><c path="writeArr.T"/></c>
	<f a="">
		<c path="writeArr.T"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></writeArr>
		<readArr params="T" get="inline" set="null" line="23"><f a="f">
	<f a=""><c path="readArr.T"/></f>
	<c path="Array"><c path="readArr.T"/></c>
</f></readArr>
		<readVarInt set="method" line="27"><f a=""><x path="Int"/></f></readVarInt>
		<writeVarInt set="method" line="36"><f a="id">
	<x path="Int"/>
	<x path="Void"/>
</f></writeVarInt>
		<writeID set="method" line="51"><f a="id">
	<x path="Int"/>
	<x path="Void"/>
</f></writeID>
		<readID get="inline" set="null" line="61"><f a=""><x path="Int"/></f></readID>
		<writeTID set="method" line="65"><f a="t">
	<e path="hxsl.Type"/>
	<x path="Bool"/>
</f></writeTID>
		<writeType set="method" line="77"><f a="t">
	<e path="hxsl.Type"/>
	<x path="Void"/>
</f></writeType>
		<readType set="method" line="103"><f a=""><e path="hxsl.Type"/></f></readType>
		<writeString set="method" line="149"><f a="s">
	<c path="String"/>
	<x path="Void"/>
</f></writeString>
		<readString set="method" line="155"><f a=""><c path="String"/></f></readString>
		<writeVar set="method" line="161"><f a="v">
	<t path="hxsl.TVar"/>
	<x path="Void"/>
</f></writeVar>
		<writeFun set="method" line="191"><f a="f">
	<t path="hxsl.TFunction"/>
	<x path="Void"/>
</f></writeFun>
		<writeConst set="method" line="199"><f a="c">
	<e path="hxsl.Const"/>
	<x path="Void"/>
</f></writeConst>
		<writeExpr set="method" line="210"><f a="e">
	<t path="hxsl.TExpr"/>
	<x path="Void"/>
</f></writeExpr>
		<readConst set="method" line="293"><f a=""><e path="hxsl.Const"/></f></readConst>
		<readExpr set="method" line="314"><f a=""><t path="hxsl.TExpr"/></f></readExpr>
		<readVar set="method" line="367"><f a=""><t path="hxsl.TVar"/></f></readVar>
		<readFun set="method" line="409"><f a=""><t path="hxsl.TFunction"/></f></readFun>
		<unserialize public="1" set="method" line="421"><f a="data">
	<c path="String"/>
	<t path="hxsl.ShaderData"/>
</f></unserialize>
		<serialize public="1" set="method" line="434"><f a="s">
	<t path="hxsl.ShaderData"/>
	<c path="String"/>
</f></serialize>
		<new public="1" set="method" line="15"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxsl.ShaderList" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/ShaderList.hx">
		<addSort public="1" set="method" line="20" static="1"><f a="s:shaders">
	<c path="hxsl.Shader"/>
	<c path="hxsl.ShaderList"/>
	<c path="hxsl.ShaderList"/>
</f></addSort>
		<s public="1"><c path="hxsl.Shader"/></s>
		<next public="1"><c path="hxsl.ShaderList"/></next>
		<clone public="1" set="method" line="10"><f a=""><x path="Null"><c path="hxsl.ShaderList"/></x></f></clone>
		<iterator public="1" get="inline" set="null" line="13"><f a=""><c path="hxsl._ShaderList.ShaderIterator"/></f></iterator>
		<iterateTo public="1" get="inline" set="null" line="16"><f a="s">
	<c path="hxsl.ShaderList"/>
	<c path="hxsl._ShaderList.ShaderIterator"/>
</f></iterateTo>
		<new public="1" set="method" line="6"><f a="s:?n">
	<c path="hxsl.Shader"/>
	<c path="hxsl.ShaderList"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxsl._ShaderList.ShaderIterator" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/ShaderList.hx" private="1" module="hxsl.ShaderList">
		<l><c path="hxsl.ShaderList"/></l>
		<last><c path="hxsl.ShaderList"/></last>
		<hasNext public="1" get="inline" set="null" line="43"><f a=""><x path="Bool"/></f></hasNext>
		<next public="1" get="inline" set="null" line="46"><f a=""><c path="hxsl.Shader"/></f></next>
		<new public="1" get="inline" set="null" line="39"><f a="l:last">
	<c path="hxsl.ShaderList"/>
	<c path="hxsl.ShaderList"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxsl.ShaderInstance" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/SharedShader.hx" module="hxsl.SharedShader">
		<id public="1"><x path="Int"/></id>
		<shader public="1"><t path="hxsl.ShaderData"/></shader>
		<params public="1"><t path="Map">
	<x path="Int"/>
	<x path="Int"/>
</t></params>
		<new public="1" set="method" line="8"><f a="shader">
	<t path="hxsl.ShaderData"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxsl.ShaderGlobal" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/SharedShader.hx" module="hxsl.SharedShader">
		<v public="1"><t path="hxsl.TVar"/></v>
		<globalId public="1"><x path="Int"/></globalId>
		<new public="1" set="method" line="18"><f a="v:gid">
	<t path="hxsl.TVar"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxsl.ShaderConst" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/SharedShader.hx" module="hxsl.SharedShader">
		<v public="1"><t path="hxsl.TVar"/></v>
		<pos public="1"><x path="Int"/></pos>
		<bits public="1"><x path="Int"/></bits>
		<globalId public="1"><x path="Int"/></globalId>
		<next public="1"><c path="hxsl.ShaderConst"/></next>
		<new public="1" set="method" line="30"><f a="v:pos:bits">
	<t path="hxsl.TVar"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxsl.SharedShader" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/SharedShader.hx">
		<UNROLL_LOOPS public="1" expr="false" line="39" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</UNROLL_LOOPS>
		<data public="1"><t path="hxsl.ShaderData"/></data>
		<globals public="1"><c path="Array"><c path="hxsl.ShaderGlobal"/></c></globals>
		<consts public="1"><c path="hxsl.ShaderConst"/></consts>
		<instanceCache><t path="Map">
	<x path="Int"/>
	<c path="hxsl.ShaderInstance"/>
</t></instanceCache>
		<paramsCount><x path="Int"/></paramsCount>
		<initialize set="method" line="57"><f a=""><x path="Void"/></f></initialize>
		<getInstance public="1" get="inline" set="null" line="63"><f a="constBits">
	<x path="Int"/>
	<x path="Null"><c path="hxsl.ShaderInstance"/></x>
</f></getInstance>
		<makeInstance set="method" line="68"><f a="constBits">
	<x path="Int"/>
	<c path="hxsl.ShaderInstance"/>
</f></makeInstance>
		<addSelfParam set="method" line="95"><f a="i:v">
	<c path="hxsl.ShaderInstance"/>
	<t path="hxsl.TVar"/>
	<x path="Void"/>
</f></addSelfParam>
		<addParam set="method" line="108"><f a="eval:i:v">
	<c path="hxsl.Eval"/>
	<c path="hxsl.ShaderInstance"/>
	<t path="hxsl.TVar"/>
	<x path="Void"/>
</f></addParam>
		<browseVar set="method" line="121"><f a="v:?path">
	<t path="hxsl.TVar"/>
	<c path="String"/>
	<x path="Void"/>
</f></browseVar>
		<new public="1" set="method" line="47"><f a="src">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxsl._Splitter.VarProps" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Splitter.hx" private="1" module="hxsl.Splitter">
		<v public="1"><t path="hxsl.TVar"/></v>
		<read public="1"><x path="Int"/></read>
		<write public="1"><x path="Int"/></write>
		<local public="1"><x path="Bool"/></local>
		<requireInit public="1"><x path="Bool"/></requireInit>
		<new public="1" set="method" line="10"><f a="v">
	<t path="hxsl.TVar"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxsl.Splitter" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Splitter.hx">
		<vars><t path="Map">
	<x path="Int"/>
	<c path="hxsl._Splitter.VarProps"/>
</t></vars>
		<varNames><t path="Map">
	<c path="String"/>
	<t path="hxsl.TVar"/>
</t></varNames>
		<varMap><t path="Map">
	<t path="hxsl.TVar"/>
	<t path="hxsl.TVar"/>
</t></varMap>
		<split public="1" set="method" line="26"><f a="s">
	<t path="hxsl.ShaderData"/>
	<a>
		<vertex><t path="hxsl.ShaderData"/></vertex>
		<fragment><t path="hxsl.ShaderData"/></fragment>
	</a>
</f></split>
		<addExpr set="method" line="184"><f a="f:e">
	<t path="hxsl.TFunction"/>
	<t path="hxsl.TExpr"/>
	<x path="Void"/>
</f></addExpr>
		<checkVar set="method" line="193"><f a="v:vertex:vvars:p">
	<c path="hxsl._Splitter.VarProps"/>
	<x path="Bool"/>
	<t path="Map">
		<x path="Int"/>
		<c path="hxsl._Splitter.VarProps"/>
	</t>
	<t path="hxsl.Position"/>
	<x path="Void"/>
</f></checkVar>
		<mapVars set="method" line="206"><f a="e">
	<t path="hxsl.TExpr"/>
	<t path="hxsl.TExpr"/>
</f></mapVars>
		<get set="method" line="222"><f a="v">
	<t path="hxsl.TVar"/>
	<x path="Null"><c path="hxsl._Splitter.VarProps"/></x>
</f></get>
		<uniqueName set="method" line="248"><f a="v">
	<t path="hxsl.TVar"/>
	<x path="Void"/>
</f></uniqueName>
		<checkExpr set="method" line="265"><f a="e">
	<t path="hxsl.TExpr"/>
	<x path="Void"/>
</f></checkExpr>
		<new public="1" set="method" line="23"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="hxsl.Vec" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Types.hx" module="hxsl.Types"><c path="h3d.Vector"/></typedef>
	<typedef path="hxsl.IVec" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Types.hx" module="hxsl.Types"><c path="Array"><x path="Int"/></c></typedef>
	<typedef path="hxsl.BVec" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Types.hx" module="hxsl.Types"><c path="Array"><x path="Bool"/></c></typedef>
	<typedef path="hxsl.Matrix" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Types.hx" module="hxsl.Types"><c path="h3d.Matrix"/></typedef>
	<typedef path="hxsl.Texture" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Types.hx" module="hxsl.Types"><c path="h3d.mat.Texture"/></typedef>
	<typedef path="hxsl.Sampler2D" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Types.hx" module="hxsl.Types"><c path="h3d.mat.Texture"/></typedef>
	<typedef path="hxsl.Sampler2DArray" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Types.hx" module="hxsl.Types"><c path="h3d.mat.TextureArray"/></typedef>
	<typedef path="hxsl.SamplerCube" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Types.hx" module="hxsl.Types"><c path="h3d.mat.Texture"/></typedef>
	<typedef path="hxsl.ChannelTextureType" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Types.hx" module="hxsl.Types"><c path="h3d.mat.Texture"/></typedef>
	<typedef path="hxsl.Buffer" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Types.hx" module="hxsl.Types"><c path="h3d.Buffer"/></typedef>
	<class path="hxsl.ChannelTools" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Types.hx" module="hxsl.Types"><isPackedFormat public="1" get="inline" set="null" line="15" static="1"><f a="c">
	<t path="hxsl.ChannelTextureType"/>
	<x path="Bool"/>
</f></isPackedFormat></class>
	<class path="samples.DocMacro" params="" file="./samples/DocMacro.hx">
		<getFiles set="method" static="1"><f a=""><d/></f></getFiles>
		<main set="method" line="47" static="1"><f a=""><x path="Void"/></f></main>
	</class>
	<typedef path="sys.FileStat" params="" file="E:\HaxeToolkit\haxe\std\sys/FileStat.hx">
		<a>
			<uid>
				<x path="Int"/>
				<haxe_doc>The user id for the file owner.</haxe_doc>
			</uid>
			<size>
				<x path="Int"/>
				<haxe_doc>The size of the file, in bytes.</haxe_doc>
			</size>
			<rdev>
				<x path="Int"/>
				<haxe_doc>The device type on which stat resides (special files only).</haxe_doc>
			</rdev>
			<nlink>
				<x path="Int"/>
				<haxe_doc>The number of hard links to stat.</haxe_doc>
			</nlink>
			<mtime>
				<c path="Date"/>
				<haxe_doc>The last modification time for the file.</haxe_doc>
			</mtime>
			<mode>
				<x path="Int"/>
				<haxe_doc>The permission bits of stat. The meaning of the bits is platform dependent.</haxe_doc>
			</mode>
			<ino>
				<x path="Int"/>
				<haxe_doc>The inode number for stat.</haxe_doc>
			</ino>
			<gid>
				<x path="Int"/>
				<haxe_doc>The user group id for the file owner.</haxe_doc>
			</gid>
			<dev>
				<x path="Int"/>
				<haxe_doc>The device on which stat resides.</haxe_doc>
			</dev>
			<ctime>
				<c path="Date"/>
				<haxe_doc>The creation time for the file (not all file systems support this).</haxe_doc>
			</ctime>
			<atime>
				<c path="Date"/>
				<haxe_doc>The last access time for the file (when enabled by the file system).</haxe_doc>
			</atime>
		</a>
		<haxe_doc>File information, as given by `sys.FileSystem.stat`.</haxe_doc>
	</typedef>
	<class path="sys.FileSystem" params="" file="E:\HaxeToolkit\haxe\std\sys/FileSystem.hx" extern="1">
		<exists public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns `true` if the file or directory specified by `path` exists.</haxe_doc>
		</exists>
		<rename public="1" set="method" static="1">
			<f a="path:newPath">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Renames/moves the file or directory specified by `path` to `newPath`.

		If `path` is not a valid file system entry, or if it is not accessible,
		or if `newPath` is not accessible, an exception is thrown.</haxe_doc>
		</rename>
		<stat public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<t path="sys.FileStat"/>
			</f>
			<haxe_doc>Returns `FileStat` information for the file or directory specified by
		`path`.</haxe_doc>
		</stat>
		<fullPath public="1" set="method" static="1">
			<f a="relPath">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the full path of the file or directory specified by `relPath`,
		which is relative to the current working directory. Symlinks will be
		followed and the path will be normalized.</haxe_doc>
		</fullPath>
		<absolutePath public="1" set="method" static="1">
			<f a="relPath">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the full path of the file or directory specified by `relPath`,
		which is relative to the current working directory. The path doesn't
		have to exist.</haxe_doc>
		</absolutePath>
		<isDirectory public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns `true` if the file or directory specified by `path` is a directory.

		If `path` is not a valid file system entry or if its destination is not
		accessible, an exception is thrown.</haxe_doc>
		</isDirectory>
		<createDirectory public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a directory specified by `path`.

		This method is recursive: The parent directories don't have to exist.

		If the directory cannot be created, an exception is thrown.</haxe_doc>
		</createDirectory>
		<deleteFile public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Deletes the file specified by `path`.

		If `path` does not denote a valid file, or if that file cannot be
		deleted, an exception is thrown.</haxe_doc>
		</deleteFile>
		<deleteDirectory public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Deletes the directory specified by `path`. Only empty directories can
		be deleted.

		If `path` does not denote a valid directory, or if that directory cannot
		be deleted, an exception is thrown.</haxe_doc>
		</deleteDirectory>
		<readDirectory public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns the names of all files and directories in the directory specified
		by `path`. `"."` and `".."` are not included in the output.

		If `path` does not denote a valid directory, an exception is thrown.</haxe_doc>
		</readDirectory>
		<haxe_doc>This class provides information about files and directories.

	If `null` is passed as a file path to any function in this class, the
	result is unspecified, and may differ from target to target.

	See `sys.io.File` for the complementary file API.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="sys.io.File" params="" file="E:\HaxeToolkit\haxe\std\sys/io/File.hx" extern="1">
		<getContent public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Retrieves the content of the file specified by `path` as a String.

		If the file does not exist or can not be read, an exception is thrown.

		`sys.FileSystem.exists` can be used to check for existence.

		If `path` is null, the result is unspecified.</haxe_doc>
		</getContent>
		<saveContent public="1" set="method" static="1">
			<f a="path:content">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Stores `content` in the file specified by `path`.

		If the file cannot be written to, an exception is thrown.

		If `path` or `content` are null, the result is unspecified.</haxe_doc>
		</saveContent>
		<getBytes public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>Retrieves the binary content of the file specified by `path`.

		If the file does not exist or can not be read, an exception is thrown.

		`sys.FileSystem.exists` can be used to check for existence.

		If `path` is null, the result is unspecified.</haxe_doc>
		</getBytes>
		<saveBytes public="1" set="method" static="1">
			<f a="path:bytes">
				<c path="String"/>
				<c path="haxe.io.Bytes"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Stores `bytes` in the file specified by `path` in binary mode.

		If the file cannot be written to, an exception is thrown.

		If `path` or `bytes` are null, the result is unspecified.</haxe_doc>
		</saveBytes>
		<read public="1" set="method" static="1">
			<f a="path:?binary" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="sys.io.FileInput"/>
			</f>
			<meta><m n=":value"><e>{ binary : true }</e></m></meta>
			<haxe_doc>Returns an `FileInput` handle to the file specified by `path`.

		If `binary` is true, the file is opened in binary mode. Otherwise it is
		opened in non-binary mode.

		If the file does not exist or can not be read, an exception is thrown.

		Operations on the returned `FileInput` handle read on the opened file.

		File handles should be closed via `FileInput.close` once the operation
		is complete.

		If `path` is null, the result is unspecified.</haxe_doc>
		</read>
		<write public="1" set="method" static="1">
			<f a="path:?binary" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="sys.io.FileOutput"/>
			</f>
			<meta><m n=":value"><e>{ binary : true }</e></m></meta>
			<haxe_doc>Returns an `FileOutput` handle to the file specified by `path`.

		If `binary` is true, the file is opened in binary mode. Otherwise it is
		opened in non-binary mode.

		If the file cannot be written to, an exception is thrown.

		Operations on the returned `FileOutput` handle write to the opened file.
		If the file existed, its previous content is overwritten.

		File handles should be closed via `FileOutput.close` once the operation
		is complete.

		If `path` is null, the result is unspecified.</haxe_doc>
		</write>
		<append public="1" set="method" static="1">
			<f a="path:?binary" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="sys.io.FileOutput"/>
			</f>
			<meta><m n=":value"><e>{ binary : true }</e></m></meta>
			<haxe_doc>Similar to `sys.io.File.write`, but appends to the file if it exists
		instead of overwriting its contents.</haxe_doc>
		</append>
		<update public="1" set="method" static="1">
			<f a="path:?binary" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="sys.io.FileOutput"/>
			</f>
			<meta><m n=":value"><e>{ binary : true }</e></m></meta>
			<haxe_doc>Similar to `sys.io.File.append`. While `append` can only seek or write
		starting from the end of the file's previous contents, `update` can
		seek to any position, so the file's previous contents can be
		selectively overwritten.</haxe_doc>
		</update>
		<copy public="1" set="method" static="1">
			<f a="srcPath:dstPath">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Copies the contents of the file specified by `srcPath` to the file
		specified by `dstPath`.

		If the `srcPath` does not exist or cannot be read, or if the `dstPath`
		file cannot be written to, an exception is thrown.

		If the file at `dstPath` exists, its contents are overwritten.

		If `srcPath` or `dstPath` are null, the result is unspecified.</haxe_doc>
		</copy>
		<haxe_doc>API for reading and writing files.

	See `sys.FileSystem` for the complementary file system API.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="sys.io.FileInput" params="" file="E:\HaxeToolkit\haxe\std\sys/io/FileInput.hx" extern="1">
		<extends path="haxe.io.Input"/>
		<seek public="1" set="method"><f a="p:pos">
	<x path="Int"/>
	<e path="sys.io.FileSeek"/>
	<x path="Void"/>
</f></seek>
		<tell public="1" set="method"><f a=""><x path="Int"/></f></tell>
		<eof public="1" set="method"><f a=""><x path="Bool"/></f></eof>
		<haxe_doc>Use `sys.io.File.read` to create a `FileInput`.</haxe_doc>
	</class>
	<class path="sys.io.FileOutput" params="" file="E:\HaxeToolkit\haxe\std\sys/io/FileOutput.hx" extern="1">
		<extends path="haxe.io.Output"/>
		<seek public="1" set="method"><f a="p:pos">
	<x path="Int"/>
	<e path="sys.io.FileSeek"/>
	<x path="Void"/>
</f></seek>
		<tell public="1" set="method"><f a=""><x path="Int"/></f></tell>
		<haxe_doc>Use `sys.io.File.write` to create a `FileOutput`.</haxe_doc>
	</class>
	<enum path="sys.io.FileSeek" params="" file="E:\HaxeToolkit\haxe\std\sys/io/FileSeek.hx">
		<SeekBegin/>
		<SeekCur/>
		<SeekEnd/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
</haxe>